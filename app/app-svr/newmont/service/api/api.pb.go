// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-gateway/app/app-svr/newmont/service/api/api.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	go_common_library_time "go-common/library/time"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SectionItemOpLinkType_Enum int32

const (
	// 按钮
	SectionItemOpLinkType_BUTTON SectionItemOpLinkType_Enum = 0
	// 跳链有文案
	SectionItemOpLinkType_LINK_WITH_TEXT SectionItemOpLinkType_Enum = 1
	// 跳链无文案
	SectionItemOpLinkType_LINK_WITHOUT_TEXT SectionItemOpLinkType_Enum = 2
	// 弹窗触发器
	SectionItemOpLinkType_DIALOG_OPENER SectionItemOpLinkType_Enum = 3
	// NA页面id，需要在下发时，在param上做拼接
	SectionItemOpLinkType_NA_PAGE_ID SectionItemOpLinkType_Enum = 4
	// 运营条公告类型
	SectionItemOpLinkType_NOTICE SectionItemOpLinkType_Enum = 5
)

var SectionItemOpLinkType_Enum_name = map[int32]string{
	0: "BUTTON",
	1: "LINK_WITH_TEXT",
	2: "LINK_WITHOUT_TEXT",
	3: "DIALOG_OPENER",
	4: "NA_PAGE_ID",
	5: "NOTICE",
}

var SectionItemOpLinkType_Enum_value = map[string]int32{
	"BUTTON":            0,
	"LINK_WITH_TEXT":    1,
	"LINK_WITHOUT_TEXT": 2,
	"DIALOG_OPENER":     3,
	"NA_PAGE_ID":        4,
	"NOTICE":            5,
}

func (x SectionItemOpLinkType_Enum) String() string {
	return proto.EnumName(SectionItemOpLinkType_Enum_name, int32(x))
}

func (SectionItemOpLinkType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{6, 0}
}

type MineSectionsRequest struct {
	Plat    int32  `protobuf:"varint,1,opt,name=plat,proto3" json:"plat,omitempty"`
	Build   int32  `protobuf:"varint,2,opt,name=build,proto3" json:"build,omitempty"`
	Mid     int64  `protobuf:"varint,3,opt,name=mid,proto3" json:"mid,omitempty"`
	Lang    string `protobuf:"bytes,4,opt,name=lang,proto3" json:"lang,omitempty"`
	Channel string `protobuf:"bytes,5,opt,name=channel,proto3" json:"channel,omitempty"`
	Ip      string `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	// 是否为up主
	IsUploader bool `protobuf:"varint,7,opt,name=is_uploader,json=isUploader,proto3" json:"is_uploader,omitempty"`
	// 是否为已开播主播
	IsLiveHost bool `protobuf:"varint,8,opt,name=is_live_host,json=isLiveHost,proto3" json:"is_live_host,omitempty"`
	// 历史粉丝数峰值
	FansCount int64 `protobuf:"varint,9,opt,name=fans_count,json=fansCount,proto3" json:"fans_count,omitempty"`
	// buvid
	Buvid                string   `protobuf:"bytes,10,opt,name=buvid,proto3" json:"buvid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MineSectionsRequest) Reset()         { *m = MineSectionsRequest{} }
func (m *MineSectionsRequest) String() string { return proto.CompactTextString(m) }
func (*MineSectionsRequest) ProtoMessage()    {}
func (*MineSectionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{0}
}
func (m *MineSectionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MineSectionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MineSectionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MineSectionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MineSectionsRequest.Merge(m, src)
}
func (m *MineSectionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *MineSectionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MineSectionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MineSectionsRequest proto.InternalMessageInfo

type MineSectionsReply struct {
	Sections             []*Section `protobuf:"bytes,1,rep,name=sections,proto3" json:"sections,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MineSectionsReply) Reset()         { *m = MineSectionsReply{} }
func (m *MineSectionsReply) String() string { return proto.CompactTextString(m) }
func (*MineSectionsReply) ProtoMessage()    {}
func (*MineSectionsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{1}
}
func (m *MineSectionsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MineSectionsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MineSectionsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MineSectionsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MineSectionsReply.Merge(m, src)
}
func (m *MineSectionsReply) XXX_Size() int {
	return m.Size()
}
func (m *MineSectionsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_MineSectionsReply.DiscardUnknown(m)
}

var xxx_messageInfo_MineSectionsReply proto.InternalMessageInfo

// 首页的模块
type HomeSectionsRequest struct {
	// 平台
	Plat int32 `protobuf:"varint,1,opt,name=plat,proto3" json:"plat,omitempty"`
	// 版本
	Build int32 `protobuf:"varint,2,opt,name=build,proto3" json:"build,omitempty"`
	// 用户mid
	Mid int64 `protobuf:"varint,3,opt,name=mid,proto3" json:"mid,omitempty"`
	// 语言
	Lang string `protobuf:"bytes,4,opt,name=lang,proto3" json:"lang,omitempty"`
	// 渠道
	Channel string `protobuf:"bytes,5,opt,name=channel,proto3" json:"channel,omitempty"`
	// ip地址
	Ip string `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	// buvid
	Buvid                string   `protobuf:"bytes,7,opt,name=buvid,proto3" json:"buvid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HomeSectionsRequest) Reset()         { *m = HomeSectionsRequest{} }
func (m *HomeSectionsRequest) String() string { return proto.CompactTextString(m) }
func (*HomeSectionsRequest) ProtoMessage()    {}
func (*HomeSectionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{2}
}
func (m *HomeSectionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HomeSectionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HomeSectionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HomeSectionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HomeSectionsRequest.Merge(m, src)
}
func (m *HomeSectionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *HomeSectionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HomeSectionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HomeSectionsRequest proto.InternalMessageInfo

type HomeSectionsReply struct {
	Sections             []*Section `protobuf:"bytes,1,rep,name=sections,proto3" json:"sections,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *HomeSectionsReply) Reset()         { *m = HomeSectionsReply{} }
func (m *HomeSectionsReply) String() string { return proto.CompactTextString(m) }
func (*HomeSectionsReply) ProtoMessage()    {}
func (*HomeSectionsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{3}
}
func (m *HomeSectionsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HomeSectionsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HomeSectionsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HomeSectionsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HomeSectionsReply.Merge(m, src)
}
func (m *HomeSectionsReply) XXX_Size() int {
	return m.Size()
}
func (m *HomeSectionsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_HomeSectionsReply.DiscardUnknown(m)
}

var xxx_messageInfo_HomeSectionsReply proto.InternalMessageInfo

type Section struct {
	Id              int64          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title           string         `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Style           int32          `protobuf:"varint,3,opt,name=style,proto3" json:"style,omitempty"`
	ButtonName      string         `protobuf:"bytes,4,opt,name=button_name,json=buttonName,proto3" json:"button_name,omitempty"`
	ButtonUrl       string         `protobuf:"bytes,5,opt,name=button_url,json=buttonUrl,proto3" json:"button_url,omitempty"`
	ButtonIcon      string         `protobuf:"bytes,6,opt,name=button_icon,json=buttonIcon,proto3" json:"button_icon,omitempty"`
	ButtonStyle     int32          `protobuf:"varint,7,opt,name=button_style,json=buttonStyle,proto3" json:"button_style,omitempty"`
	TitleColor      string         `protobuf:"bytes,8,opt,name=title_color,json=titleColor,proto3" json:"title_color,omitempty"`
	Subtitle        string         `protobuf:"bytes,9,opt,name=subtitle,proto3" json:"subtitle,omitempty"`
	SubtitleUrl     string         `protobuf:"bytes,10,opt,name=subtitle_url,json=subtitleUrl,proto3" json:"subtitle_url,omitempty"`
	SubtitleColor   string         `protobuf:"bytes,11,opt,name=subtitle_color,json=subtitleColor,proto3" json:"subtitle_color,omitempty"`
	Background      string         `protobuf:"bytes,12,opt,name=background,proto3" json:"background,omitempty"`
	BackgroundColor string         `protobuf:"bytes,13,opt,name=background_color,json=backgroundColor,proto3" json:"background_color,omitempty"`
	Items           []*SectionItem `protobuf:"bytes,14,rep,name=items,proto3" json:"items,omitempty"`
	AuditShow       int32          `protobuf:"varint,15,opt,name=audit_show,json=auditShow,proto3" json:"audit_show,omitempty"`
	IsMng           int32          `protobuf:"varint,16,opt,name=is_mng,json=isMng,proto3" json:"is_mng,omitempty"`
	// 运营位样式：当style为3时，此字段有意义，0-通用运营位，1-投稿引导强化卡
	OpStyleType          int32    `protobuf:"varint,17,opt,name=op_style_type,json=opStyleType,proto3" json:"op_style_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Section) Reset()         { *m = Section{} }
func (m *Section) String() string { return proto.CompactTextString(m) }
func (*Section) ProtoMessage()    {}
func (*Section) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{4}
}
func (m *Section) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Section) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Section.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Section) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Section.Merge(m, src)
}
func (m *Section) XXX_Size() int {
	return m.Size()
}
func (m *Section) XXX_DiscardUnknown() {
	xxx_messageInfo_Section.DiscardUnknown(m)
}

var xxx_messageInfo_Section proto.InternalMessageInfo

type SectionItem struct {
	Id           int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title        string   `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Uri          string   `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	Icon         string   `protobuf:"bytes,4,opt,name=icon,proto3" json:"icon,omitempty"`
	NeedLogin    int32    `protobuf:"varint,5,opt,name=need_login,json=needLogin,proto3" json:"need_login,omitempty"`
	RedDot       int32    `protobuf:"varint,6,opt,name=red_dot,json=redDot,proto3" json:"red_dot,omitempty"`
	GlobalRedDot int32    `protobuf:"varint,7,opt,name=global_red_dot,json=globalRedDot,proto3" json:"global_red_dot,omitempty"`
	Display      int32    `protobuf:"varint,8,opt,name=display,proto3" json:"display,omitempty"`
	MngIcon      *MngIcon `protobuf:"bytes,9,opt,name=mng_icon,json=mngIcon,proto3" json:"mng_icon,omitempty"`
	RedDotForNew bool     `protobuf:"varint,10,opt,name=red_dot_for_new,json=redDotForNew,proto3" json:"red_dot_for_new,omitempty"`
	// 运营位标题
	OpTitle string `protobuf:"bytes,11,opt,name=op_title,json=opTitle,proto3" json:"op_title,omitempty"`
	// 运营位副标题
	OpSubTitle string `protobuf:"bytes,12,opt,name=op_sub_title,json=opSubTitle,proto3" json:"op_sub_title,omitempty"`
	// 运营位标题图标
	OpTitleIcon string `protobuf:"bytes,13,opt,name=op_title_icon,json=opTitleIcon,proto3" json:"op_title_icon,omitempty"`
	// 运营位链接文案
	OpLinkText string `protobuf:"bytes,14,opt,name=op_link_text,json=opLinkText,proto3" json:"op_link_text,omitempty"`
	// 运营位链接图标
	OpLinkIcon string `protobuf:"bytes,15,opt,name=op_link_icon,json=opLinkIcon,proto3" json:"op_link_icon,omitempty"`
	// 运营位链接类型
	OpLinkType SectionItemOpLinkType_Enum `protobuf:"varint,16,opt,name=op_link_type,json=opLinkType,proto3,enum=newmont.service.v1.SectionItemOpLinkType_Enum" json:"op_link_type,omitempty"`
	// tab id
	TabId string `protobuf:"bytes,17,opt,name=tab_id,json=tabId,proto3" json:"tab_id,omitempty"`
	// animate
	Animate string `protobuf:"bytes,18,opt,name=animate,proto3" json:"animate,omitempty"`
	// 底部tab选中后的图标样式
	LogoSelected string `protobuf:"bytes,19,opt,name=logo_selected,json=logoSelected,proto3" json:"logo_selected,omitempty"`
	// 判定红点的url
	RedDotUrl string `protobuf:"bytes,20,opt,name=red_dot_url,json=redDotUrl,proto3" json:"red_dot_url,omitempty"`
	// 运营位标题颜色
	OpTitleColor string `protobuf:"bytes,21,opt,name=op_title_color,json=opTitleColor,proto3" json:"op_title_color,omitempty"`
	// 运营位背景颜色
	OpBackgroundColor string `protobuf:"bytes,22,opt,name=op_background_color,json=opBackgroundColor,proto3" json:"op_background_color,omitempty"`
	// 运营位跳链颜色
	OpLinkContainerColor string   `protobuf:"bytes,23,opt,name=op_link_container_color,json=opLinkContainerColor,proto3" json:"op_link_container_color,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SectionItem) Reset()         { *m = SectionItem{} }
func (m *SectionItem) String() string { return proto.CompactTextString(m) }
func (*SectionItem) ProtoMessage()    {}
func (*SectionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{5}
}
func (m *SectionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectionItem.Merge(m, src)
}
func (m *SectionItem) XXX_Size() int {
	return m.Size()
}
func (m *SectionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SectionItem.DiscardUnknown(m)
}

var xxx_messageInfo_SectionItem proto.InternalMessageInfo

type SectionItemOpLinkType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SectionItemOpLinkType) Reset()         { *m = SectionItemOpLinkType{} }
func (m *SectionItemOpLinkType) String() string { return proto.CompactTextString(m) }
func (*SectionItemOpLinkType) ProtoMessage()    {}
func (*SectionItemOpLinkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{6}
}
func (m *SectionItemOpLinkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectionItemOpLinkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectionItemOpLinkType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectionItemOpLinkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectionItemOpLinkType.Merge(m, src)
}
func (m *SectionItemOpLinkType) XXX_Size() int {
	return m.Size()
}
func (m *SectionItemOpLinkType) XXX_DiscardUnknown() {
	xxx_messageInfo_SectionItemOpLinkType.DiscardUnknown(m)
}

var xxx_messageInfo_SectionItemOpLinkType proto.InternalMessageInfo

type MngIcon struct {
	// 自增id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// icon地址
	Icon string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
	// 全局红点 1-是 0-否
	GlobalRed int32 `protobuf:"varint,3,opt,name=global_red,json=globalRed,proto3" json:"global_red,omitempty"`
	// 影响范围 1-全部用户 2-登录用户 3-指定名单用户
	EffectGroup int32 `protobuf:"varint,4,opt,name=effect_group,json=effectGroup,proto3" json:"effect_group,omitempty"`
	// 影响用户获取接口 （如effect_group=3 则由业务方提供接口判断）
	EffectUrl string `protobuf:"bytes,5,opt,name=effect_url,json=effectUrl,proto3" json:"effect_url,omitempty"`
	// 配置模块
	Module []*IconModule `protobuf:"bytes,6,rep,name=module,proto3" json:"module,omitempty"`
	// 开始时间
	Stime go_common_library_time.Time `protobuf:"varint,7,opt,name=stime,proto3,casttype=go-common/library/time.Time" json:"stime,omitempty"`
	// 结束时间
	Etime                go_common_library_time.Time `protobuf:"varint,8,opt,name=etime,proto3,casttype=go-common/library/time.Time" json:"etime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *MngIcon) Reset()         { *m = MngIcon{} }
func (m *MngIcon) String() string { return proto.CompactTextString(m) }
func (*MngIcon) ProtoMessage()    {}
func (*MngIcon) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{7}
}
func (m *MngIcon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MngIcon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MngIcon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MngIcon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MngIcon.Merge(m, src)
}
func (m *MngIcon) XXX_Size() int {
	return m.Size()
}
func (m *MngIcon) XXX_DiscardUnknown() {
	xxx_messageInfo_MngIcon.DiscardUnknown(m)
}

var xxx_messageInfo_MngIcon proto.InternalMessageInfo

type IconModule struct {
	Plat                 int32    `protobuf:"varint,1,opt,name=plat,proto3" json:"plat,omitempty"`
	Oid                  int64    `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IconModule) Reset()         { *m = IconModule{} }
func (m *IconModule) String() string { return proto.CompactTextString(m) }
func (*IconModule) ProtoMessage()    {}
func (*IconModule) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{8}
}
func (m *IconModule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IconModule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IconModule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IconModule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IconModule.Merge(m, src)
}
func (m *IconModule) XXX_Size() int {
	return m.Size()
}
func (m *IconModule) XXX_DiscardUnknown() {
	xxx_messageInfo_IconModule.DiscardUnknown(m)
}

var xxx_messageInfo_IconModule proto.InternalMessageInfo

type SectionIsHiddenRequest struct {
	// 数据id 首页入口对应sid 分区入口对应rid 【我的】页入口对应cid
	Oids []int64 `protobuf:"varint,1,rep,packed,name=oids,proto3" json:"oids,omitempty"`
	// 数据类型 0:首页入口 1:分区入口 2:【我的】页入口 3:一级模块入口 4:动态
	Otype int32 `protobuf:"varint,2,opt,name=otype,proto3" json:"otype,omitempty"`
	// build号
	Build int64 `protobuf:"varint,3,opt,name=build,proto3" json:"build,omitempty"`
	// 平台：0:Android 1:iphone 5:iphone_i 8:Android_i'
	Plat int32 `protobuf:"varint,4,opt,name=plat,proto3" json:"plat,omitempty"`
	// 渠道 如xiaomi,oppo
	Channel string `protobuf:"bytes,5,opt,name=channel,proto3" json:"channel,omitempty" validate:"required"`
	// 647之后使用map来传数据类型和数据id
	OidItems             map[int64]*OidList `protobuf:"bytes,6,rep,name=oid_items,json=oidItems,proto3" json:"oid_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SectionIsHiddenRequest) Reset()         { *m = SectionIsHiddenRequest{} }
func (m *SectionIsHiddenRequest) String() string { return proto.CompactTextString(m) }
func (*SectionIsHiddenRequest) ProtoMessage()    {}
func (*SectionIsHiddenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{9}
}
func (m *SectionIsHiddenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectionIsHiddenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectionIsHiddenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectionIsHiddenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectionIsHiddenRequest.Merge(m, src)
}
func (m *SectionIsHiddenRequest) XXX_Size() int {
	return m.Size()
}
func (m *SectionIsHiddenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SectionIsHiddenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SectionIsHiddenRequest proto.InternalMessageInfo

type OidList struct {
	Oids                 []int64  `protobuf:"varint,1,rep,packed,name=oids,proto3" json:"oids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OidList) Reset()         { *m = OidList{} }
func (m *OidList) String() string { return proto.CompactTextString(m) }
func (*OidList) ProtoMessage()    {}
func (*OidList) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{10}
}
func (m *OidList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OidList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OidList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OidList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OidList.Merge(m, src)
}
func (m *OidList) XXX_Size() int {
	return m.Size()
}
func (m *OidList) XXX_DiscardUnknown() {
	xxx_messageInfo_OidList.DiscardUnknown(m)
}

var xxx_messageInfo_OidList proto.InternalMessageInfo

type SectionIsHiddenReply struct {
	// 二级模块的屏蔽信息
	Infos map[int64]bool `protobuf:"bytes,1,rep,name=Infos,proto3" json:"Infos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 一级模块的屏蔽信息
	ModuleInfos map[int64]bool `protobuf:"bytes,2,rep,name=ModuleInfos,proto3" json:"ModuleInfos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 动态是否屏蔽
	HideDynamic          bool     `protobuf:"varint,3,opt,name=HideDynamic,proto3" json:"HideDynamic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SectionIsHiddenReply) Reset()         { *m = SectionIsHiddenReply{} }
func (m *SectionIsHiddenReply) String() string { return proto.CompactTextString(m) }
func (*SectionIsHiddenReply) ProtoMessage()    {}
func (*SectionIsHiddenReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{11}
}
func (m *SectionIsHiddenReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectionIsHiddenReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectionIsHiddenReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectionIsHiddenReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectionIsHiddenReply.Merge(m, src)
}
func (m *SectionIsHiddenReply) XXX_Size() int {
	return m.Size()
}
func (m *SectionIsHiddenReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SectionIsHiddenReply.DiscardUnknown(m)
}

var xxx_messageInfo_SectionIsHiddenReply proto.InternalMessageInfo

// MngIconRequest
type MngIconRequest struct {
	// 数据id
	Oids []int64 `protobuf:"varint,1,rep,packed,name=oids,proto3" json:"oids,omitempty" validate:"required,dive,gt=0"`
	// 平台：0:Android 1:iphone 5:iphone_i 8:Android_i'
	Plat int32 `protobuf:"varint,2,opt,name=plat,proto3" json:"plat,omitempty"`
	// 登录用户mid
	Mid                  int64    `protobuf:"varint,3,opt,name=mid,proto3" json:"mid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MngIconRequest) Reset()         { *m = MngIconRequest{} }
func (m *MngIconRequest) String() string { return proto.CompactTextString(m) }
func (*MngIconRequest) ProtoMessage()    {}
func (*MngIconRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{12}
}
func (m *MngIconRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MngIconRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MngIconRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MngIconRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MngIconRequest.Merge(m, src)
}
func (m *MngIconRequest) XXX_Size() int {
	return m.Size()
}
func (m *MngIconRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MngIconRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MngIconRequest proto.InternalMessageInfo

// MngIconReply
type MngIconReply struct {
	Info                 map[int64]*MngIcon `protobuf:"bytes,1,rep,name=info,proto3" json:"info,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MngIconReply) Reset()         { *m = MngIconReply{} }
func (m *MngIconReply) String() string { return proto.CompactTextString(m) }
func (*MngIconReply) ProtoMessage()    {}
func (*MngIconReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{13}
}
func (m *MngIconReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MngIconReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MngIconReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MngIconReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MngIconReply.Merge(m, src)
}
func (m *MngIconReply) XXX_Size() int {
	return m.Size()
}
func (m *MngIconReply) XXX_DiscardUnknown() {
	xxx_messageInfo_MngIconReply.DiscardUnknown(m)
}

var xxx_messageInfo_MngIconReply proto.InternalMessageInfo

// Hidden is
type Hidden struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 首页顶bar入口 对应sidebar.id
	Sid int64 `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	// 分区入口 对应region_copy.id
	Rid int64 `protobuf:"varint,3,opt,name=rid,proto3" json:"rid,omitempty"`
	// 渠道id 逗号分隔
	Channel string `protobuf:"bytes,4,opt,name=channel,proto3" json:"channel,omitempty"`
	// 渠道id map
	ChannelMap map[string]string `protobuf:"bytes,5,rep,name=channel_map,json=channelMap,proto3" json:"channel_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 屏蔽策略id
	Pid   int64                       `protobuf:"varint,6,opt,name=pid,proto3" json:"pid,omitempty"`
	Stime go_common_library_time.Time `protobuf:"varint,7,opt,name=stime,proto3,casttype=go-common/library/time.Time" json:"stime,omitempty"`
	Etime go_common_library_time.Time `protobuf:"varint,8,opt,name=etime,proto3,casttype=go-common/library/time.Time" json:"etime,omitempty"`
	// 【我的】页入口 对应sidebar.id
	Cid int64 `protobuf:"varint,9,opt,name=cid,proto3" json:"cid,omitempty"`
	//渠道屏蔽的条件
	HiddenCondition string `protobuf:"bytes,10,opt,name=hidden_condition,json=hiddenCondition,proto3" json:"hidden_condition,omitempty"`
	// 一级模块id
	ModuleId int64 `protobuf:"varint,11,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// 模糊匹配渠道id list
	ChannelFuzzy []string `protobuf:"bytes,12,rep,name=channel_fuzzy,json=channelFuzzy,proto3" json:"channel_fuzzy,omitempty"`
	//动态是否屏蔽(0-否 1-是)
	HideDynamic          int64    `protobuf:"varint,13,opt,name=hide_dynamic,json=hideDynamic,proto3" json:"hide_dynamic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Hidden) Reset()         { *m = Hidden{} }
func (m *Hidden) String() string { return proto.CompactTextString(m) }
func (*Hidden) ProtoMessage()    {}
func (*Hidden) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{14}
}
func (m *Hidden) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Hidden) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Hidden.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Hidden) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hidden.Merge(m, src)
}
func (m *Hidden) XXX_Size() int {
	return m.Size()
}
func (m *Hidden) XXX_DiscardUnknown() {
	xxx_messageInfo_Hidden.DiscardUnknown(m)
}

var xxx_messageInfo_Hidden proto.InternalMessageInfo

// HiddenLimit is
type HiddenLimit struct {
	Id         int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Oid        int64  `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	Conditions string `protobuf:"bytes,3,opt,name=conditions,proto3" json:"conditions,omitempty"`
	Build      int64  `protobuf:"varint,4,opt,name=build,proto3" json:"build,omitempty"`
	// 平台：0:Android 1:iphone 5:iphone_i 8:Android_i
	Plat                 int32    `protobuf:"varint,5,opt,name=plat,proto3" json:"plat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HiddenLimit) Reset()         { *m = HiddenLimit{} }
func (m *HiddenLimit) String() string { return proto.CompactTextString(m) }
func (*HiddenLimit) ProtoMessage()    {}
func (*HiddenLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{15}
}
func (m *HiddenLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HiddenLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HiddenLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HiddenLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HiddenLimit.Merge(m, src)
}
func (m *HiddenLimit) XXX_Size() int {
	return m.Size()
}
func (m *HiddenLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_HiddenLimit.DiscardUnknown(m)
}

var xxx_messageInfo_HiddenLimit proto.InternalMessageInfo

type HiddenInfo struct {
	Info                 *Hidden        `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	Limit                []*HiddenLimit `protobuf:"bytes,2,rep,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *HiddenInfo) Reset()         { *m = HiddenInfo{} }
func (m *HiddenInfo) String() string { return proto.CompactTextString(m) }
func (*HiddenInfo) ProtoMessage()    {}
func (*HiddenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf0d996435ae19d, []int{16}
}
func (m *HiddenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HiddenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HiddenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HiddenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HiddenInfo.Merge(m, src)
}
func (m *HiddenInfo) XXX_Size() int {
	return m.Size()
}
func (m *HiddenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HiddenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HiddenInfo proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("newmont.service.v1.SectionItemOpLinkType_Enum", SectionItemOpLinkType_Enum_name, SectionItemOpLinkType_Enum_value)
	proto.RegisterType((*MineSectionsRequest)(nil), "newmont.service.v1.MineSectionsRequest")
	proto.RegisterType((*MineSectionsReply)(nil), "newmont.service.v1.MineSectionsReply")
	proto.RegisterType((*HomeSectionsRequest)(nil), "newmont.service.v1.HomeSectionsRequest")
	proto.RegisterType((*HomeSectionsReply)(nil), "newmont.service.v1.HomeSectionsReply")
	proto.RegisterType((*Section)(nil), "newmont.service.v1.Section")
	proto.RegisterType((*SectionItem)(nil), "newmont.service.v1.SectionItem")
	proto.RegisterType((*SectionItemOpLinkType)(nil), "newmont.service.v1.SectionItemOpLinkType")
	proto.RegisterType((*MngIcon)(nil), "newmont.service.v1.MngIcon")
	proto.RegisterType((*IconModule)(nil), "newmont.service.v1.IconModule")
	proto.RegisterType((*SectionIsHiddenRequest)(nil), "newmont.service.v1.SectionIsHiddenRequest")
	proto.RegisterMapType((map[int64]*OidList)(nil), "newmont.service.v1.SectionIsHiddenRequest.OidItemsEntry")
	proto.RegisterType((*OidList)(nil), "newmont.service.v1.OidList")
	proto.RegisterType((*SectionIsHiddenReply)(nil), "newmont.service.v1.SectionIsHiddenReply")
	proto.RegisterMapType((map[int64]bool)(nil), "newmont.service.v1.SectionIsHiddenReply.InfosEntry")
	proto.RegisterMapType((map[int64]bool)(nil), "newmont.service.v1.SectionIsHiddenReply.ModuleInfosEntry")
	proto.RegisterType((*MngIconRequest)(nil), "newmont.service.v1.MngIconRequest")
	proto.RegisterType((*MngIconReply)(nil), "newmont.service.v1.MngIconReply")
	proto.RegisterMapType((map[int64]*MngIcon)(nil), "newmont.service.v1.MngIconReply.InfoEntry")
	proto.RegisterType((*Hidden)(nil), "newmont.service.v1.Hidden")
	proto.RegisterMapType((map[string]string)(nil), "newmont.service.v1.Hidden.ChannelMapEntry")
	proto.RegisterType((*HiddenLimit)(nil), "newmont.service.v1.HiddenLimit")
	proto.RegisterType((*HiddenInfo)(nil), "newmont.service.v1.HiddenInfo")
}

func init() {
	proto.RegisterFile("go-gateway/app/app-svr/newmont/service/api/api.proto", fileDescriptor_5bf0d996435ae19d)
}

var fileDescriptor_5bf0d996435ae19d = []byte{
	// 1858 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0x17, 0xff, 0x93, 0x8f, 0x14, 0x45, 0x8f, 0xe4, 0x78, 0x43, 0xc3, 0x12, 0xb3, 0x8d, 0x51,
	0x35, 0x88, 0xa9, 0xda, 0x69, 0x52, 0x37, 0x40, 0x02, 0x58, 0xb2, 0x62, 0x11, 0xd1, 0x1f, 0x77,
	0x45, 0xa1, 0x41, 0x7b, 0xd8, 0x2e, 0xb9, 0x23, 0x6a, 0xe0, 0xdd, 0x9d, 0xcd, 0xee, 0x2c, 0x15,
	0xe6, 0xdc, 0xa2, 0x87, 0x7e, 0x81, 0x7e, 0x80, 0xf6, 0x52, 0xf4, 0xd8, 0x0f, 0x91, 0x63, 0xce,
	0x3d, 0x18, 0xad, 0xfb, 0x0d, 0x72, 0xec, 0xa9, 0x98, 0x79, 0xb3, 0xe4, 0x52, 0xa4, 0x6c, 0xb5,
	0x05, 0x8a, 0x1c, 0x08, 0xcc, 0xfc, 0xf6, 0xcd, 0x7b, 0xf3, 0xde, 0xfb, 0xbd, 0xb7, 0x6f, 0x09,
	0x3f, 0x19, 0xf1, 0x07, 0x23, 0x47, 0xd0, 0x4b, 0x67, 0xb2, 0xe3, 0x84, 0xa1, 0xfc, 0x3d, 0x88,
	0xc7, 0xd1, 0x4e, 0x40, 0x2f, 0x7d, 0x1e, 0x88, 0x9d, 0x98, 0x46, 0x63, 0x36, 0xa4, 0x3b, 0x4e,
	0xc8, 0xe4, 0xaf, 0x1b, 0x46, 0x5c, 0x70, 0x42, 0xf4, 0xe3, 0xae, 0x7e, 0xdc, 0x1d, 0x3f, 0x6c,
	0x3f, 0x18, 0x31, 0x71, 0x91, 0x0c, 0xba, 0x43, 0xee, 0xef, 0x8c, 0xf8, 0x88, 0xef, 0x28, 0xd1,
	0x41, 0x72, 0xae, 0x76, 0x6a, 0xa3, 0x56, 0xa8, 0xc2, 0xfc, 0x5d, 0x1e, 0xd6, 0x8f, 0x58, 0x40,
	0x4f, 0xe9, 0x50, 0x30, 0x1e, 0xc4, 0x16, 0xfd, 0x32, 0xa1, 0xb1, 0x20, 0x04, 0x8a, 0xa1, 0xe7,
	0x08, 0x23, 0xd7, 0xc9, 0x6d, 0x97, 0x2c, 0xb5, 0x26, 0x1b, 0x50, 0x1a, 0x24, 0xcc, 0x73, 0x8d,
	0xbc, 0x02, 0x71, 0x43, 0x5a, 0x50, 0xf0, 0x99, 0x6b, 0x14, 0x3a, 0xb9, 0xed, 0x82, 0x25, 0x97,
	0xf2, 0xac, 0xe7, 0x04, 0x23, 0xa3, 0xd8, 0xc9, 0x6d, 0xd7, 0x2c, 0xb5, 0x26, 0x06, 0x54, 0x86,
	0x17, 0x4e, 0x10, 0x50, 0xcf, 0x28, 0x29, 0x38, 0xdd, 0x92, 0x26, 0xe4, 0x59, 0x68, 0x94, 0x15,
	0x98, 0x67, 0x21, 0xd9, 0x82, 0x3a, 0x8b, 0xed, 0x24, 0xf4, 0xb8, 0xe3, 0xd2, 0xc8, 0xa8, 0x74,
	0x72, 0xdb, 0x55, 0x0b, 0x58, 0x7c, 0xa6, 0x11, 0xd2, 0x81, 0x06, 0x8b, 0x6d, 0x8f, 0x8d, 0xa9,
	0x7d, 0xc1, 0x63, 0x61, 0x54, 0x53, 0x89, 0x43, 0x36, 0xa6, 0x07, 0x3c, 0x16, 0xe4, 0x1e, 0xc0,
	0xb9, 0x13, 0xc4, 0xf6, 0x90, 0x27, 0x81, 0x30, 0x6a, 0xea, 0x66, 0x35, 0x89, 0xec, 0x49, 0x00,
	0xfd, 0x18, 0x33, 0xd7, 0x00, 0x65, 0x14, 0x37, 0xe6, 0x21, 0xdc, 0x9a, 0x0f, 0x44, 0xe8, 0x4d,
	0xc8, 0x4f, 0xa1, 0x1a, 0x6b, 0xc0, 0xc8, 0x75, 0x0a, 0xdb, 0xf5, 0x47, 0x77, 0xbb, 0x8b, 0x41,
	0xef, 0xea, 0x43, 0xd6, 0x54, 0xd8, 0xfc, 0x53, 0x0e, 0xd6, 0x0f, 0xb8, 0xff, 0x3d, 0x8a, 0xeb,
	0xd4, 0xeb, 0xca, 0x15, 0xaf, 0xe7, 0xaf, 0xf9, 0x3f, 0x79, 0xfd, 0x97, 0x22, 0x54, 0x34, 0xaa,
	0xec, 0xbb, 0xca, 0xcf, 0x82, 0x95, 0x67, 0xae, 0xb4, 0x2f, 0x98, 0xf0, 0xa8, 0xf2, 0xb2, 0x66,
	0xe1, 0x46, 0xa2, 0xb1, 0x98, 0x78, 0x54, 0xf9, 0x59, 0xb2, 0x70, 0x23, 0x39, 0x30, 0x48, 0x84,
	0xe0, 0x81, 0x1d, 0x38, 0x3e, 0xd5, 0x0e, 0x03, 0x42, 0xc7, 0x8e, 0x4f, 0x65, 0x86, 0xb5, 0x40,
	0x12, 0xa5, 0x9e, 0xd7, 0x10, 0x39, 0x8b, 0xbc, 0xcc, 0x79, 0x36, 0xe4, 0x81, 0x0e, 0x82, 0x3e,
	0xd1, 0x1b, 0xf2, 0x80, 0xbc, 0x03, 0x0d, 0x2d, 0x80, 0xd6, 0x2b, 0xca, 0xba, 0x3e, 0x74, 0x9a,
	0xde, 0x41, 0x5d, 0xd1, 0x1e, 0x72, 0x8f, 0x47, 0x8a, 0x65, 0x35, 0x0b, 0x14, 0xb4, 0x27, 0x11,
	0xd2, 0x86, 0x6a, 0x9c, 0x0c, 0xd0, 0xa7, 0x9a, 0x7a, 0x3a, 0xdd, 0x4b, 0xfd, 0xe9, 0x5a, 0xdd,
	0x10, 0x99, 0x56, 0x4f, 0x31, 0x79, 0xc7, 0xfb, 0xd0, 0x9c, 0x8a, 0xa0, 0x89, 0xba, 0x12, 0x5a,
	0x4d, 0x51, 0xb4, 0xb2, 0x09, 0x30, 0x70, 0x86, 0x2f, 0x46, 0x11, 0x4f, 0x02, 0xd7, 0x68, 0x68,
	0x4f, 0xa6, 0x08, 0xf9, 0x11, 0xb4, 0x66, 0x3b, 0xad, 0x68, 0x55, 0x49, 0xad, 0xcd, 0x70, 0x54,
	0xf5, 0x21, 0x94, 0x98, 0xa0, 0x7e, 0x6c, 0x34, 0x55, 0x4e, 0xb7, 0x5e, 0x93, 0xd3, 0x9e, 0xa0,
	0xbe, 0x85, 0xd2, 0x32, 0xd6, 0x4e, 0xe2, 0x32, 0x61, 0xc7, 0x17, 0xfc, 0xd2, 0x58, 0x53, 0x91,
	0xaa, 0x29, 0xe4, 0xf4, 0x82, 0x5f, 0x92, 0xdb, 0x50, 0x66, 0xb1, 0xed, 0x07, 0x23, 0xa3, 0x85,
	0x29, 0x64, 0xf1, 0x51, 0x30, 0x22, 0x26, 0xac, 0xf2, 0x10, 0xa3, 0x6b, 0x8b, 0x49, 0x48, 0x8d,
	0x5b, 0x18, 0x62, 0x1e, 0xaa, 0xf0, 0xf6, 0x27, 0x21, 0x35, 0xff, 0x5c, 0x86, 0x7a, 0xc6, 0xe0,
	0x0d, 0x29, 0xd3, 0x82, 0x42, 0x12, 0x31, 0x45, 0x98, 0x9a, 0x25, 0x97, 0xb2, 0x30, 0x54, 0x9e,
	0x75, 0x61, 0xc8, 0xb5, 0xbc, 0x75, 0x40, 0xa9, 0x6b, 0x7b, 0x7c, 0xc4, 0x02, 0xc5, 0x90, 0x92,
	0x55, 0x93, 0xc8, 0xa1, 0x04, 0xc8, 0x1d, 0xa8, 0x44, 0xd4, 0xb5, 0x5d, 0x2e, 0x14, 0x3b, 0x4a,
	0x56, 0x39, 0xa2, 0xee, 0x53, 0x2e, 0xc8, 0xbb, 0xd0, 0x1c, 0x79, 0x7c, 0xe0, 0x78, 0x76, 0xfa,
	0x1c, 0xb9, 0xd1, 0x40, 0xd4, 0x42, 0x29, 0x03, 0x2a, 0x2e, 0x8b, 0x43, 0xcf, 0x99, 0x28, 0x62,
	0x94, 0xac, 0x74, 0x4b, 0x3e, 0x82, 0xaa, 0x1f, 0x8c, 0x90, 0x77, 0x92, 0x15, 0xd7, 0xd4, 0xce,
	0x51, 0x30, 0x92, 0x44, 0xb4, 0x2a, 0x3e, 0x2e, 0xc8, 0x7d, 0x58, 0xd3, 0x06, 0xed, 0x73, 0x1e,
	0xd9, 0x01, 0xbd, 0x54, 0xa4, 0xa9, 0x5a, 0x0d, 0xbc, 0xd8, 0x67, 0x3c, 0x3a, 0xa6, 0x97, 0xe4,
	0x6d, 0xa8, 0xf2, 0xd0, 0xc6, 0xa8, 0x20, 0x5f, 0x2a, 0x3c, 0xec, 0xab, 0xb8, 0x74, 0xa0, 0x21,
	0x23, 0x9e, 0x0c, 0xf4, 0x63, 0xcd, 0x15, 0x1e, 0x9e, 0x26, 0x03, 0x94, 0xc0, 0x9c, 0x20, 0xe5,
	0xd4, 0x05, 0x91, 0x28, 0x75, 0xad, 0x41, 0xdd, 0x03, 0xb5, 0x78, 0x2c, 0x78, 0x61, 0x0b, 0xfa,
	0x95, 0x30, 0x9a, 0xa9, 0x96, 0x43, 0x16, 0xbc, 0xe8, 0xd3, 0xaf, 0x44, 0x56, 0x42, 0x29, 0x59,
	0xcb, 0x4a, 0x28, 0x1d, 0xcf, 0x33, 0x3a, 0x64, 0xea, 0x25, 0x31, 0x9a, 0x8f, 0xba, 0x6f, 0xe0,
	0xdb, 0x09, 0x9a, 0x98, 0x84, 0xb4, 0xbb, 0x1f, 0x24, 0xfe, 0xd4, 0xe6, 0x24, 0xa4, 0x92, 0x64,
	0xc2, 0x19, 0xd8, 0xcc, 0x55, 0x34, 0x92, 0x54, 0x70, 0x06, 0x3d, 0x57, 0xa6, 0xc1, 0x09, 0x98,
	0xef, 0x08, 0x6a, 0x10, 0x0c, 0x86, 0xde, 0x92, 0x1f, 0xc0, 0xaa, 0xc7, 0x47, 0xdc, 0x8e, 0xa9,
	0x47, 0x87, 0x82, 0xba, 0xc6, 0xba, 0x7a, 0xde, 0x90, 0xe0, 0xa9, 0xc6, 0xc8, 0x26, 0xd4, 0xd3,
	0x98, 0xcb, 0x22, 0xdd, 0xc0, 0x36, 0x82, 0xf1, 0x96, 0x25, 0xfa, 0x2e, 0x34, 0xa7, 0xf1, 0xc2,
	0xca, 0xba, 0x8d, 0x5a, 0x74, 0xc0, 0xb0, 0xac, 0xba, 0xb0, 0xce, 0x43, 0x7b, 0xa1, 0x08, 0xdf,
	0x52, 0xa2, 0xb7, 0x78, 0xb8, 0xbb, 0x50, 0x86, 0x77, 0xd2, 0xe8, 0x0c, 0x79, 0x20, 0x1c, 0x16,
	0xd0, 0x48, 0x9f, 0xb9, 0xa3, 0xce, 0x6c, 0xa0, 0xe3, 0x7b, 0xe9, 0x43, 0x75, 0xcc, 0xfc, 0x6d,
	0x0e, 0x6e, 0x2f, 0x8d, 0x96, 0xe9, 0x41, 0x51, 0x06, 0x8c, 0x00, 0x94, 0x77, 0xcf, 0xfa, 0xfd,
	0x93, 0xe3, 0xd6, 0x0a, 0x21, 0xd0, 0x3c, 0xec, 0x1d, 0x7f, 0x6e, 0xff, 0xa2, 0xd7, 0x3f, 0xb0,
	0xfb, 0xfb, 0x5f, 0xf4, 0x5b, 0x39, 0x72, 0x1b, 0x6e, 0x4d, 0xb1, 0x93, 0xb3, 0x3e, 0xc2, 0x79,
	0x72, 0x0b, 0x56, 0x9f, 0xf6, 0x9e, 0x1c, 0x9e, 0x3c, 0xb3, 0x4f, 0x9e, 0xef, 0x1f, 0xef, 0x5b,
	0xad, 0x02, 0x69, 0x02, 0x1c, 0x3f, 0xb1, 0x9f, 0x3f, 0x79, 0xb6, 0x6f, 0xf7, 0x9e, 0xb6, 0x8a,
	0x52, 0xf3, 0xf1, 0x49, 0xbf, 0xb7, 0xb7, 0xdf, 0x2a, 0x99, 0x7f, 0xcd, 0x43, 0x45, 0xb3, 0x77,
	0xa1, 0x60, 0xd3, 0x42, 0xcc, 0xcf, 0x17, 0xe2, 0xac, 0xa0, 0x74, 0x9b, 0xaf, 0x4d, 0x8b, 0x49,
	0x76, 0x4a, 0x7a, 0x7e, 0x4e, 0x87, 0xc2, 0x96, 0x31, 0x0a, 0x55, 0x0d, 0x97, 0xac, 0x3a, 0x62,
	0xcf, 0x24, 0x24, 0x35, 0x68, 0x91, 0x4c, 0xb3, 0x47, 0x44, 0x66, 0xe9, 0x23, 0x28, 0xfb, 0xdc,
	0x4d, 0x3c, 0x6a, 0x94, 0x55, 0x5f, 0xdb, 0x5c, 0xc6, 0x33, 0x79, 0xdd, 0x23, 0x25, 0x65, 0x69,
	0x69, 0xd9, 0x0e, 0x63, 0xc1, 0x7c, 0x6c, 0xfe, 0x85, 0xdd, 0xad, 0x7f, 0xbd, 0xdc, 0xba, 0x3b,
	0xe2, 0x0f, 0x86, 0xdc, 0xf7, 0x79, 0xb0, 0xe3, 0xb1, 0x41, 0xe4, 0x44, 0x93, 0x1d, 0x29, 0xd1,
	0xed, 0x33, 0x9f, 0x5a, 0x28, 0x2d, 0x8f, 0x51, 0x75, 0xac, 0x7a, 0xc3, 0x63, 0x4a, 0xda, 0x7c,
	0x04, 0x30, 0xbb, 0xc3, 0xd2, 0x31, 0xa0, 0x05, 0x05, 0xce, 0x70, 0x08, 0x28, 0x58, 0x72, 0x69,
	0x7e, 0x9b, 0x87, 0xb7, 0xd2, 0x94, 0xc7, 0x07, 0xcc, 0x75, 0x69, 0x90, 0x99, 0x23, 0x38, 0x73,
	0xf1, 0xf5, 0x5c, 0xb0, 0xd4, 0x5a, 0xb6, 0x4b, 0xae, 0xea, 0x4d, 0xcf, 0x11, 0x6a, 0x33, 0x9b,
	0x2e, 0x70, 0x92, 0xd0, 0xd3, 0x45, 0x7a, 0x81, 0x62, 0xe6, 0x02, 0x0f, 0xaf, 0xcc, 0x12, 0xbb,
	0x77, 0xbe, 0x7b, 0xb9, 0xb5, 0x3e, 0x76, 0x3c, 0xe6, 0x3a, 0x82, 0x7e, 0x6c, 0x46, 0xf4, 0xcb,
	0x84, 0x45, 0xd4, 0x35, 0x67, 0x43, 0xc6, 0x19, 0xd4, 0x38, 0x73, 0x6d, 0x7c, 0xad, 0x60, 0xf8,
	0x1f, 0xbf, 0xae, 0xcc, 0xe7, 0xbd, 0xe8, 0x9e, 0x30, 0x57, 0x72, 0x39, 0xde, 0x0f, 0x44, 0x34,
	0xb1, 0xaa, 0x5c, 0x6f, 0xdb, 0x5f, 0xc0, 0xea, 0xdc, 0x23, 0x19, 0x9b, 0x17, 0x74, 0xa2, 0x99,
	0x26, 0x97, 0xe4, 0x21, 0x94, 0xc6, 0x8e, 0x97, 0xa0, 0xb3, 0xd7, 0x34, 0xd9, 0x13, 0xe6, 0x1e,
	0xb2, 0x58, 0x58, 0x28, 0xf9, 0x71, 0xfe, 0x71, 0xce, 0xbc, 0x07, 0x15, 0x8d, 0x2e, 0x0b, 0xa1,
	0xf9, 0xb7, 0x3c, 0x6c, 0x2c, 0xdc, 0x55, 0x8e, 0x44, 0x3d, 0x28, 0xf5, 0x82, 0x73, 0x9e, 0xce,
	0x43, 0x1f, 0xdc, 0xc8, 0xc9, 0xd0, 0x9b, 0x74, 0xd5, 0x29, 0xf4, 0x0f, 0x35, 0x90, 0x5f, 0x41,
	0x1d, 0x59, 0x80, 0x0a, 0xf3, 0x4a, 0xe1, 0xcf, 0x6e, 0xac, 0x30, 0x73, 0x16, 0xd5, 0x66, 0xb5,
	0x91, 0x0e, 0xd4, 0x0f, 0x98, 0x4b, 0x9f, 0x4e, 0x02, 0xc7, 0x67, 0x43, 0x95, 0xf3, 0xaa, 0x95,
	0x85, 0xda, 0x8f, 0x01, 0x66, 0x87, 0x97, 0x04, 0x76, 0x23, 0x1b, 0xd8, 0x6a, 0x26, 0x76, 0xed,
	0x4f, 0xa1, 0x75, 0xd5, 0xf8, 0x7f, 0x72, 0xde, 0xf4, 0xa1, 0x99, 0xbe, 0xf6, 0x34, 0x8b, 0x3f,
	0xcc, 0xa6, 0x60, 0xf7, 0x9d, 0xef, 0x5e, 0x6e, 0xdd, 0x5b, 0xa4, 0xdb, 0xfb, 0x2e, 0x1b, 0xd3,
	0xf7, 0x47, 0xe2, 0x93, 0x1f, 0x9b, 0x9a, 0xe8, 0x29, 0x79, 0xf3, 0xf3, 0xd5, 0x33, 0x3f, 0x2e,
	0x9b, 0x7f, 0xcc, 0x41, 0x63, 0x6a, 0x4f, 0xe6, 0xf0, 0x53, 0x28, 0xb2, 0xe0, 0x9c, 0xeb, 0x14,
	0xbe, 0xf7, 0xba, 0xd7, 0xf2, 0x34, 0x75, 0x18, 0x62, 0x75, 0xae, 0xdd, 0x87, 0xda, 0x14, 0xfa,
	0x2f, 0x19, 0x99, 0xea, 0xcf, 0x44, 0xe5, 0x37, 0x45, 0x28, 0x63, 0x7e, 0x17, 0xda, 0x69, 0x0b,
	0x0a, 0xf1, 0xac, 0x23, 0xc4, 0x88, 0x44, 0x33, 0x2f, 0x23, 0xe6, 0x66, 0x3f, 0x00, 0x8a, 0xf3,
	0x1f, 0x00, 0x9f, 0x43, 0x5d, 0x2f, 0x6d, 0xdf, 0x09, 0x8d, 0xd2, 0xf5, 0x5e, 0xa3, 0xf9, 0xee,
	0x1e, 0x4a, 0x1f, 0x39, 0x21, 0x7a, 0x0d, 0xc3, 0x29, 0x20, 0x0d, 0x87, 0xcc, 0x55, 0xb3, 0x52,
	0xc1, 0x92, 0xcb, 0xff, 0x6f, 0xfb, 0x94, 0xf6, 0x87, 0xcc, 0xd5, 0xdf, 0x72, 0x72, 0x29, 0x07,
	0xdf, 0x0b, 0x75, 0x6f, 0xf9, 0x16, 0x75, 0x99, 0x2c, 0x14, 0x3d, 0x66, 0xaf, 0x21, 0xbe, 0x97,
	0xc2, 0xe4, 0x2e, 0xd4, 0xb0, 0xe7, 0xcb, 0x01, 0xa2, 0xae, 0x54, 0x54, 0x11, 0xe8, 0xb9, 0x72,
	0x52, 0x48, 0xc3, 0x74, 0x9e, 0x7c, 0xfd, 0xf5, 0xc4, 0x68, 0x74, 0x0a, 0xf2, 0x1d, 0xaf, 0xc1,
	0xcf, 0x24, 0x26, 0xdf, 0x52, 0x17, 0xcc, 0xa5, 0xb6, 0xab, 0xeb, 0x6a, 0x55, 0x29, 0xa9, 0x5f,
	0x64, 0xea, 0xea, 0x13, 0x58, 0xbb, 0x12, 0xc0, 0x2c, 0x47, 0x6a, 0x4b, 0x8a, 0xa3, 0x96, 0xa5,
	0xc1, 0x44, 0x15, 0xae, 0x4b, 0x83, 0x43, 0xe6, 0x33, 0xb1, 0x8c, 0x0a, 0xf3, 0x2f, 0x07, 0xf9,
	0x61, 0x30, 0x75, 0x3c, 0xd6, 0xd3, 0x70, 0x06, 0x99, 0xf5, 0xfd, 0xe2, 0xb2, 0xbe, 0x5f, 0x9a,
	0x95, 0x8e, 0x19, 0x03, 0xa0, 0x69, 0xc9, 0x6e, 0xd2, 0x9d, 0x56, 0x89, 0x64, 0x71, 0xfb, 0x7a,
	0xbe, 0x60, 0x55, 0xc8, 0x84, 0x7a, 0xf2, 0xca, 0xba, 0x91, 0x6d, 0x5d, 0x7f, 0x40, 0x79, 0x66,
	0xa1, 0xf4, 0xa3, 0xdf, 0x17, 0xa0, 0x72, 0x8c, 0x92, 0xe4, 0xd7, 0xd0, 0xc8, 0x7e, 0x84, 0x92,
	0x1f, 0x2e, 0xd5, 0xb1, 0xf8, 0x35, 0xdd, 0xbe, 0xff, 0x66, 0xc1, 0xd0, 0x9b, 0x98, 0x2b, 0xd2,
	0x42, 0xf6, 0xe3, 0x7e, 0xb9, 0x85, 0x25, 0xff, 0x83, 0x2c, 0xb7, 0xb0, 0xf0, 0x3f, 0x81, 0xb9,
	0x42, 0x18, 0xac, 0x5d, 0x69, 0xd7, 0xe4, 0xbd, 0x9b, 0xbf, 0x09, 0xdb, 0xdb, 0x37, 0xed, 0xff,
	0xe6, 0x0a, 0xf9, 0xf9, 0x6c, 0x00, 0x33, 0x5f, 0xdb, 0xc4, 0x50, 0x75, 0xe7, 0x4d, 0x8d, 0xce,
	0x5c, 0xd9, 0x7d, 0xfb, 0x9b, 0x7f, 0x6c, 0xae, 0x7c, 0xf3, 0x6a, 0x33, 0xf7, 0xed, 0xab, 0xcd,
	0xdc, 0xdf, 0x5f, 0x6d, 0xe6, 0xfe, 0xf0, 0xcf, 0xcd, 0x95, 0x5f, 0x16, 0x9c, 0x90, 0x0d, 0xca,
	0xea, 0x8f, 0xa2, 0x0f, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x12, 0x36, 0x1f, 0xd0, 0xa3, 0x12,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NewmontClient is the client API for Newmont service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NewmontClient interface {
	// 获取首页模块配置
	HomeSections(ctx context.Context, in *HomeSectionsRequest, opts ...grpc.CallOption) (*HomeSectionsReply, error)
	// 获取我的页模块配置
	MineSections(ctx context.Context, in *MineSectionsRequest, opts ...grpc.CallOption) (*MineSectionsReply, error)
	// 获取入口是否屏蔽
	SectionIsHidden(ctx context.Context, in *SectionIsHiddenRequest, opts ...grpc.CallOption) (*SectionIsHiddenReply, error)
	// 获取模块icon资源配置
	MngIcon(ctx context.Context, in *MngIconRequest, opts ...grpc.CallOption) (*MngIconReply, error)
}

type newmontClient struct {
	cc *grpc.ClientConn
}

func NewNewmontClient(cc *grpc.ClientConn) NewmontClient {
	return &newmontClient{cc}
}

func (c *newmontClient) HomeSections(ctx context.Context, in *HomeSectionsRequest, opts ...grpc.CallOption) (*HomeSectionsReply, error) {
	out := new(HomeSectionsReply)
	err := c.cc.Invoke(ctx, "/newmont.service.v1.Newmont/HomeSections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newmontClient) MineSections(ctx context.Context, in *MineSectionsRequest, opts ...grpc.CallOption) (*MineSectionsReply, error) {
	out := new(MineSectionsReply)
	err := c.cc.Invoke(ctx, "/newmont.service.v1.Newmont/MineSections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newmontClient) SectionIsHidden(ctx context.Context, in *SectionIsHiddenRequest, opts ...grpc.CallOption) (*SectionIsHiddenReply, error) {
	out := new(SectionIsHiddenReply)
	err := c.cc.Invoke(ctx, "/newmont.service.v1.Newmont/SectionIsHidden", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newmontClient) MngIcon(ctx context.Context, in *MngIconRequest, opts ...grpc.CallOption) (*MngIconReply, error) {
	out := new(MngIconReply)
	err := c.cc.Invoke(ctx, "/newmont.service.v1.Newmont/MngIcon", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NewmontServer is the server API for Newmont service.
type NewmontServer interface {
	// 获取首页模块配置
	HomeSections(context.Context, *HomeSectionsRequest) (*HomeSectionsReply, error)
	// 获取我的页模块配置
	MineSections(context.Context, *MineSectionsRequest) (*MineSectionsReply, error)
	// 获取入口是否屏蔽
	SectionIsHidden(context.Context, *SectionIsHiddenRequest) (*SectionIsHiddenReply, error)
	// 获取模块icon资源配置
	MngIcon(context.Context, *MngIconRequest) (*MngIconReply, error)
}

// UnimplementedNewmontServer can be embedded to have forward compatible implementations.
type UnimplementedNewmontServer struct {
}

func (*UnimplementedNewmontServer) HomeSections(ctx context.Context, req *HomeSectionsRequest) (*HomeSectionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HomeSections not implemented")
}
func (*UnimplementedNewmontServer) MineSections(ctx context.Context, req *MineSectionsRequest) (*MineSectionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MineSections not implemented")
}
func (*UnimplementedNewmontServer) SectionIsHidden(ctx context.Context, req *SectionIsHiddenRequest) (*SectionIsHiddenReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SectionIsHidden not implemented")
}
func (*UnimplementedNewmontServer) MngIcon(ctx context.Context, req *MngIconRequest) (*MngIconReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MngIcon not implemented")
}

func RegisterNewmontServer(s *grpc.Server, srv NewmontServer) {
	s.RegisterService(&_Newmont_serviceDesc, srv)
}

func _Newmont_HomeSections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HomeSectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewmontServer).HomeSections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newmont.service.v1.Newmont/HomeSections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewmontServer).HomeSections(ctx, req.(*HomeSectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newmont_MineSections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MineSectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewmontServer).MineSections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newmont.service.v1.Newmont/MineSections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewmontServer).MineSections(ctx, req.(*MineSectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newmont_SectionIsHidden_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SectionIsHiddenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewmontServer).SectionIsHidden(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newmont.service.v1.Newmont/SectionIsHidden",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewmontServer).SectionIsHidden(ctx, req.(*SectionIsHiddenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newmont_MngIcon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MngIconRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewmontServer).MngIcon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newmont.service.v1.Newmont/MngIcon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewmontServer).MngIcon(ctx, req.(*MngIconRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Newmont_serviceDesc = grpc.ServiceDesc{
	ServiceName: "newmont.service.v1.Newmont",
	HandlerType: (*NewmontServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HomeSections",
			Handler:    _Newmont_HomeSections_Handler,
		},
		{
			MethodName: "MineSections",
			Handler:    _Newmont_MineSections_Handler,
		},
		{
			MethodName: "SectionIsHidden",
			Handler:    _Newmont_SectionIsHidden_Handler,
		},
		{
			MethodName: "MngIcon",
			Handler:    _Newmont_MngIcon_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go-gateway/app/app-svr/newmont/service/api/api.proto",
}

func (m *MineSectionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MineSectionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MineSectionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Buvid) > 0 {
		i -= len(m.Buvid)
		copy(dAtA[i:], m.Buvid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Buvid)))
		i--
		dAtA[i] = 0x52
	}
	if m.FansCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FansCount))
		i--
		dAtA[i] = 0x48
	}
	if m.IsLiveHost {
		i--
		if m.IsLiveHost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IsUploader {
		i--
		if m.IsUploader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x22
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x18
	}
	if m.Build != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x10
	}
	if m.Plat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MineSectionsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MineSectionsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MineSectionsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sections) > 0 {
		for iNdEx := len(m.Sections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HomeSectionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HomeSectionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HomeSectionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Buvid) > 0 {
		i -= len(m.Buvid)
		copy(dAtA[i:], m.Buvid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Buvid)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x22
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x18
	}
	if m.Build != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x10
	}
	if m.Plat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HomeSectionsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HomeSectionsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HomeSectionsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sections) > 0 {
		for iNdEx := len(m.Sections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Section) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Section) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Section) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OpStyleType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OpStyleType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsMng != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.IsMng))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.AuditShow != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AuditShow))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.BackgroundColor) > 0 {
		i -= len(m.BackgroundColor)
		copy(dAtA[i:], m.BackgroundColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BackgroundColor)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Background) > 0 {
		i -= len(m.Background)
		copy(dAtA[i:], m.Background)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Background)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SubtitleColor) > 0 {
		i -= len(m.SubtitleColor)
		copy(dAtA[i:], m.SubtitleColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SubtitleColor)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SubtitleUrl) > 0 {
		i -= len(m.SubtitleUrl)
		copy(dAtA[i:], m.SubtitleUrl)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SubtitleUrl)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Subtitle) > 0 {
		i -= len(m.Subtitle)
		copy(dAtA[i:], m.Subtitle)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Subtitle)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TitleColor) > 0 {
		i -= len(m.TitleColor)
		copy(dAtA[i:], m.TitleColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TitleColor)))
		i--
		dAtA[i] = 0x42
	}
	if m.ButtonStyle != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ButtonStyle))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ButtonIcon) > 0 {
		i -= len(m.ButtonIcon)
		copy(dAtA[i:], m.ButtonIcon)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ButtonIcon)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ButtonUrl) > 0 {
		i -= len(m.ButtonUrl)
		copy(dAtA[i:], m.ButtonUrl)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ButtonUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ButtonName) > 0 {
		i -= len(m.ButtonName)
		copy(dAtA[i:], m.ButtonName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ButtonName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Style != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SectionItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OpLinkContainerColor) > 0 {
		i -= len(m.OpLinkContainerColor)
		copy(dAtA[i:], m.OpLinkContainerColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpLinkContainerColor)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.OpBackgroundColor) > 0 {
		i -= len(m.OpBackgroundColor)
		copy(dAtA[i:], m.OpBackgroundColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpBackgroundColor)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.OpTitleColor) > 0 {
		i -= len(m.OpTitleColor)
		copy(dAtA[i:], m.OpTitleColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpTitleColor)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.RedDotUrl) > 0 {
		i -= len(m.RedDotUrl)
		copy(dAtA[i:], m.RedDotUrl)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RedDotUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.LogoSelected) > 0 {
		i -= len(m.LogoSelected)
		copy(dAtA[i:], m.LogoSelected)
		i = encodeVarintApi(dAtA, i, uint64(len(m.LogoSelected)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Animate) > 0 {
		i -= len(m.Animate)
		copy(dAtA[i:], m.Animate)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Animate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.TabId) > 0 {
		i -= len(m.TabId)
		copy(dAtA[i:], m.TabId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TabId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.OpLinkType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OpLinkType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.OpLinkIcon) > 0 {
		i -= len(m.OpLinkIcon)
		copy(dAtA[i:], m.OpLinkIcon)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpLinkIcon)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.OpLinkText) > 0 {
		i -= len(m.OpLinkText)
		copy(dAtA[i:], m.OpLinkText)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpLinkText)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.OpTitleIcon) > 0 {
		i -= len(m.OpTitleIcon)
		copy(dAtA[i:], m.OpTitleIcon)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpTitleIcon)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.OpSubTitle) > 0 {
		i -= len(m.OpSubTitle)
		copy(dAtA[i:], m.OpSubTitle)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpSubTitle)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.OpTitle) > 0 {
		i -= len(m.OpTitle)
		copy(dAtA[i:], m.OpTitle)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpTitle)))
		i--
		dAtA[i] = 0x5a
	}
	if m.RedDotForNew {
		i--
		if m.RedDotForNew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.MngIcon != nil {
		{
			size, err := m.MngIcon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Display != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Display))
		i--
		dAtA[i] = 0x40
	}
	if m.GlobalRedDot != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GlobalRedDot))
		i--
		dAtA[i] = 0x38
	}
	if m.RedDot != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RedDot))
		i--
		dAtA[i] = 0x30
	}
	if m.NeedLogin != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NeedLogin))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SectionItemOpLinkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionItemOpLinkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectionItemOpLinkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MngIcon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MngIcon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MngIcon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Etime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x40
	}
	if m.Stime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Module) > 0 {
		for iNdEx := len(m.Module) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Module[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EffectUrl) > 0 {
		i -= len(m.EffectUrl)
		copy(dAtA[i:], m.EffectUrl)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EffectUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if m.EffectGroup != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EffectGroup))
		i--
		dAtA[i] = 0x20
	}
	if m.GlobalRed != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GlobalRed))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IconModule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IconModule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IconModule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.Plat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SectionIsHiddenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionIsHiddenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectionIsHiddenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OidItems) > 0 {
		for k := range m.OidItems {
			v := m.OidItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Plat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x20
	}
	if m.Build != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x18
	}
	if m.Otype != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Otype))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Oids) > 0 {
		dAtA4 := make([]byte, len(m.Oids)*10)
		var j3 int
		for _, num1 := range m.Oids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OidList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OidList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OidList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Oids) > 0 {
		dAtA6 := make([]byte, len(m.Oids)*10)
		var j5 int
		for _, num1 := range m.Oids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintApi(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SectionIsHiddenReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionIsHiddenReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectionIsHiddenReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HideDynamic {
		i--
		if m.HideDynamic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ModuleInfos) > 0 {
		for k := range m.ModuleInfos {
			v := m.ModuleInfos[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Infos) > 0 {
		for k := range m.Infos {
			v := m.Infos[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MngIconRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MngIconRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MngIconRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x18
	}
	if m.Plat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Oids) > 0 {
		dAtA8 := make([]byte, len(m.Oids)*10)
		var j7 int
		for _, num1 := range m.Oids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintApi(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MngIconReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MngIconReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MngIconReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		for k := range m.Info {
			v := m.Info[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Hidden) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hidden) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Hidden) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HideDynamic != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.HideDynamic))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ChannelFuzzy) > 0 {
		for iNdEx := len(m.ChannelFuzzy) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChannelFuzzy[iNdEx])
			copy(dAtA[i:], m.ChannelFuzzy[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.ChannelFuzzy[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.ModuleId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ModuleId))
		i--
		dAtA[i] = 0x58
	}
	if len(m.HiddenCondition) > 0 {
		i -= len(m.HiddenCondition)
		copy(dAtA[i:], m.HiddenCondition)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HiddenCondition)))
		i--
		dAtA[i] = 0x52
	}
	if m.Cid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x48
	}
	if m.Etime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x40
	}
	if m.Stime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x38
	}
	if m.Pid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ChannelMap) > 0 {
		for k := range m.ChannelMap {
			v := m.ChannelMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x22
	}
	if m.Rid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x18
	}
	if m.Sid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HiddenLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HiddenLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HiddenLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Plat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x28
	}
	if m.Build != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Conditions) > 0 {
		i -= len(m.Conditions)
		copy(dAtA[i:], m.Conditions)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Conditions)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HiddenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HiddenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HiddenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Limit) > 0 {
		for iNdEx := len(m.Limit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Limit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MineSectionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plat != 0 {
		n += 1 + sovApi(uint64(m.Plat))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsUploader {
		n += 2
	}
	if m.IsLiveHost {
		n += 2
	}
	if m.FansCount != 0 {
		n += 1 + sovApi(uint64(m.FansCount))
	}
	l = len(m.Buvid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MineSectionsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for _, e := range m.Sections {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HomeSectionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plat != 0 {
		n += 1 + sovApi(uint64(m.Plat))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Buvid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HomeSectionsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for _, e := range m.Sections {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Section) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovApi(uint64(m.Style))
	}
	l = len(m.ButtonName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ButtonUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ButtonIcon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ButtonStyle != 0 {
		n += 1 + sovApi(uint64(m.ButtonStyle))
	}
	l = len(m.TitleColor)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Subtitle)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SubtitleUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SubtitleColor)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Background)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.BackgroundColor)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.AuditShow != 0 {
		n += 1 + sovApi(uint64(m.AuditShow))
	}
	if m.IsMng != 0 {
		n += 2 + sovApi(uint64(m.IsMng))
	}
	if m.OpStyleType != 0 {
		n += 2 + sovApi(uint64(m.OpStyleType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectionItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NeedLogin != 0 {
		n += 1 + sovApi(uint64(m.NeedLogin))
	}
	if m.RedDot != 0 {
		n += 1 + sovApi(uint64(m.RedDot))
	}
	if m.GlobalRedDot != 0 {
		n += 1 + sovApi(uint64(m.GlobalRedDot))
	}
	if m.Display != 0 {
		n += 1 + sovApi(uint64(m.Display))
	}
	if m.MngIcon != nil {
		l = m.MngIcon.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RedDotForNew {
		n += 2
	}
	l = len(m.OpTitle)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OpSubTitle)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OpTitleIcon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OpLinkText)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OpLinkIcon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.OpLinkType != 0 {
		n += 2 + sovApi(uint64(m.OpLinkType))
	}
	l = len(m.TabId)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Animate)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.LogoSelected)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.RedDotUrl)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.OpTitleColor)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.OpBackgroundColor)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.OpLinkContainerColor)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectionItemOpLinkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MngIcon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GlobalRed != 0 {
		n += 1 + sovApi(uint64(m.GlobalRed))
	}
	if m.EffectGroup != 0 {
		n += 1 + sovApi(uint64(m.EffectGroup))
	}
	l = len(m.EffectUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Module) > 0 {
		for _, e := range m.Module {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Stime != 0 {
		n += 1 + sovApi(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovApi(uint64(m.Etime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IconModule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plat != 0 {
		n += 1 + sovApi(uint64(m.Plat))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectionIsHiddenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Oids) > 0 {
		l = 0
		for _, e := range m.Oids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Otype != 0 {
		n += 1 + sovApi(uint64(m.Otype))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if m.Plat != 0 {
		n += 1 + sovApi(uint64(m.Plat))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.OidItems) > 0 {
		for k, v := range m.OidItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OidList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Oids) > 0 {
		l = 0
		for _, e := range m.Oids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectionIsHiddenReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for k, v := range m.Infos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.ModuleInfos) > 0 {
		for k, v := range m.ModuleInfos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.HideDynamic {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MngIconRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Oids) > 0 {
		l = 0
		for _, e := range m.Oids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Plat != 0 {
		n += 1 + sovApi(uint64(m.Plat))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MngIconReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Hidden) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Sid != 0 {
		n += 1 + sovApi(uint64(m.Sid))
	}
	if m.Rid != 0 {
		n += 1 + sovApi(uint64(m.Rid))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.ChannelMap) > 0 {
		for k, v := range m.ChannelMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Pid != 0 {
		n += 1 + sovApi(uint64(m.Pid))
	}
	if m.Stime != 0 {
		n += 1 + sovApi(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovApi(uint64(m.Etime))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	l = len(m.HiddenCondition)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ModuleId != 0 {
		n += 1 + sovApi(uint64(m.ModuleId))
	}
	if len(m.ChannelFuzzy) > 0 {
		for _, s := range m.ChannelFuzzy {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.HideDynamic != 0 {
		n += 1 + sovApi(uint64(m.HideDynamic))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HiddenLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Conditions)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if m.Plat != 0 {
		n += 1 + sovApi(uint64(m.Plat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HiddenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Limit) > 0 {
		for _, e := range m.Limit {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MineSectionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MineSectionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MineSectionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUploader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUploader = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLiveHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLiveHost = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FansCount", wireType)
			}
			m.FansCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FansCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buvid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buvid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MineSectionsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MineSectionsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MineSectionsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sections = append(m.Sections, &Section{})
			if err := m.Sections[len(m.Sections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HomeSectionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HomeSectionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HomeSectionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buvid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buvid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HomeSectionsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HomeSectionsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HomeSectionsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sections = append(m.Sections, &Section{})
			if err := m.Sections[len(m.Sections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Section) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Section: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Section: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ButtonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ButtonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ButtonUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ButtonUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ButtonIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ButtonIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ButtonStyle", wireType)
			}
			m.ButtonStyle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ButtonStyle |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TitleColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitleUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubtitleUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitleColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubtitleColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Background = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackgroundColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SectionItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditShow", wireType)
			}
			m.AuditShow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuditShow |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMng", wireType)
			}
			m.IsMng = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsMng |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStyleType", wireType)
			}
			m.OpStyleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpStyleType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLogin", wireType)
			}
			m.NeedLogin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedLogin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedDot", wireType)
			}
			m.RedDot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedDot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalRedDot", wireType)
			}
			m.GlobalRedDot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalRedDot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			m.Display = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Display |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MngIcon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MngIcon == nil {
				m.MngIcon = &MngIcon{}
			}
			if err := m.MngIcon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedDotForNew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedDotForNew = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpSubTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpSubTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpTitleIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpTitleIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLinkText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLinkText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLinkIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLinkIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLinkType", wireType)
			}
			m.OpLinkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpLinkType |= SectionItemOpLinkType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TabId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Animate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogoSelected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogoSelected = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedDotUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedDotUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpTitleColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpTitleColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpBackgroundColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpBackgroundColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLinkContainerColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLinkContainerColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionItemOpLinkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionItemOpLinkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionItemOpLinkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MngIcon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MngIcon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MngIcon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalRed", wireType)
			}
			m.GlobalRed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalRed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectGroup", wireType)
			}
			m.EffectGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectGroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = append(m.Module, &IconModule{})
			if err := m.Module[len(m.Module)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IconModule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IconModule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IconModule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionIsHiddenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionIsHiddenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionIsHiddenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Oids = append(m.Oids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Oids) == 0 {
					m.Oids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Oids = append(m.Oids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Oids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			m.Otype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Otype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OidItems == nil {
				m.OidItems = make(map[int64]*OidList)
			}
			var mapkey int64
			var mapvalue *OidList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &OidList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OidItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OidList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OidList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OidList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Oids = append(m.Oids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Oids) == 0 {
					m.Oids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Oids = append(m.Oids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Oids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionIsHiddenReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionIsHiddenReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionIsHiddenReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infos == nil {
				m.Infos = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Infos[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModuleInfos == nil {
				m.ModuleInfos = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ModuleInfos[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideDynamic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideDynamic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MngIconRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MngIconRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MngIconRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Oids = append(m.Oids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Oids) == 0 {
					m.Oids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Oids = append(m.Oids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Oids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MngIconReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MngIconReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MngIconReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[int64]*MngIcon)
			}
			var mapkey int64
			var mapvalue *MngIcon
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MngIcon{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hidden) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hidden: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hidden: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelMap == nil {
				m.ChannelMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChannelMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenCondition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HiddenCondition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			m.ModuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModuleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelFuzzy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelFuzzy = append(m.ChannelFuzzy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideDynamic", wireType)
			}
			m.HideDynamic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HideDynamic |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HiddenLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HiddenLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HiddenLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HiddenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HiddenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HiddenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Hidden{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limit = append(m.Limit, &HiddenLimit{})
			if err := m.Limit[len(m.Limit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
