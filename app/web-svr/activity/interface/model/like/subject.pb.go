// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: subject.proto

package like

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	go_common_library_time "go-common/library/time"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SubjectItem struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Oid                  int64                       `protobuf:"varint,2,opt,name=Oid,proto3" json:"oid"`
	Type                 int64                       `protobuf:"varint,3,opt,name=Type,proto3" json:"type"`
	State                int64                       `protobuf:"varint,4,opt,name=State,proto3" json:"state"`
	Stime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Stime,proto3,casttype=go-common/library/time.Time" json:"stime"`
	Etime                go_common_library_time.Time `protobuf:"varint,6,opt,name=Etime,proto3,casttype=go-common/library/time.Time" json:"etime"`
	Ctime                go_common_library_time.Time `protobuf:"varint,7,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,8,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Name                 string                      `protobuf:"bytes,9,opt,name=Name,proto3" json:"name"`
	Author               string                      `protobuf:"bytes,10,opt,name=Author,proto3" json:"author"`
	ActURL               string                      `protobuf:"bytes,11,opt,name=ActURL,proto3" json:"act_url"`
	Lstime               go_common_library_time.Time `protobuf:"varint,12,opt,name=Lstime,proto3,casttype=go-common/library/time.Time" json:"lstime"`
	Letime               go_common_library_time.Time `protobuf:"varint,13,opt,name=Letime,proto3,casttype=go-common/library/time.Time" json:"letime"`
	Cover                string                      `protobuf:"bytes,14,opt,name=Cover,proto3" json:"cover"`
	Dic                  string                      `protobuf:"bytes,15,opt,name=Dic,proto3" json:"dic"`
	Flag                 int64                       `protobuf:"varint,16,opt,name=Flag,proto3" json:"flag"`
	Uetime               go_common_library_time.Time `protobuf:"varint,17,opt,name=Uetime,proto3,casttype=go-common/library/time.Time" json:"uetime"`
	Ustime               go_common_library_time.Time `protobuf:"varint,18,opt,name=Ustime,proto3,casttype=go-common/library/time.Time" json:"ustime"`
	Level                int64                       `protobuf:"varint,19,opt,name=Level,proto3" json:"level"`
	H5Cover              string                      `protobuf:"bytes,20,opt,name=H5_cover,json=H5Cover,proto3" json:"h5_cover"`
	Rank                 int64                       `protobuf:"varint,21,opt,name=Rank,proto3" json:"rank"`
	LikeLimit            int64                       `protobuf:"varint,22,opt,name=LikeLimit,proto3" json:"like_limit"`
	AndroidURL           string                      `protobuf:"bytes,23,opt,name=AndroidURL,proto3" json:"android_url"`
	IosURL               string                      `protobuf:"bytes,24,opt,name=IosURL,proto3" json:"ios_url"`
	DailyLikeLimit       int64                       `protobuf:"varint,25,opt,name=DailyLikeLimit,proto3" json:"daily_like_limit"`
	DailySingleLikeLimit int64                       `protobuf:"varint,26,opt,name=DailySingleLikeLimit,proto3" json:"daily_single_like_limit"`
	UpLevel              int64                       `protobuf:"varint,27,opt,name=UpLevel,proto3" json:"up_level"`
	UpScore              int64                       `protobuf:"varint,28,opt,name=UpScore,proto3" json:"up_score"`
	UpUetime             go_common_library_time.Time `protobuf:"varint,29,opt,name=UpUetime,proto3,casttype=go-common/library/time.Time" json:"up_uetime"`
	UpUstime             go_common_library_time.Time `protobuf:"varint,30,opt,name=UpUstime,proto3,casttype=go-common/library/time.Time" json:"up_ustime"`
	FanLimitMax          int64                       `protobuf:"varint,31,opt,name=FanLimitMax,proto3" json:"fan_limit_max"`
	FanLimitMin          int64                       `protobuf:"varint,32,opt,name=FanLimitMin,proto3" json:"fan_limit_min"`
	MonthScore           int64                       `protobuf:"varint,33,opt,name=MonthScore,proto3" json:"month_score"`
	YearScore            int64                       `protobuf:"varint,34,opt,name=YearScore,proto3" json:"year_score"`
	ChildSids            string                      `protobuf:"bytes,35,opt,name=ChildSids,proto3" json:"child_sids"`
	UpFigureScore        int64                       `protobuf:"varint,36,opt,name=UpFigureScore,proto3" json:"up_figure_score"`
	ShieldFlag           int64                       `protobuf:"varint,37,opt,name=ShieldFlag,proto3" json:"sheild_flag"`
	RelationID           int64                       `protobuf:"varint,38,opt,name=RelationID,proto3" json:"relation_id"`
	Calendar             string                      `protobuf:"bytes,39,opt,name=Calendar,proto3" json:"calendar"`
	AuditPlatform        string                      `protobuf:"bytes,40,opt,name=AuditPlatform,proto3" json:"-"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SubjectItem) Reset()         { *m = SubjectItem{} }
func (m *SubjectItem) String() string { return proto.CompactTextString(m) }
func (*SubjectItem) ProtoMessage()    {}
func (*SubjectItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{0}
}
func (m *SubjectItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubjectItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubjectItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubjectItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubjectItem.Merge(m, src)
}
func (m *SubjectItem) XXX_Size() int {
	return m.Size()
}
func (m *SubjectItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SubjectItem.DiscardUnknown(m)
}

var xxx_messageInfo_SubjectItem proto.InternalMessageInfo

type Info struct {
	Title                string   `protobuf:"bytes,1,opt,name=Title,proto3" json:"title"`
	Stime                string   `protobuf:"bytes,2,opt,name=Stime,proto3" json:"stime"`
	Etime                string   `protobuf:"bytes,3,opt,name=Etime,proto3" json:"etime"`
	Remarks              string   `protobuf:"bytes,4,opt,name=Remarks,proto3" json:"remarks"`
	JumpUrl              string   `protobuf:"bytes,5,opt,name=JumpUrl,proto3" json:"jump_url"`
	ButtonToast          string   `protobuf:"bytes,6,opt,name=ButtonToast,proto3" json:"button_toast"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}
func (*Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{1}
}
func (m *Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Info.Merge(m, src)
}
func (m *Info) XXX_Size() int {
	return m.Size()
}
func (m *Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Info proto.InternalMessageInfo

type LikeContent struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Message              string                      `protobuf:"bytes,2,opt,name=Message,proto3" json:"message"`
	IP                   int64                       `protobuf:"varint,3,opt,name=IP,proto3" json:"ip"`
	Plat                 int64                       `protobuf:"varint,4,opt,name=Plat,proto3" json:"plat"`
	Device               int64                       `protobuf:"varint,5,opt,name=Device,proto3" json:"device"`
	Ctime                go_common_library_time.Time `protobuf:"varint,6,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,7,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Image                string                      `protobuf:"bytes,8,opt,name=Image,proto3" json:"image"`
	Reply                string                      `protobuf:"bytes,9,opt,name=Reply,proto3" json:"reply"`
	Link                 string                      `protobuf:"bytes,10,opt,name=Link,proto3" json:"link"`
	ExName               string                      `protobuf:"bytes,11,opt,name=ExName,proto3" json:"ex_name"`
	IPv6                 []byte                      `protobuf:"bytes,12,opt,name=IPv6,proto3" json:"ipv6"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *LikeContent) Reset()         { *m = LikeContent{} }
func (m *LikeContent) String() string { return proto.CompactTextString(m) }
func (*LikeContent) ProtoMessage()    {}
func (*LikeContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{2}
}
func (m *LikeContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LikeContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LikeContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LikeContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LikeContent.Merge(m, src)
}
func (m *LikeContent) XXX_Size() int {
	return m.Size()
}
func (m *LikeContent) XXX_DiscardUnknown() {
	xxx_messageInfo_LikeContent.DiscardUnknown(m)
}

var xxx_messageInfo_LikeContent proto.InternalMessageInfo

type ActSubjectProtocol struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Sid                  int64                       `protobuf:"varint,2,opt,name=Sid,proto3" json:"sid"`
	Protocol             string                      `protobuf:"bytes,3,opt,name=Protocol,proto3" json:"protocol"`
	Mtime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Ctime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Types                string                      `protobuf:"bytes,6,opt,name=Types,proto3" json:"types"`
	Tags                 string                      `protobuf:"bytes,7,opt,name=Tags,proto3" json:"tags"`
	Pubtime              go_common_library_time.Time `protobuf:"varint,8,opt,name=Pubtime,proto3,casttype=go-common/library/time.Time" json:"pubtime"`
	Deltime              go_common_library_time.Time `protobuf:"varint,9,opt,name=Deltime,proto3,casttype=go-common/library/time.Time" json:"deltime"`
	Editime              go_common_library_time.Time `protobuf:"varint,10,opt,name=Editime,proto3,casttype=go-common/library/time.Time" json:"editime"`
	Hot                  int64                       `protobuf:"varint,11,opt,name=Hot,proto3" json:"hot"`
	BgmID                int64                       `protobuf:"varint,12,opt,name=BgmID,proto3" json:"bgm_id"`
	PasterID             int64                       `protobuf:"varint,13,opt,name=PasterID,proto3" json:"paster_id"`
	Oids                 string                      `protobuf:"bytes,14,opt,name=Oids,proto3" json:"oids"`
	ScreenSet            int64                       `protobuf:"varint,15,opt,name=ScreenSet,proto3" json:"screen_set"`
	PriorityRegion       string                      `protobuf:"bytes,16,opt,name=PriorityRegion,proto3" json:"priority_region"`
	RegionWeight         int32                       `protobuf:"varint,17,opt,name=RegionWeight,proto3" json:"region_weight"`
	GlobalWeight         int32                       `protobuf:"varint,18,opt,name=GlobalWeight,proto3" json:"global_weight"`
	WeightStime          go_common_library_time.Time `protobuf:"varint,19,opt,name=WeightStime,proto3,casttype=go-common/library/time.Time" json:"weight_stime"`
	WeightEtime          go_common_library_time.Time `protobuf:"varint,20,opt,name=weightEtime,proto3,casttype=go-common/library/time.Time" json:"weight_etime"`
	InstepID             int64                       `protobuf:"varint,21,opt,name=InstepID,proto3" json:"instep_id"`
	TagShowPlatform      int64                       `protobuf:"varint,22,opt,name=TagShowPlatform,proto3" json:"tag_show_platform"`
	Award                string                      `protobuf:"bytes,23,opt,name=Award,proto3" json:"award"`
	AwardURL             string                      `protobuf:"bytes,24,opt,name=AwardURL,proto3" json:"award_url"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ActSubjectProtocol) Reset()         { *m = ActSubjectProtocol{} }
func (m *ActSubjectProtocol) String() string { return proto.CompactTextString(m) }
func (*ActSubjectProtocol) ProtoMessage()    {}
func (*ActSubjectProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{3}
}
func (m *ActSubjectProtocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActSubjectProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActSubjectProtocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActSubjectProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActSubjectProtocol.Merge(m, src)
}
func (m *ActSubjectProtocol) XXX_Size() int {
	return m.Size()
}
func (m *ActSubjectProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_ActSubjectProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_ActSubjectProtocol proto.InternalMessageInfo

type HasReserve struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	State                int32                       `protobuf:"varint,2,opt,name=state,proto3" json:"state"`
	Num                  int32                       `protobuf:"varint,3,opt,name=num,proto3" json:"num"`
	Mtime                go_common_library_time.Time `protobuf:"varint,4,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Ctime                go_common_library_time.Time `protobuf:"varint,5,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Order                int64                       `protobuf:"varint,6,opt,name=order,proto3" json:"order"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *HasReserve) Reset()         { *m = HasReserve{} }
func (m *HasReserve) String() string { return proto.CompactTextString(m) }
func (*HasReserve) ProtoMessage()    {}
func (*HasReserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{4}
}
func (m *HasReserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasReserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasReserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasReserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasReserve.Merge(m, src)
}
func (m *HasReserve) XXX_Size() int {
	return m.Size()
}
func (m *HasReserve) XXX_DiscardUnknown() {
	xxx_messageInfo_HasReserve.DiscardUnknown(m)
}

var xxx_messageInfo_HasReserve proto.InternalMessageInfo

type AwardSubject struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Name                 string                      `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Etime                go_common_library_time.Time `protobuf:"varint,3,opt,name=etime,proto3,casttype=go-common/library/time.Time" json:"etime"`
	Sid                  int64                       `protobuf:"varint,4,opt,name=sid,proto3" json:"sid"`
	Type                 int64                       `protobuf:"varint,5,opt,name=type,proto3" json:"type"`
	SourceId             string                      `protobuf:"bytes,6,opt,name=source_id,json=sourceId,proto3" json:"source_id"`
	SourceExpire         int64                       `protobuf:"varint,7,opt,name=source_expire,json=sourceExpire,proto3" json:"source_expire"`
	State                int64                       `protobuf:"varint,8,opt,name=state,proto3" json:"state"`
	Ctime                go_common_library_time.Time `protobuf:"varint,9,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,10,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	SidType              int64                       `protobuf:"varint,11,opt,name=sid_type,json=sidType,proto3" json:"sid_type"`
	OtherSids            string                      `protobuf:"bytes,12,opt,name=other_sids,json=otherSids,proto3" json:"other_sids"`
	TaskID               int64                       `protobuf:"varint,13,opt,name=taskID,proto3" json:"task_id"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *AwardSubject) Reset()         { *m = AwardSubject{} }
func (m *AwardSubject) String() string { return proto.CompactTextString(m) }
func (*AwardSubject) ProtoMessage()    {}
func (*AwardSubject) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{5}
}
func (m *AwardSubject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardSubject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardSubject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardSubject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardSubject.Merge(m, src)
}
func (m *AwardSubject) XXX_Size() int {
	return m.Size()
}
func (m *AwardSubject) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardSubject.DiscardUnknown(m)
}

var xxx_messageInfo_AwardSubject proto.InternalMessageInfo

type SubjectRule struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Sid                  int64                       `protobuf:"varint,2,opt,name=sid,proto3" json:"sid"`
	Type                 int64                       `protobuf:"varint,3,opt,name=type,proto3" json:"type"`
	TypeIds              string                      `protobuf:"bytes,4,opt,name=type_ids,json=typeIds,proto3" json:"type_ids"`
	Tags                 string                      `protobuf:"bytes,5,opt,name=tags,proto3" json:"tags"`
	State                int64                       `protobuf:"varint,8,opt,name=state,proto3" json:"state"`
	Attribute            int64                       `protobuf:"varint,9,opt,name=attribute,proto3" json:"attribute"`
	Ctime                go_common_library_time.Time `protobuf:"varint,10,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,11,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	TaskID               int64                       `protobuf:"varint,12,opt,name=taskID,proto3" json:"task_id"`
	RuleName             string                      `protobuf:"bytes,13,opt,name=rule_name,json=ruleName,proto3" json:"rule_name"`
	Sids                 string                      `protobuf:"bytes,14,opt,name=sids,proto3" json:"sids"`
	Coefficient          string                      `protobuf:"bytes,15,opt,name=coefficient,proto3" json:"coefficient"`
	AidSource            string                      `protobuf:"bytes,16,opt,name=aid_source,json=aidSource,proto3" json:"aid_source"`
	AidSourceType        int64                       `protobuf:"varint,17,opt,name=aid_source_type,json=aidSourceType,proto3" json:"aid_source_type"`
	Stime                go_common_library_time.Time `protobuf:"varint,18,opt,name=stime,proto3,casttype=go-common/library/time.Time" json:"stime"`
	Etime                go_common_library_time.Time `protobuf:"varint,19,opt,name=etime,proto3,casttype=go-common/library/time.Time" json:"etime"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SubjectRule) Reset()         { *m = SubjectRule{} }
func (m *SubjectRule) String() string { return proto.CompactTextString(m) }
func (*SubjectRule) ProtoMessage()    {}
func (*SubjectRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{6}
}
func (m *SubjectRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubjectRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubjectRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubjectRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubjectRule.Merge(m, src)
}
func (m *SubjectRule) XXX_Size() int {
	return m.Size()
}
func (m *SubjectRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SubjectRule.DiscardUnknown(m)
}

var xxx_messageInfo_SubjectRule proto.InternalMessageInfo

type UpActReserveWhiteList struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=Mid,proto3" json:"oid"`
	Type                 int64    `protobuf:"varint,2,opt,name=Type,proto3" json:"type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpActReserveWhiteList) Reset()         { *m = UpActReserveWhiteList{} }
func (m *UpActReserveWhiteList) String() string { return proto.CompactTextString(m) }
func (*UpActReserveWhiteList) ProtoMessage()    {}
func (*UpActReserveWhiteList) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181af8fcb9beccf, []int{7}
}
func (m *UpActReserveWhiteList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpActReserveWhiteList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpActReserveWhiteList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpActReserveWhiteList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpActReserveWhiteList.Merge(m, src)
}
func (m *UpActReserveWhiteList) XXX_Size() int {
	return m.Size()
}
func (m *UpActReserveWhiteList) XXX_DiscardUnknown() {
	xxx_messageInfo_UpActReserveWhiteList.DiscardUnknown(m)
}

var xxx_messageInfo_UpActReserveWhiteList proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SubjectItem)(nil), "activity.service.SubjectItem")
	proto.RegisterType((*Info)(nil), "activity.service.Info")
	proto.RegisterType((*LikeContent)(nil), "activity.service.LikeContent")
	proto.RegisterType((*ActSubjectProtocol)(nil), "activity.service.ActSubjectProtocol")
	proto.RegisterType((*HasReserve)(nil), "activity.service.HasReserve")
	proto.RegisterType((*AwardSubject)(nil), "activity.service.AwardSubject")
	proto.RegisterType((*SubjectRule)(nil), "activity.service.SubjectRule")
	proto.RegisterType((*UpActReserveWhiteList)(nil), "activity.service.UpActReserveWhiteList")
}

func init() { proto.RegisterFile("subject.proto", fileDescriptor_3181af8fcb9beccf) }

var fileDescriptor_3181af8fcb9beccf = []byte{
	// 2049 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x5b, 0x6f, 0x1b, 0xc7,
	0x15, 0xb6, 0x2e, 0xbc, 0x0d, 0x25, 0xcb, 0xde, 0xd8, 0xc9, 0x26, 0x76, 0xb5, 0x2e, 0x5d, 0xc7,
	0xca, 0xc5, 0x16, 0xda, 0xc0, 0x06, 0x8a, 0x14, 0x29, 0x24, 0x51, 0xae, 0x58, 0x48, 0xb5, 0x3a,
	0x94, 0x10, 0xb4, 0x2f, 0x8b, 0xe1, 0xee, 0x88, 0x9c, 0x68, 0x6f, 0xd8, 0x99, 0x95, 0xa5, 0xc7,
	0xfc, 0x89, 0xa2, 0xff, 0x26, 0xaf, 0xe9, 0x5b, 0x7e, 0x01, 0xd1, 0xb8, 0x6f, 0x44, 0x7f, 0x41,
	0x9f, 0x8a, 0x73, 0x66, 0x96, 0xb3, 0x54, 0xe4, 0x98, 0x56, 0x5e, 0xc8, 0xe5, 0x77, 0x2e, 0x9c,
	0x39, 0xe7, 0xcc, 0x39, 0xdf, 0x0e, 0x59, 0x95, 0xc5, 0xe0, 0x1b, 0x1e, 0xa8, 0xa7, 0x59, 0x9e,
	0xaa, 0xd4, 0xb9, 0xc5, 0x02, 0x25, 0xce, 0x84, 0xba, 0x78, 0x2a, 0x79, 0x7e, 0x26, 0x02, 0xfe,
	0xd1, 0x93, 0xa1, 0x50, 0xa3, 0x62, 0xf0, 0x34, 0x48, 0xe3, 0xcd, 0x61, 0x3a, 0x4c, 0x37, 0x51,
	0x71, 0x50, 0x9c, 0xe0, 0x2f, 0xfc, 0x81, 0x4f, 0xda, 0x41, 0xe7, 0x1f, 0x6b, 0xa4, 0xdd, 0xd7,
	0x2e, 0x7b, 0x8a, 0xc7, 0xce, 0xfb, 0x64, 0xb1, 0xd7, 0x75, 0x17, 0x1e, 0x2c, 0x6c, 0x2c, 0x6d,
	0xd7, 0x27, 0x63, 0x6f, 0x51, 0x84, 0x74, 0xb1, 0xd7, 0x75, 0x3e, 0x24, 0x4b, 0x2f, 0x45, 0xe8,
	0x2e, 0xa2, 0xa0, 0x31, 0x19, 0x7b, 0x4b, 0xa9, 0x08, 0x29, 0x60, 0xce, 0x7d, 0xb2, 0x7c, 0x74,
	0x91, 0x71, 0x77, 0x09, 0x65, 0xcd, 0xc9, 0xd8, 0x5b, 0x56, 0x17, 0x19, 0xa7, 0x88, 0x3a, 0x1e,
	0xa9, 0xf5, 0x15, 0x53, 0xdc, 0x5d, 0x46, 0x71, 0x6b, 0x32, 0xf6, 0x6a, 0x12, 0x00, 0xaa, 0x71,
	0xe7, 0x2b, 0x50, 0x10, 0x31, 0x77, 0x6b, 0xa8, 0xb0, 0xa1, 0x15, 0x44, 0xcc, 0xff, 0x37, 0xf6,
	0xee, 0x0d, 0xd3, 0x27, 0x41, 0x1a, 0xc7, 0x69, 0xb2, 0x19, 0x89, 0x41, 0xce, 0xf2, 0x8b, 0x4d,
	0x90, 0x3c, 0x3d, 0x12, 0x31, 0xda, 0x8b, 0x18, 0xed, 0x77, 0xd1, 0xbe, 0x6e, 0xed, 0xf9, 0x5c,
	0xf6, 0xbb, 0xa5, 0xfd, 0x0e, 0xda, 0x37, 0xac, 0x7d, 0x30, 0x97, 0xfd, 0x4e, 0x69, 0x7f, 0x80,
	0xf6, 0x4d, 0x6b, 0x1f, 0xcf, 0x65, 0x8f, 0x66, 0x10, 0xbe, 0xbf, 0xb0, 0x98, 0xbb, 0xad, 0x07,
	0x0b, 0x1b, 0x2d, 0x1d, 0xbe, 0x84, 0xc5, 0x9c, 0x22, 0xea, 0x74, 0x48, 0x7d, 0xab, 0x50, 0xa3,
	0x34, 0x77, 0x09, 0xca, 0xc9, 0x64, 0xec, 0xd5, 0x19, 0x22, 0xd4, 0x48, 0x9c, 0x87, 0xa4, 0xbe,
	0x15, 0xa8, 0x63, 0xba, 0xef, 0xb6, 0x51, 0xa7, 0x3d, 0x19, 0x7b, 0x0d, 0x16, 0x28, 0xbf, 0xc8,
	0x23, 0x6a, 0x44, 0xce, 0x16, 0xa9, 0xef, 0x63, 0x58, 0xdd, 0x15, 0x5c, 0xe7, 0x27, 0xe0, 0x28,
	0x9a, 0x2b, 0xd0, 0xc6, 0x10, 0x5d, 0x60, 0x64, 0xdd, 0xd5, 0x8a, 0x0b, 0x3e, 0x9f, 0x0b, 0x54,
	0x83, 0x6a, 0xd8, 0x49, 0xcf, 0x78, 0xee, 0xde, 0xc4, 0x95, 0x62, 0x35, 0x04, 0x00, 0x50, 0x8d,
	0x43, 0x9d, 0x75, 0x45, 0xe0, 0xae, 0xa1, 0x18, 0xeb, 0x2c, 0x14, 0x01, 0x05, 0x0c, 0x02, 0xf5,
	0x22, 0x62, 0x43, 0xf7, 0x96, 0xad, 0xb3, 0x93, 0x88, 0x0d, 0x29, 0xa2, 0xb0, 0xb8, 0x63, 0xbd,
	0xb8, 0xdb, 0x76, 0x71, 0xc5, 0x7c, 0x8b, 0xd3, 0x86, 0xe8, 0x42, 0x87, 0xc8, 0xa9, 0xb8, 0x98,
	0x2f, 0x44, 0xda, 0x10, 0xf6, 0xb7, 0xcf, 0xcf, 0x78, 0xe4, 0xbe, 0x67, 0xab, 0x3d, 0x02, 0x80,
	0x6a, 0xdc, 0x79, 0x4c, 0x9a, 0x7b, 0xcf, 0x7c, 0xdc, 0xb2, 0x7b, 0x07, 0x37, 0xb9, 0x32, 0x19,
	0x7b, 0xcd, 0x91, 0xc1, 0x68, 0x63, 0xef, 0x99, 0x0e, 0xc4, 0x7d, 0xb2, 0x4c, 0x59, 0x72, 0xea,
	0xde, 0xb5, 0xbb, 0xcd, 0x59, 0x72, 0x4a, 0x11, 0x75, 0x3e, 0x27, 0xad, 0x7d, 0x71, 0xca, 0xf7,
	0x45, 0x2c, 0x94, 0xfb, 0x3e, 0xaa, 0xdc, 0x9c, 0x8c, 0x3d, 0x12, 0x89, 0x53, 0xee, 0x47, 0x80,
	0x52, 0xab, 0xe0, 0x6c, 0x12, 0xb2, 0x95, 0x84, 0x79, 0x2a, 0x42, 0x28, 0x92, 0x0f, 0xf0, 0x6f,
	0xd7, 0x26, 0x63, 0xaf, 0xcd, 0x34, 0x8a, 0x85, 0x52, 0x51, 0x81, 0x8a, 0xea, 0xa5, 0x12, 0x94,
	0x5d, 0x5b, 0x51, 0x22, 0x95, 0xba, 0xa2, 0xb4, 0xc8, 0xf9, 0x03, 0xb9, 0xd9, 0x65, 0x22, 0xba,
	0xb0, 0x0b, 0xf9, 0x10, 0x17, 0x72, 0x67, 0x32, 0xf6, 0x6e, 0x85, 0x20, 0xf1, 0x2b, 0xcb, 0xb9,
	0xa4, 0xeb, 0xbc, 0x24, 0x77, 0x10, 0xe9, 0x8b, 0x64, 0x18, 0x71, 0xeb, 0xe3, 0x23, 0xf4, 0x71,
	0x6f, 0x32, 0xf6, 0x3e, 0xd0, 0x3e, 0x24, 0x2a, 0x54, 0x5d, 0x5d, 0x69, 0xe8, 0x7c, 0x4c, 0x1a,
	0xc7, 0x99, 0x0e, 0xfe, 0x3d, 0xf4, 0x81, 0x81, 0x2d, 0x32, 0x5f, 0xc7, 0xbf, 0x14, 0x6a, 0xbd,
	0x7e, 0x90, 0xe6, 0xdc, 0xbd, 0x3f, 0xa3, 0x27, 0x01, 0xa3, 0xa5, 0xd0, 0xd9, 0x23, 0xcd, 0xe3,
	0xcc, 0x94, 0xd4, 0xaf, 0x50, 0xf1, 0xf3, 0xc9, 0xd8, 0x6b, 0x15, 0x99, 0x3f, 0x5f, 0x55, 0x4d,
	0xad, 0x8d, 0x27, 0x5d, 0x59, 0xeb, 0xb3, 0x9e, 0xe4, 0xbc, 0x9e, 0x74, 0x79, 0x7d, 0x41, 0xda,
	0x2f, 0x58, 0x82, 0xfb, 0x3d, 0x60, 0xe7, 0xae, 0x87, 0xce, 0x6e, 0x4f, 0xc6, 0xde, 0xea, 0x09,
	0x4b, 0x74, 0x74, 0xfc, 0x98, 0x9d, 0xd3, 0xaa, 0xd6, 0x8c, 0x91, 0x48, 0xdc, 0x07, 0x57, 0x1a,
	0x89, 0x84, 0x56, 0xb5, 0xa0, 0x64, 0x0e, 0xd2, 0x44, 0x8d, 0x74, 0xa0, 0x7e, 0x8d, 0x36, 0x58,
	0x32, 0x31, 0xa0, 0x26, 0x56, 0x15, 0x15, 0xa8, 0xc8, 0xbf, 0x71, 0x96, 0x6b, 0xfd, 0x8e, 0xad,
	0xc8, 0x0b, 0xce, 0x72, 0xa3, 0x6e, 0x15, 0x40, 0x7b, 0x67, 0x24, 0xa2, 0xb0, 0x2f, 0x42, 0xe9,
	0x3e, 0xc4, 0x1a, 0x43, 0xed, 0x00, 0x40, 0x5f, 0x8a, 0x50, 0x52, 0xab, 0xe0, 0xfc, 0x9e, 0xac,
	0x1e, 0x67, 0x2f, 0xc4, 0xb0, 0xc8, 0xb9, 0xf6, 0xff, 0x1b, 0xf4, 0xff, 0xde, 0x64, 0xec, 0xad,
	0x15, 0x99, 0x7f, 0x82, 0x12, 0xf3, 0x27, 0xb3, 0x9a, 0xb0, 0x8f, 0xfe, 0x48, 0xf0, 0x28, 0xc4,
	0xd6, 0xf1, 0xc8, 0xee, 0x43, 0x8e, 0x38, 0xfc, 0x15, 0x76, 0x90, 0x8a, 0x0a, 0x18, 0x50, 0x1e,
	0x31, 0x25, 0xd2, 0xa4, 0xd7, 0x75, 0x3f, 0xb6, 0x06, 0xb9, 0x41, 0x7d, 0x11, 0xd2, 0x8a, 0x8a,
	0xb3, 0x41, 0x9a, 0x3b, 0x2c, 0xe2, 0x49, 0xc8, 0x72, 0xf7, 0xb1, 0x3d, 0xd1, 0x81, 0xc1, 0xe8,
	0x54, 0xea, 0x7c, 0x46, 0x56, 0xb7, 0x8a, 0x50, 0xa8, 0xc3, 0x88, 0xa9, 0x93, 0x34, 0x8f, 0xdd,
	0x0d, 0x54, 0xaf, 0x4d, 0xc6, 0xde, 0xc2, 0x13, 0x3a, 0x2b, 0xeb, 0xfc, 0x77, 0x81, 0x2c, 0xf7,
	0x92, 0x93, 0x14, 0x5a, 0xca, 0x91, 0x50, 0x11, 0xc7, 0xa1, 0x6c, 0x5a, 0xa6, 0x02, 0x80, 0x6a,
	0x5c, 0x4f, 0x58, 0xa8, 0xad, 0x45, 0xab, 0x80, 0xe5, 0x52, 0x4e, 0x48, 0xaf, 0x9c, 0x90, 0x4b,
	0x56, 0x81, 0xab, 0xca, 0x08, 0x7c, 0x44, 0x1a, 0x94, 0xc7, 0x2c, 0x3f, 0x95, 0x38, 0xa5, 0xcd,
	0x79, 0xcf, 0x35, 0x44, 0x4b, 0x19, 0x9c, 0x9c, 0x3f, 0x17, 0x71, 0x76, 0x9c, 0x47, 0x38, 0xab,
	0xcd, 0x46, 0xbf, 0x29, 0xe2, 0x0c, 0xfb, 0x42, 0x29, 0x74, 0x7e, 0x47, 0xda, 0xdb, 0x85, 0x52,
	0x69, 0x72, 0x94, 0x32, 0xa9, 0x70, 0x2e, 0xb7, 0xb6, 0x6f, 0x4d, 0xc6, 0xde, 0xca, 0x00, 0x61,
	0x5f, 0x01, 0x4e, 0xab, 0x4a, 0x9d, 0x7f, 0x2d, 0x91, 0x36, 0x9c, 0xe5, 0x9d, 0x34, 0x51, 0x3c,
	0x51, 0x6f, 0xe4, 0x21, 0x8f, 0x48, 0xe3, 0x80, 0x4b, 0xc9, 0x86, 0xe5, 0x76, 0x71, 0xa9, 0xb1,
	0x86, 0x68, 0x29, 0x43, 0xf3, 0x43, 0xc3, 0x48, 0xb4, 0x79, 0x46, 0x17, 0x7b, 0x87, 0xd0, 0x55,
	0x21, 0xc2, 0x86, 0x8c, 0x60, 0x57, 0xcd, 0x22, 0xa6, 0x28, 0xa2, 0x30, 0x6c, 0xbb, 0x1c, 0x58,
	0x94, 0xe1, 0x22, 0x38, 0x6c, 0x43, 0x44, 0xa8, 0x91, 0x58, 0xba, 0x50, 0xff, 0x85, 0x74, 0xa1,
	0x71, 0x3d, 0xba, 0xe0, 0x91, 0x5a, 0x2f, 0x86, 0xed, 0x37, 0x6d, 0x32, 0x05, 0x00, 0x54, 0xe3,
	0xa0, 0x40, 0x79, 0x16, 0x5d, 0x18, 0x42, 0x81, 0x0a, 0x39, 0x00, 0x54, 0xe3, 0x10, 0x83, 0x7d,
	0x91, 0x9c, 0x1a, 0x42, 0x81, 0x31, 0x88, 0x04, 0x4c, 0x16, 0x40, 0xa1, 0xf5, 0xef, 0x9e, 0x23,
	0x21, 0xa9, 0x90, 0x09, 0x7e, 0xee, 0x23, 0x27, 0x31, 0x22, 0x70, 0xd1, 0x3b, 0x3c, 0x7b, 0x8e,
	0x54, 0x62, 0x45, 0xbb, 0x10, 0xd9, 0xd9, 0x73, 0x8a, 0x68, 0xe7, 0xbb, 0x16, 0x71, 0xb6, 0x02,
	0x65, 0x68, 0xe5, 0x21, 0xf0, 0xcc, 0x20, 0x8d, 0x7e, 0x8e, 0x5a, 0xf6, 0x67, 0xa9, 0xa5, 0x04,
	0x6a, 0xd9, 0x17, 0x21, 0x9c, 0xad, 0xd2, 0xdc, 0x14, 0x2f, 0x96, 0x5c, 0x66, 0x30, 0x3a, 0x95,
	0xda, 0xb0, 0x2e, 0x5f, 0x2f, 0xac, 0xd3, 0xb4, 0xd6, 0xae, 0x97, 0x56, 0x38, 0xa5, 0x17, 0x19,
	0x97, 0xa6, 0xda, 0xf5, 0x29, 0x05, 0x80, 0x6a, 0x1c, 0x59, 0x32, 0x1b, 0x4a, 0x4c, 0xbb, 0x89,
	0xba, 0x62, 0x43, 0x49, 0x11, 0x75, 0xba, 0xa4, 0x71, 0x58, 0x0c, 0x2a, 0x34, 0xf2, 0x53, 0x08,
	0x7b, 0xa6, 0xa1, 0xb7, 0x2d, 0xa1, 0x34, 0x05, 0x2f, 0x5d, 0x1e, 0xa1, 0x97, 0x96, 0xf5, 0x12,
	0x6a, 0xe8, 0xad, 0x5e, 0x8c, 0x29, 0x78, 0xd9, 0x0d, 0x05, 0x7a, 0x21, 0xd6, 0x0b, 0xd7, 0xd0,
	0x5b, 0xbd, 0x18, 0x53, 0xc8, 0xea, 0x5e, 0xaa, 0xb0, 0x88, 0x4c, 0x56, 0x47, 0xa9, 0xa2, 0x80,
	0x39, 0x0f, 0x48, 0x6d, 0x7b, 0x18, 0xf7, 0xba, 0x86, 0x89, 0xe2, 0x29, 0x1b, 0x0c, 0x63, 0x68,
	0xac, 0x5a, 0xe0, 0x7c, 0x42, 0x9a, 0x87, 0x4c, 0x2a, 0x9e, 0xf7, 0xba, 0x86, 0x6b, 0xae, 0xc2,
	0xc4, 0xcc, 0x10, 0x03, 0xbd, 0xa9, 0x18, 0xe2, 0xfa, 0x12, 0x86, 0xc8, 0x4d, 0x1b, 0xd7, 0x14,
	0xc6, 0x07, 0xa2, 0x30, 0x67, 0xfa, 0x41, 0xce, 0x79, 0xd2, 0xe7, 0x0a, 0x49, 0xa5, 0x99, 0x4a,
	0x12, 0x41, 0x5f, 0x72, 0x45, 0xad, 0x82, 0xf3, 0x25, 0xb9, 0x79, 0x98, 0x8b, 0x34, 0x17, 0xea,
	0x82, 0xf2, 0xa1, 0x48, 0x13, 0xe4, 0x9a, 0x2d, 0x3d, 0x68, 0x32, 0x23, 0xf1, 0x73, 0x14, 0xd1,
	0x4b, 0xaa, 0xce, 0x33, 0xb2, 0xa2, 0x9f, 0xbe, 0xe6, 0x62, 0x38, 0x52, 0x48, 0x43, 0x6b, 0x7a,
	0xce, 0x6a, 0x0b, 0xff, 0x15, 0x0a, 0xe8, 0x8c, 0x1a, 0x98, 0xfd, 0x29, 0x4a, 0x07, 0x2c, 0x32,
	0x66, 0x8e, 0x35, 0x1b, 0x22, 0x3e, 0x35, 0xab, 0xaa, 0x39, 0x7f, 0x25, 0x6d, 0xfd, 0xa4, 0x5b,
	0xbf, 0xa6, 0x9b, 0x9b, 0xd0, 0x63, 0xb5, 0xba, 0x3f, 0x17, 0xb3, 0xa8, 0xfa, 0x00, 0x97, 0xda,
	0x56, 0x0f, 0x8b, 0x3b, 0x3f, 0x71, 0x39, 0x17, 0xed, 0xa9, 0xfa, 0x80, 0x3c, 0xf6, 0x12, 0xa9,
	0x78, 0xd6, 0xeb, 0x1a, 0x22, 0x8b, 0x79, 0x14, 0x88, 0x61, 0x1e, 0x4b, 0xb1, 0xf3, 0x47, 0xb2,
	0x76, 0xc4, 0x86, 0xfd, 0x51, 0xfa, 0x6a, 0x3a, 0x1e, 0x35, 0xaf, 0xbd, 0x3b, 0x19, 0x7b, 0xb7,
	0x15, 0x1b, 0xfa, 0x72, 0x94, 0xbe, 0xf2, 0x33, 0x23, 0xa4, 0x97, 0xb5, 0xe1, 0x04, 0x6e, 0xbd,
	0x62, 0x79, 0x68, 0xf8, 0x2d, 0x9e, 0x40, 0x06, 0x00, 0xd5, 0x38, 0x2c, 0x06, 0x1f, 0x2c, 0xad,
	0xc5, 0xc5, 0xa0, 0x0e, 0x0e, 0xb0, 0xa9, 0xb8, 0xf3, 0xed, 0x22, 0x21, 0x7b, 0x4c, 0x52, 0x0e,
	0x6f, 0xd5, 0xfc, 0x8d, 0x9d, 0xcb, 0x23, 0xfa, 0x55, 0x16, 0x7b, 0x57, 0x6d, 0xe6, 0xdd, 0x16,
	0xbf, 0xe0, 0x10, 0x24, 0x45, 0x8c, 0xad, 0xab, 0xa6, 0x0f, 0x41, 0x52, 0xc4, 0x14, 0x3e, 0xa0,
	0xe1, 0xc4, 0xd7, 0x6b, 0x58, 0x71, 0xd9, 0xb0, 0x82, 0xeb, 0x35, 0xac, 0xa0, 0x6c, 0x58, 0x69,
	0x1e, 0xf2, 0xdc, 0xcc, 0x31, 0x5c, 0x3b, 0x02, 0x54, 0x7f, 0x75, 0xbe, 0x5b, 0x26, 0x2b, 0x18,
	0x10, 0xd3, 0xc7, 0xdf, 0x18, 0x85, 0xfb, 0x04, 0x5f, 0x58, 0xcd, 0x3c, 0xae, 0xbc, 0xc0, 0xc2,
	0x27, 0xac, 0x93, 0x4f, 0xc9, 0xc7, 0x3b, 0xbd, 0x9e, 0xf3, 0xb2, 0x8f, 0x48, 0x11, 0x9a, 0x28,
	0xd9, 0xe9, 0x20, 0xf5, 0xc5, 0x03, 0xb4, 0x58, 0x13, 0x81, 0xca, 0xc5, 0x03, 0x7c, 0x3a, 0x9f,
	0x92, 0x96, 0x4c, 0x8b, 0x3c, 0xe0, 0xbe, 0x08, 0x4d, 0x57, 0xc6, 0x7c, 0x4f, 0x41, 0xda, 0xd4,
	0x8f, 0xbd, 0xd0, 0x79, 0x4e, 0x56, 0x0d, 0xcc, 0xcf, 0x33, 0x91, 0x97, 0xc3, 0x19, 0x4f, 0xe1,
	0x8c, 0x80, 0xae, 0xe8, 0x9f, 0xbb, 0xf8, 0xcb, 0x16, 0x40, 0xf3, 0x27, 0x97, 0x1b, 0xb2, 0xbc,
	0xdc, 0x08, 0x2a, 0xfd, 0xf8, 0x9d, 0xb3, 0x34, 0xad, 0x12, 0x72, 0xbd, 0x2a, 0x79, 0x4c, 0x9a,
	0x52, 0x84, 0x3e, 0x86, 0xa9, 0x6d, 0xdf, 0x76, 0x4a, 0x8c, 0x36, 0xa4, 0x08, 0xf1, 0x9a, 0xe6,
	0x09, 0x21, 0xa9, 0x1a, 0xf1, 0x1c, 0xb9, 0x37, 0x36, 0x66, 0xc3, 0xc8, 0x2d, 0x4a, 0x5b, 0xf8,
	0x8c, 0x8c, 0xfc, 0x21, 0xa9, 0x2b, 0x26, 0x4f, 0xa7, 0xed, 0x19, 0x59, 0x02, 0x20, 0x10, 0x57,
	0x23, 0xea, 0x7c, 0x5b, 0x9f, 0xde, 0x2d, 0xd1, 0x22, 0xe2, 0x3f, 0x47, 0x00, 0xe4, 0x15, 0x04,
	0xa0, 0x9a, 0xe2, 0xa5, 0x2b, 0x53, 0xfc, 0x98, 0x34, 0xe1, 0xdb, 0x87, 0x25, 0x2f, 0x5b, 0x7a,
	0x50, 0x62, 0xb4, 0x01, 0x4f, 0xbd, 0x10, 0x87, 0x2f, 0x0c, 0x5b, 0x43, 0x5b, 0x2b, 0xc3, 0x17,
	0x3e, 0xdf, 0x9e, 0xc5, 0xcf, 0x48, 0x8b, 0x29, 0x95, 0x8b, 0x41, 0xa1, 0xca, 0x4c, 0xea, 0xd6,
	0x51, 0x82, 0xd4, 0x3e, 0xda, 0x94, 0x93, 0x5f, 0x98, 0xf2, 0xf6, 0xf5, 0x52, 0x6e, 0x53, 0xb3,
	0xf2, 0xc6, 0xd4, 0xc0, 0xe1, 0xc8, 0x8b, 0x88, 0x23, 0xab, 0xc3, 0x14, 0x9a, 0xc3, 0x31, 0x05,
	0x69, 0x13, 0x1e, 0x4b, 0xb2, 0x27, 0x2f, 0x4d, 0x58, 0x2c, 0x07, 0xfc, 0x74, 0x7e, 0x4b, 0xda,
	0x41, 0xca, 0x4f, 0x4e, 0x44, 0x20, 0x78, 0xa2, 0xcc, 0xc5, 0x0d, 0xbe, 0x30, 0x55, 0x60, 0x5a,
	0xfd, 0x01, 0xb5, 0xc6, 0x44, 0xe8, 0xeb, 0x93, 0x64, 0x46, 0x2c, 0xd6, 0x9a, 0x45, 0x69, 0x8b,
	0x89, 0xb0, 0x8f, 0x8f, 0xce, 0x97, 0x64, 0xcd, 0x0a, 0x74, 0x29, 0xdf, 0xb6, 0xef, 0x7f, 0x97,
	0x44, 0x74, 0x75, 0x6a, 0x88, 0x75, 0xfd, 0x15, 0xa9, 0x55, 0xaf, 0x74, 0xde, 0xe1, 0x76, 0x51,
	0x96, 0xd9, 0xe0, 0x95, 0x09, 0xfb, 0xae, 0xed, 0xab, 0x73, 0x48, 0xee, 0x1e, 0x67, 0x5b, 0x81,
	0x32, 0xa3, 0xe4, 0xeb, 0x91, 0x50, 0x7c, 0x5f, 0x48, 0x05, 0x45, 0x7f, 0x20, 0x42, 0x73, 0x1a,
	0xec, 0x85, 0xea, 0x41, 0xe5, 0x42, 0x75, 0xf1, 0xaa, 0x0b, 0xd5, 0xed, 0xf5, 0xef, 0x7f, 0x5c,
	0xbf, 0xf1, 0xc3, 0x8f, 0xeb, 0x37, 0xbe, 0x7f, 0xbd, 0xbe, 0xf0, 0xc3, 0xeb, 0xf5, 0x85, 0x7f,
	0xbf, 0x5e, 0x5f, 0xf8, 0xe7, 0x7f, 0xd6, 0x6f, 0xfc, 0x7d, 0x39, 0x12, 0xa7, 0x7c, 0x50, 0x47,
	0x76, 0xfc, 0xc5, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x05, 0x15, 0x0f, 0xc2, 0x2a, 0x16, 0x00,
	0x00,
}

func (m *SubjectItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubjectItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubjectItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AuditPlatform) > 0 {
		i -= len(m.AuditPlatform)
		copy(dAtA[i:], m.AuditPlatform)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.AuditPlatform)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Calendar) > 0 {
		i -= len(m.Calendar)
		copy(dAtA[i:], m.Calendar)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Calendar)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.RelationID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.RelationID))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.ShieldFlag != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ShieldFlag))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.UpFigureScore != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.UpFigureScore))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ChildSids) > 0 {
		i -= len(m.ChildSids)
		copy(dAtA[i:], m.ChildSids)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.ChildSids)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.YearScore != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.YearScore))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.MonthScore != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.MonthScore))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.FanLimitMin != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.FanLimitMin))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.FanLimitMax != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.FanLimitMax))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.UpUstime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.UpUstime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.UpUetime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.UpUetime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.UpScore != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.UpScore))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.UpLevel != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.UpLevel))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.DailySingleLikeLimit != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.DailySingleLikeLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.DailyLikeLimit != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.DailyLikeLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.IosURL) > 0 {
		i -= len(m.IosURL)
		copy(dAtA[i:], m.IosURL)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.IosURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.AndroidURL) > 0 {
		i -= len(m.AndroidURL)
		copy(dAtA[i:], m.AndroidURL)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.AndroidURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.LikeLimit != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.LikeLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Rank != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.H5Cover) > 0 {
		i -= len(m.H5Cover)
		copy(dAtA[i:], m.H5Cover)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.H5Cover)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Level != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Ustime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Ustime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Uetime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Uetime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Flag != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Dic) > 0 {
		i -= len(m.Dic)
		copy(dAtA[i:], m.Dic)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Dic)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Cover) > 0 {
		i -= len(m.Cover)
		copy(dAtA[i:], m.Cover)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Cover)))
		i--
		dAtA[i] = 0x72
	}
	if m.Letime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Letime))
		i--
		dAtA[i] = 0x68
	}
	if m.Lstime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Lstime))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ActURL) > 0 {
		i -= len(m.ActURL)
		copy(dAtA[i:], m.ActURL)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.ActURL)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Mtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x40
	}
	if m.Ctime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x38
	}
	if m.Etime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x30
	}
	if m.Stime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Oid != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ButtonToast) > 0 {
		i -= len(m.ButtonToast)
		copy(dAtA[i:], m.ButtonToast)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.ButtonToast)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.JumpUrl) > 0 {
		i -= len(m.JumpUrl)
		copy(dAtA[i:], m.JumpUrl)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.JumpUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Remarks) > 0 {
		i -= len(m.Remarks)
		copy(dAtA[i:], m.Remarks)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Remarks)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Etime) > 0 {
		i -= len(m.Etime)
		copy(dAtA[i:], m.Etime)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Etime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Stime) > 0 {
		i -= len(m.Stime)
		copy(dAtA[i:], m.Stime)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Stime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LikeContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LikeContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LikeContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IPv6) > 0 {
		i -= len(m.IPv6)
		copy(dAtA[i:], m.IPv6)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.IPv6)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ExName) > 0 {
		i -= len(m.ExName)
		copy(dAtA[i:], m.ExName)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.ExName)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Reply) > 0 {
		i -= len(m.Reply)
		copy(dAtA[i:], m.Reply)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Reply)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x42
	}
	if m.Mtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x38
	}
	if m.Ctime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x30
	}
	if m.Device != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Device))
		i--
		dAtA[i] = 0x28
	}
	if m.Plat != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x20
	}
	if m.IP != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.IP))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActSubjectProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActSubjectProtocol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActSubjectProtocol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AwardURL) > 0 {
		i -= len(m.AwardURL)
		copy(dAtA[i:], m.AwardURL)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.AwardURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Award) > 0 {
		i -= len(m.Award)
		copy(dAtA[i:], m.Award)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Award)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.TagShowPlatform != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.TagShowPlatform))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.InstepID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.InstepID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.WeightEtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.WeightEtime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.WeightStime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.WeightStime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.GlobalWeight != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.GlobalWeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.RegionWeight != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.RegionWeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.PriorityRegion) > 0 {
		i -= len(m.PriorityRegion)
		copy(dAtA[i:], m.PriorityRegion)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.PriorityRegion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ScreenSet != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ScreenSet))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Oids) > 0 {
		i -= len(m.Oids)
		copy(dAtA[i:], m.Oids)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Oids)))
		i--
		dAtA[i] = 0x72
	}
	if m.PasterID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.PasterID))
		i--
		dAtA[i] = 0x68
	}
	if m.BgmID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.BgmID))
		i--
		dAtA[i] = 0x60
	}
	if m.Hot != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Hot))
		i--
		dAtA[i] = 0x58
	}
	if m.Editime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Editime))
		i--
		dAtA[i] = 0x50
	}
	if m.Deltime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Deltime))
		i--
		dAtA[i] = 0x48
	}
	if m.Pubtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Pubtime))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Types) > 0 {
		i -= len(m.Types)
		copy(dAtA[i:], m.Types)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Types)))
		i--
		dAtA[i] = 0x32
	}
	if m.Ctime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x28
	}
	if m.Mtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Sid != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HasReserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasReserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasReserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Order != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x30
	}
	if m.Ctime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x28
	}
	if m.Mtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AwardSubject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardSubject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardSubject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TaskID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.TaskID))
		i--
		dAtA[i] = 0x68
	}
	if len(m.OtherSids) > 0 {
		i -= len(m.OtherSids)
		copy(dAtA[i:], m.OtherSids)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.OtherSids)))
		i--
		dAtA[i] = 0x62
	}
	if m.SidType != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.SidType))
		i--
		dAtA[i] = 0x58
	}
	if m.Mtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x50
	}
	if m.Ctime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x48
	}
	if m.State != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	if m.SourceExpire != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.SourceExpire))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SourceId) > 0 {
		i -= len(m.SourceId)
		copy(dAtA[i:], m.SourceId)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.SourceId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Type != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Sid != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x20
	}
	if m.Etime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubjectRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubjectRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubjectRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Etime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Stime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.AidSourceType != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.AidSourceType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.AidSource) > 0 {
		i -= len(m.AidSource)
		copy(dAtA[i:], m.AidSource)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.AidSource)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Coefficient) > 0 {
		i -= len(m.Coefficient)
		copy(dAtA[i:], m.Coefficient)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Coefficient)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Sids) > 0 {
		i -= len(m.Sids)
		copy(dAtA[i:], m.Sids)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Sids)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.RuleName) > 0 {
		i -= len(m.RuleName)
		copy(dAtA[i:], m.RuleName)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.RuleName)))
		i--
		dAtA[i] = 0x6a
	}
	if m.TaskID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.TaskID))
		i--
		dAtA[i] = 0x60
	}
	if m.Mtime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x58
	}
	if m.Ctime != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x50
	}
	if m.Attribute != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Attribute))
		i--
		dAtA[i] = 0x48
	}
	if m.State != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TypeIds) > 0 {
		i -= len(m.TypeIds)
		copy(dAtA[i:], m.TypeIds)
		i = encodeVarintSubject(dAtA, i, uint64(len(m.TypeIds)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Sid != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpActReserveWhiteList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpActReserveWhiteList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpActReserveWhiteList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintSubject(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSubject(dAtA []byte, offset int, v uint64) int {
	offset -= sovSubject(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SubjectItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	if m.Oid != 0 {
		n += 1 + sovSubject(uint64(m.Oid))
	}
	if m.Type != 0 {
		n += 1 + sovSubject(uint64(m.Type))
	}
	if m.State != 0 {
		n += 1 + sovSubject(uint64(m.State))
	}
	if m.Stime != 0 {
		n += 1 + sovSubject(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovSubject(uint64(m.Etime))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.ActURL)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Lstime != 0 {
		n += 1 + sovSubject(uint64(m.Lstime))
	}
	if m.Letime != 0 {
		n += 1 + sovSubject(uint64(m.Letime))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Dic)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Flag != 0 {
		n += 2 + sovSubject(uint64(m.Flag))
	}
	if m.Uetime != 0 {
		n += 2 + sovSubject(uint64(m.Uetime))
	}
	if m.Ustime != 0 {
		n += 2 + sovSubject(uint64(m.Ustime))
	}
	if m.Level != 0 {
		n += 2 + sovSubject(uint64(m.Level))
	}
	l = len(m.H5Cover)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.Rank != 0 {
		n += 2 + sovSubject(uint64(m.Rank))
	}
	if m.LikeLimit != 0 {
		n += 2 + sovSubject(uint64(m.LikeLimit))
	}
	l = len(m.AndroidURL)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	l = len(m.IosURL)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.DailyLikeLimit != 0 {
		n += 2 + sovSubject(uint64(m.DailyLikeLimit))
	}
	if m.DailySingleLikeLimit != 0 {
		n += 2 + sovSubject(uint64(m.DailySingleLikeLimit))
	}
	if m.UpLevel != 0 {
		n += 2 + sovSubject(uint64(m.UpLevel))
	}
	if m.UpScore != 0 {
		n += 2 + sovSubject(uint64(m.UpScore))
	}
	if m.UpUetime != 0 {
		n += 2 + sovSubject(uint64(m.UpUetime))
	}
	if m.UpUstime != 0 {
		n += 2 + sovSubject(uint64(m.UpUstime))
	}
	if m.FanLimitMax != 0 {
		n += 2 + sovSubject(uint64(m.FanLimitMax))
	}
	if m.FanLimitMin != 0 {
		n += 2 + sovSubject(uint64(m.FanLimitMin))
	}
	if m.MonthScore != 0 {
		n += 2 + sovSubject(uint64(m.MonthScore))
	}
	if m.YearScore != 0 {
		n += 2 + sovSubject(uint64(m.YearScore))
	}
	l = len(m.ChildSids)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.UpFigureScore != 0 {
		n += 2 + sovSubject(uint64(m.UpFigureScore))
	}
	if m.ShieldFlag != 0 {
		n += 2 + sovSubject(uint64(m.ShieldFlag))
	}
	if m.RelationID != 0 {
		n += 2 + sovSubject(uint64(m.RelationID))
	}
	l = len(m.Calendar)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	l = len(m.AuditPlatform)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Stime)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Etime)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Remarks)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.JumpUrl)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.ButtonToast)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LikeContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.IP != 0 {
		n += 1 + sovSubject(uint64(m.IP))
	}
	if m.Plat != 0 {
		n += 1 + sovSubject(uint64(m.Plat))
	}
	if m.Device != 0 {
		n += 1 + sovSubject(uint64(m.Device))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.ExName)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.IPv6)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActSubjectProtocol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	if m.Sid != 0 {
		n += 1 + sovSubject(uint64(m.Sid))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	l = len(m.Types)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Pubtime != 0 {
		n += 1 + sovSubject(uint64(m.Pubtime))
	}
	if m.Deltime != 0 {
		n += 1 + sovSubject(uint64(m.Deltime))
	}
	if m.Editime != 0 {
		n += 1 + sovSubject(uint64(m.Editime))
	}
	if m.Hot != 0 {
		n += 1 + sovSubject(uint64(m.Hot))
	}
	if m.BgmID != 0 {
		n += 1 + sovSubject(uint64(m.BgmID))
	}
	if m.PasterID != 0 {
		n += 1 + sovSubject(uint64(m.PasterID))
	}
	l = len(m.Oids)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.ScreenSet != 0 {
		n += 1 + sovSubject(uint64(m.ScreenSet))
	}
	l = len(m.PriorityRegion)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.RegionWeight != 0 {
		n += 2 + sovSubject(uint64(m.RegionWeight))
	}
	if m.GlobalWeight != 0 {
		n += 2 + sovSubject(uint64(m.GlobalWeight))
	}
	if m.WeightStime != 0 {
		n += 2 + sovSubject(uint64(m.WeightStime))
	}
	if m.WeightEtime != 0 {
		n += 2 + sovSubject(uint64(m.WeightEtime))
	}
	if m.InstepID != 0 {
		n += 2 + sovSubject(uint64(m.InstepID))
	}
	if m.TagShowPlatform != 0 {
		n += 2 + sovSubject(uint64(m.TagShowPlatform))
	}
	l = len(m.Award)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	l = len(m.AwardURL)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HasReserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	if m.State != 0 {
		n += 1 + sovSubject(uint64(m.State))
	}
	if m.Num != 0 {
		n += 1 + sovSubject(uint64(m.Num))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	if m.Order != 0 {
		n += 1 + sovSubject(uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardSubject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Etime != 0 {
		n += 1 + sovSubject(uint64(m.Etime))
	}
	if m.Sid != 0 {
		n += 1 + sovSubject(uint64(m.Sid))
	}
	if m.Type != 0 {
		n += 1 + sovSubject(uint64(m.Type))
	}
	l = len(m.SourceId)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.SourceExpire != 0 {
		n += 1 + sovSubject(uint64(m.SourceExpire))
	}
	if m.State != 0 {
		n += 1 + sovSubject(uint64(m.State))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	if m.SidType != 0 {
		n += 1 + sovSubject(uint64(m.SidType))
	}
	l = len(m.OtherSids)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.TaskID != 0 {
		n += 1 + sovSubject(uint64(m.TaskID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubjectRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	if m.Sid != 0 {
		n += 1 + sovSubject(uint64(m.Sid))
	}
	if m.Type != 0 {
		n += 1 + sovSubject(uint64(m.Type))
	}
	l = len(m.TypeIds)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovSubject(uint64(m.State))
	}
	if m.Attribute != 0 {
		n += 1 + sovSubject(uint64(m.Attribute))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	if m.TaskID != 0 {
		n += 1 + sovSubject(uint64(m.TaskID))
	}
	l = len(m.RuleName)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Sids)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Coefficient)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.AidSource)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.AidSourceType != 0 {
		n += 2 + sovSubject(uint64(m.AidSourceType))
	}
	if m.Stime != 0 {
		n += 2 + sovSubject(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 2 + sovSubject(uint64(m.Etime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpActReserveWhiteList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovSubject(uint64(m.Mid))
	}
	if m.Type != 0 {
		n += 1 + sovSubject(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSubject(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSubject(x uint64) (n int) {
	return sovSubject(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SubjectItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubjectItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubjectItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lstime", wireType)
			}
			m.Lstime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lstime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Letime", wireType)
			}
			m.Letime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Letime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uetime", wireType)
			}
			m.Uetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uetime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ustime", wireType)
			}
			m.Ustime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ustime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H5Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H5Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeLimit", wireType)
			}
			m.LikeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LikeLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IosURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IosURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyLikeLimit", wireType)
			}
			m.DailyLikeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyLikeLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailySingleLikeLimit", wireType)
			}
			m.DailySingleLikeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailySingleLikeLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpLevel", wireType)
			}
			m.UpLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpScore", wireType)
			}
			m.UpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpUetime", wireType)
			}
			m.UpUetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpUetime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpUstime", wireType)
			}
			m.UpUstime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpUstime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanLimitMax", wireType)
			}
			m.FanLimitMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FanLimitMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanLimitMin", wireType)
			}
			m.FanLimitMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FanLimitMin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthScore", wireType)
			}
			m.MonthScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonthScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearScore", wireType)
			}
			m.YearScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YearScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildSids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildSids = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpFigureScore", wireType)
			}
			m.UpFigureScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpFigureScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldFlag", wireType)
			}
			m.ShieldFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShieldFlag |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationID", wireType)
			}
			m.RelationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelationID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calendar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calendar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditPlatform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuditPlatform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remarks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remarks = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ButtonToast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ButtonToast = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LikeContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LikeContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LikeContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			m.IP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IP |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			m.Device = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Device |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPv6 = append(m.IPv6[:0], dAtA[iNdEx:postIndex]...)
			if m.IPv6 == nil {
				m.IPv6 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActSubjectProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActSubjectProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActSubjectProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubtime", wireType)
			}
			m.Pubtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pubtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deltime", wireType)
			}
			m.Deltime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deltime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Editime", wireType)
			}
			m.Editime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Editime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hot", wireType)
			}
			m.Hot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hot |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgmID", wireType)
			}
			m.BgmID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgmID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasterID", wireType)
			}
			m.PasterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PasterID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oids = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenSet", wireType)
			}
			m.ScreenSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScreenSet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionWeight", wireType)
			}
			m.RegionWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionWeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalWeight", wireType)
			}
			m.GlobalWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalWeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightStime", wireType)
			}
			m.WeightStime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeightStime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightEtime", wireType)
			}
			m.WeightEtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeightEtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstepID", wireType)
			}
			m.InstepID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstepID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagShowPlatform", wireType)
			}
			m.TagShowPlatform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagShowPlatform |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Award = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasReserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasReserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasReserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardSubject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardSubject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardSubject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceExpire", wireType)
			}
			m.SourceExpire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceExpire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidType", wireType)
			}
			m.SidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherSids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherSids = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			m.TaskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubjectRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubjectRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubjectRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeIds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			m.Attribute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attribute |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			m.TaskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sids = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coefficient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coefficient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AidSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AidSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AidSourceType", wireType)
			}
			m.AidSourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AidSourceType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpActReserveWhiteList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpActReserveWhiteList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpActReserveWhiteList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubject(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSubject
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSubject
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSubject
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSubject        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubject          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSubject = fmt.Errorf("proto: unexpected end of group")
)
