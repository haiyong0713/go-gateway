// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: item.proto

package act

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ActItem 话题活动页面新卡片proto
type ActItem struct {
	Goto                 string        `protobuf:"bytes,1,opt,name=goto,proto3" json:"goto,omitempty"`
	Param                string        `protobuf:"bytes,2,opt,name=param,proto3" json:"param,omitempty"`
	ItemId               int64         `protobuf:"varint,3,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	Image                string        `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	Title                string        `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	Uri                  string        `protobuf:"bytes,6,opt,name=uri,proto3" json:"uri,omitempty"`
	CoverLeftText_1      string        `protobuf:"bytes,7,opt,name=cover_left_text_1,json=coverLeftText1,proto3" json:"cover_left_text_1,omitempty"`
	CoverLeftText_2      string        `protobuf:"bytes,8,opt,name=cover_left_text_2,json=coverLeftText2,proto3" json:"cover_left_text_2,omitempty"`
	CoverLeftText_3      string        `protobuf:"bytes,9,opt,name=cover_left_text_3,json=coverLeftText3,proto3" json:"cover_left_text_3,omitempty"`
	Rights               *ArcRights    `protobuf:"bytes,10,opt,name=rights,proto3" json:"rights,omitempty"`
	Dimension            *ArcDimension `protobuf:"bytes,11,opt,name=dimension,proto3" json:"dimension,omitempty"`
	Badge                *ReasonStyle  `protobuf:"bytes,12,opt,name=badge,proto3" json:"badge,omitempty"`
	Repost               *Repost       `protobuf:"bytes,13,opt,name=repost,proto3" json:"repost,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ActItem) Reset()         { *m = ActItem{} }
func (m *ActItem) String() string { return proto.CompactTextString(m) }
func (*ActItem) ProtoMessage()    {}
func (*ActItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_6007f868cf6553df, []int{0}
}
func (m *ActItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActItem.Merge(m, src)
}
func (m *ActItem) XXX_Size() int {
	return m.Size()
}
func (m *ActItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ActItem.DiscardUnknown(m)
}

var xxx_messageInfo_ActItem proto.InternalMessageInfo

type ArcRights struct {
	UgcPay               int32    `protobuf:"varint,1,opt,name=ugc_pay,json=ugcPay,proto3" json:"ugc_pay,omitempty"`
	IsCooperation        int32    `protobuf:"varint,2,opt,name=is_cooperation,json=isCooperation,proto3" json:"is_cooperation,omitempty"`
	IsPgc                bool     `protobuf:"varint,3,opt,name=is_pgc,json=isPgc,proto3" json:"is_pgc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcRights) Reset()         { *m = ArcRights{} }
func (m *ArcRights) String() string { return proto.CompactTextString(m) }
func (*ArcRights) ProtoMessage()    {}
func (*ArcRights) Descriptor() ([]byte, []int) {
	return fileDescriptor_6007f868cf6553df, []int{1}
}
func (m *ArcRights) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcRights) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcRights.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcRights) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcRights.Merge(m, src)
}
func (m *ArcRights) XXX_Size() int {
	return m.Size()
}
func (m *ArcRights) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcRights.DiscardUnknown(m)
}

var xxx_messageInfo_ArcRights proto.InternalMessageInfo

type ArcDimension struct {
	Width int64 `protobuf:"varint,1,opt,name=width,proto3" json:"width,omitempty"`
	// 高 如 1080
	Height int64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// 是否竖屏 0=否 1=是
	Rotate               int64    `protobuf:"varint,3,opt,name=rotate,proto3" json:"rotate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcDimension) Reset()         { *m = ArcDimension{} }
func (m *ArcDimension) String() string { return proto.CompactTextString(m) }
func (*ArcDimension) ProtoMessage()    {}
func (*ArcDimension) Descriptor() ([]byte, []int) {
	return fileDescriptor_6007f868cf6553df, []int{2}
}
func (m *ArcDimension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcDimension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcDimension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcDimension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcDimension.Merge(m, src)
}
func (m *ArcDimension) XXX_Size() int {
	return m.Size()
}
func (m *ArcDimension) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcDimension.DiscardUnknown(m)
}

var xxx_messageInfo_ArcDimension proto.InternalMessageInfo

type ReasonStyle struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	BgColor              string   `protobuf:"bytes,2,opt,name=bgColor,proto3" json:"bg_color,omitempty"`
	BgColorNight         string   `protobuf:"bytes,3,opt,name=bgColorNight,proto3" json:"bg_color_night,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReasonStyle) Reset()         { *m = ReasonStyle{} }
func (m *ReasonStyle) String() string { return proto.CompactTextString(m) }
func (*ReasonStyle) ProtoMessage()    {}
func (*ReasonStyle) Descriptor() ([]byte, []int) {
	return fileDescriptor_6007f868cf6553df, []int{3}
}
func (m *ReasonStyle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReasonStyle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReasonStyle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReasonStyle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReasonStyle.Merge(m, src)
}
func (m *ReasonStyle) XXX_Size() int {
	return m.Size()
}
func (m *ReasonStyle) XXX_DiscardUnknown() {
	xxx_messageInfo_ReasonStyle.DiscardUnknown(m)
}

var xxx_messageInfo_ReasonStyle proto.InternalMessageInfo

type Repost struct {
	BizType              string   `protobuf:"bytes,1,opt,name=biz_type,json=bizType,proto3" json:"biz_type,omitempty"`
	SeasonType           string   `protobuf:"bytes,2,opt,name=season_type,json=seasonType,proto3" json:"season_type,omitempty"`
	Aid                  int64    `protobuf:"varint,3,opt,name=aid,proto3" json:"aid,omitempty"`
	Cid                  int64    `protobuf:"varint,4,opt,name=cid,proto3" json:"cid,omitempty"`
	SubType              int32    `protobuf:"varint,5,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	EpId                 int64    `protobuf:"varint,6,opt,name=ep_id,json=epId,proto3" json:"ep_id,omitempty"`
	IsPreview            int32    `protobuf:"varint,7,opt,name=is_preview,json=isPreview,proto3" json:"is_preview,omitempty"`
	SeasonId             int64    `protobuf:"varint,8,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	AuthorName           string   `protobuf:"bytes,9,opt,name=author_name,json=authorName,proto3" json:"author_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Repost) Reset()         { *m = Repost{} }
func (m *Repost) String() string { return proto.CompactTextString(m) }
func (*Repost) ProtoMessage()    {}
func (*Repost) Descriptor() ([]byte, []int) {
	return fileDescriptor_6007f868cf6553df, []int{4}
}
func (m *Repost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repost.Merge(m, src)
}
func (m *Repost) XXX_Size() int {
	return m.Size()
}
func (m *Repost) XXX_DiscardUnknown() {
	xxx_messageInfo_Repost.DiscardUnknown(m)
}

var xxx_messageInfo_Repost proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ActItem)(nil), "bilibili.app.show.v1.ActItem")
	proto.RegisterType((*ArcRights)(nil), "bilibili.app.show.v1.ArcRights")
	proto.RegisterType((*ArcDimension)(nil), "bilibili.app.show.v1.ArcDimension")
	proto.RegisterType((*ReasonStyle)(nil), "bilibili.app.show.v1.ReasonStyle")
	proto.RegisterType((*Repost)(nil), "bilibili.app.show.v1.Repost")
}

func init() { proto.RegisterFile("item.proto", fileDescriptor_6007f868cf6553df) }

var fileDescriptor_6007f868cf6553df = []byte{
	// 662 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0x4d, 0x4f, 0xdb, 0x40,
	0x10, 0xc5, 0x18, 0x3b, 0xc9, 0x04, 0x10, 0xdd, 0x52, 0xba, 0xb4, 0x34, 0xa1, 0x91, 0x2a, 0x51,
	0xa9, 0x35, 0x05, 0x2a, 0x71, 0xe5, 0xa3, 0x97, 0x48, 0x15, 0x42, 0x5b, 0x4e, 0xbd, 0x58, 0x6b,
	0x7b, 0x71, 0x56, 0x8a, 0xb3, 0x96, 0xbd, 0x06, 0xc2, 0xff, 0xe8, 0x7f, 0xe2, 0xc8, 0x2f, 0x40,
	0x85, 0x23, 0x77, 0xee, 0xd5, 0xce, 0x3a, 0x40, 0xa5, 0x70, 0x88, 0x34, 0xef, 0xcd, 0x7b, 0x9b,
	0xd9, 0x9d, 0x19, 0x03, 0x48, 0x2d, 0xb2, 0x20, 0x2f, 0x94, 0x56, 0x64, 0x39, 0x92, 0x43, 0x69,
	0x7e, 0x01, 0xcf, 0xf3, 0xa0, 0x1c, 0xa8, 0xf3, 0xe0, 0x6c, 0xeb, 0xdd, 0xd7, 0x54, 0xea, 0x41,
	0x15, 0x05, 0xb1, 0xca, 0x36, 0x53, 0x95, 0xaa, 0x4d, 0x14, 0x47, 0xd5, 0x29, 0x22, 0x04, 0x18,
	0xd9, 0x43, 0x7a, 0x0f, 0x2e, 0x34, 0xf6, 0x63, 0xdd, 0xd7, 0x22, 0x23, 0x04, 0xe6, 0x52, 0xa5,
	0x15, 0x75, 0xd6, 0x9d, 0x8d, 0x16, 0xc3, 0x98, 0x2c, 0x83, 0x97, 0xf3, 0x82, 0x67, 0x74, 0x16,
	0x49, 0x0b, 0xc8, 0x5b, 0x68, 0x98, 0x42, 0x42, 0x99, 0x50, 0x77, 0xdd, 0xd9, 0x70, 0x99, 0x6f,
	0x60, 0x3f, 0x31, 0x72, 0x99, 0xf1, 0x54, 0xd0, 0x39, 0x2b, 0x47, 0x60, 0x58, 0x2d, 0xf5, 0x50,
	0x50, 0xcf, 0xb2, 0x08, 0xc8, 0x12, 0xb8, 0x55, 0x21, 0xa9, 0x8f, 0x9c, 0x09, 0xc9, 0x67, 0x78,
	0x15, 0xab, 0x33, 0x51, 0x84, 0x43, 0x71, 0xaa, 0x43, 0x2d, 0x2e, 0x74, 0xb8, 0x45, 0x1b, 0x98,
	0x5f, 0xc4, 0xc4, 0x4f, 0x71, 0xaa, 0x4f, 0xc4, 0x85, 0xde, 0x9a, 0x26, 0xdd, 0xa6, 0xcd, 0x29,
	0xd2, 0xed, 0x69, 0xd2, 0x1d, 0xda, 0x9a, 0x22, 0xdd, 0x21, 0xbb, 0xe0, 0x17, 0x32, 0x1d, 0xe8,
	0x92, 0xc2, 0xba, 0xb3, 0xd1, 0xde, 0xee, 0x06, 0xd3, 0xde, 0x38, 0xd8, 0x2f, 0x62, 0x86, 0x32,
	0x56, 0xcb, 0xc9, 0x1e, 0xb4, 0x12, 0x99, 0x89, 0x51, 0x29, 0xd5, 0x88, 0xb6, 0xd1, 0xdb, 0x7b,
	0xd1, 0xfb, 0x63, 0xa2, 0x64, 0x4f, 0x26, 0xb2, 0x0b, 0x5e, 0xc4, 0x93, 0x54, 0xd0, 0x79, 0x74,
	0x7f, 0x9c, 0xee, 0x66, 0x82, 0x97, 0x6a, 0xf4, 0x4b, 0x8f, 0x87, 0x82, 0x59, 0x3d, 0xf9, 0x0e,
	0x7e, 0x21, 0x72, 0x55, 0x6a, 0xba, 0x80, 0xce, 0xb5, 0x97, 0x9c, 0x46, 0xc3, 0x6a, 0x6d, 0x2f,
	0x82, 0xd6, 0xe3, 0x2d, 0x4c, 0x3b, 0xab, 0x34, 0x0e, 0x73, 0x3e, 0xc6, 0xde, 0x7b, 0xcc, 0xaf,
	0xd2, 0xf8, 0x98, 0x8f, 0xc9, 0x27, 0x58, 0x94, 0x65, 0x18, 0x2b, 0x95, 0x8b, 0x82, 0x6b, 0x73,
	0xb7, 0x59, 0xcc, 0x2f, 0xc8, 0xf2, 0xf0, 0x89, 0x24, 0x6f, 0xc0, 0x97, 0x65, 0x98, 0xa7, 0x31,
	0x4e, 0x43, 0x93, 0x79, 0xb2, 0x3c, 0x4e, 0xe3, 0xde, 0x09, 0xcc, 0x3f, 0xbf, 0xad, 0x19, 0x83,
	0x73, 0x99, 0xe8, 0x01, 0xfe, 0x89, 0xcb, 0x2c, 0x20, 0x2b, 0xe0, 0x0f, 0x84, 0xa9, 0x03, 0xcf,
	0x76, 0x59, 0x8d, 0x0c, 0x5f, 0x28, 0xcd, 0xb5, 0x98, 0x8c, 0x98, 0x45, 0xbd, 0x3f, 0x0e, 0xb4,
	0x9f, 0x3d, 0x83, 0x99, 0x5a, 0xd3, 0xd3, 0xc9, 0xd4, 0x9a, 0x98, 0x7c, 0x83, 0x46, 0x94, 0x1e,
	0xaa, 0xa1, 0x2a, 0xec, 0xdc, 0x1e, 0xac, 0xdc, 0xdf, 0x74, 0x49, 0x94, 0x86, 0xb1, 0xe1, 0xbe,
	0xa8, 0xcc, 0x8c, 0x6b, 0xae, 0xc7, 0x6c, 0x22, 0x23, 0x7b, 0x30, 0x5f, 0x87, 0x47, 0x58, 0x8b,
	0x8b, 0xb6, 0xb5, 0xfb, 0x9b, 0x2e, 0x9d, 0xd8, 0xc2, 0x91, 0xc9, 0x3c, 0x33, 0xff, 0xe7, 0xe8,
	0x3d, 0x38, 0xe0, 0xdb, 0x47, 0x26, 0xab, 0xd0, 0x8c, 0xe4, 0x65, 0xa8, 0xc7, 0xb9, 0xa8, 0xcb,
	0x6a, 0x44, 0xf2, 0xf2, 0x64, 0x9c, 0x0b, 0xd2, 0x85, 0x76, 0x89, 0xc5, 0xdb, 0xac, 0xdd, 0x2a,
	0xb0, 0x14, 0x0a, 0x96, 0xc0, 0xe5, 0x8f, 0x6b, 0x65, 0x42, 0xc3, 0xc4, 0x32, 0xc1, 0x8d, 0x72,
	0x99, 0x09, 0xcd, 0xf9, 0x65, 0x15, 0xd9, 0x13, 0x3c, 0x6c, 0x48, 0xa3, 0xac, 0x22, 0xb4, 0xbf,
	0x06, 0x4f, 0xe4, 0x66, 0x2f, 0x7d, 0x94, 0xcf, 0x89, 0xbc, 0x9f, 0x90, 0x0f, 0x00, 0xa6, 0x3f,
	0x85, 0x38, 0x93, 0xe2, 0x1c, 0x17, 0xca, 0x63, 0x2d, 0x59, 0x1e, 0x5b, 0x82, 0xbc, 0x87, 0x56,
	0x5d, 0x93, 0x4c, 0x70, 0x87, 0x5c, 0xd6, 0xb4, 0x44, 0x3f, 0x31, 0x05, 0xf3, 0x4a, 0x0f, 0xcc,
	0xf5, 0x79, 0x26, 0xea, 0xbd, 0x01, 0x4b, 0x1d, 0xf1, 0x4c, 0x1c, 0xac, 0x5e, 0xdd, 0x76, 0x66,
	0xae, 0x6f, 0x3b, 0x33, 0x57, 0x77, 0x1d, 0xe7, 0xfa, 0xae, 0xe3, 0xfc, 0xbd, 0xeb, 0x38, 0xbf,
	0x5d, 0x1e, 0xeb, 0xc8, 0xc7, 0x6f, 0xcc, 0xce, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x41,
	0x9d, 0x9e, 0xb6, 0x04, 0x00, 0x00,
}

func (m *ActItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Repost != nil {
		{
			size, err := m.Repost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintItem(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Badge != nil {
		{
			size, err := m.Badge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintItem(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Dimension != nil {
		{
			size, err := m.Dimension.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintItem(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Rights != nil {
		{
			size, err := m.Rights.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintItem(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.CoverLeftText_3) > 0 {
		i -= len(m.CoverLeftText_3)
		copy(dAtA[i:], m.CoverLeftText_3)
		i = encodeVarintItem(dAtA, i, uint64(len(m.CoverLeftText_3)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CoverLeftText_2) > 0 {
		i -= len(m.CoverLeftText_2)
		copy(dAtA[i:], m.CoverLeftText_2)
		i = encodeVarintItem(dAtA, i, uint64(len(m.CoverLeftText_2)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CoverLeftText_1) > 0 {
		i -= len(m.CoverLeftText_1)
		copy(dAtA[i:], m.CoverLeftText_1)
		i = encodeVarintItem(dAtA, i, uint64(len(m.CoverLeftText_1)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintItem(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintItem(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintItem(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if m.ItemId != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.ItemId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintItem(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Goto) > 0 {
		i -= len(m.Goto)
		copy(dAtA[i:], m.Goto)
		i = encodeVarintItem(dAtA, i, uint64(len(m.Goto)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArcRights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcRights) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcRights) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsPgc {
		i--
		if m.IsPgc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsCooperation != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.IsCooperation))
		i--
		dAtA[i] = 0x10
	}
	if m.UgcPay != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.UgcPay))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcDimension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcDimension) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcDimension) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rotate != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.Rotate))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Width != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReasonStyle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReasonStyle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReasonStyle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BgColorNight) > 0 {
		i -= len(m.BgColorNight)
		copy(dAtA[i:], m.BgColorNight)
		i = encodeVarintItem(dAtA, i, uint64(len(m.BgColorNight)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BgColor) > 0 {
		i -= len(m.BgColor)
		copy(dAtA[i:], m.BgColor)
		i = encodeVarintItem(dAtA, i, uint64(len(m.BgColor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintItem(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Repost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Repost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AuthorName) > 0 {
		i -= len(m.AuthorName)
		copy(dAtA[i:], m.AuthorName)
		i = encodeVarintItem(dAtA, i, uint64(len(m.AuthorName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.SeasonId != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.SeasonId))
		i--
		dAtA[i] = 0x40
	}
	if m.IsPreview != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.IsPreview))
		i--
		dAtA[i] = 0x38
	}
	if m.EpId != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.EpId))
		i--
		dAtA[i] = 0x30
	}
	if m.SubType != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.SubType))
		i--
		dAtA[i] = 0x28
	}
	if m.Cid != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x20
	}
	if m.Aid != 0 {
		i = encodeVarintItem(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SeasonType) > 0 {
		i -= len(m.SeasonType)
		copy(dAtA[i:], m.SeasonType)
		i = encodeVarintItem(dAtA, i, uint64(len(m.SeasonType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BizType) > 0 {
		i -= len(m.BizType)
		copy(dAtA[i:], m.BizType)
		i = encodeVarintItem(dAtA, i, uint64(len(m.BizType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintItem(dAtA []byte, offset int, v uint64) int {
	offset -= sovItem(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ActItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Goto)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.ItemId != 0 {
		n += 1 + sovItem(uint64(m.ItemId))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.CoverLeftText_1)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.CoverLeftText_2)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.CoverLeftText_3)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Rights != nil {
		l = m.Rights.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Dimension != nil {
		l = m.Dimension.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Badge != nil {
		l = m.Badge.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Repost != nil {
		l = m.Repost.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcRights) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UgcPay != 0 {
		n += 1 + sovItem(uint64(m.UgcPay))
	}
	if m.IsCooperation != 0 {
		n += 1 + sovItem(uint64(m.IsCooperation))
	}
	if m.IsPgc {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcDimension) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovItem(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovItem(uint64(m.Height))
	}
	if m.Rotate != 0 {
		n += 1 + sovItem(uint64(m.Rotate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReasonStyle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.BgColor)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.BgColorNight)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Repost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BizType)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.SeasonType)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Aid != 0 {
		n += 1 + sovItem(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovItem(uint64(m.Cid))
	}
	if m.SubType != 0 {
		n += 1 + sovItem(uint64(m.SubType))
	}
	if m.EpId != 0 {
		n += 1 + sovItem(uint64(m.EpId))
	}
	if m.IsPreview != 0 {
		n += 1 + sovItem(uint64(m.IsPreview))
	}
	if m.SeasonId != 0 {
		n += 1 + sovItem(uint64(m.SeasonId))
	}
	l = len(m.AuthorName)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovItem(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozItem(x uint64) (n int) {
	return sovItem(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ActItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverLeftText_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverLeftText_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverLeftText_2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverLeftText_2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverLeftText_3", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverLeftText_3 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rights == nil {
				m.Rights = &ArcRights{}
			}
			if err := m.Rights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dimension == nil {
				m.Dimension = &ArcDimension{}
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Badge == nil {
				m.Badge = &ReasonStyle{}
			}
			if err := m.Badge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repost == nil {
				m.Repost = &Repost{}
			}
			if err := m.Repost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcRights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcRights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcRights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UgcPay", wireType)
			}
			m.UgcPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UgcPay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCooperation", wireType)
			}
			m.IsCooperation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCooperation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPgc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPgc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcDimension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcDimension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcDimension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate", wireType)
			}
			m.Rotate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReasonStyle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReasonStyle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReasonStyle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgColorNight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgColorNight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeasonType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			m.SubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpId", wireType)
			}
			m.EpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPreview", wireType)
			}
			m.IsPreview = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPreview |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipItem(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowItem
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowItem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowItem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthItem
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupItem
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthItem
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthItem        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowItem          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupItem = fmt.Errorf("proto: unexpected end of group")
)
