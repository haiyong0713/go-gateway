// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bws.proto

package bws

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	go_common_library_time "go-common/library/time"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Users struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Mid                  int64                       `protobuf:"varint,2,opt,name=Mid,proto3" json:"mid"`
	Key                  string                      `protobuf:"bytes,3,opt,name=Key,proto3" json:"key"`
	Ctime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Bid                  int64                       `protobuf:"varint,6,opt,name=Bid,proto3" json:"bid"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Users) Reset()         { *m = Users{} }
func (m *Users) String() string { return proto.CompactTextString(m) }
func (*Users) ProtoMessage()    {}
func (*Users) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{0}
}
func (m *Users) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Users) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Users.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Users) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Users.Merge(m, src)
}
func (m *Users) XXX_Size() int {
	return m.Size()
}
func (m *Users) XXX_DiscardUnknown() {
	xxx_messageInfo_Users.DiscardUnknown(m)
}

var xxx_messageInfo_Users proto.InternalMessageInfo

type VipUsersToken struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Mid                  int64                       `protobuf:"varint,2,opt,name=Mid,proto3" json:"mid"`
	VipKey               string                      `protobuf:"bytes,3,opt,name=VipKey,proto3" json:"vip_key"`
	Ctime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Bid                  int64                       `protobuf:"varint,6,opt,name=Bid,proto3" json:"bid"`
	BwsDate              string                      `protobuf:"bytes,7,opt,name=BwsDate,proto3" json:"bws_date"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *VipUsersToken) Reset()         { *m = VipUsersToken{} }
func (m *VipUsersToken) String() string { return proto.CompactTextString(m) }
func (*VipUsersToken) ProtoMessage()    {}
func (*VipUsersToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{1}
}
func (m *VipUsersToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VipUsersToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VipUsersToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VipUsersToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VipUsersToken.Merge(m, src)
}
func (m *VipUsersToken) XXX_Size() int {
	return m.Size()
}
func (m *VipUsersToken) XXX_DiscardUnknown() {
	xxx_messageInfo_VipUsersToken.DiscardUnknown(m)
}

var xxx_messageInfo_VipUsersToken proto.InternalMessageInfo

type Point struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Name                 string                      `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Icon                 string                      `protobuf:"bytes,3,opt,name=Icon,proto3" json:"icon"`
	Fid                  int64                       `protobuf:"varint,4,opt,name=Fid,proto3" json:"fid"`
	Image                string                      `protobuf:"bytes,5,opt,name=Image,proto3" json:"image"`
	Unlocked             int64                       `protobuf:"varint,6,opt,name=Unlocked,proto3" json:"unlocked"`
	LockType             int64                       `protobuf:"varint,7,opt,name=LockType,proto3" json:"lockType"`
	Dic                  string                      `protobuf:"bytes,8,opt,name=Dic,proto3" json:"dic"`
	Rule                 string                      `protobuf:"bytes,9,opt,name=Rule,proto3" json:"rule"`
	Bid                  int64                       `protobuf:"varint,10,opt,name=Bid,proto3" json:"bid"`
	LoseUnlocked         int64                       `protobuf:"varint,11,opt,name=LoseUnlocked,proto3" json:"lose_unlocked"`
	OtherIp              string                      `protobuf:"bytes,12,opt,name=OtherIp,proto3" json:"other_ip"`
	Ower                 int64                       `protobuf:"varint,13,opt,name=Ower,proto3" json:"ower"`
	Ctime                go_common_library_time.Time `protobuf:"varint,14,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,15,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Point) Reset()         { *m = Point{} }
func (m *Point) String() string { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()    {}
func (*Point) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{2}
}
func (m *Point) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Point) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Point.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Point) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Point.Merge(m, src)
}
func (m *Point) XXX_Size() int {
	return m.Size()
}
func (m *Point) XXX_DiscardUnknown() {
	xxx_messageInfo_Point.DiscardUnknown(m)
}

var xxx_messageInfo_Point proto.InternalMessageInfo

type Points struct {
	Points               []*Point `protobuf:"bytes,1,rep,name=points,proto3" json:"points,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Points) Reset()         { *m = Points{} }
func (m *Points) String() string { return proto.CompactTextString(m) }
func (*Points) ProtoMessage()    {}
func (*Points) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{3}
}
func (m *Points) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Points) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Points.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Points) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Points.Merge(m, src)
}
func (m *Points) XXX_Size() int {
	return m.Size()
}
func (m *Points) XXX_DiscardUnknown() {
	xxx_messageInfo_Points.DiscardUnknown(m)
}

var xxx_messageInfo_Points proto.InternalMessageInfo

type Achievement struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Name                 string                      `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Icon                 string                      `protobuf:"bytes,3,opt,name=Icon,proto3" json:"icon"`
	Dic                  string                      `protobuf:"bytes,4,opt,name=Dic,proto3" json:"dic"`
	LockType             int64                       `protobuf:"varint,5,opt,name=LockType,proto3" json:"lockType"`
	Unlock               int64                       `protobuf:"varint,6,opt,name=Unlock,proto3" json:"unlock"`
	Bid                  int64                       `protobuf:"varint,7,opt,name=Bid,proto3" json:"bid"`
	IconBig              string                      `protobuf:"bytes,8,opt,name=IconBig,proto3" json:"icon_big"`
	IconActive           string                      `protobuf:"bytes,9,opt,name=IconActive,proto3" json:"icon_active"`
	IconActiveBig        string                      `protobuf:"bytes,10,opt,name=IconActiveBig,proto3" json:"icon_active_big"`
	Award                int64                       `protobuf:"varint,11,opt,name=Award,proto3" json:"award"`
	UserCount            int64                       `protobuf:"varint,12,opt,name=UserCount,proto3" json:"user_count"`
	Ctime                go_common_library_time.Time `protobuf:"varint,13,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,14,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Image                string                      `protobuf:"bytes,15,opt,name=Image,proto3" json:"image"`
	SuitID               int64                       `protobuf:"varint,16,opt,name=SuitID,proto3" json:"suit_id"`
	AchievePoint         int64                       `protobuf:"varint,17,opt,name=AchievePoint,proto3" json:"achieve_point"`
	Level                int32                       `protobuf:"varint,18,opt,name=Level,proto3" json:"level"`
	ExtraType            int32                       `protobuf:"varint,19,opt,name=ExtraType,proto3" json:"extra_type"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Achievement) Reset()         { *m = Achievement{} }
func (m *Achievement) String() string { return proto.CompactTextString(m) }
func (*Achievement) ProtoMessage()    {}
func (*Achievement) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{4}
}
func (m *Achievement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Achievement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Achievement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Achievement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Achievement.Merge(m, src)
}
func (m *Achievement) XXX_Size() int {
	return m.Size()
}
func (m *Achievement) XXX_DiscardUnknown() {
	xxx_messageInfo_Achievement.DiscardUnknown(m)
}

var xxx_messageInfo_Achievement proto.InternalMessageInfo

type Achievements struct {
	Achievements         []*Achievement `protobuf:"bytes,1,rep,name=achievements,proto3" json:"achievements,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Achievements) Reset()         { *m = Achievements{} }
func (m *Achievements) String() string { return proto.CompactTextString(m) }
func (*Achievements) ProtoMessage()    {}
func (*Achievements) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{5}
}
func (m *Achievements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Achievements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Achievements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Achievements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Achievements.Merge(m, src)
}
func (m *Achievements) XXX_Size() int {
	return m.Size()
}
func (m *Achievements) XXX_DiscardUnknown() {
	xxx_messageInfo_Achievements.DiscardUnknown(m)
}

var xxx_messageInfo_Achievements proto.InternalMessageInfo

type PointsLevel struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Bid                  int64                       `protobuf:"varint,2,opt,name=Bid,proto3" json:"bid"`
	Pid                  int64                       `protobuf:"varint,3,opt,name=Pid,proto3" json:"pid"`
	Ctime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Level                int32                       `protobuf:"varint,6,opt,name=Level,proto3" json:"level"`
	Points               int64                       `protobuf:"varint,7,opt,name=Points,proto3" json:"points"`
	Unlock               int32                       `protobuf:"varint,8,opt,name=Unlock,proto3" json:"unlock"`
	IsDelete             int32                       `protobuf:"varint,9,opt,name=IsDelete,proto3" json:"is_delete"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PointsLevel) Reset()         { *m = PointsLevel{} }
func (m *PointsLevel) String() string { return proto.CompactTextString(m) }
func (*PointsLevel) ProtoMessage()    {}
func (*PointsLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{6}
}
func (m *PointsLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsLevel.Merge(m, src)
}
func (m *PointsLevel) XXX_Size() int {
	return m.Size()
}
func (m *PointsLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsLevel.DiscardUnknown(m)
}

var xxx_messageInfo_PointsLevel proto.InternalMessageInfo

type PointsAward struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Bid                  int64                       `protobuf:"varint,2,opt,name=Bid,proto3" json:"bid"`
	PlID                 int64                       `protobuf:"varint,3,opt,name=PlID,proto3" json:"pl_id"`
	Ctime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Name                 string                      `protobuf:"bytes,6,opt,name=Name,proto3" json:"name"`
	Icon                 string                      `protobuf:"bytes,7,opt,name=Icon,proto3" json:"icon"`
	Amount               int64                       `protobuf:"varint,8,opt,name=Amount,proto3" json:"amount"`
	IsDelete             int32                       `protobuf:"varint,9,opt,name=IsDelete,proto3" json:"is_delete"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PointsAward) Reset()         { *m = PointsAward{} }
func (m *PointsAward) String() string { return proto.CompactTextString(m) }
func (*PointsAward) ProtoMessage()    {}
func (*PointsAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{7}
}
func (m *PointsAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsAward.Merge(m, src)
}
func (m *PointsAward) XXX_Size() int {
	return m.Size()
}
func (m *PointsAward) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsAward.DiscardUnknown(m)
}

var xxx_messageInfo_PointsAward proto.InternalMessageInfo

type PointSign struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Bid                  int64                       `protobuf:"varint,2,opt,name=Bid,proto3" json:"bid"`
	Pid                  int64                       `protobuf:"varint,3,opt,name=Pid,proto3" json:"pid"`
	Ctime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Stime                int64                       `protobuf:"varint,6,opt,name=Stime,proto3" json:"stime"`
	Etime                int64                       `protobuf:"varint,7,opt,name=Etime,proto3" json:"etime"`
	State                int32                       `protobuf:"varint,8,opt,name=State,proto3" json:"state"`
	Points               int64                       `protobuf:"varint,9,opt,name=Points,proto3" json:"points"`
	ProvidePoints        int64                       `protobuf:"varint,10,opt,name=ProvidePoints,proto3" json:"provide_points"`
	SignPoints           int64                       `protobuf:"varint,11,opt,name=SignPoints,proto3" json:"sign_points"`
	IsDelete             int32                       `protobuf:"varint,12,opt,name=IsDelete,proto3" json:"is_delete"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PointSign) Reset()         { *m = PointSign{} }
func (m *PointSign) String() string { return proto.CompactTextString(m) }
func (*PointSign) ProtoMessage()    {}
func (*PointSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{8}
}
func (m *PointSign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointSign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointSign.Merge(m, src)
}
func (m *PointSign) XXX_Size() int {
	return m.Size()
}
func (m *PointSign) XXX_DiscardUnknown() {
	xxx_messageInfo_PointSign.DiscardUnknown(m)
}

var xxx_messageInfo_PointSign proto.InternalMessageInfo

type ActField struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Name                 string                      `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Area                 string                      `protobuf:"bytes,3,opt,name=Area,proto3" json:"area"`
	Ctime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Del                  int32                       `protobuf:"varint,6,opt,name=del,proto3" json:"del"`
	Bid                  int64                       `protobuf:"varint,7,opt,name=bid,proto3" json:"bid"`
	Image                string                      `protobuf:"bytes,8,opt,name=image,proto3" json:"image"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ActField) Reset()         { *m = ActField{} }
func (m *ActField) String() string { return proto.CompactTextString(m) }
func (*ActField) ProtoMessage()    {}
func (*ActField) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{9}
}
func (m *ActField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActField.Merge(m, src)
}
func (m *ActField) XXX_Size() int {
	return m.Size()
}
func (m *ActField) XXX_DiscardUnknown() {
	xxx_messageInfo_ActField.DiscardUnknown(m)
}

var xxx_messageInfo_ActField proto.InternalMessageInfo

type ActFields struct {
	ActField             []*ActField `protobuf:"bytes,1,rep,name=actField,proto3" json:"actField,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ActFields) Reset()         { *m = ActFields{} }
func (m *ActFields) String() string { return proto.CompactTextString(m) }
func (*ActFields) ProtoMessage()    {}
func (*ActFields) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{10}
}
func (m *ActFields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActFields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActFields.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActFields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActFields.Merge(m, src)
}
func (m *ActFields) XXX_Size() int {
	return m.Size()
}
func (m *ActFields) XXX_DiscardUnknown() {
	xxx_messageInfo_ActFields.DiscardUnknown(m)
}

var xxx_messageInfo_ActFields proto.InternalMessageInfo

type Task struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Title                string                      `protobuf:"bytes,2,opt,name=title,proto3" json:"title"`
	Cate                 string                      `protobuf:"bytes,3,opt,name=cate,proto3" json:"cate"`
	FinishCount          int64                       `protobuf:"varint,4,opt,name=finish_count,json=finishCount,proto3" json:"finish_count"`
	RuleIds              []int64                     `protobuf:"varint,5,rep,packed,name=rule_ids,json=ruleIds,proto3" json:"rule_ids"`
	OrderNum             int64                       `protobuf:"varint,6,opt,name=order_num,json=orderNum,proto3" json:"order_num"`
	Ctime                go_common_library_time.Time `protobuf:"varint,7,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,8,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{11}
}
func (m *Task) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Task.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return m.Size()
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

type Award struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Title                string                      `protobuf:"bytes,2,opt,name=title,proto3" json:"title"`
	Image                string                      `protobuf:"bytes,3,opt,name=image,proto3" json:"image"`
	Intro                string                      `protobuf:"bytes,4,opt,name=intro,proto3" json:"intro"`
	Cate                 string                      `protobuf:"bytes,5,opt,name=cate,proto3" json:"cate"`
	IsOnline             int64                       `protobuf:"varint,6,opt,name=is_online,json=isOnline,proto3" json:"is_online"`
	Owner                int64                       `protobuf:"varint,7,opt,name=owner,proto3" json:"owner"`
	Stage                string                      `protobuf:"bytes,8,opt,name=stage,proto3" json:"stage"`
	Stock                int64                       `protobuf:"varint,9,opt,name=stock,proto3" json:"stock"`
	Ctime                go_common_library_time.Time `protobuf:"varint,10,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,11,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Award) Reset()         { *m = Award{} }
func (m *Award) String() string { return proto.CompactTextString(m) }
func (*Award) ProtoMessage()    {}
func (*Award) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{12}
}
func (m *Award) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Award) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Award.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Award) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Award.Merge(m, src)
}
func (m *Award) XXX_Size() int {
	return m.Size()
}
func (m *Award) XXX_DiscardUnknown() {
	xxx_messageInfo_Award.DiscardUnknown(m)
}

var xxx_messageInfo_Award proto.InternalMessageInfo

type UserAward struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	UserToken            string                      `protobuf:"bytes,2,opt,name=user_token,json=userToken,proto3" json:"user_token"`
	AwardId              int64                       `protobuf:"varint,3,opt,name=award_id,json=awardId,proto3" json:"award_id"`
	State                string                      `protobuf:"bytes,4,opt,name=state,proto3" json:"state"`
	Ctime                go_common_library_time.Time `protobuf:"varint,5,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,6,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *UserAward) Reset()         { *m = UserAward{} }
func (m *UserAward) String() string { return proto.CompactTextString(m) }
func (*UserAward) ProtoMessage()    {}
func (*UserAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{13}
}
func (m *UserAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAward.Merge(m, src)
}
func (m *UserAward) XXX_Size() int {
	return m.Size()
}
func (m *UserAward) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAward.DiscardUnknown(m)
}

var xxx_messageInfo_UserAward proto.InternalMessageInfo

type BluetoothUpList struct {
	List                 []*BluetoothUp `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BluetoothUpList) Reset()         { *m = BluetoothUpList{} }
func (m *BluetoothUpList) String() string { return proto.CompactTextString(m) }
func (*BluetoothUpList) ProtoMessage()    {}
func (*BluetoothUpList) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{14}
}
func (m *BluetoothUpList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BluetoothUpList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BluetoothUpList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BluetoothUpList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BluetoothUpList.Merge(m, src)
}
func (m *BluetoothUpList) XXX_Size() int {
	return m.Size()
}
func (m *BluetoothUpList) XXX_DiscardUnknown() {
	xxx_messageInfo_BluetoothUpList.DiscardUnknown(m)
}

var xxx_messageInfo_BluetoothUpList proto.InternalMessageInfo

type BluetoothUp struct {
	Id                   int64                       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Bid                  int64                       `protobuf:"varint,2,opt,name=bid,proto3" json:"bid,omitempty"`
	Mid                  int64                       `protobuf:"varint,3,opt,name=mid,proto3" json:"mid,omitempty"`
	Key                  string                      `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	Desc                 string                      `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	Ctime                go_common_library_time.Time `protobuf:"varint,6,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,7,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *BluetoothUp) Reset()         { *m = BluetoothUp{} }
func (m *BluetoothUp) String() string { return proto.CompactTextString(m) }
func (*BluetoothUp) ProtoMessage()    {}
func (*BluetoothUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{15}
}
func (m *BluetoothUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BluetoothUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BluetoothUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BluetoothUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BluetoothUp.Merge(m, src)
}
func (m *BluetoothUp) XXX_Size() int {
	return m.Size()
}
func (m *BluetoothUp) XXX_DiscardUnknown() {
	xxx_messageInfo_BluetoothUp.DiscardUnknown(m)
}

var xxx_messageInfo_BluetoothUp proto.InternalMessageInfo

type CatchUser struct {
	Mid                  int64                       `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	Key                  string                      `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Ctime                go_common_library_time.Time `protobuf:"varint,3,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,4,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *CatchUser) Reset()         { *m = CatchUser{} }
func (m *CatchUser) String() string { return proto.CompactTextString(m) }
func (*CatchUser) ProtoMessage()    {}
func (*CatchUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{16}
}
func (m *CatchUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatchUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatchUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatchUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatchUser.Merge(m, src)
}
func (m *CatchUser) XXX_Size() int {
	return m.Size()
}
func (m *CatchUser) XXX_DiscardUnknown() {
	xxx_messageInfo_CatchUser.DiscardUnknown(m)
}

var xxx_messageInfo_CatchUser proto.InternalMessageInfo

type BluetoothUpInfo struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Face                 string   `protobuf:"bytes,3,opt,name=face,proto3" json:"face,omitempty"`
	Key                  string   `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	Desc                 string   `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BluetoothUpInfo) Reset()         { *m = BluetoothUpInfo{} }
func (m *BluetoothUpInfo) String() string { return proto.CompactTextString(m) }
func (*BluetoothUpInfo) ProtoMessage()    {}
func (*BluetoothUpInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{17}
}
func (m *BluetoothUpInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BluetoothUpInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BluetoothUpInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BluetoothUpInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BluetoothUpInfo.Merge(m, src)
}
func (m *BluetoothUpInfo) XXX_Size() int {
	return m.Size()
}
func (m *BluetoothUpInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BluetoothUpInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BluetoothUpInfo proto.InternalMessageInfo

type UserDetail struct {
	Id                   int64                       `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Mid                  int64                       `protobuf:"varint,2,opt,name=mid,proto3" json:"mid"`
	Bid                  int64                       `protobuf:"varint,3,opt,name=bid,proto3" json:"bid"`
	Heart                int64                       `protobuf:"varint,4,opt,name=heart,proto3" json:"heart"`
	Star                 int64                       `protobuf:"varint,5,opt,name=star,proto3" json:"star"`
	StarInRank           int64                       `protobuf:"varint,6,opt,name=starInRank,proto3" json:"star_in_rank"`
	LotteryUsed          int64                       `protobuf:"varint,7,opt,name=lottery_used,json=lotteryUsed,proto3" json:"lottery_used"`
	StarDetail           string                      `protobuf:"bytes,8,opt,name=star_detail,json=starDetail,proto3" json:"star_detail"`
	BwsDate              string                      `protobuf:"bytes,9,opt,name=bws_date,json=bwsDate,proto3" json:"bws_date"`
	State                int64                       `protobuf:"varint,10,opt,name=state,proto3" json:"state"`
	StarLastTime         int64                       `protobuf:"varint,11,opt,name=star_last_time,json=starLastTime,proto3" json:"star_last_time"`
	Ups                  int64                       `protobuf:"varint,12,opt,name=ups,proto3" json:"ups"`
	Ctime                go_common_library_time.Time `protobuf:"varint,13,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,14,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	PlayTimes            int64                       `protobuf:"varint,15,opt,name=PlayTimes,proto3" json:"play_times"`
	PlaySuccessTimes     int64                       `protobuf:"varint,16,opt,name=PlaySuccessTimes,proto3" json:"play_success_times"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *UserDetail) Reset()         { *m = UserDetail{} }
func (m *UserDetail) String() string { return proto.CompactTextString(m) }
func (*UserDetail) ProtoMessage()    {}
func (*UserDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_5091ac315f1ae111, []int{18}
}
func (m *UserDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDetail.Merge(m, src)
}
func (m *UserDetail) XXX_Size() int {
	return m.Size()
}
func (m *UserDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDetail.DiscardUnknown(m)
}

var xxx_messageInfo_UserDetail proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Users)(nil), "activity.service.Users")
	proto.RegisterType((*VipUsersToken)(nil), "activity.service.VipUsersToken")
	proto.RegisterType((*Point)(nil), "activity.service.Point")
	proto.RegisterType((*Points)(nil), "activity.service.Points")
	proto.RegisterType((*Achievement)(nil), "activity.service.Achievement")
	proto.RegisterType((*Achievements)(nil), "activity.service.Achievements")
	proto.RegisterType((*PointsLevel)(nil), "activity.service.PointsLevel")
	proto.RegisterType((*PointsAward)(nil), "activity.service.PointsAward")
	proto.RegisterType((*PointSign)(nil), "activity.service.PointSign")
	proto.RegisterType((*ActField)(nil), "activity.service.ActField")
	proto.RegisterType((*ActFields)(nil), "activity.service.ActFields")
	proto.RegisterType((*Task)(nil), "activity.service.Task")
	proto.RegisterType((*Award)(nil), "activity.service.Award")
	proto.RegisterType((*UserAward)(nil), "activity.service.UserAward")
	proto.RegisterType((*BluetoothUpList)(nil), "activity.service.BluetoothUpList")
	proto.RegisterType((*BluetoothUp)(nil), "activity.service.BluetoothUp")
	proto.RegisterType((*CatchUser)(nil), "activity.service.CatchUser")
	proto.RegisterType((*BluetoothUpInfo)(nil), "activity.service.BluetoothUpInfo")
	proto.RegisterType((*UserDetail)(nil), "activity.service.UserDetail")
}

func init() { proto.RegisterFile("bws.proto", fileDescriptor_5091ac315f1ae111) }

var fileDescriptor_5091ac315f1ae111 = []byte{
	// 1827 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xbd, 0x6f, 0x23, 0xc7,
	0x15, 0x3f, 0x7e, 0x2d, 0xc9, 0xa1, 0xbe, 0xbc, 0x06, 0x1c, 0xda, 0xc9, 0x69, 0x85, 0x35, 0x90,
	0x53, 0x8c, 0x9c, 0xe4, 0xc4, 0x48, 0x60, 0x37, 0x01, 0xc4, 0xe3, 0x1d, 0x40, 0x44, 0xf6, 0x29,
	0x23, 0x9d, 0x8b, 0x34, 0x8b, 0xe5, 0xee, 0x88, 0x1a, 0x68, 0x3f, 0x98, 0x9d, 0x59, 0x31, 0xfc,
	0x3f, 0x52, 0xa4, 0xc8, 0x5f, 0x90, 0x26, 0x55, 0xba, 0x74, 0x69, 0x5c, 0xfa, 0x2f, 0x58, 0xc4,
	0x97, 0xc2, 0xc0, 0x36, 0x49, 0x95, 0x22, 0x55, 0xf0, 0xde, 0xcc, 0x7e, 0xf0, 0x8e, 0x12, 0x7c,
	0x14, 0x02, 0x1b, 0x6e, 0xb8, 0x33, 0xbf, 0xf7, 0x66, 0xf7, 0xcd, 0xef, 0x7d, 0xcc, 0xe3, 0x90,
	0xfe, 0x74, 0x21, 0x8e, 0xe6, 0x49, 0x2c, 0x63, 0x73, 0xcf, 0xf5, 0x24, 0xbf, 0xe1, 0x72, 0x79,
	0x24, 0x58, 0x72, 0xc3, 0x3d, 0xf6, 0xde, 0xe3, 0x19, 0x97, 0x57, 0xe9, 0xf4, 0xc8, 0x8b, 0xc3,
	0xe3, 0x59, 0x3c, 0x8b, 0x8f, 0x51, 0x71, 0x9a, 0x5e, 0xe2, 0x0c, 0x27, 0x38, 0x52, 0x2f, 0xb0,
	0xff, 0xdd, 0x20, 0x9d, 0x17, 0x82, 0x25, 0xc2, 0x7c, 0x87, 0x34, 0x27, 0xe3, 0x61, 0xe3, 0xa0,
	0x71, 0xd8, 0x1a, 0x19, 0x79, 0x66, 0x35, 0xb9, 0x4f, 0x9b, 0x93, 0xb1, 0xf9, 0x2e, 0x69, 0x7d,
	0xca, 0xfd, 0x61, 0x13, 0x05, 0xdd, 0x3c, 0xb3, 0x5a, 0x21, 0xf7, 0x29, 0x60, 0x20, 0xfa, 0x35,
	0x5b, 0x0e, 0x5b, 0x07, 0x8d, 0xc3, 0xbe, 0x12, 0x5d, 0xb3, 0x25, 0x05, 0xcc, 0xfc, 0x15, 0xe9,
	0x3c, 0x91, 0x3c, 0x64, 0xc3, 0x36, 0xae, 0x3b, 0xcc, 0x33, 0xab, 0xe3, 0x01, 0xf0, 0xdf, 0xcc,
	0xfa, 0xe1, 0x2c, 0x7e, 0xec, 0xc5, 0x61, 0x18, 0x47, 0xc7, 0x01, 0x9f, 0x26, 0x6e, 0xb2, 0x3c,
	0x06, 0xc9, 0xd1, 0x05, 0x0f, 0x19, 0x55, 0xcb, 0x60, 0xfd, 0xa7, 0xb8, 0xbe, 0x53, 0xad, 0x0f,
	0xbf, 0xd1, 0x7a, 0x5c, 0x06, 0xa6, 0x8d, 0xb8, 0x3f, 0x34, 0x2a, 0xab, 0xa7, 0x60, 0xf5, 0x88,
	0xfb, 0xf6, 0x9f, 0x9b, 0x64, 0xfb, 0x73, 0x3e, 0xc7, 0x5d, 0x5f, 0xc4, 0xd7, 0x2c, 0xda, 0x64,
	0xeb, 0xef, 0x13, 0xe3, 0x73, 0x3e, 0xaf, 0x76, 0x3f, 0xc8, 0x33, 0xab, 0x7b, 0xc3, 0xe7, 0x0e,
	0x30, 0xa0, 0x45, 0xdf, 0x61, 0x12, 0xcc, 0x1f, 0x93, 0xee, 0x68, 0x21, 0xc6, 0xae, 0x64, 0xc3,
	0x2e, 0x6e, 0x60, 0x2b, 0xcf, 0xac, 0xde, 0x74, 0x21, 0x1c, 0xdf, 0x95, 0x8c, 0x16, 0x42, 0xfb,
	0x6f, 0x6d, 0xd2, 0x39, 0x8b, 0x79, 0x24, 0x6f, 0x25, 0xe9, 0x47, 0xa4, 0xfd, 0x99, 0x1b, 0x32,
	0x64, 0xa9, 0x3f, 0xea, 0xe5, 0x99, 0xd5, 0x8e, 0xdc, 0x90, 0x51, 0x44, 0x41, 0x3a, 0xf1, 0xe2,
	0x48, 0xb3, 0x84, 0x52, 0xee, 0xc5, 0x11, 0x45, 0x14, 0x0c, 0x7c, 0xc6, 0x7d, 0x4d, 0x0f, 0x1a,
	0x78, 0x09, 0x06, 0x3e, 0xe3, 0xbe, 0x69, 0x91, 0xce, 0x24, 0x74, 0x67, 0x6a, 0xef, 0xfd, 0x51,
	0x1f, 0xf6, 0xce, 0x01, 0xa0, 0x0a, 0x37, 0x0f, 0x49, 0xef, 0x45, 0x14, 0xc4, 0xde, 0x35, 0x2b,
	0x76, 0x88, 0x5b, 0x48, 0x35, 0x46, 0x4b, 0x29, 0x68, 0x9e, 0xc6, 0xde, 0xf5, 0xc5, 0x72, 0xae,
	0x36, 0xab, 0x35, 0x03, 0x8d, 0xd1, 0x52, 0x0a, 0xf6, 0x8c, 0xb9, 0x37, 0xec, 0x55, 0x01, 0xed,
	0x73, 0x8f, 0x02, 0x06, 0x1b, 0xa1, 0x69, 0xc0, 0x86, 0xfd, 0x6a, 0x23, 0x49, 0x1a, 0x30, 0x8a,
	0x68, 0xc1, 0x34, 0x59, 0xc3, 0xf4, 0x2f, 0xc8, 0xd6, 0x69, 0x2c, 0x58, 0x69, 0xeb, 0x00, 0x75,
	0xde, 0xca, 0x33, 0x6b, 0x3b, 0x88, 0x05, 0x73, 0x4a, 0x83, 0x57, 0xd4, 0xc0, 0x41, 0xcf, 0xe5,
	0x15, 0x4b, 0x26, 0xf3, 0xe1, 0x56, 0xe5, 0xa0, 0x18, 0x20, 0x87, 0xcf, 0x69, 0x21, 0x04, 0xbb,
	0x9e, 0x2f, 0x58, 0x32, 0xdc, 0xc6, 0xd7, 0xa2, 0x5d, 0xf1, 0x82, 0x25, 0x14, 0xd1, 0x2a, 0x02,
	0x77, 0xee, 0x19, 0x81, 0xbb, 0x1b, 0x45, 0xa0, 0xfd, 0x09, 0x31, 0x30, 0x7a, 0x84, 0x79, 0x4c,
	0x8c, 0x39, 0x8e, 0x86, 0x8d, 0x83, 0xd6, 0xe1, 0xe0, 0xe7, 0x3f, 0x38, 0x7a, 0xb5, 0x74, 0x1d,
	0xa1, 0x26, 0xd5, 0x6a, 0xf6, 0x1f, 0x0c, 0x32, 0x38, 0xf1, 0xae, 0x38, 0xbb, 0x61, 0x21, 0xfb,
	0xff, 0xc5, 0x1f, 0xf8, 0xbb, 0xbd, 0xc6, 0xdf, 0xf5, 0xa0, 0xe9, 0xdc, 0x19, 0x34, 0x36, 0x31,
	0x94, 0xd7, 0x74, 0x18, 0x92, 0x3c, 0xb3, 0x0c, 0xe5, 0x55, 0xaa, 0x25, 0x45, 0x7c, 0x74, 0xd7,
	0x67, 0x22, 0xd8, 0x32, 0xe2, 0x33, 0x1d, 0x77, 0xf8, 0x1d, 0x30, 0xd2, 0x99, 0xf2, 0x19, 0x2d,
	0x84, 0xe6, 0x31, 0x21, 0x30, 0x3c, 0x01, 0xd6, 0x8a, 0x30, 0xdc, 0xcd, 0x33, 0x6b, 0x80, 0xaa,
	0x48, 0x26, 0xa3, 0x35, 0x15, 0xf3, 0x13, 0xb2, 0x5d, 0xcd, 0xe0, 0xf5, 0x04, 0xd7, 0xbc, 0x9d,
	0x67, 0xd6, 0x6e, 0x6d, 0x0d, 0x7e, 0x65, 0x55, 0x13, 0x92, 0xef, 0x64, 0xe1, 0x26, 0x45, 0xb0,
	0x62, 0xf2, 0xb9, 0x00, 0x50, 0x85, 0x9b, 0x3f, 0x25, 0x7d, 0xa8, 0x9f, 0x4f, 0xe2, 0x34, 0x92,
	0x18, 0x9f, 0xad, 0xd1, 0x4e, 0x9e, 0x59, 0x24, 0x15, 0x2c, 0x71, 0x3c, 0x40, 0x69, 0xa5, 0x50,
	0x45, 0xe1, 0xf6, 0x3d, 0xa3, 0x70, 0x67, 0xb3, 0x3a, 0x58, 0xd6, 0x92, 0xdd, 0x5b, 0x6a, 0xc9,
	0xfb, 0xc4, 0x38, 0x4f, 0xb9, 0x9c, 0x8c, 0x87, 0x7b, 0xf8, 0x05, 0xac, 0xe6, 0x22, 0xe5, 0xd2,
	0xe1, 0x3e, 0xd5, 0x22, 0x48, 0x64, 0x1d, 0x8f, 0x18, 0xa8, 0xc3, 0xb7, 0xaa, 0x44, 0x76, 0x15,
	0xee, 0x60, 0xe8, 0xd2, 0x15, 0x35, 0xf8, 0xf8, 0x29, 0xbb, 0x61, 0xc1, 0xd0, 0x3c, 0x68, 0x1c,
	0x76, 0xd4, 0xc7, 0x03, 0x00, 0xa8, 0xc2, 0x81, 0xcb, 0xa7, 0xbf, 0x97, 0x89, 0x8b, 0xa1, 0xf6,
	0x36, 0x2a, 0x21, 0x97, 0x0c, 0x40, 0x47, 0x42, 0xb0, 0x55, 0x0a, 0xf6, 0x6f, 0x4a, 0x2b, 0x20,
	0x2b, 0x84, 0x79, 0x42, 0xb6, 0xdc, 0xda, 0x5c, 0x67, 0xd7, 0xc3, 0xd7, 0xb3, 0xab, 0xb6, 0x8a,
	0xae, 0x2c, 0xb1, 0xff, 0xd5, 0x24, 0x03, 0x95, 0xa5, 0xca, 0xa0, 0x3b, 0x8e, 0xc3, 0xd1, 0xea,
	0x71, 0x58, 0x06, 0xf1, 0xbb, 0xa4, 0x75, 0xc6, 0x7d, 0xcc, 0x32, 0x2d, 0x9a, 0x83, 0xe8, 0x8c,
	0xfb, 0xdf, 0xfa, 0x21, 0x58, 0xf2, 0x6f, 0xdc, 0xc2, 0xbf, 0x5d, 0xd4, 0x28, 0x9d, 0x9e, 0x98,
	0xbf, 0xaa, 0x08, 0xd1, 0xa2, 0x7a, 0x55, 0x39, 0xde, 0xc3, 0xb7, 0xac, 0xcb, 0xf1, 0x9f, 0x90,
	0xde, 0x44, 0x8c, 0x59, 0xc0, 0xa4, 0x4a, 0xcf, 0xce, 0x68, 0x3b, 0xcf, 0xac, 0x3e, 0x17, 0x8e,
	0x8f, 0x20, 0x2d, 0xc5, 0x76, 0x5e, 0x32, 0xae, 0xd2, 0x69, 0x03, 0xc6, 0x1f, 0x92, 0xf6, 0x59,
	0x30, 0x19, 0x6b, 0xca, 0x71, 0x57, 0xf3, 0x00, 0xc2, 0x15, 0xe1, 0x6f, 0x9d, 0xf5, 0xa2, 0x2a,
	0x1b, 0x77, 0x56, 0xe5, 0xee, 0xda, 0xaa, 0x6c, 0x13, 0xe3, 0x24, 0xc4, 0xca, 0xd2, 0xab, 0x1c,
	0xe2, 0x22, 0x42, 0xb5, 0xe4, 0x4d, 0xc8, 0xfe, 0x4f, 0x8b, 0xf4, 0x91, 0xec, 0x73, 0x3e, 0x8b,
	0xbe, 0x7f, 0xc1, 0x7d, 0x8e, 0xeb, 0x8d, 0x2a, 0x0c, 0x84, 0x44, 0x85, 0xf3, 0x42, 0xe1, 0x29,
	0x2a, 0x74, 0x2b, 0x05, 0xa6, 0x14, 0x9e, 0x56, 0x6f, 0x80, 0x36, 0xb0, 0x57, 0xa5, 0x87, 0x00,
	0x80, 0x2a, 0xbc, 0x96, 0x1e, 0xfd, 0x5b, 0xd3, 0xe3, 0x63, 0xb2, 0x7d, 0x96, 0xc4, 0x37, 0xdc,
	0x67, 0x5a, 0x55, 0x35, 0x42, 0x66, 0x9e, 0x59, 0x3b, 0x73, 0x25, 0x70, 0xf4, 0x92, 0x55, 0x45,
	0x38, 0xd5, 0xc0, 0x2d, 0x7a, 0x99, 0x3a, 0x6e, 0xf0, 0x54, 0x13, 0x7c, 0x16, 0x15, 0x6b, 0x6a,
	0x2a, 0x2b, 0x8e, 0xdf, 0xba, 0xdb, 0xf1, 0x7f, 0x6d, 0x92, 0xde, 0x89, 0x27, 0x9f, 0x71, 0x16,
	0xf8, 0x9b, 0xb7, 0x0f, 0x27, 0x09, 0x73, 0xeb, 0xed, 0x83, 0x9b, 0x30, 0x97, 0x22, 0xfa, 0x5d,
	0xe8, 0xef, 0xfd, 0xb2, 0xb0, 0xa9, 0xf6, 0x85, 0x05, 0x14, 0x7e, 0x40, 0x34, 0x5d, 0xd3, 0x70,
	0x4c, 0x55, 0x67, 0x8d, 0x87, 0x9f, 0x6e, 0x37, 0xea, 0xa7, 0x21, 0x3e, 0xec, 0x27, 0xa4, 0x5f,
	0xd0, 0x26, 0xcc, 0x5f, 0x92, 0x9e, 0xab, 0x27, 0xfa, 0x6c, 0x79, 0x6f, 0xdd, 0xd9, 0xa2, 0x34,
	0x68, 0xa9, 0x6b, 0x7f, 0xdd, 0x24, 0xed, 0x0b, 0x57, 0x5c, 0xdf, 0x4a, 0xbc, 0x45, 0x3a, 0x92,
	0xcb, 0xa0, 0x60, 0x1e, 0xcd, 0x40, 0x80, 0xaa, 0x07, 0x70, 0xef, 0x41, 0x60, 0xd6, 0xb8, 0x87,
	0x39, 0xc5, 0x5f, 0xf3, 0x23, 0xb2, 0x75, 0xc9, 0x23, 0x2e, 0xae, 0x54, 0xbb, 0xa1, 0x5d, 0xb0,
	0x97, 0x67, 0xd6, 0x0a, 0x4e, 0x07, 0x6a, 0xa6, 0x1a, 0x91, 0x47, 0xa4, 0x07, 0x4d, 0xbb, 0xc3,
	0x7d, 0x31, 0xec, 0x1c, 0xb4, 0x8a, 0xa6, 0xae, 0xc0, 0x68, 0x17, 0x46, 0x13, 0x5f, 0x98, 0x1f,
	0x90, 0x7e, 0x9c, 0xf8, 0x2c, 0x71, 0xa2, 0x34, 0xd4, 0xb9, 0x85, 0x61, 0x56, 0x82, 0xb4, 0x87,
	0xc3, 0xcf, 0xd2, 0x10, 0xbc, 0xe8, 0xd5, 0x52, 0xec, 0x0d, 0xa2, 0xc0, 0x2b, 0xa2, 0x00, 0x9d,
	0xae, 0xab, 0xdd, 0x1b, 0x44, 0x01, 0x6a, 0xd9, 0x7f, 0x69, 0xe9, 0x6e, 0x6d, 0x73, 0xaa, 0xcb,
	0x90, 0x68, 0xad, 0x0f, 0x09, 0x54, 0x88, 0x64, 0x12, 0xeb, 0x56, 0x59, 0x29, 0x00, 0x40, 0xd5,
	0xa3, 0x74, 0x56, 0x67, 0xad, 0xb3, 0x3e, 0x20, 0x90, 0xa0, 0x71, 0x14, 0xf0, 0x88, 0xd5, 0xe9,
	0x2c, 0x41, 0xda, 0xe3, 0xe2, 0x39, 0x8e, 0xe0, 0x53, 0xf1, 0x22, 0x62, 0x49, 0xbd, 0x62, 0x21,
	0x40, 0xd5, 0x03, 0x14, 0x84, 0x7c, 0x25, 0x7e, 0x11, 0xa0, 0xea, 0xa1, 0x14, 0xe0, 0xac, 0xee,
	0xd7, 0x8b, 0x22, 0x1c, 0xd5, 0xea, 0x51, 0x79, 0x8c, 0xdc, 0xd3, 0x63, 0x83, 0xcd, 0x3c, 0xf6,
	0xa7, 0xa6, 0x6a, 0x9f, 0xef, 0xf6, 0xda, 0x63, 0xa2, 0xda, 0x69, 0x19, 0x5f, 0xb3, 0x48, 0xbb,
	0xae, 0x6a, 0xb2, 0x11, 0xa5, 0x7d, 0x18, 0xab, 0x4b, 0x8c, 0x47, 0xa4, 0x87, 0x2d, 0xba, 0x53,
	0x1e, 0x55, 0x18, 0xdb, 0x05, 0x46, 0xbb, 0x38, 0x9a, 0xf8, 0x9a, 0x3f, 0xc9, 0xea, 0xbe, 0xd4,
	0x15, 0x1f, 0x1f, 0x15, 0x3d, 0x9d, 0x7b, 0xd2, 0x63, 0x6c, 0x46, 0xcf, 0x98, 0xec, 0x8e, 0x82,
	0x94, 0xc9, 0x38, 0x96, 0x57, 0x2f, 0xe6, 0xa7, 0x5c, 0x48, 0xf3, 0x67, 0xa4, 0x1d, 0x70, 0x21,
	0x6f, 0xef, 0x6e, 0x6b, 0x0b, 0x28, 0xaa, 0xda, 0x5f, 0x37, 0xc8, 0xa0, 0x86, 0x9a, 0x3b, 0xa4,
	0xc9, 0x7d, 0x45, 0x33, 0x6d, 0x72, 0xdf, 0xdc, 0x53, 0x15, 0x12, 0x0f, 0x7c, 0x55, 0x18, 0xf7,
	0x48, 0x2b, 0x2c, 0xc8, 0xa3, 0x30, 0x04, 0xe4, 0x9a, 0x2d, 0x15, 0x51, 0x14, 0x86, 0xa6, 0x49,
	0xda, 0x3e, 0x13, 0x9e, 0x8a, 0x73, 0x8a, 0xe3, 0x8a, 0x2f, 0xe3, 0x9e, 0x7c, 0x75, 0x37, 0x2c,
	0x00, 0x0d, 0xd2, 0x7f, 0xe2, 0x4a, 0xef, 0x0a, 0x62, 0xaa, 0xd8, 0x45, 0xe3, 0xb5, 0x5d, 0x34,
	0xab, 0x5d, 0x94, 0x16, 0xb7, 0xee, 0x69, 0x71, 0x7b, 0x33, 0x8b, 0x7f, 0xb7, 0xe2, 0xe1, 0x49,
	0x74, 0x19, 0xaf, 0x31, 0xdb, 0x24, 0x78, 0x12, 0x6b, 0xbb, 0x71, 0x0c, 0xd8, 0xa5, 0xeb, 0xe9,
	0x3a, 0x45, 0x71, 0xfc, 0xcd, 0x9c, 0x64, 0xff, 0xbd, 0x43, 0x08, 0xf0, 0x33, 0x66, 0xd2, 0xe5,
	0xf8, 0x1f, 0xa7, 0xf8, 0x5a, 0x95, 0x74, 0xaa, 0xd7, 0x0b, 0xd7, 0x5c, 0xf9, 0x85, 0x4a, 0x34,
	0x5d, 0x6d, 0x03, 0xeb, 0x47, 0xea, 0x15, 0x73, 0x93, 0xe2, 0x14, 0xc2, 0x94, 0x42, 0x80, 0xaa,
	0x07, 0x94, 0x47, 0x21, 0xdd, 0x44, 0x67, 0x14, 0x96, 0x47, 0x98, 0x53, 0xfc, 0x35, 0x3f, 0x24,
	0x04, 0x9e, 0x93, 0x88, 0xba, 0x51, 0x71, 0x8b, 0x80, 0x27, 0x19, 0xa0, 0x0e, 0x8f, 0x9c, 0xc4,
	0x8d, 0xae, 0x69, 0x4d, 0x07, 0x4e, 0xbf, 0x20, 0x96, 0x92, 0x25, 0x4b, 0x27, 0x15, 0xac, 0x38,
	0xe7, 0x71, 0x4d, 0x1d, 0xa7, 0x03, 0x3d, 0x7b, 0x21, 0x98, 0x6f, 0x7e, 0x48, 0x06, 0xf8, 0x42,
	0x1f, 0x29, 0xd0, 0xe5, 0x53, 0x35, 0x5b, 0x15, 0xac, 0x3e, 0xa3, 0x59, 0x7a, 0x44, 0xca, 0x2b,
	0x41, 0x7d, 0xe3, 0xf0, 0xca, 0x35, 0xe1, 0x54, 0x5d, 0x13, 0x56, 0x35, 0x85, 0xd4, 0x4b, 0x6e,
	0xad, 0xa6, 0x7c, 0x4c, 0x76, 0xf0, 0x23, 0x81, 0x2b, 0xa4, 0x53, 0xab, 0x9d, 0xd8, 0x22, 0xae,
	0x4a, 0x28, 0x6e, 0xfb, 0xd4, 0x15, 0xf2, 0x42, 0x37, 0x39, 0xe9, 0x5c, 0xe8, 0x4b, 0x06, 0xa4,
	0x3d, 0x9d, 0x0b, 0x0a, 0x3f, 0x55, 0x18, 0x6f, 0xdf, 0x33, 0x8c, 0x77, 0x36, 0x0a, 0x63, 0xf8,
	0xe7, 0x7e, 0x16, 0xb8, 0x4b, 0x80, 0x84, 0xbe, 0x21, 0xc3, 0x02, 0x3d, 0x0f, 0xdc, 0x25, 0x6e,
	0x45, 0xd0, 0x4a, 0xc1, 0x1c, 0x91, 0x3d, 0x98, 0x9c, 0xa7, 0x9e, 0xc7, 0x84, 0x50, 0x8b, 0xd4,
	0x75, 0xc3, 0x3b, 0x79, 0x66, 0x99, 0xb8, 0x48, 0x28, 0xa1, 0x5e, 0xfc, 0x9a, 0xfe, 0xe8, 0xe1,
	0x17, 0x5f, 0xed, 0x3f, 0xf8, 0xf2, 0xab, 0xfd, 0x07, 0x5f, 0xbc, 0xdc, 0x6f, 0x7c, 0xf9, 0x72,
	0xbf, 0xf1, 0x8f, 0x97, 0xfb, 0x8d, 0x3f, 0xfe, 0x73, 0xff, 0xc1, 0x6f, 0x5b, 0xd3, 0x85, 0x98,
	0x1a, 0x78, 0xa9, 0xff, 0xd1, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x35, 0x7f, 0xa4, 0xa3, 0x22,
	0x18, 0x00, 0x00,
}

func (m *Users) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Users) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Users) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x30
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VipUsersToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipUsersToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VipUsersToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BwsDate) > 0 {
		i -= len(m.BwsDate)
		copy(dAtA[i:], m.BwsDate)
		i = encodeVarintBws(dAtA, i, uint64(len(m.BwsDate)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x30
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.VipKey) > 0 {
		i -= len(m.VipKey)
		copy(dAtA[i:], m.VipKey)
		i = encodeVarintBws(dAtA, i, uint64(len(m.VipKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Point) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x78
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x70
	}
	if m.Ower != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ower))
		i--
		dAtA[i] = 0x68
	}
	if len(m.OtherIp) > 0 {
		i -= len(m.OtherIp)
		copy(dAtA[i:], m.OtherIp)
		i = encodeVarintBws(dAtA, i, uint64(len(m.OtherIp)))
		i--
		dAtA[i] = 0x62
	}
	if m.LoseUnlocked != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.LoseUnlocked))
		i--
		dAtA[i] = 0x58
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Rule) > 0 {
		i -= len(m.Rule)
		copy(dAtA[i:], m.Rule)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Rule)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Dic) > 0 {
		i -= len(m.Dic)
		copy(dAtA[i:], m.Dic)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Dic)))
		i--
		dAtA[i] = 0x42
	}
	if m.LockType != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.LockType))
		i--
		dAtA[i] = 0x38
	}
	if m.Unlocked != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Unlocked))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Fid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Fid))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Points) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Points) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Points) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Points) > 0 {
		for iNdEx := len(m.Points) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Points[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBws(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Achievement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Achievement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Achievement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtraType != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ExtraType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Level != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.AchievePoint != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.AchievePoint))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SuitID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.SuitID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x7a
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x70
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x68
	}
	if m.UserCount != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.UserCount))
		i--
		dAtA[i] = 0x60
	}
	if m.Award != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Award))
		i--
		dAtA[i] = 0x58
	}
	if len(m.IconActiveBig) > 0 {
		i -= len(m.IconActiveBig)
		copy(dAtA[i:], m.IconActiveBig)
		i = encodeVarintBws(dAtA, i, uint64(len(m.IconActiveBig)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.IconActive) > 0 {
		i -= len(m.IconActive)
		copy(dAtA[i:], m.IconActive)
		i = encodeVarintBws(dAtA, i, uint64(len(m.IconActive)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.IconBig) > 0 {
		i -= len(m.IconBig)
		copy(dAtA[i:], m.IconBig)
		i = encodeVarintBws(dAtA, i, uint64(len(m.IconBig)))
		i--
		dAtA[i] = 0x42
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x38
	}
	if m.Unlock != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Unlock))
		i--
		dAtA[i] = 0x30
	}
	if m.LockType != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.LockType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Dic) > 0 {
		i -= len(m.Dic)
		copy(dAtA[i:], m.Dic)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Dic)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Achievements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Achievements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Achievements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Achievements) > 0 {
		for iNdEx := len(m.Achievements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Achievements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBws(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsDelete != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.IsDelete))
		i--
		dAtA[i] = 0x48
	}
	if m.Unlock != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Unlock))
		i--
		dAtA[i] = 0x40
	}
	if m.Points != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Points))
		i--
		dAtA[i] = 0x38
	}
	if m.Level != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x30
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x20
	}
	if m.Pid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x18
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PointsAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsDelete != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.IsDelete))
		i--
		dAtA[i] = 0x48
	}
	if m.Amount != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x20
	}
	if m.PlID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.PlID))
		i--
		dAtA[i] = 0x18
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PointSign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointSign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointSign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsDelete != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.IsDelete))
		i--
		dAtA[i] = 0x60
	}
	if m.SignPoints != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.SignPoints))
		i--
		dAtA[i] = 0x58
	}
	if m.ProvidePoints != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ProvidePoints))
		i--
		dAtA[i] = 0x50
	}
	if m.Points != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Points))
		i--
		dAtA[i] = 0x48
	}
	if m.State != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	if m.Etime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x38
	}
	if m.Stime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x30
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x20
	}
	if m.Pid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x18
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActField) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActField) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x42
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x38
	}
	if m.Del != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Del))
		i--
		dAtA[i] = 0x30
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Area) > 0 {
		i -= len(m.Area)
		copy(dAtA[i:], m.Area)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Area)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActFields) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActFields) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ActField) > 0 {
		for iNdEx := len(m.ActField) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActField[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBws(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Task) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x40
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x38
	}
	if m.OrderNum != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.OrderNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.RuleIds) > 0 {
		dAtA2 := make([]byte, len(m.RuleIds)*10)
		var j1 int
		for _, num1 := range m.RuleIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintBws(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if m.FinishCount != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.FinishCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Cate) > 0 {
		i -= len(m.Cate)
		copy(dAtA[i:], m.Cate)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Cate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Award) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Award) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Award) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x58
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x50
	}
	if m.Stock != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Stock))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Stage) > 0 {
		i -= len(m.Stage)
		copy(dAtA[i:], m.Stage)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Stage)))
		i--
		dAtA[i] = 0x42
	}
	if m.Owner != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Owner))
		i--
		dAtA[i] = 0x38
	}
	if m.IsOnline != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.IsOnline))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Cate) > 0 {
		i -= len(m.Cate)
		copy(dAtA[i:], m.Cate)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Cate)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Intro) > 0 {
		i -= len(m.Intro)
		copy(dAtA[i:], m.Intro)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Intro)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x30
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintBws(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if m.AwardId != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.AwardId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserToken) > 0 {
		i -= len(m.UserToken)
		copy(dAtA[i:], m.UserToken)
		i = encodeVarintBws(dAtA, i, uint64(len(m.UserToken)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BluetoothUpList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BluetoothUpList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BluetoothUpList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBws(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BluetoothUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BluetoothUp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BluetoothUp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x38
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x22
	}
	if m.Mid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x18
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatchUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatchUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatchUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x20
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BluetoothUpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BluetoothUpInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BluetoothUpInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Face) > 0 {
		i -= len(m.Face)
		copy(dAtA[i:], m.Face)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Face)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBws(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlaySuccessTimes != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.PlaySuccessTimes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PlayTimes != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.PlayTimes))
		i--
		dAtA[i] = 0x78
	}
	if m.Mtime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x70
	}
	if m.Ctime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x68
	}
	if m.Ups != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Ups))
		i--
		dAtA[i] = 0x60
	}
	if m.StarLastTime != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.StarLastTime))
		i--
		dAtA[i] = 0x58
	}
	if m.State != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x50
	}
	if len(m.BwsDate) > 0 {
		i -= len(m.BwsDate)
		copy(dAtA[i:], m.BwsDate)
		i = encodeVarintBws(dAtA, i, uint64(len(m.BwsDate)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.StarDetail) > 0 {
		i -= len(m.StarDetail)
		copy(dAtA[i:], m.StarDetail)
		i = encodeVarintBws(dAtA, i, uint64(len(m.StarDetail)))
		i--
		dAtA[i] = 0x42
	}
	if m.LotteryUsed != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.LotteryUsed))
		i--
		dAtA[i] = 0x38
	}
	if m.StarInRank != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.StarInRank))
		i--
		dAtA[i] = 0x30
	}
	if m.Star != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Star))
		i--
		dAtA[i] = 0x28
	}
	if m.Heart != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Heart))
		i--
		dAtA[i] = 0x20
	}
	if m.Bid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Bid))
		i--
		dAtA[i] = 0x18
	}
	if m.Mid != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBws(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBws(dAtA []byte, offset int, v uint64) int {
	offset -= sovBws(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Users) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	if m.Mid != 0 {
		n += 1 + sovBws(uint64(m.Mid))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VipUsersToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	if m.Mid != 0 {
		n += 1 + sovBws(uint64(m.Mid))
	}
	l = len(m.VipKey)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	l = len(m.BwsDate)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Point) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Fid != 0 {
		n += 1 + sovBws(uint64(m.Fid))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Unlocked != 0 {
		n += 1 + sovBws(uint64(m.Unlocked))
	}
	if m.LockType != 0 {
		n += 1 + sovBws(uint64(m.LockType))
	}
	l = len(m.Dic)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	if m.LoseUnlocked != 0 {
		n += 1 + sovBws(uint64(m.LoseUnlocked))
	}
	l = len(m.OtherIp)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Ower != 0 {
		n += 1 + sovBws(uint64(m.Ower))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Points) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Points) > 0 {
		for _, e := range m.Points {
			l = e.Size()
			n += 1 + l + sovBws(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Achievement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Dic)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.LockType != 0 {
		n += 1 + sovBws(uint64(m.LockType))
	}
	if m.Unlock != 0 {
		n += 1 + sovBws(uint64(m.Unlock))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	l = len(m.IconBig)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.IconActive)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.IconActiveBig)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Award != 0 {
		n += 1 + sovBws(uint64(m.Award))
	}
	if m.UserCount != 0 {
		n += 1 + sovBws(uint64(m.UserCount))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.SuitID != 0 {
		n += 2 + sovBws(uint64(m.SuitID))
	}
	if m.AchievePoint != 0 {
		n += 2 + sovBws(uint64(m.AchievePoint))
	}
	if m.Level != 0 {
		n += 2 + sovBws(uint64(m.Level))
	}
	if m.ExtraType != 0 {
		n += 2 + sovBws(uint64(m.ExtraType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Achievements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Achievements) > 0 {
		for _, e := range m.Achievements {
			l = e.Size()
			n += 1 + l + sovBws(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PointsLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	if m.Pid != 0 {
		n += 1 + sovBws(uint64(m.Pid))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.Level != 0 {
		n += 1 + sovBws(uint64(m.Level))
	}
	if m.Points != 0 {
		n += 1 + sovBws(uint64(m.Points))
	}
	if m.Unlock != 0 {
		n += 1 + sovBws(uint64(m.Unlock))
	}
	if m.IsDelete != 0 {
		n += 1 + sovBws(uint64(m.IsDelete))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PointsAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	if m.PlID != 0 {
		n += 1 + sovBws(uint64(m.PlID))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovBws(uint64(m.Amount))
	}
	if m.IsDelete != 0 {
		n += 1 + sovBws(uint64(m.IsDelete))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PointSign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	if m.Pid != 0 {
		n += 1 + sovBws(uint64(m.Pid))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.Stime != 0 {
		n += 1 + sovBws(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovBws(uint64(m.Etime))
	}
	if m.State != 0 {
		n += 1 + sovBws(uint64(m.State))
	}
	if m.Points != 0 {
		n += 1 + sovBws(uint64(m.Points))
	}
	if m.ProvidePoints != 0 {
		n += 1 + sovBws(uint64(m.ProvidePoints))
	}
	if m.SignPoints != 0 {
		n += 1 + sovBws(uint64(m.SignPoints))
	}
	if m.IsDelete != 0 {
		n += 1 + sovBws(uint64(m.IsDelete))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Area)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.Del != 0 {
		n += 1 + sovBws(uint64(m.Del))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActFields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ActField) > 0 {
		for _, e := range m.ActField {
			l = e.Size()
			n += 1 + l + sovBws(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Task) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Cate)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.FinishCount != 0 {
		n += 1 + sovBws(uint64(m.FinishCount))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovBws(uint64(e))
		}
		n += 1 + sovBws(uint64(l)) + l
	}
	if m.OrderNum != 0 {
		n += 1 + sovBws(uint64(m.OrderNum))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Award) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Intro)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Cate)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.IsOnline != 0 {
		n += 1 + sovBws(uint64(m.IsOnline))
	}
	if m.Owner != 0 {
		n += 1 + sovBws(uint64(m.Owner))
	}
	l = len(m.Stage)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Stock != 0 {
		n += 1 + sovBws(uint64(m.Stock))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBws(uint64(m.ID))
	}
	l = len(m.UserToken)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.AwardId != 0 {
		n += 1 + sovBws(uint64(m.AwardId))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BluetoothUpList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovBws(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BluetoothUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBws(uint64(m.Id))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	if m.Mid != 0 {
		n += 1 + sovBws(uint64(m.Mid))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatchUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovBws(uint64(m.Mid))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BluetoothUpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovBws(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBws(uint64(m.Id))
	}
	if m.Mid != 0 {
		n += 1 + sovBws(uint64(m.Mid))
	}
	if m.Bid != 0 {
		n += 1 + sovBws(uint64(m.Bid))
	}
	if m.Heart != 0 {
		n += 1 + sovBws(uint64(m.Heart))
	}
	if m.Star != 0 {
		n += 1 + sovBws(uint64(m.Star))
	}
	if m.StarInRank != 0 {
		n += 1 + sovBws(uint64(m.StarInRank))
	}
	if m.LotteryUsed != 0 {
		n += 1 + sovBws(uint64(m.LotteryUsed))
	}
	l = len(m.StarDetail)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	l = len(m.BwsDate)
	if l > 0 {
		n += 1 + l + sovBws(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBws(uint64(m.State))
	}
	if m.StarLastTime != 0 {
		n += 1 + sovBws(uint64(m.StarLastTime))
	}
	if m.Ups != 0 {
		n += 1 + sovBws(uint64(m.Ups))
	}
	if m.Ctime != 0 {
		n += 1 + sovBws(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovBws(uint64(m.Mtime))
	}
	if m.PlayTimes != 0 {
		n += 1 + sovBws(uint64(m.PlayTimes))
	}
	if m.PlaySuccessTimes != 0 {
		n += 2 + sovBws(uint64(m.PlaySuccessTimes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBws(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBws(x uint64) (n int) {
	return sovBws(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Users) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Users: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Users: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipUsersToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipUsersToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipUsersToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwsDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BwsDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlocked", wireType)
			}
			m.Unlocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unlocked |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockType", wireType)
			}
			m.LockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoseUnlocked", wireType)
			}
			m.LoseUnlocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoseUnlocked |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ower", wireType)
			}
			m.Ower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Points) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Points: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Points: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Points = append(m.Points, &Point{})
			if err := m.Points[len(m.Points)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Achievement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Achievement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Achievement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockType", wireType)
			}
			m.LockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlock", wireType)
			}
			m.Unlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconBig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconBig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconActive", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconActive = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconActiveBig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconActiveBig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			m.Award = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Award |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCount", wireType)
			}
			m.UserCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitID", wireType)
			}
			m.SuitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuitID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievePoint", wireType)
			}
			m.AchievePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AchievePoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraType", wireType)
			}
			m.ExtraType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Achievements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Achievements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Achievements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Achievements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Achievements = append(m.Achievements, &Achievement{})
			if err := m.Achievements[len(m.Achievements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			m.Points = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Points |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlock", wireType)
			}
			m.Unlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unlock |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelete", wireType)
			}
			m.IsDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDelete |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlID", wireType)
			}
			m.PlID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelete", wireType)
			}
			m.IsDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDelete |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointSign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointSign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointSign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			m.Points = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Points |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvidePoints", wireType)
			}
			m.ProvidePoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvidePoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPoints", wireType)
			}
			m.SignPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelete", wireType)
			}
			m.IsDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDelete |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Area = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Del", wireType)
			}
			m.Del = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Del |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActField", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActField = append(m.ActField, &ActField{})
			if err := m.ActField[len(m.ActField)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishCount", wireType)
			}
			m.FinishCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBws
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBws
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBws
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBws
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RuleIds) == 0 {
					m.RuleIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBws
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderNum", wireType)
			}
			m.OrderNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Award) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Award: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Award: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intro", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intro = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnline", wireType)
			}
			m.IsOnline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsOnline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stock", wireType)
			}
			m.Stock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardId", wireType)
			}
			m.AwardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AwardId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BluetoothUpList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BluetoothUpList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BluetoothUpList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &BluetoothUp{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BluetoothUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BluetoothUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BluetoothUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatchUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatchUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatchUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BluetoothUpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BluetoothUpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BluetoothUpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBws
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			m.Bid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heart", wireType)
			}
			m.Heart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Heart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarInRank", wireType)
			}
			m.StarInRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarInRank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LotteryUsed", wireType)
			}
			m.LotteryUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LotteryUsed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarDetail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StarDetail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwsDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBws
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBws
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BwsDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarLastTime", wireType)
			}
			m.StarLastTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarLastTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ups", wireType)
			}
			m.Ups = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ups |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayTimes", wireType)
			}
			m.PlayTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayTimes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaySuccessTimes", wireType)
			}
			m.PlaySuccessTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBws
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlaySuccessTimes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBws(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBws
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBws(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBws
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBws
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBws
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBws
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBws
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBws
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBws        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBws          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBws = fmt.Errorf("proto: unexpected end of group")
)
