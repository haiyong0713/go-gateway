// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// use {app_id}.{version} as package name

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DisplayType int32

const (
	DisplayType_DisplayTypeNone    DisplayType = 0
	DisplayType_DisplayTypeDegrade DisplayType = 1
	DisplayType_DisplayTypeChannel DisplayType = 2
)

var DisplayType_name = map[int32]string{
	0: "DisplayTypeNone",
	1: "DisplayTypeDegrade",
	2: "DisplayTypeChannel",
}

var DisplayType_value = map[string]int32{
	"DisplayTypeNone":    0,
	"DisplayTypeDegrade": 1,
	"DisplayTypeChannel": 2,
}

func (x DisplayType) String() string {
	return proto.EnumName(DisplayType_name, int32(x))
}

func (DisplayType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

// NoArgReq
type NoArgRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoArgRequest) Reset()         { *m = NoArgRequest{} }
func (m *NoArgRequest) String() string { return proto.CompactTextString(m) }
func (*NoArgRequest) ProtoMessage()    {}
func (*NoArgRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *NoArgRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoArgRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoArgRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoArgRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoArgRequest.Merge(m, src)
}
func (m *NoArgRequest) XXX_Size() int {
	return m.Size()
}
func (m *NoArgRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NoArgRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NoArgRequest proto.InternalMessageInfo

// NoReply
type NoReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoReply) Reset()         { *m = NoReply{} }
func (m *NoReply) String() string { return proto.CompactTextString(m) }
func (*NoReply) ProtoMessage()    {}
func (*NoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *NoReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoReply.Merge(m, src)
}
func (m *NoReply) XXX_Size() int {
	return m.Size()
}
func (m *NoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NoReply.DiscardUnknown(m)
}

var xxx_messageInfo_NoReply proto.InternalMessageInfo

type BuildLimitReq struct {
	TreeId               int64    `protobuf:"varint,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildLimitReq) Reset()         { *m = BuildLimitReq{} }
func (m *BuildLimitReq) String() string { return proto.CompactTextString(m) }
func (*BuildLimitReq) ProtoMessage()    {}
func (*BuildLimitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *BuildLimitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildLimitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildLimitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildLimitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildLimitReq.Merge(m, src)
}
func (m *BuildLimitReq) XXX_Size() int {
	return m.Size()
}
func (m *BuildLimitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildLimitReq.DiscardUnknown(m)
}

var xxx_messageInfo_BuildLimitReq proto.InternalMessageInfo

func (m *BuildLimitReq) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

type BuildLimitReply struct {
	Keys                 []*BuildLimitkeys `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BuildLimitReply) Reset()         { *m = BuildLimitReply{} }
func (m *BuildLimitReply) String() string { return proto.CompactTextString(m) }
func (*BuildLimitReply) ProtoMessage()    {}
func (*BuildLimitReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *BuildLimitReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildLimitReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildLimitReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildLimitReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildLimitReply.Merge(m, src)
}
func (m *BuildLimitReply) XXX_Size() int {
	return m.Size()
}
func (m *BuildLimitReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildLimitReply.DiscardUnknown(m)
}

var xxx_messageInfo_BuildLimitReply proto.InternalMessageInfo

func (m *BuildLimitReply) GetKeys() []*BuildLimitkeys {
	if m != nil {
		return m.Keys
	}
	return nil
}

type BuildLimitkeys struct {
	KeyName              string             `protobuf:"bytes,1,opt,name=key_name,json=keyName,proto3" json:"key_name,omitempty"`
	Plats                []*BuildLimitPlats `protobuf:"bytes,2,rep,name=plats,proto3" json:"plats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BuildLimitkeys) Reset()         { *m = BuildLimitkeys{} }
func (m *BuildLimitkeys) String() string { return proto.CompactTextString(m) }
func (*BuildLimitkeys) ProtoMessage()    {}
func (*BuildLimitkeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *BuildLimitkeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildLimitkeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildLimitkeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildLimitkeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildLimitkeys.Merge(m, src)
}
func (m *BuildLimitkeys) XXX_Size() int {
	return m.Size()
}
func (m *BuildLimitkeys) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildLimitkeys.DiscardUnknown(m)
}

var xxx_messageInfo_BuildLimitkeys proto.InternalMessageInfo

func (m *BuildLimitkeys) GetKeyName() string {
	if m != nil {
		return m.KeyName
	}
	return ""
}

func (m *BuildLimitkeys) GetPlats() []*BuildLimitPlats {
	if m != nil {
		return m.Plats
	}
	return nil
}

type BuildLimitPlats struct {
	MobiApp              string                  `protobuf:"bytes,1,opt,name=mobi_app,json=mobiApp,proto3" json:"mobi_app,omitempty"`
	Conditions           []*BuildLimitConditions `protobuf:"bytes,2,rep,name=conditions,proto3" json:"conditions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *BuildLimitPlats) Reset()         { *m = BuildLimitPlats{} }
func (m *BuildLimitPlats) String() string { return proto.CompactTextString(m) }
func (*BuildLimitPlats) ProtoMessage()    {}
func (*BuildLimitPlats) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *BuildLimitPlats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildLimitPlats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildLimitPlats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildLimitPlats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildLimitPlats.Merge(m, src)
}
func (m *BuildLimitPlats) XXX_Size() int {
	return m.Size()
}
func (m *BuildLimitPlats) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildLimitPlats.DiscardUnknown(m)
}

var xxx_messageInfo_BuildLimitPlats proto.InternalMessageInfo

func (m *BuildLimitPlats) GetMobiApp() string {
	if m != nil {
		return m.MobiApp
	}
	return ""
}

func (m *BuildLimitPlats) GetConditions() []*BuildLimitConditions {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type BuildLimitConditions struct {
	Op                   string   `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	Build                int64    `protobuf:"varint,2,opt,name=build,proto3" json:"build,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildLimitConditions) Reset()         { *m = BuildLimitConditions{} }
func (m *BuildLimitConditions) String() string { return proto.CompactTextString(m) }
func (*BuildLimitConditions) ProtoMessage()    {}
func (*BuildLimitConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *BuildLimitConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildLimitConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildLimitConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildLimitConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildLimitConditions.Merge(m, src)
}
func (m *BuildLimitConditions) XXX_Size() int {
	return m.Size()
}
func (m *BuildLimitConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildLimitConditions.DiscardUnknown(m)
}

var xxx_messageInfo_BuildLimitConditions proto.InternalMessageInfo

func (m *BuildLimitConditions) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *BuildLimitConditions) GetBuild() int64 {
	if m != nil {
		return m.Build
	}
	return 0
}

type FeatureDegradesReq struct {
	// 渠道
	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// 品牌
	Brand string `protobuf:"bytes,2,opt,name=brand,proto3" json:"brand,omitempty"`
	// 机型
	Model string `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	// 安卓版本
	SysVer int64 `protobuf:"varint,4,opt,name=sys_ver,json=sysVer,proto3" json:"sys_ver,omitempty"`
	// 版本号
	Build int64 `protobuf:"varint,5,opt,name=build,proto3" json:"build,omitempty"`
	// 降级功能
	Feature []string `protobuf:"bytes,6,rep,name=feature,proto3" json:"feature,omitempty" validate:"required"`
	// 内存大小
	Memory               int64    `protobuf:"varint,7,opt,name=memory,proto3" json:"memory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FeatureDegradesReq) Reset()         { *m = FeatureDegradesReq{} }
func (m *FeatureDegradesReq) String() string { return proto.CompactTextString(m) }
func (*FeatureDegradesReq) ProtoMessage()    {}
func (*FeatureDegradesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *FeatureDegradesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureDegradesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureDegradesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureDegradesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureDegradesReq.Merge(m, src)
}
func (m *FeatureDegradesReq) XXX_Size() int {
	return m.Size()
}
func (m *FeatureDegradesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureDegradesReq.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureDegradesReq proto.InternalMessageInfo

func (m *FeatureDegradesReq) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *FeatureDegradesReq) GetBrand() string {
	if m != nil {
		return m.Brand
	}
	return ""
}

func (m *FeatureDegradesReq) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *FeatureDegradesReq) GetSysVer() int64 {
	if m != nil {
		return m.SysVer
	}
	return 0
}

func (m *FeatureDegradesReq) GetBuild() int64 {
	if m != nil {
		return m.Build
	}
	return 0
}

func (m *FeatureDegradesReq) GetFeature() []string {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *FeatureDegradesReq) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

type FeatureDegradesReply struct {
	Items                map[string]*FeatureDegradeItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *FeatureDegradesReply) Reset()         { *m = FeatureDegradesReply{} }
func (m *FeatureDegradesReply) String() string { return proto.CompactTextString(m) }
func (*FeatureDegradesReply) ProtoMessage()    {}
func (*FeatureDegradesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *FeatureDegradesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureDegradesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureDegradesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureDegradesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureDegradesReply.Merge(m, src)
}
func (m *FeatureDegradesReply) XXX_Size() int {
	return m.Size()
}
func (m *FeatureDegradesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureDegradesReply.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureDegradesReply proto.InternalMessageInfo

func (m *FeatureDegradesReply) GetItems() map[string]*FeatureDegradeItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type FeatureDegradeItem struct {
	// 是否降级
	IsDegrade bool `protobuf:"varint,1,opt,name=is_degrade,json=isDegrade,proto3" json:"is_degrade"`
	// 放大倍数
	Enlarge float32 `protobuf:"fixed32,2,opt,name=enlarge,proto3" json:"enlarge"`
	// 日志等级
	LogLevel             int32    `protobuf:"varint,3,opt,name=logLevel,proto3" json:"log_level"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FeatureDegradeItem) Reset()         { *m = FeatureDegradeItem{} }
func (m *FeatureDegradeItem) String() string { return proto.CompactTextString(m) }
func (*FeatureDegradeItem) ProtoMessage()    {}
func (*FeatureDegradeItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *FeatureDegradeItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureDegradeItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureDegradeItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureDegradeItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureDegradeItem.Merge(m, src)
}
func (m *FeatureDegradeItem) XXX_Size() int {
	return m.Size()
}
func (m *FeatureDegradeItem) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureDegradeItem.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureDegradeItem proto.InternalMessageInfo

func (m *FeatureDegradeItem) GetIsDegrade() bool {
	if m != nil {
		return m.IsDegrade
	}
	return false
}

func (m *FeatureDegradeItem) GetEnlarge() float32 {
	if m != nil {
		return m.Enlarge
	}
	return 0
}

func (m *FeatureDegradeItem) GetLogLevel() int32 {
	if m != nil {
		return m.LogLevel
	}
	return 0
}

type ChannelFeatureReq struct {
	Channel              string   `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelFeatureReq) Reset()         { *m = ChannelFeatureReq{} }
func (m *ChannelFeatureReq) String() string { return proto.CompactTextString(m) }
func (*ChannelFeatureReq) ProtoMessage()    {}
func (*ChannelFeatureReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *ChannelFeatureReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelFeatureReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelFeatureReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelFeatureReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelFeatureReq.Merge(m, src)
}
func (m *ChannelFeatureReq) XXX_Size() int {
	return m.Size()
}
func (m *ChannelFeatureReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelFeatureReq.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelFeatureReq proto.InternalMessageInfo

func (m *ChannelFeatureReq) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

type ChannelFeatureReply struct {
	DecodeType           int64    `protobuf:"varint,1,opt,name=decode_type,json=decodeType,proto3" json:"decode_type"`
	AutoLaunch           int32    `protobuf:"varint,2,opt,name=auto_launch,json=autoLaunch,proto3" json:"auto_launch"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelFeatureReply) Reset()         { *m = ChannelFeatureReply{} }
func (m *ChannelFeatureReply) String() string { return proto.CompactTextString(m) }
func (*ChannelFeatureReply) ProtoMessage()    {}
func (*ChannelFeatureReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *ChannelFeatureReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelFeatureReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelFeatureReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelFeatureReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelFeatureReply.Merge(m, src)
}
func (m *ChannelFeatureReply) XXX_Size() int {
	return m.Size()
}
func (m *ChannelFeatureReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelFeatureReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelFeatureReply proto.InternalMessageInfo

func (m *ChannelFeatureReply) GetDecodeType() int64 {
	if m != nil {
		return m.DecodeType
	}
	return 0
}

func (m *ChannelFeatureReply) GetAutoLaunch() int32 {
	if m != nil {
		return m.AutoLaunch
	}
	return 0
}

type FeatureTVSwitchReq struct {
	// 渠道
	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// 品牌
	Brand string `protobuf:"bytes,2,opt,name=brand,proto3" json:"brand,omitempty"`
	// 机型
	Model string `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	// 安卓版本
	SysVer int64 `protobuf:"varint,4,opt,name=sys_ver,json=sysVer,proto3" json:"sys_ver,omitempty"`
	// 内存大小
	Memory int64 `protobuf:"varint,5,opt,name=memory,proto3" json:"memory,omitempty"`
	// 降级功能
	Feature              []string `protobuf:"bytes,6,rep,name=feature,proto3" json:"feature,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FeatureTVSwitchReq) Reset()         { *m = FeatureTVSwitchReq{} }
func (m *FeatureTVSwitchReq) String() string { return proto.CompactTextString(m) }
func (*FeatureTVSwitchReq) ProtoMessage()    {}
func (*FeatureTVSwitchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *FeatureTVSwitchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureTVSwitchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureTVSwitchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureTVSwitchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureTVSwitchReq.Merge(m, src)
}
func (m *FeatureTVSwitchReq) XXX_Size() int {
	return m.Size()
}
func (m *FeatureTVSwitchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureTVSwitchReq.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureTVSwitchReq proto.InternalMessageInfo

func (m *FeatureTVSwitchReq) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *FeatureTVSwitchReq) GetBrand() string {
	if m != nil {
		return m.Brand
	}
	return ""
}

func (m *FeatureTVSwitchReq) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *FeatureTVSwitchReq) GetSysVer() int64 {
	if m != nil {
		return m.SysVer
	}
	return 0
}

func (m *FeatureTVSwitchReq) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *FeatureTVSwitchReq) GetFeature() []string {
	if m != nil {
		return m.Feature
	}
	return nil
}

type FeatureTVSwitchReply struct {
	Switch               map[string]*FeatureTVSwitchItem `protobuf:"bytes,1,rep,name=switch,proto3" json:"switch,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IsHit                bool                            `protobuf:"varint,2,opt,name=is_hit,json=isHit,proto3" json:"is_hit,omitempty"`
	Id                   int64                           `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *FeatureTVSwitchReply) Reset()         { *m = FeatureTVSwitchReply{} }
func (m *FeatureTVSwitchReply) String() string { return proto.CompactTextString(m) }
func (*FeatureTVSwitchReply) ProtoMessage()    {}
func (*FeatureTVSwitchReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *FeatureTVSwitchReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureTVSwitchReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureTVSwitchReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureTVSwitchReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureTVSwitchReply.Merge(m, src)
}
func (m *FeatureTVSwitchReply) XXX_Size() int {
	return m.Size()
}
func (m *FeatureTVSwitchReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureTVSwitchReply.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureTVSwitchReply proto.InternalMessageInfo

func (m *FeatureTVSwitchReply) GetSwitch() map[string]*FeatureTVSwitchItem {
	if m != nil {
		return m.Switch
	}
	return nil
}

func (m *FeatureTVSwitchReply) GetIsHit() bool {
	if m != nil {
		return m.IsHit
	}
	return false
}

func (m *FeatureTVSwitchReply) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type FeatureTVSwitchItem struct {
	// 业务类型
	DisplayType DisplayType `protobuf:"varint,1,opt,name=display_type,json=displayType,proto3,enum=feature.service.v1.DisplayType" json:"display_type,omitempty"`
	// 是否命中极速版规则
	IsHit bool `protobuf:"varint,2,opt,name=is_hit,json=isHit,proto3" json:"is_hit,omitempty"`
	// 命中的规则ID
	HitId int64 `protobuf:"varint,3,opt,name=hit_id,json=hitId,proto3" json:"hit_id,omitempty"`
	// 返回值
	//
	// Types that are valid to be assigned to Item:
	//	*FeatureTVSwitchItem_Degrade
	//	*FeatureTVSwitchItem_Channel
	Item                 isFeatureTVSwitchItem_Item `protobuf_oneof:"item"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *FeatureTVSwitchItem) Reset()         { *m = FeatureTVSwitchItem{} }
func (m *FeatureTVSwitchItem) String() string { return proto.CompactTextString(m) }
func (*FeatureTVSwitchItem) ProtoMessage()    {}
func (*FeatureTVSwitchItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *FeatureTVSwitchItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureTVSwitchItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureTVSwitchItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureTVSwitchItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureTVSwitchItem.Merge(m, src)
}
func (m *FeatureTVSwitchItem) XXX_Size() int {
	return m.Size()
}
func (m *FeatureTVSwitchItem) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureTVSwitchItem.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureTVSwitchItem proto.InternalMessageInfo

type isFeatureTVSwitchItem_Item interface {
	isFeatureTVSwitchItem_Item()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FeatureTVSwitchItem_Degrade struct {
	Degrade *FeatureDegradeItem `protobuf:"bytes,4,opt,name=degrade,proto3,oneof" json:"degrade,omitempty"`
}
type FeatureTVSwitchItem_Channel struct {
	Channel *ChannelFeatureReply `protobuf:"bytes,5,opt,name=channel,proto3,oneof" json:"channel,omitempty"`
}

func (*FeatureTVSwitchItem_Degrade) isFeatureTVSwitchItem_Item() {}
func (*FeatureTVSwitchItem_Channel) isFeatureTVSwitchItem_Item() {}

func (m *FeatureTVSwitchItem) GetItem() isFeatureTVSwitchItem_Item {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *FeatureTVSwitchItem) GetDisplayType() DisplayType {
	if m != nil {
		return m.DisplayType
	}
	return DisplayType_DisplayTypeNone
}

func (m *FeatureTVSwitchItem) GetIsHit() bool {
	if m != nil {
		return m.IsHit
	}
	return false
}

func (m *FeatureTVSwitchItem) GetHitId() int64 {
	if m != nil {
		return m.HitId
	}
	return 0
}

func (m *FeatureTVSwitchItem) GetDegrade() *FeatureDegradeItem {
	if x, ok := m.GetItem().(*FeatureTVSwitchItem_Degrade); ok {
		return x.Degrade
	}
	return nil
}

func (m *FeatureTVSwitchItem) GetChannel() *ChannelFeatureReply {
	if x, ok := m.GetItem().(*FeatureTVSwitchItem_Channel); ok {
		return x.Channel
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FeatureTVSwitchItem) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FeatureTVSwitchItem_Degrade)(nil),
		(*FeatureTVSwitchItem_Channel)(nil),
	}
}

type BusinessConfigReq struct {
	TreeId               int64    `protobuf:"varint,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BusinessConfigReq) Reset()         { *m = BusinessConfigReq{} }
func (m *BusinessConfigReq) String() string { return proto.CompactTextString(m) }
func (*BusinessConfigReq) ProtoMessage()    {}
func (*BusinessConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *BusinessConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BusinessConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BusinessConfigReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BusinessConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BusinessConfigReq.Merge(m, src)
}
func (m *BusinessConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *BusinessConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BusinessConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_BusinessConfigReq proto.InternalMessageInfo

func (m *BusinessConfigReq) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

type BusinessConfigReply struct {
	BusinessConfigs      map[string]*BusinessConfig `protobuf:"bytes,1,rep,name=business_configs,json=businessConfigs,proto3" json:"business_configs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *BusinessConfigReply) Reset()         { *m = BusinessConfigReply{} }
func (m *BusinessConfigReply) String() string { return proto.CompactTextString(m) }
func (*BusinessConfigReply) ProtoMessage()    {}
func (*BusinessConfigReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *BusinessConfigReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BusinessConfigReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BusinessConfigReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BusinessConfigReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BusinessConfigReply.Merge(m, src)
}
func (m *BusinessConfigReply) XXX_Size() int {
	return m.Size()
}
func (m *BusinessConfigReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BusinessConfigReply.DiscardUnknown(m)
}

var xxx_messageInfo_BusinessConfigReply proto.InternalMessageInfo

func (m *BusinessConfigReply) GetBusinessConfigs() map[string]*BusinessConfig {
	if m != nil {
		return m.BusinessConfigs
	}
	return nil
}

type BusinessConfig struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TreeId               int64    `protobuf:"varint,2,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	KeyName              string   `protobuf:"bytes,3,opt,name=key_name,json=keyName,proto3" json:"key_name,omitempty"`
	Config               string   `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	Description          string   `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Relations            []int64  `protobuf:"varint,6,rep,packed,name=relations,proto3" json:"relations,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BusinessConfig) Reset()         { *m = BusinessConfig{} }
func (m *BusinessConfig) String() string { return proto.CompactTextString(m) }
func (*BusinessConfig) ProtoMessage()    {}
func (*BusinessConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *BusinessConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BusinessConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BusinessConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BusinessConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BusinessConfig.Merge(m, src)
}
func (m *BusinessConfig) XXX_Size() int {
	return m.Size()
}
func (m *BusinessConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BusinessConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BusinessConfig proto.InternalMessageInfo

func (m *BusinessConfig) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BusinessConfig) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *BusinessConfig) GetKeyName() string {
	if m != nil {
		return m.KeyName
	}
	return ""
}

func (m *BusinessConfig) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *BusinessConfig) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BusinessConfig) GetRelations() []int64 {
	if m != nil {
		return m.Relations
	}
	return nil
}

type ABTestReq struct {
	TreeId               int64    `protobuf:"varint,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ABTestReq) Reset()         { *m = ABTestReq{} }
func (m *ABTestReq) String() string { return proto.CompactTextString(m) }
func (*ABTestReq) ProtoMessage()    {}
func (*ABTestReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *ABTestReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ABTestReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ABTestReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ABTestReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ABTestReq.Merge(m, src)
}
func (m *ABTestReq) XXX_Size() int {
	return m.Size()
}
func (m *ABTestReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ABTestReq.DiscardUnknown(m)
}

var xxx_messageInfo_ABTestReq proto.InternalMessageInfo

func (m *ABTestReq) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

type ABTestReply struct {
	AbtestItems          []*ABTestItem `protobuf:"bytes,1,rep,name=abtest_items,json=abtestItems,proto3" json:"abtest_items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ABTestReply) Reset()         { *m = ABTestReply{} }
func (m *ABTestReply) String() string { return proto.CompactTextString(m) }
func (*ABTestReply) ProtoMessage()    {}
func (*ABTestReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *ABTestReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ABTestReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ABTestReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ABTestReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ABTestReply.Merge(m, src)
}
func (m *ABTestReply) XXX_Size() int {
	return m.Size()
}
func (m *ABTestReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ABTestReply.DiscardUnknown(m)
}

var xxx_messageInfo_ABTestReply proto.InternalMessageInfo

func (m *ABTestReply) GetAbtestItems() []*ABTestItem {
	if m != nil {
		return m.AbtestItems
	}
	return nil
}

type ABTestItem struct {
	// 数据ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 实验所属服务
	TreeId int64 `protobuf:"varint,2,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	// 实验key
	KeyName string `protobuf:"bytes,3,opt,name=key_name,json=keyName,proto3" json:"key_name,omitempty"`
	// 实验类型
	AbType string `protobuf:"bytes,4,opt,name=ab_type,json=abType,proto3" json:"ab_type,omitempty"`
	// 分桶数
	Bucket int32 `protobuf:"varint,5,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// 盐值
	Salt string `protobuf:"bytes,6,opt,name=salt,proto3" json:"salt,omitempty"`
	// 实验配置
	Config               []*ExpConfig `protobuf:"bytes,7,rep,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ABTestItem) Reset()         { *m = ABTestItem{} }
func (m *ABTestItem) String() string { return proto.CompactTextString(m) }
func (*ABTestItem) ProtoMessage()    {}
func (*ABTestItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *ABTestItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ABTestItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ABTestItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ABTestItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ABTestItem.Merge(m, src)
}
func (m *ABTestItem) XXX_Size() int {
	return m.Size()
}
func (m *ABTestItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ABTestItem.DiscardUnknown(m)
}

var xxx_messageInfo_ABTestItem proto.InternalMessageInfo

func (m *ABTestItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ABTestItem) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *ABTestItem) GetKeyName() string {
	if m != nil {
		return m.KeyName
	}
	return ""
}

func (m *ABTestItem) GetAbType() string {
	if m != nil {
		return m.AbType
	}
	return ""
}

func (m *ABTestItem) GetBucket() int32 {
	if m != nil {
		return m.Bucket
	}
	return 0
}

func (m *ABTestItem) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *ABTestItem) GetConfig() []*ExpConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

type ExpConfig struct {
	Group                string   `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`
	Start                int32    `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End                  int32    `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Whitelist            string   `protobuf:"bytes,4,opt,name=whitelist,proto3" json:"whitelist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpConfig) Reset()         { *m = ExpConfig{} }
func (m *ExpConfig) String() string { return proto.CompactTextString(m) }
func (*ExpConfig) ProtoMessage()    {}
func (*ExpConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *ExpConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpConfig.Merge(m, src)
}
func (m *ExpConfig) XXX_Size() int {
	return m.Size()
}
func (m *ExpConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ExpConfig proto.InternalMessageInfo

func (m *ExpConfig) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *ExpConfig) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ExpConfig) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *ExpConfig) GetWhitelist() string {
	if m != nil {
		return m.Whitelist
	}
	return ""
}

func init() {
	proto.RegisterEnum("feature.service.v1.DisplayType", DisplayType_name, DisplayType_value)
	proto.RegisterType((*NoArgRequest)(nil), "feature.service.v1.NoArgRequest")
	proto.RegisterType((*NoReply)(nil), "feature.service.v1.NoReply")
	proto.RegisterType((*BuildLimitReq)(nil), "feature.service.v1.BuildLimitReq")
	proto.RegisterType((*BuildLimitReply)(nil), "feature.service.v1.BuildLimitReply")
	proto.RegisterType((*BuildLimitkeys)(nil), "feature.service.v1.BuildLimitkeys")
	proto.RegisterType((*BuildLimitPlats)(nil), "feature.service.v1.BuildLimitPlats")
	proto.RegisterType((*BuildLimitConditions)(nil), "feature.service.v1.BuildLimitConditions")
	proto.RegisterType((*FeatureDegradesReq)(nil), "feature.service.v1.FeatureDegradesReq")
	proto.RegisterType((*FeatureDegradesReply)(nil), "feature.service.v1.FeatureDegradesReply")
	proto.RegisterMapType((map[string]*FeatureDegradeItem)(nil), "feature.service.v1.FeatureDegradesReply.ItemsEntry")
	proto.RegisterType((*FeatureDegradeItem)(nil), "feature.service.v1.FeatureDegradeItem")
	proto.RegisterType((*ChannelFeatureReq)(nil), "feature.service.v1.ChannelFeatureReq")
	proto.RegisterType((*ChannelFeatureReply)(nil), "feature.service.v1.ChannelFeatureReply")
	proto.RegisterType((*FeatureTVSwitchReq)(nil), "feature.service.v1.FeatureTVSwitchReq")
	proto.RegisterType((*FeatureTVSwitchReply)(nil), "feature.service.v1.FeatureTVSwitchReply")
	proto.RegisterMapType((map[string]*FeatureTVSwitchItem)(nil), "feature.service.v1.FeatureTVSwitchReply.SwitchEntry")
	proto.RegisterType((*FeatureTVSwitchItem)(nil), "feature.service.v1.FeatureTVSwitchItem")
	proto.RegisterType((*BusinessConfigReq)(nil), "feature.service.v1.BusinessConfigReq")
	proto.RegisterType((*BusinessConfigReply)(nil), "feature.service.v1.BusinessConfigReply")
	proto.RegisterMapType((map[string]*BusinessConfig)(nil), "feature.service.v1.BusinessConfigReply.BusinessConfigsEntry")
	proto.RegisterType((*BusinessConfig)(nil), "feature.service.v1.BusinessConfig")
	proto.RegisterType((*ABTestReq)(nil), "feature.service.v1.ABTestReq")
	proto.RegisterType((*ABTestReply)(nil), "feature.service.v1.ABTestReply")
	proto.RegisterType((*ABTestItem)(nil), "feature.service.v1.ABTestItem")
	proto.RegisterType((*ExpConfig)(nil), "feature.service.v1.ExpConfig")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1279 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xee, 0xda, 0x59, 0x3b, 0xfb, 0xdc, 0x26, 0xe9, 0xa4, 0x4d, 0x8d, 0x45, 0xe3, 0xb0, 0xa5,
	0x25, 0x20, 0xea, 0xd2, 0x14, 0x50, 0xa9, 0xca, 0x21, 0x9b, 0xb6, 0x4a, 0xa4, 0x28, 0xaa, 0x86,
	0xa8, 0x07, 0x2e, 0xee, 0xda, 0x3b, 0x59, 0x8f, 0xb2, 0xde, 0xdd, 0xec, 0xcc, 0xba, 0xec, 0x0f,
	0x41, 0xea, 0x8f, 0xe0, 0xce, 0x8d, 0x33, 0x07, 0x84, 0x38, 0x70, 0x8e, 0x50, 0x91, 0x38, 0xe4,
	0x82, 0xc4, 0x2f, 0x40, 0x33, 0xb3, 0x9b, 0x5d, 0xdb, 0x1b, 0xd7, 0x20, 0xc4, 0xc9, 0xf3, 0xbe,
	0x7d, 0x6f, 0xde, 0xbc, 0xf7, 0xbe, 0xf7, 0x66, 0x0c, 0x86, 0x1d, 0xd2, 0x4e, 0x18, 0x05, 0x3c,
	0x40, 0xe8, 0x88, 0xd8, 0x3c, 0x8e, 0x48, 0x87, 0x91, 0x68, 0x44, 0xfb, 0xa4, 0x33, 0xba, 0xdf,
	0xba, 0xeb, 0x52, 0x3e, 0x88, 0x7b, 0x9d, 0x7e, 0x30, 0xbc, 0xe7, 0x06, 0x6e, 0x70, 0x4f, 0xaa,
	0xf6, 0xe2, 0x23, 0x29, 0x49, 0x41, 0xae, 0xd4, 0x16, 0xe6, 0x12, 0x5c, 0x3e, 0x08, 0xb6, 0x23,
	0x17, 0x93, 0x93, 0x98, 0x30, 0x6e, 0x1a, 0x50, 0x3f, 0x08, 0x30, 0x09, 0xbd, 0xc4, 0xdc, 0x84,
	0x2b, 0x56, 0x4c, 0x3d, 0x67, 0x9f, 0x0e, 0x29, 0xc7, 0xe4, 0x04, 0xdd, 0x80, 0x3a, 0x8f, 0x08,
	0xe9, 0x52, 0xa7, 0xa9, 0x6d, 0x68, 0x9b, 0x55, 0x5c, 0x13, 0xe2, 0x9e, 0x63, 0xee, 0xc1, 0x72,
	0x51, 0x33, 0xf4, 0x12, 0xf4, 0x39, 0x2c, 0x1c, 0x93, 0x84, 0x35, 0x2b, 0x1b, 0xd5, 0xcd, 0xc6,
	0x96, 0xd9, 0x99, 0x3e, 0x69, 0x27, 0x37, 0x11, 0x9a, 0x58, 0xea, 0x9b, 0x47, 0xb0, 0x34, 0x8e,
	0xa3, 0x77, 0x60, 0xf1, 0x98, 0x24, 0x5d, 0xdf, 0x1e, 0x12, 0xe9, 0xd6, 0xc0, 0xf5, 0x63, 0x92,
	0x1c, 0xd8, 0x43, 0x82, 0xbe, 0x00, 0x3d, 0xf4, 0x6c, 0x9e, 0x79, 0xb9, 0x35, 0xdb, 0xcb, 0x73,
	0xa1, 0x8a, 0x95, 0x85, 0x39, 0x2a, 0x1e, 0x59, 0x7e, 0x11, 0x8e, 0x86, 0x41, 0x8f, 0x76, 0xed,
	0x30, 0xcc, 0x1c, 0x09, 0x79, 0x3b, 0x0c, 0xd1, 0x2e, 0x40, 0x3f, 0xf0, 0x1d, 0xca, 0x69, 0xe0,
	0x67, 0xde, 0x36, 0x67, 0x7b, 0xdb, 0x39, 0xd7, 0xc7, 0x05, 0x5b, 0xf3, 0x31, 0x5c, 0x2b, 0xd3,
	0x41, 0x4b, 0x50, 0x09, 0x32, 0xb7, 0x95, 0x20, 0x44, 0xd7, 0x40, 0xef, 0x09, 0xbd, 0x66, 0x45,
	0x66, 0x5a, 0x09, 0xe6, 0xaf, 0x1a, 0xa0, 0x67, 0xca, 0xeb, 0x13, 0xe2, 0x46, 0xb6, 0x43, 0x98,
	0x28, 0x4c, 0x13, 0xea, 0xfd, 0x81, 0xed, 0xfb, 0xc4, 0xcb, 0x0e, 0x9e, 0x8a, 0x72, 0x9b, 0xc8,
	0xf6, 0xd5, 0x36, 0x06, 0x56, 0x82, 0x40, 0x87, 0x81, 0x43, 0xbc, 0x66, 0x55, 0xa1, 0x52, 0x10,
	0xe5, 0x65, 0x09, 0xeb, 0x8e, 0x48, 0xd4, 0x5c, 0x50, 0xe5, 0x65, 0x09, 0x7b, 0x41, 0xa2, 0xfc,
	0x2c, 0x7a, 0xe1, 0x2c, 0xe8, 0x3e, 0xd4, 0xd3, 0x04, 0x34, 0x6b, 0x1b, 0xd5, 0x4d, 0xc3, 0xba,
	0xf1, 0xd7, 0x69, 0x7b, 0x75, 0x64, 0x7b, 0xd4, 0xb1, 0x39, 0x79, 0x64, 0x46, 0xe4, 0x24, 0xa6,
	0x11, 0x71, 0x4c, 0x9c, 0xe9, 0xa1, 0x35, 0xa8, 0x0d, 0xc9, 0x30, 0x88, 0x92, 0x66, 0x5d, 0x39,
	0x50, 0x92, 0xf9, 0xb3, 0x06, 0xd7, 0xa6, 0xc2, 0x12, 0x2c, 0x3a, 0x04, 0x9d, 0x72, 0x32, 0x64,
	0x4d, 0x4d, 0xa6, 0xfc, 0x41, 0x59, 0xca, 0xcb, 0x0c, 0x3b, 0x7b, 0xc2, 0xea, 0xa9, 0xcf, 0xa3,
	0xc4, 0x32, 0xce, 0x4e, 0xdb, 0x6a, 0x17, 0xac, 0x7e, 0x5a, 0x2f, 0x01, 0xf2, 0xef, 0x68, 0x05,
	0xaa, 0xc7, 0x24, 0x49, 0x13, 0x27, 0x96, 0xe8, 0x31, 0xe8, 0x23, 0xdb, 0x8b, 0x89, 0x4c, 0x5a,
	0x63, 0xeb, 0xce, 0xdb, 0xbd, 0x8a, 0xed, 0xb0, 0x32, 0x7a, 0x54, 0x79, 0xa8, 0x99, 0xdf, 0x4e,
	0xd5, 0x49, 0x68, 0xa0, 0xbb, 0x00, 0x94, 0x75, 0x1d, 0x85, 0x48, 0x8f, 0x8b, 0xd6, 0xd2, 0xd9,
	0x69, 0xbb, 0x80, 0x62, 0x83, 0xb2, 0xd4, 0x04, 0xdd, 0x86, 0x3a, 0xf1, 0x3d, 0x3b, 0x72, 0xd5,
	0x49, 0x2a, 0x56, 0xe3, 0xec, 0xb4, 0x9d, 0x41, 0x38, 0x5b, 0xa0, 0x0f, 0x61, 0xd1, 0x0b, 0xdc,
	0x7d, 0x32, 0x4a, 0x0b, 0xaa, 0x5b, 0x57, 0xce, 0x4e, 0xdb, 0x86, 0x17, 0xb8, 0x5d, 0x4f, 0x80,
	0xf8, 0xfc, 0xb3, 0xf9, 0x0c, 0xae, 0xee, 0x28, 0x66, 0xa4, 0xa7, 0x13, 0xec, 0xb9, 0x3f, 0xc1,
	0x9e, 0x19, 0x85, 0x4c, 0xf5, 0xcc, 0x04, 0x56, 0x27, 0xf7, 0x11, 0xe5, 0xfa, 0x04, 0x1a, 0x0e,
	0xe9, 0x07, 0x0e, 0xe9, 0xf2, 0x24, 0x54, 0x01, 0x56, 0xad, 0xe5, 0xb3, 0xd3, 0x76, 0x11, 0xc6,
	0xa0, 0x84, 0xc3, 0x24, 0x24, 0xc2, 0xc2, 0x8e, 0x79, 0xd0, 0xf5, 0xec, 0xd8, 0xef, 0x0f, 0x64,
	0x98, 0xba, 0xb2, 0x28, 0xc0, 0x18, 0x84, 0xb0, 0x2f, 0xd7, 0xe6, 0x0f, 0x79, 0x6a, 0x0f, 0x5f,
	0x7c, 0xf5, 0x8a, 0xf2, 0xfe, 0xe0, 0x7f, 0x68, 0x81, 0x9c, 0xb9, 0x7a, 0x91, 0xb9, 0xff, 0xa2,
	0x09, 0xcc, 0x3f, 0x73, 0xb2, 0xe7, 0x01, 0x88, 0xec, 0xed, 0x43, 0x8d, 0x49, 0x31, 0x65, 0xfb,
	0xa7, 0x33, 0x78, 0x37, 0x66, 0xd9, 0x51, 0x6b, 0x49, 0x67, 0x9c, 0xee, 0x81, 0xae, 0x43, 0x8d,
	0xb2, 0xee, 0x80, 0x72, 0x19, 0xf7, 0x22, 0xd6, 0x29, 0xdb, 0xa5, 0x5c, 0xcc, 0x19, 0xea, 0xc8,
	0xa0, 0xab, 0xb8, 0x42, 0x9d, 0x56, 0x0f, 0x1a, 0x05, 0xeb, 0x92, 0x66, 0xf8, 0x72, 0xbc, 0x19,
	0x3e, 0x98, 0xe3, 0x50, 0x93, 0xdd, 0xf0, 0xba, 0x02, 0xab, 0x25, 0x2a, 0xc8, 0x82, 0xcb, 0x0e,
	0x65, 0xa1, 0x67, 0x27, 0x39, 0x5f, 0x96, 0xb6, 0xda, 0x65, 0x1e, 0x9e, 0x28, 0x3d, 0xc1, 0x19,
	0xdc, 0x70, 0x72, 0xe1, 0xa2, 0x30, 0xaf, 0x43, 0x6d, 0x40, 0x79, 0xf7, 0x3c, 0x54, 0x7d, 0x40,
	0xf9, 0x9e, 0x83, 0x2c, 0xa8, 0x67, 0xdd, 0xb7, 0xf0, 0x4f, 0x7a, 0x7b, 0xf7, 0x12, 0xce, 0x0c,
	0xd1, 0x4e, 0xce, 0x34, 0xfd, 0xe2, 0x94, 0x94, 0xb4, 0x87, 0xd8, 0x24, 0xb5, 0xb4, 0x6a, 0xb0,
	0x20, 0x66, 0x91, 0xf9, 0x31, 0x5c, 0xb5, 0x62, 0x46, 0x7d, 0xc2, 0xd8, 0x4e, 0xe0, 0x1f, 0x51,
	0x77, 0xe6, 0x3d, 0xfb, 0x87, 0x06, 0xab, 0x93, 0xea, 0x82, 0x39, 0x2e, 0xac, 0xf4, 0x52, 0xb8,
	0xdb, 0x97, 0x78, 0x36, 0x31, 0x1f, 0x97, 0x5f, 0x52, 0x53, 0x5b, 0x4c, 0x60, 0x6a, 0x34, 0xe2,
	0xe5, 0xde, 0x38, 0xda, 0x3a, 0x12, 0xb7, 0xd7, 0xb4, 0x62, 0x09, 0x6d, 0x1e, 0x8e, 0xd3, 0xc6,
	0x9c, 0xe3, 0x1c, 0x05, 0xc6, 0x7c, 0xa7, 0x89, 0x67, 0x40, 0xf1, 0x6b, 0x4a, 0x5c, 0x2d, 0x23,
	0x6e, 0x31, 0x49, 0x95, 0x62, 0x92, 0xc6, 0xde, 0x0b, 0xd5, 0xf1, 0xf7, 0xc2, 0x1a, 0xd4, 0x54,
	0x7a, 0x64, 0xf5, 0x0d, 0x9c, 0x4a, 0x68, 0x43, 0xcc, 0x2d, 0xd6, 0x8f, 0x68, 0x28, 0x2e, 0x63,
	0x59, 0x56, 0x03, 0x17, 0x21, 0xf4, 0x2e, 0x18, 0x11, 0xf1, 0x6c, 0x75, 0xff, 0x8b, 0x4e, 0xaf,
	0xe2, 0x1c, 0x30, 0xdf, 0x07, 0x63, 0xdb, 0x3a, 0x24, 0x6c, 0xf6, 0x2b, 0xe9, 0x39, 0x34, 0x32,
	0x2d, 0x51, 0xb4, 0x6d, 0xb8, 0x6c, 0xf7, 0x38, 0x61, 0xbc, 0x5b, 0xbc, 0xe2, 0xd6, 0xcb, 0x12,
	0xa5, 0xcc, 0x64, 0x5b, 0x35, 0x94, 0x8d, 0xbc, 0xbf, 0xcc, 0x9f, 0x34, 0x80, 0xfc, 0xdb, 0x7f,
	0x92, 0xa2, 0x1b, 0x50, 0xb7, 0x7b, 0xaa, 0x1d, 0xd3, 0x1c, 0xd9, 0x3d, 0xd9, 0x68, 0x6b, 0x50,
	0xeb, 0xc5, 0xfd, 0x63, 0xc2, 0x65, 0x7a, 0x74, 0x9c, 0x4a, 0x08, 0xc1, 0x02, 0xb3, 0x3d, 0xde,
	0xac, 0x49, 0x6d, 0xb9, 0x46, 0x9f, 0x9d, 0xe7, 0xb9, 0x2e, 0x83, 0xba, 0x59, 0x16, 0xd4, 0xd3,
	0x6f, 0xc2, 0xb4, 0xf0, 0xa9, 0xb2, 0xe9, 0x82, 0x71, 0x0e, 0x8a, 0x01, 0xed, 0x46, 0x41, 0x9c,
	0xbd, 0x89, 0x94, 0x20, 0x50, 0xc6, 0xed, 0x48, 0x75, 0xbb, 0x8e, 0x95, 0x20, 0xe8, 0x47, 0x7c,
	0xd5, 0xea, 0x3a, 0x16, 0x4b, 0x51, 0xaf, 0x57, 0x03, 0xca, 0x89, 0x47, 0x19, 0x4f, 0x03, 0xc9,
	0x81, 0x8f, 0x30, 0x34, 0x0a, 0x03, 0x05, 0xad, 0xc2, 0x72, 0x41, 0x3c, 0x08, 0x7c, 0xb2, 0x72,
	0x09, 0xad, 0x01, 0x2a, 0x80, 0xe9, 0x2c, 0x58, 0xd1, 0x26, 0xf0, 0xb4, 0xcd, 0x57, 0x2a, 0x5b,
	0xdf, 0x2f, 0x40, 0x3d, 0xed, 0x76, 0x74, 0x08, 0x90, 0x3f, 0xf2, 0xd0, 0x7b, 0xb3, 0x1f, 0x8a,
	0x98, 0x9c, 0xb4, 0x6e, 0xbd, 0x4d, 0x45, 0x10, 0xa6, 0x0f, 0xcb, 0x13, 0x6f, 0x1d, 0x74, 0x67,
	0xae, 0x07, 0xd1, 0x49, 0x6b, 0x73, 0xde, 0x87, 0x13, 0x7a, 0x09, 0x4b, 0xe3, 0xa3, 0x0b, 0xdd,
	0x9e, 0x67, 0xbc, 0x9d, 0xb4, 0xe6, 0x9d, 0x82, 0x85, 0x30, 0xb2, 0xcb, 0x60, 0x66, 0x18, 0x85,
	0x4b, 0x7e, 0x66, 0x18, 0xe3, 0x77, 0xe9, 0xcb, 0xa9, 0xf9, 0x71, 0x7b, 0x9e, 0x49, 0x78, 0x41,
	0x18, 0x65, 0x33, 0x77, 0x17, 0x6a, 0xaa, 0xf5, 0xd0, 0xcd, 0x8b, 0x5b, 0x56, 0xec, 0xd8, 0x9e,
	0xf5, 0x39, 0xf4, 0x12, 0xeb, 0xfa, 0x8f, 0x6f, 0xd6, 0xb5, 0x5f, 0xde, 0xac, 0x6b, 0xbf, 0xbd,
	0x59, 0xd7, 0x5e, 0xff, 0xbe, 0x7e, 0xe9, 0xeb, 0xaa, 0x1d, 0xd2, 0x5e, 0x4d, 0xfe, 0x41, 0x7b,
	0xf0, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4d, 0xf0, 0x64, 0x7c, 0xf0, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FeatureClient is the client API for Feature service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FeatureClient interface {
	// BuildLimit 获取treeID对应版本控制
	BuildLimit(ctx context.Context, in *BuildLimitReq, opts ...grpc.CallOption) (*BuildLimitReply, error)
	// FeatureDegrades ott交互开关(部分)
	FeatureDegrades(ctx context.Context, in *FeatureDegradesReq, opts ...grpc.CallOption) (*FeatureDegradesReply, error)
	// ChannelFeature ott交互开关(部分)
	ChannelFeature(ctx context.Context, in *ChannelFeatureReq, opts ...grpc.CallOption) (*ChannelFeatureReply, error)
	// FeatureTVSwitch ott极速版交互开关
	FeatureTVSwitch(ctx context.Context, in *FeatureTVSwitchReq, opts ...grpc.CallOption) (*FeatureTVSwitchReply, error)
	// BusinessConfig 业务配置下发
	BusinessConfig(ctx context.Context, in *BusinessConfigReq, opts ...grpc.CallOption) (*BusinessConfigReply, error)
	// ABTest 获取treeID对应分组实验
	ABTest(ctx context.Context, in *ABTestReq, opts ...grpc.CallOption) (*ABTestReply, error)
}

type featureClient struct {
	cc *grpc.ClientConn
}

func NewFeatureClient(cc *grpc.ClientConn) FeatureClient {
	return &featureClient{cc}
}

func (c *featureClient) BuildLimit(ctx context.Context, in *BuildLimitReq, opts ...grpc.CallOption) (*BuildLimitReply, error) {
	out := new(BuildLimitReply)
	err := c.cc.Invoke(ctx, "/feature.service.v1.Feature/BuildLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureClient) FeatureDegrades(ctx context.Context, in *FeatureDegradesReq, opts ...grpc.CallOption) (*FeatureDegradesReply, error) {
	out := new(FeatureDegradesReply)
	err := c.cc.Invoke(ctx, "/feature.service.v1.Feature/FeatureDegrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureClient) ChannelFeature(ctx context.Context, in *ChannelFeatureReq, opts ...grpc.CallOption) (*ChannelFeatureReply, error) {
	out := new(ChannelFeatureReply)
	err := c.cc.Invoke(ctx, "/feature.service.v1.Feature/ChannelFeature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureClient) FeatureTVSwitch(ctx context.Context, in *FeatureTVSwitchReq, opts ...grpc.CallOption) (*FeatureTVSwitchReply, error) {
	out := new(FeatureTVSwitchReply)
	err := c.cc.Invoke(ctx, "/feature.service.v1.Feature/FeatureTVSwitch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureClient) BusinessConfig(ctx context.Context, in *BusinessConfigReq, opts ...grpc.CallOption) (*BusinessConfigReply, error) {
	out := new(BusinessConfigReply)
	err := c.cc.Invoke(ctx, "/feature.service.v1.Feature/BusinessConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureClient) ABTest(ctx context.Context, in *ABTestReq, opts ...grpc.CallOption) (*ABTestReply, error) {
	out := new(ABTestReply)
	err := c.cc.Invoke(ctx, "/feature.service.v1.Feature/ABTest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeatureServer is the server API for Feature service.
type FeatureServer interface {
	// BuildLimit 获取treeID对应版本控制
	BuildLimit(context.Context, *BuildLimitReq) (*BuildLimitReply, error)
	// FeatureDegrades ott交互开关(部分)
	FeatureDegrades(context.Context, *FeatureDegradesReq) (*FeatureDegradesReply, error)
	// ChannelFeature ott交互开关(部分)
	ChannelFeature(context.Context, *ChannelFeatureReq) (*ChannelFeatureReply, error)
	// FeatureTVSwitch ott极速版交互开关
	FeatureTVSwitch(context.Context, *FeatureTVSwitchReq) (*FeatureTVSwitchReply, error)
	// BusinessConfig 业务配置下发
	BusinessConfig(context.Context, *BusinessConfigReq) (*BusinessConfigReply, error)
	// ABTest 获取treeID对应分组实验
	ABTest(context.Context, *ABTestReq) (*ABTestReply, error)
}

// UnimplementedFeatureServer can be embedded to have forward compatible implementations.
type UnimplementedFeatureServer struct {
}

func (*UnimplementedFeatureServer) BuildLimit(ctx context.Context, req *BuildLimitReq) (*BuildLimitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildLimit not implemented")
}
func (*UnimplementedFeatureServer) FeatureDegrades(ctx context.Context, req *FeatureDegradesReq) (*FeatureDegradesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeatureDegrades not implemented")
}
func (*UnimplementedFeatureServer) ChannelFeature(ctx context.Context, req *ChannelFeatureReq) (*ChannelFeatureReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelFeature not implemented")
}
func (*UnimplementedFeatureServer) FeatureTVSwitch(ctx context.Context, req *FeatureTVSwitchReq) (*FeatureTVSwitchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeatureTVSwitch not implemented")
}
func (*UnimplementedFeatureServer) BusinessConfig(ctx context.Context, req *BusinessConfigReq) (*BusinessConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BusinessConfig not implemented")
}
func (*UnimplementedFeatureServer) ABTest(ctx context.Context, req *ABTestReq) (*ABTestReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ABTest not implemented")
}

func RegisterFeatureServer(s *grpc.Server, srv FeatureServer) {
	s.RegisterService(&_Feature_serviceDesc, srv)
}

func _Feature_BuildLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildLimitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServer).BuildLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/feature.service.v1.Feature/BuildLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServer).BuildLimit(ctx, req.(*BuildLimitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feature_FeatureDegrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeatureDegradesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServer).FeatureDegrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/feature.service.v1.Feature/FeatureDegrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServer).FeatureDegrades(ctx, req.(*FeatureDegradesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feature_ChannelFeature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelFeatureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServer).ChannelFeature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/feature.service.v1.Feature/ChannelFeature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServer).ChannelFeature(ctx, req.(*ChannelFeatureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feature_FeatureTVSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeatureTVSwitchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServer).FeatureTVSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/feature.service.v1.Feature/FeatureTVSwitch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServer).FeatureTVSwitch(ctx, req.(*FeatureTVSwitchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feature_BusinessConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BusinessConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServer).BusinessConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/feature.service.v1.Feature/BusinessConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServer).BusinessConfig(ctx, req.(*BusinessConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feature_ABTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ABTestReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServer).ABTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/feature.service.v1.Feature/ABTest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServer).ABTest(ctx, req.(*ABTestReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Feature_serviceDesc = grpc.ServiceDesc{
	ServiceName: "feature.service.v1.Feature",
	HandlerType: (*FeatureServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BuildLimit",
			Handler:    _Feature_BuildLimit_Handler,
		},
		{
			MethodName: "FeatureDegrades",
			Handler:    _Feature_FeatureDegrades_Handler,
		},
		{
			MethodName: "ChannelFeature",
			Handler:    _Feature_ChannelFeature_Handler,
		},
		{
			MethodName: "FeatureTVSwitch",
			Handler:    _Feature_FeatureTVSwitch_Handler,
		},
		{
			MethodName: "BusinessConfig",
			Handler:    _Feature_BusinessConfig_Handler,
		},
		{
			MethodName: "ABTest",
			Handler:    _Feature_ABTest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *NoArgRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoArgRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoArgRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BuildLimitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildLimitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildLimitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TreeId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TreeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuildLimitReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildLimitReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildLimitReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *BuildLimitkeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildLimitkeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildLimitkeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plats) > 0 {
		for iNdEx := len(m.Plats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Plats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.KeyName) > 0 {
		i -= len(m.KeyName)
		copy(dAtA[i:], m.KeyName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.KeyName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildLimitPlats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildLimitPlats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildLimitPlats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MobiApp) > 0 {
		i -= len(m.MobiApp)
		copy(dAtA[i:], m.MobiApp)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MobiApp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildLimitConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildLimitConditions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildLimitConditions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Build != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeatureDegradesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureDegradesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureDegradesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Memory != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Feature) > 0 {
		for iNdEx := len(m.Feature) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Feature[iNdEx])
			copy(dAtA[i:], m.Feature[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Feature[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Build != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x28
	}
	if m.SysVer != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SysVer))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Brand) > 0 {
		i -= len(m.Brand)
		copy(dAtA[i:], m.Brand)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Brand)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeatureDegradesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureDegradesReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureDegradesReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FeatureDegradeItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureDegradeItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureDegradeItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogLevel != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LogLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.Enlarge != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Enlarge))))
		i--
		dAtA[i] = 0x15
	}
	if m.IsDegrade {
		i--
		if m.IsDegrade {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChannelFeatureReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelFeatureReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelFeatureReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChannelFeatureReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelFeatureReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelFeatureReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AutoLaunch != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AutoLaunch))
		i--
		dAtA[i] = 0x10
	}
	if m.DecodeType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DecodeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeatureTVSwitchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureTVSwitchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureTVSwitchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Feature) > 0 {
		for iNdEx := len(m.Feature) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Feature[iNdEx])
			copy(dAtA[i:], m.Feature[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Feature[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Memory != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x28
	}
	if m.SysVer != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SysVer))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Brand) > 0 {
		i -= len(m.Brand)
		copy(dAtA[i:], m.Brand)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Brand)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeatureTVSwitchReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureTVSwitchReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureTVSwitchReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.IsHit {
		i--
		if m.IsHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Switch) > 0 {
		for k := range m.Switch {
			v := m.Switch[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FeatureTVSwitchItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureTVSwitchItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureTVSwitchItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size := m.Item.Size()
			i -= size
			if _, err := m.Item.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.HitId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.HitId))
		i--
		dAtA[i] = 0x18
	}
	if m.IsHit {
		i--
		if m.IsHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.DisplayType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DisplayType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeatureTVSwitchItem_Degrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureTVSwitchItem_Degrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Degrade != nil {
		{
			size, err := m.Degrade.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *FeatureTVSwitchItem_Channel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureTVSwitchItem_Channel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *BusinessConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BusinessConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BusinessConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TreeId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TreeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BusinessConfigReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BusinessConfigReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BusinessConfigReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BusinessConfigs) > 0 {
		for k := range m.BusinessConfigs {
			v := m.BusinessConfigs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BusinessConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BusinessConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BusinessConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Relations) > 0 {
		dAtA7 := make([]byte, len(m.Relations)*10)
		var j6 int
		for _, num1 := range m.Relations {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintApi(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyName) > 0 {
		i -= len(m.KeyName)
		copy(dAtA[i:], m.KeyName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.KeyName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TreeId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TreeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ABTestReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ABTestReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ABTestReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TreeId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TreeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ABTestReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ABTestReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ABTestReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AbtestItems) > 0 {
		for iNdEx := len(m.AbtestItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AbtestItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ABTestItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ABTestItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ABTestItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		for iNdEx := len(m.Config) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Config[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x32
	}
	if m.Bucket != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Bucket))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AbType) > 0 {
		i -= len(m.AbType)
		copy(dAtA[i:], m.AbType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AbType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyName) > 0 {
		i -= len(m.KeyName)
		copy(dAtA[i:], m.KeyName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.KeyName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TreeId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TreeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExpConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExpConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Whitelist) > 0 {
		i -= len(m.Whitelist)
		copy(dAtA[i:], m.Whitelist)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Whitelist)))
		i--
		dAtA[i] = 0x22
	}
	if m.End != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NoArgRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildLimitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TreeId != 0 {
		n += 1 + sovApi(uint64(m.TreeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildLimitReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildLimitkeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Plats) > 0 {
		for _, e := range m.Plats {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildLimitPlats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MobiApp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildLimitConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeatureDegradesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Brand)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SysVer != 0 {
		n += 1 + sovApi(uint64(m.SysVer))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if len(m.Feature) > 0 {
		for _, s := range m.Feature {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeatureDegradesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeatureDegradeItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsDegrade {
		n += 2
	}
	if m.Enlarge != 0 {
		n += 5
	}
	if m.LogLevel != 0 {
		n += 1 + sovApi(uint64(m.LogLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChannelFeatureReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChannelFeatureReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DecodeType != 0 {
		n += 1 + sovApi(uint64(m.DecodeType))
	}
	if m.AutoLaunch != 0 {
		n += 1 + sovApi(uint64(m.AutoLaunch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeatureTVSwitchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Brand)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SysVer != 0 {
		n += 1 + sovApi(uint64(m.SysVer))
	}
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if len(m.Feature) > 0 {
		for _, s := range m.Feature {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeatureTVSwitchReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Switch) > 0 {
		for k, v := range m.Switch {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.IsHit {
		n += 2
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeatureTVSwitchItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisplayType != 0 {
		n += 1 + sovApi(uint64(m.DisplayType))
	}
	if m.IsHit {
		n += 2
	}
	if m.HitId != 0 {
		n += 1 + sovApi(uint64(m.HitId))
	}
	if m.Item != nil {
		n += m.Item.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeatureTVSwitchItem_Degrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Degrade != nil {
		l = m.Degrade.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *FeatureTVSwitchItem_Channel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *BusinessConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TreeId != 0 {
		n += 1 + sovApi(uint64(m.TreeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BusinessConfigReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BusinessConfigs) > 0 {
		for k, v := range m.BusinessConfigs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BusinessConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.TreeId != 0 {
		n += 1 + sovApi(uint64(m.TreeId))
	}
	l = len(m.KeyName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Relations) > 0 {
		l = 0
		for _, e := range m.Relations {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ABTestReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TreeId != 0 {
		n += 1 + sovApi(uint64(m.TreeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ABTestReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AbtestItems) > 0 {
		for _, e := range m.AbtestItems {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ABTestItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.TreeId != 0 {
		n += 1 + sovApi(uint64(m.TreeId))
	}
	l = len(m.KeyName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AbType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Bucket != 0 {
		n += 1 + sovApi(uint64(m.Bucket))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExpConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovApi(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovApi(uint64(m.End))
	}
	l = len(m.Whitelist)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NoArgRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoArgRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoArgRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildLimitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildLimitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildLimitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildLimitReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildLimitReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildLimitReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &BuildLimitkeys{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildLimitkeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildLimitkeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildLimitkeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plats = append(m.Plats, &BuildLimitPlats{})
			if err := m.Plats[len(m.Plats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildLimitPlats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildLimitPlats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildLimitPlats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobiApp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MobiApp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &BuildLimitConditions{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildLimitConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildLimitConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildLimitConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureDegradesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureDegradesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureDegradesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysVer", wireType)
			}
			m.SysVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SysVer |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feature = append(m.Feature, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureDegradesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureDegradesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureDegradesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[string]*FeatureDegradeItem)
			}
			var mapkey string
			var mapvalue *FeatureDegradeItem
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FeatureDegradeItem{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureDegradeItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureDegradeItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureDegradeItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDegrade", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDegrade = bool(v != 0)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enlarge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Enlarge = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			m.LogLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelFeatureReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelFeatureReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelFeatureReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelFeatureReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelFeatureReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelFeatureReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecodeType", wireType)
			}
			m.DecodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecodeType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoLaunch", wireType)
			}
			m.AutoLaunch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoLaunch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureTVSwitchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureTVSwitchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureTVSwitchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysVer", wireType)
			}
			m.SysVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SysVer |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feature = append(m.Feature, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureTVSwitchReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureTVSwitchReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureTVSwitchReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Switch == nil {
				m.Switch = make(map[string]*FeatureTVSwitchItem)
			}
			var mapkey string
			var mapvalue *FeatureTVSwitchItem
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FeatureTVSwitchItem{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Switch[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureTVSwitchItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureTVSwitchItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureTVSwitchItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayType", wireType)
			}
			m.DisplayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisplayType |= DisplayType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitId", wireType)
			}
			m.HitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HitId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Degrade", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FeatureDegradeItem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Item = &FeatureTVSwitchItem_Degrade{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChannelFeatureReply{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Item = &FeatureTVSwitchItem_Channel{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BusinessConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BusinessConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BusinessConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BusinessConfigReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BusinessConfigReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BusinessConfigReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BusinessConfigs == nil {
				m.BusinessConfigs = make(map[string]*BusinessConfig)
			}
			var mapkey string
			var mapvalue *BusinessConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BusinessConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BusinessConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BusinessConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BusinessConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BusinessConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Relations = append(m.Relations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Relations) == 0 {
					m.Relations = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Relations = append(m.Relations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ABTestReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ABTestReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ABTestReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ABTestReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ABTestReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ABTestReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbtestItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbtestItems = append(m.AbtestItems, &ABTestItem{})
			if err := m.AbtestItems[len(m.AbtestItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ABTestItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ABTestItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ABTestItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			m.Bucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bucket |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &ExpConfig{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Whitelist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Whitelist = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
