// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-gateway/app/app-svr/fawkes/service/api/app/tribe/tribe.proto

package tribe

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Sort int32

const (
	Sort_DESC Sort = 0
	Sort_ASC  Sort = 1
)

var Sort_name = map[int32]string{
	0: "DESC",
	1: "ASC",
}

var Sort_value = map[string]int32{
	"DESC": 0,
	"ASC":  1,
}

func (x Sort) String() string {
	return proto.EnumName(Sort_name, int32(x))
}

func (Sort) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{0}
}

type CallbackStatus int32

const (
	CallbackStatus_Success CallbackStatus = 0
	CallbackStatus_Failed  CallbackStatus = -1
)

var CallbackStatus_name = map[int32]string{
	0:  "Success",
	-1: "Failed",
}

var CallbackStatus_value = map[string]int32{
	"Success": 0,
	"Failed":  -1,
}

func (x CallbackStatus) String() string {
	return proto.EnumName(CallbackStatus_name, int32(x))
}

func (CallbackStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{1}
}

type UpgradeType int32

const (
	UpgradeType_Custom UpgradeType = 0
	UpgradeType_All    UpgradeType = 1
	UpgradeType_Test   UpgradeType = 2
)

var UpgradeType_name = map[int32]string{
	0: "Custom",
	1: "All",
	2: "Test",
}

var UpgradeType_value = map[string]int32{
	"Custom": 0,
	"All":    1,
	"Test":   2,
}

func (x UpgradeType) String() string {
	return proto.EnumName(UpgradeType_name, int32(x))
}

func (UpgradeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{2}
}

type ListTribeBuildPackReq_GitType int32

const (
	ListTribeBuildPackReq_BRANCH ListTribeBuildPackReq_GitType = 0
	ListTribeBuildPackReq_TAG    ListTribeBuildPackReq_GitType = 1
	ListTribeBuildPackReq_COMMIT ListTribeBuildPackReq_GitType = 2
)

var ListTribeBuildPackReq_GitType_name = map[int32]string{
	0: "BRANCH",
	1: "TAG",
	2: "COMMIT",
}

var ListTribeBuildPackReq_GitType_value = map[string]int32{
	"BRANCH": 0,
	"TAG":    1,
	"COMMIT": 2,
}

func (x ListTribeBuildPackReq_GitType) String() string {
	return proto.EnumName(ListTribeBuildPackReq_GitType_name, int32(x))
}

func (ListTribeBuildPackReq_GitType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{15, 0}
}

type ListTribeBuildPackReq_OrderBy int32

const (
	ListTribeBuildPackReq_CTIME ListTribeBuildPackReq_OrderBy = 0
	ListTribeBuildPackReq_ID    ListTribeBuildPackReq_OrderBy = 1
)

var ListTribeBuildPackReq_OrderBy_name = map[int32]string{
	0: "CTIME",
	1: "ID",
}

var ListTribeBuildPackReq_OrderBy_value = map[string]int32{
	"CTIME": 0,
	"ID":    1,
}

func (x ListTribeBuildPackReq_OrderBy) String() string {
	return proto.EnumName(ListTribeBuildPackReq_OrderBy_name, int32(x))
}

func (ListTribeBuildPackReq_OrderBy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{15, 1}
}

type GetPackRelationsReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key" validate:"required"`
	Feature              string   `protobuf:"bytes,2,opt,name=feature,proto3" json:"feature" form:"feature"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPackRelationsReq) Reset()         { *m = GetPackRelationsReq{} }
func (m *GetPackRelationsReq) String() string { return proto.CompactTextString(m) }
func (*GetPackRelationsReq) ProtoMessage()    {}
func (*GetPackRelationsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{0}
}
func (m *GetPackRelationsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPackRelationsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPackRelationsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPackRelationsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPackRelationsReq.Merge(m, src)
}
func (m *GetPackRelationsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetPackRelationsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPackRelationsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetPackRelationsReq proto.InternalMessageInfo

type GetPackRelationsResp struct {
	Relations            []*Relation `protobuf:"bytes,1,rep,name=relations,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetPackRelationsResp) Reset()         { *m = GetPackRelationsResp{} }
func (m *GetPackRelationsResp) String() string { return proto.CompactTextString(m) }
func (*GetPackRelationsResp) ProtoMessage()    {}
func (*GetPackRelationsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{1}
}
func (m *GetPackRelationsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPackRelationsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPackRelationsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPackRelationsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPackRelationsResp.Merge(m, src)
}
func (m *GetPackRelationsResp) XXX_Size() int {
	return m.Size()
}
func (m *GetPackRelationsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPackRelationsResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetPackRelationsResp proto.InternalMessageInfo

type Relation struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id"`
	CurrentBuildId       int64    `protobuf:"varint,2,opt,name=current_build_id,json=currentBuildId,proto3" json:"current_build_id" form:"current_build_id"`
	ParentBuildId        int64    `protobuf:"varint,3,opt,name=parent_build_id,json=parentBuildId,proto3" json:"parent_build_id" form:"parent_build_id"`
	Feature              string   `protobuf:"bytes,4,opt,name=feature,proto3" json:"feature" form:"feature"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Relation) Reset()         { *m = Relation{} }
func (m *Relation) String() string { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()    {}
func (*Relation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{2}
}
func (m *Relation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relation.Merge(m, src)
}
func (m *Relation) XXX_Size() int {
	return m.Size()
}
func (m *Relation) XXX_DiscardUnknown() {
	xxx_messageInfo_Relation.DiscardUnknown(m)
}

var xxx_messageInfo_Relation proto.InternalMessageInfo

type GetTribeBuildPackReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key" validate:"required"`
	IdType               int64    `protobuf:"varint,2,opt,name=id_type,json=idType,proto3" json:"id_type" form:"id_type"`
	GitlabJobId          int64    `protobuf:"varint,3,opt,name=gitlab_job_id,json=gitlabJobId,proto3" json:"gl_job_id" form:"gl_job_id"`
	PkgType              int64    `protobuf:"varint,4,opt,name=pkg_type,json=pkgType,proto3" json:"pkg_type" form:"pkg_type"`
	Status               int64    `protobuf:"varint,5,opt,name=status,proto3" json:"status" form:"status"`
	GitType              int64    `protobuf:"varint,6,opt,name=git_type,json=gitType,proto3" json:"git_type" form:"git_type"`
	GitKeyword           string   `protobuf:"bytes,7,opt,name=git_keyword,json=gitKeyword,proto3" json:"git_keyword" form:"git_keyword"`
	Operator             string   `protobuf:"bytes,8,opt,name=operator,proto3" json:"operator" form:"operator"`
	Order                Sort     `protobuf:"varint,9,opt,name=order,proto3,enum=app.tribe.v1.Sort" json:"order" form:"order"`
	Pn                   int64    `protobuf:"varint,10,opt,name=pn,proto3" json:"pn" form:"pn"`
	Ps                   int64    `protobuf:"varint,11,opt,name=ps,proto3" json:"ps" form:"ps"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTribeBuildPackReq) Reset()         { *m = GetTribeBuildPackReq{} }
func (m *GetTribeBuildPackReq) String() string { return proto.CompactTextString(m) }
func (*GetTribeBuildPackReq) ProtoMessage()    {}
func (*GetTribeBuildPackReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{3}
}
func (m *GetTribeBuildPackReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTribeBuildPackReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTribeBuildPackReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTribeBuildPackReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTribeBuildPackReq.Merge(m, src)
}
func (m *GetTribeBuildPackReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTribeBuildPackReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTribeBuildPackReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTribeBuildPackReq proto.InternalMessageInfo

type GetTribeBuildPackResp struct {
	Page                 *PageInfo             `protobuf:"bytes,1,opt,name=page,proto3" json:"page" form:"page"`
	Items                []*TribeBuildPackInfo `protobuf:"bytes,2,rep,name=items,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GetTribeBuildPackResp) Reset()         { *m = GetTribeBuildPackResp{} }
func (m *GetTribeBuildPackResp) String() string { return proto.CompactTextString(m) }
func (*GetTribeBuildPackResp) ProtoMessage()    {}
func (*GetTribeBuildPackResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{4}
}
func (m *GetTribeBuildPackResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTribeBuildPackResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTribeBuildPackResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTribeBuildPackResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTribeBuildPackResp.Merge(m, src)
}
func (m *GetTribeBuildPackResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTribeBuildPackResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTribeBuildPackResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTribeBuildPackResp proto.InternalMessageInfo

type TribeInfo struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id"`
	AppKey               string   `protobuf:"bytes,2,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name" form:"name"`
	CName                string   `protobuf:"bytes,4,opt,name=c_name,json=cName,proto3" json:"c_name" form:"c_name"`
	Owners               string   `protobuf:"bytes,5,opt,name=owners,proto3" json:"owners" form:"owners"`
	Description          string   `protobuf:"bytes,6,opt,name=description,proto3" json:"description" form:"description"`
	NoHost               bool     `protobuf:"varint,7,opt,name=no_host,json=noHost,proto3" json:"no_host" form:"no_host"`
	Priority             int64    `protobuf:"varint,8,opt,name=priority,proto3" json:"priority" form:"priority"`
	IsBuildIn            bool     `protobuf:"varint,9,opt,name=is_build_in,json=isBuildIn,proto3" json:"is_build_in" form:"is_build_in"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TribeInfo) Reset()         { *m = TribeInfo{} }
func (m *TribeInfo) String() string { return proto.CompactTextString(m) }
func (*TribeInfo) ProtoMessage()    {}
func (*TribeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{5}
}
func (m *TribeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TribeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TribeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TribeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TribeInfo.Merge(m, src)
}
func (m *TribeInfo) XXX_Size() int {
	return m.Size()
}
func (m *TribeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TribeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TribeInfo proto.InternalMessageInfo

type PageInfo struct {
	Total                int64    `protobuf:"varint,1,opt,name=total,proto3" json:"total"`
	Pn                   int64    `protobuf:"varint,2,opt,name=pn,proto3" json:"pn"`
	Ps                   int64    `protobuf:"varint,3,opt,name=ps,proto3" json:"ps"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PageInfo) Reset()         { *m = PageInfo{} }
func (m *PageInfo) String() string { return proto.CompactTextString(m) }
func (*PageInfo) ProtoMessage()    {}
func (*PageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{6}
}
func (m *PageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageInfo.Merge(m, src)
}
func (m *PageInfo) XXX_Size() int {
	return m.Size()
}
func (m *PageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PageInfo proto.InternalMessageInfo

type GetTribeInfoReq struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTribeInfoReq) Reset()         { *m = GetTribeInfoReq{} }
func (m *GetTribeInfoReq) String() string { return proto.CompactTextString(m) }
func (*GetTribeInfoReq) ProtoMessage()    {}
func (*GetTribeInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{7}
}
func (m *GetTribeInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTribeInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTribeInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTribeInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTribeInfoReq.Merge(m, src)
}
func (m *GetTribeInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTribeInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTribeInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTribeInfoReq proto.InternalMessageInfo

type GetTribeInfoResp struct {
	TribeInfo            *TribeInfo `protobuf:"bytes,1,opt,name=tribe_info,json=tribeInfo,proto3" json:"tribe_info" form:"tribe_info"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetTribeInfoResp) Reset()         { *m = GetTribeInfoResp{} }
func (m *GetTribeInfoResp) String() string { return proto.CompactTextString(m) }
func (*GetTribeInfoResp) ProtoMessage()    {}
func (*GetTribeInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{8}
}
func (m *GetTribeInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTribeInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTribeInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTribeInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTribeInfoResp.Merge(m, src)
}
func (m *GetTribeInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTribeInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTribeInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTribeInfoResp proto.InternalMessageInfo

type ListTribeInfoReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name" form:"name"`
	CName                string   `protobuf:"bytes,3,opt,name=c_name,json=cName,proto3" json:"c_name" form:"c_name"`
	Ps                   int64    `protobuf:"varint,4,opt,name=ps,proto3" json:"ps" form:"ps"`
	Pn                   int64    `protobuf:"varint,5,opt,name=pn,proto3" json:"pn" form:"pn"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTribeInfoReq) Reset()         { *m = ListTribeInfoReq{} }
func (m *ListTribeInfoReq) String() string { return proto.CompactTextString(m) }
func (*ListTribeInfoReq) ProtoMessage()    {}
func (*ListTribeInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{9}
}
func (m *ListTribeInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTribeInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTribeInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTribeInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTribeInfoReq.Merge(m, src)
}
func (m *ListTribeInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *ListTribeInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTribeInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListTribeInfoReq proto.InternalMessageInfo

type ListTribeInfoResp struct {
	PageInfo             *PageInfo    `protobuf:"bytes,1,opt,name=page_info,json=pageInfo,proto3" json:"page" form:"page"`
	TribeInfo            []*TribeInfo `protobuf:"bytes,2,rep,name=tribe_info,json=tribeInfo,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListTribeInfoResp) Reset()         { *m = ListTribeInfoResp{} }
func (m *ListTribeInfoResp) String() string { return proto.CompactTextString(m) }
func (*ListTribeInfoResp) ProtoMessage()    {}
func (*ListTribeInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{10}
}
func (m *ListTribeInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTribeInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTribeInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTribeInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTribeInfoResp.Merge(m, src)
}
func (m *ListTribeInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *ListTribeInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTribeInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListTribeInfoResp proto.InternalMessageInfo

type DeleteTribeInfoReq struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteTribeInfoReq) Reset()         { *m = DeleteTribeInfoReq{} }
func (m *DeleteTribeInfoReq) String() string { return proto.CompactTextString(m) }
func (*DeleteTribeInfoReq) ProtoMessage()    {}
func (*DeleteTribeInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{11}
}
func (m *DeleteTribeInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTribeInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTribeInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTribeInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTribeInfoReq.Merge(m, src)
}
func (m *DeleteTribeInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTribeInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTribeInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTribeInfoReq proto.InternalMessageInfo

type UpdateTribeInfoReq struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id"`
	AppKey               string   `protobuf:"bytes,2,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name" form:"name"`
	CName                string   `protobuf:"bytes,4,opt,name=c_name,json=cName,proto3" json:"c_name" form:"c_name"`
	Owners               string   `protobuf:"bytes,5,opt,name=owners,proto3" json:"owners" form:"owners"`
	Description          string   `protobuf:"bytes,6,opt,name=description,proto3" json:"description" form:"description"`
	NoHost               bool     `protobuf:"varint,7,opt,name=no_host,json=noHost,proto3" json:"no_host" form:"no_host"`
	Priority             int64    `protobuf:"varint,8,opt,name=priority,proto3" json:"priority" form:"priority"`
	IsBuildIn            bool     `protobuf:"varint,9,opt,name=is_build_in,json=isBuildIn,proto3" json:"is_build_in" form:"is_build_in"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateTribeInfoReq) Reset()         { *m = UpdateTribeInfoReq{} }
func (m *UpdateTribeInfoReq) String() string { return proto.CompactTextString(m) }
func (*UpdateTribeInfoReq) ProtoMessage()    {}
func (*UpdateTribeInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{12}
}
func (m *UpdateTribeInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTribeInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTribeInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTribeInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTribeInfoReq.Merge(m, src)
}
func (m *UpdateTribeInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTribeInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTribeInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTribeInfoReq proto.InternalMessageInfo

type AddTribeInfoReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key" validate:"required"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name" form:"name" validate:"required"`
	CName                string   `protobuf:"bytes,3,opt,name=c_name,json=cName,proto3" json:"c_name" form:"c_name"`
	Owners               string   `protobuf:"bytes,4,opt,name=owners,proto3" json:"owners" form:"owners"`
	Description          string   `protobuf:"bytes,5,opt,name=description,proto3" json:"description" form:"description"`
	NoHost               bool     `protobuf:"varint,6,opt,name=no_host,json=noHost,proto3" json:"no_host" form:"no_host"`
	Priority             int64    `protobuf:"varint,7,opt,name=priority,proto3" json:"priority" form:"priority"`
	IsBuildIn            bool     `protobuf:"varint,8,opt,name=is_build_in,json=isBuildIn,proto3" json:"is_build_in" form:"is_build_in"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddTribeInfoReq) Reset()         { *m = AddTribeInfoReq{} }
func (m *AddTribeInfoReq) String() string { return proto.CompactTextString(m) }
func (*AddTribeInfoReq) ProtoMessage()    {}
func (*AddTribeInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{13}
}
func (m *AddTribeInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTribeInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTribeInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTribeInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTribeInfoReq.Merge(m, src)
}
func (m *AddTribeInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *AddTribeInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTribeInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddTribeInfoReq proto.InternalMessageInfo

type AddTribeBuildPackReq struct {
	TribeId              int64    `protobuf:"varint,1,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id" validate:"required"`
	PkgType              int64    `protobuf:"varint,2,opt,name=pkg_type,json=pkgType,proto3" json:"pkg_type" form:"pkg_type"`
	GitType              int64    `protobuf:"varint,3,opt,name=git_type,json=gitType,proto3" json:"git_type" form:"git_type"`
	GitName              string   `protobuf:"bytes,4,opt,name=git_name,json=gitName,proto3" json:"git_name" form:"git_name" validate:"required"`
	CiEnvVar             string   `protobuf:"bytes,5,opt,name=ci_env_var,json=ciEnvVar,proto3" json:"ci_env_var" form:"ci_env_var"`
	Description          string   `protobuf:"bytes,6,opt,name=description,proto3" json:"description" form:"description"`
	ShouldNotify         bool     `protobuf:"varint,7,opt,name=should_notify,json=shouldNotify,proto3" json:"should_notify" form:"should_notify"`
	DepGlJobId           int64    `protobuf:"varint,8,opt,name=dep_gl_job_id,json=depGlJobId,proto3" json:"dep_gl_job_id" form:"dep_gl_job_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddTribeBuildPackReq) Reset()         { *m = AddTribeBuildPackReq{} }
func (m *AddTribeBuildPackReq) String() string { return proto.CompactTextString(m) }
func (*AddTribeBuildPackReq) ProtoMessage()    {}
func (*AddTribeBuildPackReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{14}
}
func (m *AddTribeBuildPackReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTribeBuildPackReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTribeBuildPackReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTribeBuildPackReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTribeBuildPackReq.Merge(m, src)
}
func (m *AddTribeBuildPackReq) XXX_Size() int {
	return m.Size()
}
func (m *AddTribeBuildPackReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTribeBuildPackReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddTribeBuildPackReq proto.InternalMessageInfo

type ListTribeBuildPackReq struct {
	GlJobId              int64                         `protobuf:"varint,1,opt,name=gl_job_id,json=glJobId,proto3" json:"gl_job_id" form:"gl_job_id"`
	DepGlJobId           int64                         `protobuf:"varint,12,opt,name=dep_gl_job_id,json=depGlJobId,proto3" json:"dep_gl_job_id" form:"dep_gl_job_id"`
	PkgType              int32                         `protobuf:"varint,2,opt,name=pkg_type,json=pkgType,proto3" json:"pkg_type" form:"pkg_type"`
	Status               int32                         `protobuf:"varint,3,opt,name=status,proto3" json:"status" form:"status"`
	State                int32                         `protobuf:"varint,14,opt,name=state,proto3" json:"state" form:"state"`
	GitType              ListTribeBuildPackReq_GitType `protobuf:"varint,4,opt,name=git_type,json=gitType,proto3,enum=app.tribe.v1.ListTribeBuildPackReq_GitType" json:"git_type" form:"git_type"`
	Commit               string                        `protobuf:"bytes,13,opt,name=commit,proto3" json:"commit" form:"commit"`
	GitName              string                        `protobuf:"bytes,5,opt,name=git_name,json=gitName,proto3" json:"git_name" form:"git_name"`
	Operator             string                        `protobuf:"bytes,6,opt,name=operator,proto3" json:"operator" form:"operator"`
	TribeId              int64                         `protobuf:"varint,7,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id"`
	OrderBy              ListTribeBuildPackReq_OrderBy `protobuf:"varint,8,opt,name=order_by,json=orderBy,proto3,enum=app.tribe.v1.ListTribeBuildPackReq_OrderBy" json:"order_by" form:"order_by"`
	Sort                 Sort                          `protobuf:"varint,9,opt,name=sort,proto3,enum=app.tribe.v1.Sort" json:"sort" form:"sort"`
	Pn                   int64                         `protobuf:"varint,10,opt,name=pn,proto3" json:"pn" form:"pn"`
	Ps                   int64                         `protobuf:"varint,11,opt,name=ps,proto3" json:"ps" form:"ps"`
	AppKey               string                        `protobuf:"bytes,15,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	PushCd               string                        `protobuf:"bytes,16,opt,name=push_cd,json=pushCd,proto3" json:"push_cd" form:"push_cd"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ListTribeBuildPackReq) Reset()         { *m = ListTribeBuildPackReq{} }
func (m *ListTribeBuildPackReq) String() string { return proto.CompactTextString(m) }
func (*ListTribeBuildPackReq) ProtoMessage()    {}
func (*ListTribeBuildPackReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{15}
}
func (m *ListTribeBuildPackReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTribeBuildPackReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTribeBuildPackReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTribeBuildPackReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTribeBuildPackReq.Merge(m, src)
}
func (m *ListTribeBuildPackReq) XXX_Size() int {
	return m.Size()
}
func (m *ListTribeBuildPackReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTribeBuildPackReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListTribeBuildPackReq proto.InternalMessageInfo

type ListTribeBuildPackResp struct {
	TribeBuildPackInfos  []*TribeBuildPackInfo `protobuf:"bytes,1,rep,name=tribe_build_pack_infos,json=tribeBuildPackInfos,proto3" json:"items" form:"items"`
	PageInfo             *PageInfo             `protobuf:"bytes,2,opt,name=page_info,json=pageInfo,proto3" json:"page" form:"page"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ListTribeBuildPackResp) Reset()         { *m = ListTribeBuildPackResp{} }
func (m *ListTribeBuildPackResp) String() string { return proto.CompactTextString(m) }
func (*ListTribeBuildPackResp) ProtoMessage()    {}
func (*ListTribeBuildPackResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{16}
}
func (m *ListTribeBuildPackResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTribeBuildPackResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTribeBuildPackResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTribeBuildPackResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTribeBuildPackResp.Merge(m, src)
}
func (m *ListTribeBuildPackResp) XXX_Size() int {
	return m.Size()
}
func (m *ListTribeBuildPackResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTribeBuildPackResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListTribeBuildPackResp proto.InternalMessageInfo

type TribeBuildPackInfo struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id"`
	TribeId              int64    `protobuf:"varint,2,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id"`
	GlJobId              int64    `protobuf:"varint,3,opt,name=gl_job_id,json=glJobId,proto3" json:"gl_job_id" form:"gl_job_id"`
	DepGlJobId           int64    `protobuf:"varint,4,opt,name=dep_gl_job_id,json=depGlJobId,proto3" json:"dep_gl_job_id" form:"dep_gl_job_id"`
	AppId                string   `protobuf:"bytes,5,opt,name=app_id,json=appId,proto3" json:"app_id" form:"app_id"`
	AppKey               string   `protobuf:"bytes,6,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	GitPath              string   `protobuf:"bytes,7,opt,name=git_path,json=gitPath,proto3" json:"git_path" form:"git_path"`
	GitType              int32    `protobuf:"varint,8,opt,name=git_type,json=gitType,proto3" json:"git_type" form:"git_type"`
	GitName              string   `protobuf:"bytes,9,opt,name=git_name,json=gitName,proto3" json:"git_name" form:"git_name"`
	Commit               string   `protobuf:"bytes,10,opt,name=commit,proto3" json:"commit" form:"commit"`
	PkgType              int32    `protobuf:"varint,11,opt,name=pkg_type,json=pkgType,proto3" json:"pkg_type" form:"pkg_type"`
	Operator             string   `protobuf:"bytes,12,opt,name=operator,proto3" json:"operator" form:"operator"`
	Size_                int64    `protobuf:"varint,13,opt,name=size,proto3" json:"size" form:"size"`
	Md5                  string   `protobuf:"bytes,14,opt,name=md5,proto3" json:"md5" form:"md5"`
	PkgPath              string   `protobuf:"bytes,15,opt,name=pkg_path,json=pkgPath,proto3" json:"pkg_path" form:"pkg_path"`
	PkgUrl               string   `protobuf:"bytes,16,opt,name=pkg_url,json=pkgUrl,proto3" json:"pkg_url" form:"pkg_url"`
	MappingUrl           string   `protobuf:"bytes,17,opt,name=mapping_url,json=mappingUrl,proto3" json:"mapping_url" form:"mapping_url"`
	BbrUrl               string   `protobuf:"bytes,18,opt,name=bbr_url,json=bbrUrl,proto3" json:"bbr_url" form:"bbr_url"`
	State                int32    `protobuf:"varint,19,opt,name=state,proto3" json:"state" form:"state"`
	Status               int32    `protobuf:"varint,20,opt,name=status,proto3" json:"status" form:"status"`
	DidPush              int32    `protobuf:"varint,21,opt,name=did_push,json=didPush,proto3" json:"did_push" form:"did_push"`
	ChangeLog            string   `protobuf:"bytes,22,opt,name=change_log,json=changeLog,proto3" json:"change_log" form:"change_log"`
	NotifyGroup          bool     `protobuf:"varint,23,opt,name=notify_group,json=notifyGroup,proto3" json:"notify_group" form:"notify_group"`
	CiEnvVars            string   `protobuf:"bytes,24,opt,name=ci_env_vars,json=ciEnvVars,proto3" json:"ci_env_vars" form:"ci_env_vars"`
	BuildStartTime       int64    `protobuf:"varint,25,opt,name=build_start_time,json=buildStartTime,proto3" json:"build_start_time" form:"build_start_time"`
	BuildEndTime         int64    `protobuf:"varint,26,opt,name=build_end_time,json=buildEndTime,proto3" json:"build_end_time" form:"build_end_time"`
	Description          string   `protobuf:"bytes,27,opt,name=description,proto3" json:"description" form:"description"`
	Ctime                int64    `protobuf:"varint,28,opt,name=ctime,proto3" json:"ctime" form:"ctime"`
	Mtime                int64    `protobuf:"varint,29,opt,name=mtime,proto3" json:"mtime" form:"mtime"`
	ErrMsg               string   `protobuf:"bytes,30,opt,name=err_msg,json=errMsg,proto3" json:"err_msg" form:"err_msg"`
	JobUrl               string   `protobuf:"bytes,31,opt,name=job_url,json=jobUrl,proto3" json:"job_url" form:"job_url"`
	VersionCode          int64    `protobuf:"varint,32,opt,name=version_code,json=versionCode,proto3" json:"version_code" form:"version_code"`
	VersionName          string   `protobuf:"bytes,33,opt,name=version_name,json=versionName,proto3" json:"version_name" form:"version_name"`
	DepFeature           string   `protobuf:"bytes,34,opt,name=dep_feature,json=depFeature,proto3" json:"dep_feature" form:"dep_feature"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TribeBuildPackInfo) Reset()         { *m = TribeBuildPackInfo{} }
func (m *TribeBuildPackInfo) String() string { return proto.CompactTextString(m) }
func (*TribeBuildPackInfo) ProtoMessage()    {}
func (*TribeBuildPackInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{17}
}
func (m *TribeBuildPackInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TribeBuildPackInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TribeBuildPackInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TribeBuildPackInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TribeBuildPackInfo.Merge(m, src)
}
func (m *TribeBuildPackInfo) XXX_Size() int {
	return m.Size()
}
func (m *TribeBuildPackInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TribeBuildPackInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TribeBuildPackInfo proto.InternalMessageInfo

type GetTribeBuildPackInfoReq struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTribeBuildPackInfoReq) Reset()         { *m = GetTribeBuildPackInfoReq{} }
func (m *GetTribeBuildPackInfoReq) String() string { return proto.CompactTextString(m) }
func (*GetTribeBuildPackInfoReq) ProtoMessage()    {}
func (*GetTribeBuildPackInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{18}
}
func (m *GetTribeBuildPackInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTribeBuildPackInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTribeBuildPackInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTribeBuildPackInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTribeBuildPackInfoReq.Merge(m, src)
}
func (m *GetTribeBuildPackInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTribeBuildPackInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTribeBuildPackInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTribeBuildPackInfoReq proto.InternalMessageInfo

type GetTribeBuildPackInfoResp struct {
	TribeBuildPackInfo   *TribeBuildPackInfo `protobuf:"bytes,1,opt,name=tribe_build_pack_info,json=tribeBuildPackInfo,proto3" json:"tribe_build_pack_info" form:"tribe_build_pack_info"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetTribeBuildPackInfoResp) Reset()         { *m = GetTribeBuildPackInfoResp{} }
func (m *GetTribeBuildPackInfoResp) String() string { return proto.CompactTextString(m) }
func (*GetTribeBuildPackInfoResp) ProtoMessage()    {}
func (*GetTribeBuildPackInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{19}
}
func (m *GetTribeBuildPackInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTribeBuildPackInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTribeBuildPackInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTribeBuildPackInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTribeBuildPackInfoResp.Merge(m, src)
}
func (m *GetTribeBuildPackInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTribeBuildPackInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTribeBuildPackInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTribeBuildPackInfoResp proto.InternalMessageInfo

type PushTribeBuildPackToCDReq struct {
	TribeBuildPackId     int64    `protobuf:"varint,1,opt,name=tribe_build_pack_id,json=tribeBuildPackId,proto3" json:"tribe_build_pack_id" form:"tribe_build_pack_id" validate:"required"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description" form:"description" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushTribeBuildPackToCDReq) Reset()         { *m = PushTribeBuildPackToCDReq{} }
func (m *PushTribeBuildPackToCDReq) String() string { return proto.CompactTextString(m) }
func (*PushTribeBuildPackToCDReq) ProtoMessage()    {}
func (*PushTribeBuildPackToCDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{20}
}
func (m *PushTribeBuildPackToCDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushTribeBuildPackToCDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushTribeBuildPackToCDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushTribeBuildPackToCDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushTribeBuildPackToCDReq.Merge(m, src)
}
func (m *PushTribeBuildPackToCDReq) XXX_Size() int {
	return m.Size()
}
func (m *PushTribeBuildPackToCDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PushTribeBuildPackToCDReq.DiscardUnknown(m)
}

var xxx_messageInfo_PushTribeBuildPackToCDReq proto.InternalMessageInfo

type UpdateTribeBuildPackGitInfoReq struct {
	TribeBuildPackId     int64          `protobuf:"varint,1,opt,name=tribe_build_pack_id,json=tribeBuildPackId,proto3" json:"tribe_build_pack_id" form:"tribe_build_pack_id" validate:"required"`
	Status               CallbackStatus `protobuf:"varint,2,opt,name=status,proto3,enum=app.tribe.v1.CallbackStatus" json:"status" form:"status"`
	GitlabJobId          int64          `protobuf:"varint,3,opt,name=gitlab_job_id,json=gitlabJobId,proto3" json:"gitlab_job_id" form:"gitlab_job_id"`
	GitPath              string         `protobuf:"bytes,4,opt,name=git_path,json=gitPath,proto3" json:"git_path" form:"git_path"`
	Commit               string         `protobuf:"bytes,5,opt,name=commit,proto3" json:"commit" form:"commit"`
	BuildStartTime       int64          `protobuf:"varint,6,opt,name=build_start_time,json=buildStartTime,proto3" json:"build_start_time" form:"build_start_time"`
	DepGitlabJobId       int64          `protobuf:"varint,7,opt,name=dep_gitlab_job_id,json=depGitlabJobId,proto3" json:"dep_gitlab_job_id" form:"dep_gitlab_job_id"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpdateTribeBuildPackGitInfoReq) Reset()         { *m = UpdateTribeBuildPackGitInfoReq{} }
func (m *UpdateTribeBuildPackGitInfoReq) String() string { return proto.CompactTextString(m) }
func (*UpdateTribeBuildPackGitInfoReq) ProtoMessage()    {}
func (*UpdateTribeBuildPackGitInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{21}
}
func (m *UpdateTribeBuildPackGitInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTribeBuildPackGitInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTribeBuildPackGitInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTribeBuildPackGitInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTribeBuildPackGitInfoReq.Merge(m, src)
}
func (m *UpdateTribeBuildPackGitInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTribeBuildPackGitInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTribeBuildPackGitInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTribeBuildPackGitInfoReq proto.InternalMessageInfo

type UpdateTribeBuildPackPkgInfoReq struct {
	TribeBuildPackId     int64          `protobuf:"varint,1,opt,name=tribe_build_pack_id,json=tribeBuildPackId,proto3" json:"tribe_build_pack_id" form:"tribe_build_pack_id" validate:"required"`
	Status               CallbackStatus `protobuf:"varint,2,opt,name=status,proto3,enum=app.tribe.v1.CallbackStatus" json:"status" form:"status"`
	File                 []byte         `protobuf:"bytes,3,opt,name=file,proto3" json:"file" form:"file"`
	ChangeLog            string         `protobuf:"bytes,4,opt,name=change_log,json=changeLog,proto3" json:"change_log" form:"change_log"`
	PkgPath              string         `protobuf:"bytes,5,opt,name=pkg_path,json=pkgPath,proto3" json:"apk_path" form:"apk_path"`
	MappingPath          string         `protobuf:"bytes,6,opt,name=mapping_path,json=mappingPath,proto3" json:"mapping_path" form:"mapping_path"`
	BbrPath              string         `protobuf:"bytes,7,opt,name=bbr_path,json=bbrPath,proto3" json:"bbr_path" form:"bbr_path"`
	BuildEndTime         int64          `protobuf:"varint,8,opt,name=build_end_time,json=buildEndTime,proto3" json:"build_end_time" form:"build_end_time"`
	VersionCode          int64          `protobuf:"varint,9,opt,name=version_code,json=versionCode,proto3" json:"version_code" form:"version_code"`
	VersionName          string         `protobuf:"bytes,12,opt,name=version_name,json=versionName,proto3" json:"version_name" form:"version_name"`
	Unzip                bool           `protobuf:"varint,10,opt,name=unzip,proto3" json:"unzip" form:"unzip"`
	Md5                  string         `protobuf:"bytes,11,opt,name=md5,proto3" json:"md5" form:"md5"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpdateTribeBuildPackPkgInfoReq) Reset()         { *m = UpdateTribeBuildPackPkgInfoReq{} }
func (m *UpdateTribeBuildPackPkgInfoReq) String() string { return proto.CompactTextString(m) }
func (*UpdateTribeBuildPackPkgInfoReq) ProtoMessage()    {}
func (*UpdateTribeBuildPackPkgInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{22}
}
func (m *UpdateTribeBuildPackPkgInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTribeBuildPackPkgInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTribeBuildPackPkgInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTribeBuildPackPkgInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTribeBuildPackPkgInfoReq.Merge(m, src)
}
func (m *UpdateTribeBuildPackPkgInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTribeBuildPackPkgInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTribeBuildPackPkgInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTribeBuildPackPkgInfoReq proto.InternalMessageInfo

type UpdateTribeBuildPackPkgInfoResp struct {
	MainApkUrl           string   `protobuf:"bytes,1,opt,name=main_apk_url,json=mainApkUrl,proto3" json:"main_apk_url" form:"main_apk_url"`
	MainBbrUrl           string   `protobuf:"bytes,2,opt,name=main_bbr_url,json=mainBbrUrl,proto3" json:"main_bbr_url" form:"main_bbr_url"`
	MappingUrl           string   `protobuf:"bytes,3,opt,name=mapping_url,json=mappingUrl,proto3" json:"mapping_url" form:"mapping_url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateTribeBuildPackPkgInfoResp) Reset()         { *m = UpdateTribeBuildPackPkgInfoResp{} }
func (m *UpdateTribeBuildPackPkgInfoResp) String() string { return proto.CompactTextString(m) }
func (*UpdateTribeBuildPackPkgInfoResp) ProtoMessage()    {}
func (*UpdateTribeBuildPackPkgInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{23}
}
func (m *UpdateTribeBuildPackPkgInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTribeBuildPackPkgInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTribeBuildPackPkgInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTribeBuildPackPkgInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTribeBuildPackPkgInfoResp.Merge(m, src)
}
func (m *UpdateTribeBuildPackPkgInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTribeBuildPackPkgInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTribeBuildPackPkgInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTribeBuildPackPkgInfoResp proto.InternalMessageInfo

type CancelTribeBuildPackReq struct {
	TribeBuildPackId     int64    `protobuf:"varint,2,opt,name=tribe_build_pack_id,json=tribeBuildPackId,proto3" json:"tribe_build_pack_id" form:"tribe_build_pack_id" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelTribeBuildPackReq) Reset()         { *m = CancelTribeBuildPackReq{} }
func (m *CancelTribeBuildPackReq) String() string { return proto.CompactTextString(m) }
func (*CancelTribeBuildPackReq) ProtoMessage()    {}
func (*CancelTribeBuildPackReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{24}
}
func (m *CancelTribeBuildPackReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelTribeBuildPackReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelTribeBuildPackReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelTribeBuildPackReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelTribeBuildPackReq.Merge(m, src)
}
func (m *CancelTribeBuildPackReq) XXX_Size() int {
	return m.Size()
}
func (m *CancelTribeBuildPackReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelTribeBuildPackReq.DiscardUnknown(m)
}

var xxx_messageInfo_CancelTribeBuildPackReq proto.InternalMessageInfo

type ListTribePackReq struct {
	TribeId              int64    `protobuf:"varint,1,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id" validate:"required"`
	Env                  string   `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env" validate:"required"`
	State                int32    `protobuf:"varint,3,opt,name=state,proto3" json:"state" form:"state"`
	Ps                   int64    `protobuf:"varint,4,opt,name=ps,proto3" json:"ps" form:"ps" validate:"required"`
	Pn                   int64    `protobuf:"varint,5,opt,name=pn,proto3" json:"pn" form:"pn" validate:"required"`
	AppKey               string   `protobuf:"bytes,6,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTribePackReq) Reset()         { *m = ListTribePackReq{} }
func (m *ListTribePackReq) String() string { return proto.CompactTextString(m) }
func (*ListTribePackReq) ProtoMessage()    {}
func (*ListTribePackReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{25}
}
func (m *ListTribePackReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTribePackReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTribePackReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTribePackReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTribePackReq.Merge(m, src)
}
func (m *ListTribePackReq) XXX_Size() int {
	return m.Size()
}
func (m *ListTribePackReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTribePackReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListTribePackReq proto.InternalMessageInfo

type ListTribePackResp struct {
	PageInfo             *PageInfo      `protobuf:"bytes,1,opt,name=page_info,json=pageInfo,proto3" json:"page" form:"page"`
	VersionPackInfo      []*VersionPack `protobuf:"bytes,2,rep,name=version_pack_info,json=versionPackInfo,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListTribePackResp) Reset()         { *m = ListTribePackResp{} }
func (m *ListTribePackResp) String() string { return proto.CompactTextString(m) }
func (*ListTribePackResp) ProtoMessage()    {}
func (*ListTribePackResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{26}
}
func (m *ListTribePackResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTribePackResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTribePackResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTribePackResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTribePackResp.Merge(m, src)
}
func (m *ListTribePackResp) XXX_Size() int {
	return m.Size()
}
func (m *ListTribePackResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTribePackResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListTribePackResp proto.InternalMessageInfo

type VersionPack struct {
	VersionName          string      `protobuf:"bytes,1,opt,name=version_name,json=versionName,proto3" json:"version_name" form:"version_name"`
	PackInfo             []*PackInfo `protobuf:"bytes,2,rep,name=pack_info,json=packInfo,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VersionPack) Reset()         { *m = VersionPack{} }
func (m *VersionPack) String() string { return proto.CompactTextString(m) }
func (*VersionPack) ProtoMessage()    {}
func (*VersionPack) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{27}
}
func (m *VersionPack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionPack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionPack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionPack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionPack.Merge(m, src)
}
func (m *VersionPack) XXX_Size() int {
	return m.Size()
}
func (m *VersionPack) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionPack.DiscardUnknown(m)
}

var xxx_messageInfo_VersionPack proto.InternalMessageInfo

type ConfigVersionFlowReq struct {
	TribeId              int64    `protobuf:"varint,1,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id"`
	Env                  string   `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env"`
	VersionId            int64    `protobuf:"varint,3,opt,name=version_id,json=versionId,proto3" json:"version_id" form:"version_id"`
	AppKey               string   `protobuf:"bytes,4,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	Flow                 []*Flow  `protobuf:"bytes,5,rep,name=flow,proto3" json:"flow" form:"flow"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigVersionFlowReq) Reset()         { *m = ConfigVersionFlowReq{} }
func (m *ConfigVersionFlowReq) String() string { return proto.CompactTextString(m) }
func (*ConfigVersionFlowReq) ProtoMessage()    {}
func (*ConfigVersionFlowReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{28}
}
func (m *ConfigVersionFlowReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigVersionFlowReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigVersionFlowReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigVersionFlowReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigVersionFlowReq.Merge(m, src)
}
func (m *ConfigVersionFlowReq) XXX_Size() int {
	return m.Size()
}
func (m *ConfigVersionFlowReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigVersionFlowReq.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigVersionFlowReq proto.InternalMessageInfo

type Flow struct {
	From                 int64    `protobuf:"varint,1,opt,name=from,proto3" json:"from" form:"from"`
	To                   int64    `protobuf:"varint,2,opt,name=to,proto3" json:"to" form:"to"`
	GitJobId             int64    `protobuf:"varint,3,opt,name=git_job_id,json=gitJobId,proto3" json:"gl_job_id" form:"gl_job_id"`
	Ctime                int64    `protobuf:"varint,4,opt,name=ctime,proto3" json:"ctime" form:"ctime"`
	Mtime                int64    `protobuf:"varint,5,opt,name=mtime,proto3" json:"mtime" form:"mtime"`
	Operator             string   `protobuf:"bytes,6,opt,name=operator,proto3" json:"operator" form:"operator"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{29}
}
func (m *Flow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(m, src)
}
func (m *Flow) XXX_Size() int {
	return m.Size()
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

type ConfigVersionUpgradeReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	TribeId              int64    `protobuf:"varint,6,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id" validate:"required"`
	Env                  string   `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env" validate:"required"`
	TribePackId          int64    `protobuf:"varint,3,opt,name=tribe_pack_id,json=tribePackId,proto3" json:"tribe_pack_id" form:"tribe_pack_id" validate:"required"`
	ChosenVersionCode    []string `protobuf:"bytes,4,rep,name=chosen_version_code,json=chosenVersionCode,proto3" json:"chosen_version_code" form:"chosen_version_code"`
	StartingVersionCode  []string `protobuf:"bytes,5,rep,name=starting_version_code,json=startingVersionCode,proto3" json:"starting_version_code" form:"starting_version_code"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigVersionUpgradeReq) Reset()         { *m = ConfigVersionUpgradeReq{} }
func (m *ConfigVersionUpgradeReq) String() string { return proto.CompactTextString(m) }
func (*ConfigVersionUpgradeReq) ProtoMessage()    {}
func (*ConfigVersionUpgradeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{30}
}
func (m *ConfigVersionUpgradeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigVersionUpgradeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigVersionUpgradeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigVersionUpgradeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigVersionUpgradeReq.Merge(m, src)
}
func (m *ConfigVersionUpgradeReq) XXX_Size() int {
	return m.Size()
}
func (m *ConfigVersionUpgradeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigVersionUpgradeReq.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigVersionUpgradeReq proto.InternalMessageInfo

type VersionRange struct {
	Min                  string   `protobuf:"bytes,1,opt,name=min,proto3" json:"min,omitempty"`
	Max                  string   `protobuf:"bytes,2,opt,name=max,proto3" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionRange) Reset()         { *m = VersionRange{} }
func (m *VersionRange) String() string { return proto.CompactTextString(m) }
func (*VersionRange) ProtoMessage()    {}
func (*VersionRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{31}
}
func (m *VersionRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionRange.Merge(m, src)
}
func (m *VersionRange) XXX_Size() int {
	return m.Size()
}
func (m *VersionRange) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionRange.DiscardUnknown(m)
}

var xxx_messageInfo_VersionRange proto.InternalMessageInfo

type BuildVersion struct {
	VersionId            int64    `protobuf:"varint,1,opt,name=version_id,json=versionId,proto3" json:"version_id" form:"version_id"`
	BuildId              []int64  `protobuf:"varint,2,rep,packed,name=build_id,json=buildId,proto3" json:"build_id" form:"build_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildVersion) Reset()         { *m = BuildVersion{} }
func (m *BuildVersion) String() string { return proto.CompactTextString(m) }
func (*BuildVersion) ProtoMessage()    {}
func (*BuildVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{32}
}
func (m *BuildVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildVersion.Merge(m, src)
}
func (m *BuildVersion) XXX_Size() int {
	return m.Size()
}
func (m *BuildVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildVersion.DiscardUnknown(m)
}

var xxx_messageInfo_BuildVersion proto.InternalMessageInfo

type PackInfo struct {
	Id                   int64                           `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id"`
	AppId                string                          `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"app_id" form:"app_id"`
	AppKey               string                          `protobuf:"bytes,3,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	Env                  string                          `protobuf:"bytes,4,opt,name=env,proto3" json:"env" form:"env"`
	TribeId              int64                           `protobuf:"varint,5,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id"`
	GlJobId              int64                           `protobuf:"varint,6,opt,name=gl_job_id,json=glJobId,proto3" json:"gl_job_id" form:"gl_job_id"`
	DepGlJobId           int64                           `protobuf:"varint,7,opt,name=dep_gl_job_id,json=depGlJobId,proto3" json:"dep_gl_job_id" form:"dep_gl_job_id"`
	VersionId            int64                           `protobuf:"varint,8,opt,name=version_id,json=versionId,proto3" json:"version_id" form:"version_id"`
	GitType              int32                           `protobuf:"varint,9,opt,name=git_type,json=gitType,proto3" json:"git_type" form:"git_type"`
	GitName              string                          `protobuf:"bytes,10,opt,name=git_name,json=gitName,proto3" json:"git_name" form:"git_name"`
	Commit               string                          `protobuf:"bytes,11,opt,name=commit,proto3" json:"commit" form:"commit"`
	PackType             int32                           `protobuf:"varint,12,opt,name=pack_type,json=packType,proto3" json:"pack_type" form:"pack_type"`
	ChangeLog            string                          `protobuf:"bytes,13,opt,name=change_log,json=changeLog,proto3" json:"change_log" form:"change_log"`
	Operator             string                          `protobuf:"bytes,14,opt,name=operator,proto3" json:"operator" form:"operator"`
	Size_                int64                           `protobuf:"varint,15,opt,name=size,proto3" json:"size" form:"size"`
	Md5                  string                          `protobuf:"bytes,16,opt,name=md5,proto3" json:"md5" form:"md5"`
	PackPath             string                          `protobuf:"bytes,17,opt,name=pack_path,json=packPath,proto3" json:"pack_path" form:"pack_path"`
	PackUrl              string                          `protobuf:"bytes,18,opt,name=pack_url,json=packUrl,proto3" json:"pack_url" form:"pack_url"`
	MappingUrl           string                          `protobuf:"bytes,19,opt,name=mapping_url,json=mappingUrl,proto3" json:"mapping_url" form:"mapping_url"`
	BbrUrl               string                          `protobuf:"bytes,20,opt,name=bbr_url,json=bbrUrl,proto3" json:"bbr_url" form:"bbr_url"`
	CdnUrl               string                          `protobuf:"bytes,21,opt,name=cdn_url,json=cdnUrl,proto3" json:"cdn_url" form:"cdn_url"`
	Description          string                          `protobuf:"bytes,22,opt,name=description,proto3" json:"description" form:"description"`
	Mtime                int64                           `protobuf:"varint,24,opt,name=mtime,proto3" json:"mtime" form:"mtime"`
	Ctime                int64                           `protobuf:"varint,25,opt,name=ctime,proto3" json:"ctime" form:"ctime"`
	Flow                 *Flow                           `protobuf:"bytes,26,opt,name=flow,proto3" json:"flow" form:"flow"`
	PackUpgrade          *GetConfigPackUpgradeFilterResp `protobuf:"bytes,23,opt,name=pack_upgrade,json=packUpgrade,proto3" json:"pack_upgrade" form:"pack_upgrade"`
	JobUrl               string                          `protobuf:"bytes,27,opt,name=job_url,json=jobUrl,proto3" json:"job_url" form:"job_url"`
	VersionInfo          *VersionInfo                    `protobuf:"bytes,28,opt,name=version_info,json=versionInfo,proto3" json:"version" form:"version"`
	LastOperator         string                          `protobuf:"bytes,29,opt,name=last_operator,json=lastOperator,proto3" json:"last_operator" form:"last_operator"`
	LastMtime            int64                           `protobuf:"varint,30,opt,name=last_mtime,json=lastMtime,proto3" json:"last_mtime" form:"last_mtime"`
	DepFeature           string                          `protobuf:"bytes,31,opt,name=dep_feature,json=depFeature,proto3" json:"dep_feature" form:"dep_feature"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *PackInfo) Reset()         { *m = PackInfo{} }
func (m *PackInfo) String() string { return proto.CompactTextString(m) }
func (*PackInfo) ProtoMessage()    {}
func (*PackInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{33}
}
func (m *PackInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackInfo.Merge(m, src)
}
func (m *PackInfo) XXX_Size() int {
	return m.Size()
}
func (m *PackInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PackInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PackInfo proto.InternalMessageInfo

type VersionInfo struct {
	Env                  string   `protobuf:"bytes,1,opt,name=env,proto3" json:"env" form:"env"`
	IsActive             bool     `protobuf:"varint,2,opt,name=is_active,json=isActive,proto3" json:"is_active" form:"is_active"`
	VersionCode          string   `protobuf:"bytes,3,opt,name=version_code,json=versionCode,proto3" json:"version_code" form:"version_code"`
	VersionId            int64    `protobuf:"varint,4,opt,name=version_id,json=versionId,proto3" json:"version_id" form:"version_id"`
	Ctime                int64    `protobuf:"varint,5,opt,name=ctime,proto3" json:"ctime" form:"ctime"`
	Mtime                int64    `protobuf:"varint,6,opt,name=mtime,proto3" json:"mtime" form:"mtime"`
	Operator             string   `protobuf:"bytes,7,opt,name=operator,proto3" json:"operator" form:"operator"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionInfo) Reset()         { *m = VersionInfo{} }
func (m *VersionInfo) String() string { return proto.CompactTextString(m) }
func (*VersionInfo) ProtoMessage()    {}
func (*VersionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{34}
}
func (m *VersionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionInfo.Merge(m, src)
}
func (m *VersionInfo) XXX_Size() int {
	return m.Size()
}
func (m *VersionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VersionInfo proto.InternalMessageInfo

type ActiveVersionReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	Env                  string   `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env"`
	VersionId            int64    `protobuf:"varint,4,opt,name=version_id,json=versionId,proto3" json:"version_id" form:"version_id"`
	Active               bool     `protobuf:"varint,5,opt,name=active,proto3" json:"active" form:"active"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActiveVersionReq) Reset()         { *m = ActiveVersionReq{} }
func (m *ActiveVersionReq) String() string { return proto.CompactTextString(m) }
func (*ActiveVersionReq) ProtoMessage()    {}
func (*ActiveVersionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{35}
}
func (m *ActiveVersionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveVersionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveVersionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveVersionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveVersionReq.Merge(m, src)
}
func (m *ActiveVersionReq) XXX_Size() int {
	return m.Size()
}
func (m *ActiveVersionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveVersionReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveVersionReq proto.InternalMessageInfo

type GetVersionFlowReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	TribeId              int64    `protobuf:"varint,2,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id"`
	Env                  string   `protobuf:"bytes,3,opt,name=env,proto3" json:"env" form:"env"`
	VersionId            int64    `protobuf:"varint,4,opt,name=version_id,json=versionId,proto3" json:"version_id" form:"version_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVersionFlowReq) Reset()         { *m = GetVersionFlowReq{} }
func (m *GetVersionFlowReq) String() string { return proto.CompactTextString(m) }
func (*GetVersionFlowReq) ProtoMessage()    {}
func (*GetVersionFlowReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{36}
}
func (m *GetVersionFlowReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVersionFlowReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVersionFlowReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVersionFlowReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionFlowReq.Merge(m, src)
}
func (m *GetVersionFlowReq) XXX_Size() int {
	return m.Size()
}
func (m *GetVersionFlowReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionFlowReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionFlowReq proto.InternalMessageInfo

type GetVersionFlowResp struct {
	Flows                []*Flow  `protobuf:"bytes,1,rep,name=flows,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVersionFlowResp) Reset()         { *m = GetVersionFlowResp{} }
func (m *GetVersionFlowResp) String() string { return proto.CompactTextString(m) }
func (*GetVersionFlowResp) ProtoMessage()    {}
func (*GetVersionFlowResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{37}
}
func (m *GetVersionFlowResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVersionFlowResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVersionFlowResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVersionFlowResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionFlowResp.Merge(m, src)
}
func (m *GetVersionFlowResp) XXX_Size() int {
	return m.Size()
}
func (m *GetVersionFlowResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionFlowResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionFlowResp proto.InternalMessageInfo

type GetConfigVersionUpgradeReq struct {
	TribeId              int64    `protobuf:"varint,1,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id"`
	Env                  string   `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env"`
	TribePackId          int64    `protobuf:"varint,3,opt,name=tribe_pack_id,json=tribePackId,proto3" json:"tribe_pack_id" form:"tribe_pack_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConfigVersionUpgradeReq) Reset()         { *m = GetConfigVersionUpgradeReq{} }
func (m *GetConfigVersionUpgradeReq) String() string { return proto.CompactTextString(m) }
func (*GetConfigVersionUpgradeReq) ProtoMessage()    {}
func (*GetConfigVersionUpgradeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{38}
}
func (m *GetConfigVersionUpgradeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigVersionUpgradeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigVersionUpgradeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigVersionUpgradeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigVersionUpgradeReq.Merge(m, src)
}
func (m *GetConfigVersionUpgradeReq) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigVersionUpgradeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigVersionUpgradeReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigVersionUpgradeReq proto.InternalMessageInfo

type GetConfigVersionUpgradeResp struct {
	ChosenVersionCode    []string `protobuf:"bytes,1,rep,name=chosen_version_code,json=chosenVersionCode,proto3" json:"chosen_version_code" form:"chosen_version_code"`
	StartingVersionCode  []string `protobuf:"bytes,2,rep,name=starting_version_code,json=startingVersionCode,proto3" json:"starting_version_code" form:"starting_version_code"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConfigVersionUpgradeResp) Reset()         { *m = GetConfigVersionUpgradeResp{} }
func (m *GetConfigVersionUpgradeResp) String() string { return proto.CompactTextString(m) }
func (*GetConfigVersionUpgradeResp) ProtoMessage()    {}
func (*GetConfigVersionUpgradeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{39}
}
func (m *GetConfigVersionUpgradeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigVersionUpgradeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigVersionUpgradeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigVersionUpgradeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigVersionUpgradeResp.Merge(m, src)
}
func (m *GetConfigVersionUpgradeResp) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigVersionUpgradeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigVersionUpgradeResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigVersionUpgradeResp proto.InternalMessageInfo

type ConfigPackUpgradeFilterReq struct {
	TribeId              int64       `protobuf:"varint,1,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id" validate:"required"`
	Env                  string      `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env" validate:"required"`
	TribePackId          int64       `protobuf:"varint,3,opt,name=tribe_pack_id,json=tribePackId,proto3" json:"tribe_pack_id" form:"tribe_pack_id" validate:"required"`
	Network              string      `protobuf:"bytes,4,opt,name=network,proto3" json:"network" form:"network"`
	Isp                  string      `protobuf:"bytes,5,opt,name=isp,proto3" json:"isp" form:"isp"`
	Channel              string      `protobuf:"bytes,6,opt,name=channel,proto3" json:"channel" form:"channel"`
	City                 string      `protobuf:"bytes,7,opt,name=city,proto3" json:"city" form:"city"`
	Type                 UpgradeType `protobuf:"varint,8,opt,name=type,proto3,enum=app.tribe.v1.UpgradeType" json:"type" form:"type"`
	AppKey               string      `protobuf:"bytes,10,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key" validate:"required"`
	Percent              int64       `protobuf:"varint,11,opt,name=percent,proto3" json:"percent" form:"percent"`
	DeviceId             string      `protobuf:"bytes,9,opt,name=device_id,json=deviceId,proto3" json:"device" form:"device"`
	ExcludesSystem       string      `protobuf:"bytes,12,opt,name=excludes_system,json=excludesSystem,proto3" json:"excludes_system" form:"excludes_system"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ConfigPackUpgradeFilterReq) Reset()         { *m = ConfigPackUpgradeFilterReq{} }
func (m *ConfigPackUpgradeFilterReq) String() string { return proto.CompactTextString(m) }
func (*ConfigPackUpgradeFilterReq) ProtoMessage()    {}
func (*ConfigPackUpgradeFilterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{40}
}
func (m *ConfigPackUpgradeFilterReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigPackUpgradeFilterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigPackUpgradeFilterReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigPackUpgradeFilterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigPackUpgradeFilterReq.Merge(m, src)
}
func (m *ConfigPackUpgradeFilterReq) XXX_Size() int {
	return m.Size()
}
func (m *ConfigPackUpgradeFilterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigPackUpgradeFilterReq.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigPackUpgradeFilterReq proto.InternalMessageInfo

type GetConfigPackUpgradeFilterResp struct {
	TribeId              int64       `protobuf:"varint,1,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id" validate:"required"`
	Env                  string      `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env" validate:"required"`
	BuildId              int64       `protobuf:"varint,3,opt,name=build_id,json=buildId,proto3" json:"build_id" form:"build_id" validate:"required"`
	Network              string      `protobuf:"bytes,4,opt,name=network,proto3" json:"network" form:"network"`
	Isp                  string      `protobuf:"bytes,5,opt,name=isp,proto3" json:"isp" form:"isp"`
	Channel              string      `protobuf:"bytes,6,opt,name=channel,proto3" json:"channel" form:"channel"`
	City                 string      `protobuf:"bytes,7,opt,name=city,proto3" json:"city" form:"city"`
	Type                 UpgradeType `protobuf:"varint,8,opt,name=type,proto3,enum=app.tribe.v1.UpgradeType" json:"type" form:"type"`
	Percent              int64       `protobuf:"varint,11,opt,name=percent,proto3" json:"percent" form:"percent"`
	DeviceId             string      `protobuf:"bytes,9,opt,name=device_id,json=deviceId,proto3" json:"device" form:"device"`
	Salt                 string      `protobuf:"bytes,12,opt,name=salt,proto3" json:"salt" form:"salt"`
	ExcludesSystem       string      `protobuf:"bytes,13,opt,name=excludes_system,json=excludesSystem,proto3" json:"excludes_system" form:"excludes_system"`
	Operator             string      `protobuf:"bytes,14,opt,name=operator,proto3" json:"operator" form:"operator"`
	Ctime                int64       `protobuf:"varint,15,opt,name=ctime,proto3" json:"ctime" form:"ctime"`
	Mtime                int64       `protobuf:"varint,16,opt,name=mtime,proto3" json:"mtime" form:"mtime"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetConfigPackUpgradeFilterResp) Reset()         { *m = GetConfigPackUpgradeFilterResp{} }
func (m *GetConfigPackUpgradeFilterResp) String() string { return proto.CompactTextString(m) }
func (*GetConfigPackUpgradeFilterResp) ProtoMessage()    {}
func (*GetConfigPackUpgradeFilterResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{41}
}
func (m *GetConfigPackUpgradeFilterResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigPackUpgradeFilterResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigPackUpgradeFilterResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigPackUpgradeFilterResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigPackUpgradeFilterResp.Merge(m, src)
}
func (m *GetConfigPackUpgradeFilterResp) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigPackUpgradeFilterResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigPackUpgradeFilterResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigPackUpgradeFilterResp proto.InternalMessageInfo

type EvolutionTribeReq struct {
	TribePackId          int64    `protobuf:"varint,1,opt,name=tribe_pack_id,json=tribePackId,proto3" json:"tribe_pack_id" form:"tribe_pack_id" validate:"required"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description" form:"description"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvolutionTribeReq) Reset()         { *m = EvolutionTribeReq{} }
func (m *EvolutionTribeReq) String() string { return proto.CompactTextString(m) }
func (*EvolutionTribeReq) ProtoMessage()    {}
func (*EvolutionTribeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{42}
}
func (m *EvolutionTribeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvolutionTribeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvolutionTribeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvolutionTribeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvolutionTribeReq.Merge(m, src)
}
func (m *EvolutionTribeReq) XXX_Size() int {
	return m.Size()
}
func (m *EvolutionTribeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EvolutionTribeReq.DiscardUnknown(m)
}

var xxx_messageInfo_EvolutionTribeReq proto.InternalMessageInfo

type GetConfigPackUpgradeFilterReq struct {
	TribeId              int64    `protobuf:"varint,1,opt,name=tribe_id,json=tribeId,proto3" json:"tribe_id" form:"tribe_id"`
	Env                  string   `protobuf:"bytes,2,opt,name=env,proto3" json:"env" form:"env"`
	TribePackId          int64    `protobuf:"varint,3,opt,name=tribe_pack_id,json=tribePackId,proto3" json:"tribe_pack_id" form:"tribe_pack_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConfigPackUpgradeFilterReq) Reset()         { *m = GetConfigPackUpgradeFilterReq{} }
func (m *GetConfigPackUpgradeFilterReq) String() string { return proto.CompactTextString(m) }
func (*GetConfigPackUpgradeFilterReq) ProtoMessage()    {}
func (*GetConfigPackUpgradeFilterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a645404a8b56032a, []int{43}
}
func (m *GetConfigPackUpgradeFilterReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigPackUpgradeFilterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigPackUpgradeFilterReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigPackUpgradeFilterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigPackUpgradeFilterReq.Merge(m, src)
}
func (m *GetConfigPackUpgradeFilterReq) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigPackUpgradeFilterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigPackUpgradeFilterReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigPackUpgradeFilterReq proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("app.tribe.v1.Sort", Sort_name, Sort_value)
	proto.RegisterEnum("app.tribe.v1.CallbackStatus", CallbackStatus_name, CallbackStatus_value)
	proto.RegisterEnum("app.tribe.v1.UpgradeType", UpgradeType_name, UpgradeType_value)
	proto.RegisterEnum("app.tribe.v1.ListTribeBuildPackReq_GitType", ListTribeBuildPackReq_GitType_name, ListTribeBuildPackReq_GitType_value)
	proto.RegisterEnum("app.tribe.v1.ListTribeBuildPackReq_OrderBy", ListTribeBuildPackReq_OrderBy_name, ListTribeBuildPackReq_OrderBy_value)
	proto.RegisterType((*GetPackRelationsReq)(nil), "app.tribe.v1.GetPackRelationsReq")
	proto.RegisterType((*GetPackRelationsResp)(nil), "app.tribe.v1.GetPackRelationsResp")
	proto.RegisterType((*Relation)(nil), "app.tribe.v1.Relation")
	proto.RegisterType((*GetTribeBuildPackReq)(nil), "app.tribe.v1.GetTribeBuildPackReq")
	proto.RegisterType((*GetTribeBuildPackResp)(nil), "app.tribe.v1.GetTribeBuildPackResp")
	proto.RegisterType((*TribeInfo)(nil), "app.tribe.v1.TribeInfo")
	proto.RegisterType((*PageInfo)(nil), "app.tribe.v1.PageInfo")
	proto.RegisterType((*GetTribeInfoReq)(nil), "app.tribe.v1.GetTribeInfoReq")
	proto.RegisterType((*GetTribeInfoResp)(nil), "app.tribe.v1.GetTribeInfoResp")
	proto.RegisterType((*ListTribeInfoReq)(nil), "app.tribe.v1.ListTribeInfoReq")
	proto.RegisterType((*ListTribeInfoResp)(nil), "app.tribe.v1.ListTribeInfoResp")
	proto.RegisterType((*DeleteTribeInfoReq)(nil), "app.tribe.v1.DeleteTribeInfoReq")
	proto.RegisterType((*UpdateTribeInfoReq)(nil), "app.tribe.v1.UpdateTribeInfoReq")
	proto.RegisterType((*AddTribeInfoReq)(nil), "app.tribe.v1.AddTribeInfoReq")
	proto.RegisterType((*AddTribeBuildPackReq)(nil), "app.tribe.v1.AddTribeBuildPackReq")
	proto.RegisterType((*ListTribeBuildPackReq)(nil), "app.tribe.v1.ListTribeBuildPackReq")
	proto.RegisterType((*ListTribeBuildPackResp)(nil), "app.tribe.v1.ListTribeBuildPackResp")
	proto.RegisterType((*TribeBuildPackInfo)(nil), "app.tribe.v1.TribeBuildPackInfo")
	proto.RegisterType((*GetTribeBuildPackInfoReq)(nil), "app.tribe.v1.GetTribeBuildPackInfoReq")
	proto.RegisterType((*GetTribeBuildPackInfoResp)(nil), "app.tribe.v1.GetTribeBuildPackInfoResp")
	proto.RegisterType((*PushTribeBuildPackToCDReq)(nil), "app.tribe.v1.PushTribeBuildPackToCDReq")
	proto.RegisterType((*UpdateTribeBuildPackGitInfoReq)(nil), "app.tribe.v1.UpdateTribeBuildPackGitInfoReq")
	proto.RegisterType((*UpdateTribeBuildPackPkgInfoReq)(nil), "app.tribe.v1.UpdateTribeBuildPackPkgInfoReq")
	proto.RegisterType((*UpdateTribeBuildPackPkgInfoResp)(nil), "app.tribe.v1.UpdateTribeBuildPackPkgInfoResp")
	proto.RegisterType((*CancelTribeBuildPackReq)(nil), "app.tribe.v1.CancelTribeBuildPackReq")
	proto.RegisterType((*ListTribePackReq)(nil), "app.tribe.v1.ListTribePackReq")
	proto.RegisterType((*ListTribePackResp)(nil), "app.tribe.v1.ListTribePackResp")
	proto.RegisterType((*VersionPack)(nil), "app.tribe.v1.VersionPack")
	proto.RegisterType((*ConfigVersionFlowReq)(nil), "app.tribe.v1.ConfigVersionFlowReq")
	proto.RegisterType((*Flow)(nil), "app.tribe.v1.Flow")
	proto.RegisterType((*ConfigVersionUpgradeReq)(nil), "app.tribe.v1.ConfigVersionUpgradeReq")
	proto.RegisterType((*VersionRange)(nil), "app.tribe.v1.VersionRange")
	proto.RegisterType((*BuildVersion)(nil), "app.tribe.v1.BuildVersion")
	proto.RegisterType((*PackInfo)(nil), "app.tribe.v1.PackInfo")
	proto.RegisterType((*VersionInfo)(nil), "app.tribe.v1.VersionInfo")
	proto.RegisterType((*ActiveVersionReq)(nil), "app.tribe.v1.ActiveVersionReq")
	proto.RegisterType((*GetVersionFlowReq)(nil), "app.tribe.v1.GetVersionFlowReq")
	proto.RegisterType((*GetVersionFlowResp)(nil), "app.tribe.v1.GetVersionFlowResp")
	proto.RegisterType((*GetConfigVersionUpgradeReq)(nil), "app.tribe.v1.GetConfigVersionUpgradeReq")
	proto.RegisterType((*GetConfigVersionUpgradeResp)(nil), "app.tribe.v1.GetConfigVersionUpgradeResp")
	proto.RegisterType((*ConfigPackUpgradeFilterReq)(nil), "app.tribe.v1.ConfigPackUpgradeFilterReq")
	proto.RegisterType((*GetConfigPackUpgradeFilterResp)(nil), "app.tribe.v1.GetConfigPackUpgradeFilterResp")
	proto.RegisterType((*EvolutionTribeReq)(nil), "app.tribe.v1.EvolutionTribeReq")
	proto.RegisterType((*GetConfigPackUpgradeFilterReq)(nil), "app.tribe.v1.GetConfigPackUpgradeFilterReq")
}

func init() {
	proto.RegisterFile("go-gateway/app/app-svr/fawkes/service/api/app/tribe/tribe.proto", fileDescriptor_a645404a8b56032a)
}

var fileDescriptor_a645404a8b56032a = []byte{
	// 4787 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5c, 0x4d, 0x6c, 0x1c, 0x47,
	0x76, 0x56, 0xcf, 0xff, 0x14, 0xff, 0x86, 0x45, 0x89, 0x1a, 0x51, 0x12, 0x9b, 0x2e, 0x45, 0x96,
	0x64, 0x59, 0x64, 0x4c, 0xd9, 0xd2, 0xae, 0x9c, 0x5d, 0x41, 0xa4, 0x25, 0x9a, 0x5a, 0x4b, 0x96,
	0x5b, 0xb2, 0x01, 0xc7, 0x01, 0x26, 0xcd, 0xe9, 0xe6, 0xb0, 0x97, 0x33, 0xdd, 0xed, 0xee, 0x1e,
	0x52, 0x74, 0x90, 0xcb, 0xee, 0x2d, 0xd8, 0xf8, 0x90, 0x05, 0xf2, 0xb3, 0xc8, 0x21, 0x08, 0x92,
	0x43, 0x90, 0x00, 0x49, 0x90, 0x1c, 0xf6, 0x10, 0x20, 0x87, 0x1c, 0xb2, 0xc7, 0x05, 0xf6, 0xb2,
	0xa7, 0x4e, 0xe2, 0x04, 0x09, 0x40, 0xe4, 0x34, 0x49, 0xce, 0x1b, 0xd4, 0xab, 0xea, 0xae, 0xea,
	0x9e, 0x1f, 0xcd, 0x0f, 0x6d, 0x6f, 0xb2, 0x5e, 0x60, 0x2d, 0xd6, 0x57, 0x5d, 0xaf, 0x5e, 0x57,
	0xbd, 0xf7, 0xea, 0x7b, 0x55, 0xd5, 0x83, 0xee, 0x36, 0x9c, 0x1b, 0x0d, 0x3d, 0x30, 0x0f, 0xf5,
	0xa3, 0x35, 0xdd, 0x75, 0xe9, 0xff, 0x6f, 0xf8, 0x07, 0xde, 0xda, 0xae, 0x7e, 0xb8, 0x6f, 0xfa,
	0x6b, 0xbe, 0xe9, 0x1d, 0x58, 0x75, 0x73, 0x4d, 0x77, 0x2d, 0xa8, 0x0e, 0x3c, 0x6b, 0xc7, 0x64,
	0xff, 0x5d, 0x75, 0x3d, 0x27, 0x70, 0xf0, 0xb4, 0xee, 0xba, 0xab, 0x0c, 0x38, 0x78, 0x6d, 0xe9,
	0x46, 0xc3, 0x0a, 0xf6, 0xda, 0x3b, 0xab, 0x75, 0xa7, 0xb5, 0xd6, 0x70, 0x1a, 0xce, 0x1a, 0x3c,
	0xb4, 0xd3, 0xde, 0x85, 0x12, 0x14, 0xe0, 0x2f, 0xd6, 0x78, 0xe9, 0x42, 0xc3, 0x71, 0x1a, 0x4d,
	0x2e, 0xde, 0xb6, 0x9d, 0x40, 0x0f, 0x2c, 0xc7, 0xf6, 0x79, 0xed, 0x79, 0x5e, 0x1b, 0xcb, 0x30,
	0x5b, 0x6e, 0x70, 0xc4, 0x2a, 0xc9, 0x0f, 0x14, 0xb4, 0xb0, 0x65, 0x06, 0x4f, 0xf4, 0xfa, 0xbe,
	0x66, 0x36, 0x59, 0x3b, 0xcd, 0xfc, 0x18, 0x3f, 0x44, 0x45, 0xdd, 0x75, 0x6b, 0xfb, 0xe6, 0x51,
	0x55, 0x59, 0x51, 0xae, 0x96, 0x37, 0x5e, 0x3b, 0x0e, 0xd5, 0x08, 0xea, 0x84, 0x2a, 0xd9, 0x75,
	0xbc, 0xd6, 0x1d, 0xc2, 0x01, 0xb2, 0x72, 0xa0, 0x37, 0x2d, 0x43, 0x0f, 0xcc, 0x3b, 0xc4, 0x33,
	0x3f, 0x6e, 0x5b, 0x9e, 0x69, 0x10, 0xad, 0xa0, 0xbb, 0xee, 0xb7, 0xcc, 0x23, 0x7c, 0x1b, 0x15,
	0x77, 0x4d, 0x3d, 0x68, 0x7b, 0x66, 0x35, 0x03, 0xb2, 0x2e, 0x52, 0x59, 0x1c, 0xea, 0x84, 0xea,
	0x2c, 0x93, 0xc5, 0x01, 0xa2, 0x45, 0x55, 0xa4, 0x81, 0x4e, 0x77, 0xeb, 0xe6, 0xbb, 0xf8, 0x5d,
	0x54, 0xf6, 0x22, 0xa0, 0xaa, 0xac, 0x64, 0xaf, 0x4e, 0xad, 0x2f, 0xae, 0xca, 0x03, 0xb8, 0x1a,
	0x3d, 0xbf, 0x71, 0xee, 0x38, 0x54, 0xf3, 0x56, 0x60, 0xb6, 0xfc, 0x4e, 0xa8, 0x4e, 0xb3, 0x8e,
	0xa0, 0x48, 0x34, 0x21, 0x83, 0xfc, 0x20, 0x83, 0x4a, 0x51, 0x13, 0x7c, 0x09, 0x65, 0x2c, 0x03,
	0xde, 0x3a, 0xbb, 0xb1, 0x70, 0x1c, 0xaa, 0x19, 0xcb, 0xe8, 0x84, 0x6a, 0x99, 0xb7, 0x35, 0x88,
	0x96, 0xb1, 0x0c, 0xfc, 0x21, 0xaa, 0xd4, 0xdb, 0x9e, 0x67, 0xda, 0x41, 0x6d, 0xa7, 0x6d, 0x35,
	0x8d, 0x9a, 0x65, 0xc0, 0xcb, 0x65, 0x37, 0xd6, 0x8e, 0x43, 0xb5, 0xab, 0xae, 0x13, 0xaa, 0x67,
	0x99, 0x80, 0x74, 0x0d, 0xd1, 0x66, 0x39, 0xb4, 0x41, 0x91, 0x6d, 0x03, 0xbf, 0x8f, 0xe6, 0x5c,
	0x3d, 0x29, 0x39, 0x0b, 0x92, 0x6f, 0x1c, 0x87, 0x6a, 0xba, 0xaa, 0x13, 0xaa, 0x8b, 0x4c, 0x70,
	0xaa, 0x82, 0x68, 0x33, 0x0c, 0x89, 0xc4, 0x4a, 0xb3, 0x90, 0x1b, 0x69, 0x16, 0xfe, 0x38, 0x0f,
	0xd3, 0xf0, 0x8c, 0x8e, 0x2d, 0x08, 0x63, 0x13, 0x72, 0xb2, 0x36, 0x72, 0x0b, 0x15, 0x2d, 0xa3,
	0x16, 0x1c, 0xb9, 0x26, 0x1f, 0x46, 0xd0, 0x8e, 0x43, 0x42, 0x3b, 0x0e, 0x10, 0xad, 0x60, 0x19,
	0xcf, 0x8e, 0x5c, 0x13, 0xdf, 0x47, 0x33, 0x0d, 0x2b, 0x68, 0xea, 0x3b, 0xb5, 0x6f, 0x3b, 0x3b,
	0x62, 0xa8, 0x5e, 0x3a, 0x0e, 0xd5, 0x72, 0xa3, 0xc9, 0xc1, 0x4e, 0xa8, 0x56, 0x58, 0xfb, 0x18,
	0x22, 0xda, 0x14, 0x6b, 0xf7, 0xd0, 0xd9, 0xd9, 0x36, 0xf0, 0x1d, 0x54, 0x72, 0xf7, 0x1b, 0xac,
	0xff, 0x1c, 0x48, 0x50, 0x8f, 0x43, 0x35, 0xc6, 0x3a, 0xa1, 0x3a, 0xc7, 0x47, 0x99, 0x23, 0x44,
	0x2b, 0xba, 0xfb, 0x0d, 0x50, 0xe1, 0x26, 0x2a, 0xf8, 0x81, 0x1e, 0xb4, 0xfd, 0x6a, 0x1e, 0x5a,
	0x9e, 0x3f, 0x0e, 0x55, 0x8e, 0x74, 0x42, 0x75, 0x86, 0xb5, 0x63, 0x65, 0xa2, 0xf1, 0x0a, 0xda,
	0x61, 0xc3, 0x0a, 0x58, 0x87, 0x05, 0xd1, 0x61, 0x84, 0x89, 0x0e, 0x23, 0x84, 0x68, 0xc5, 0x86,
	0x15, 0x40, 0x87, 0x0f, 0x10, 0xd5, 0x9d, 0x8e, 0xe9, 0xa1, 0xe3, 0x19, 0xd5, 0x22, 0x8c, 0xfd,
	0xe5, 0xe3, 0x50, 0x95, 0xe1, 0x4e, 0xa8, 0x62, 0x21, 0x81, 0x83, 0x44, 0x43, 0x0d, 0x2b, 0xf8,
	0x16, 0x2b, 0xe0, 0x37, 0x51, 0xc9, 0x71, 0x4d, 0x4f, 0x0f, 0x1c, 0xaf, 0x5a, 0x02, 0x21, 0xa0,
	0x43, 0x84, 0x09, 0x1d, 0x22, 0x84, 0x68, 0x71, 0x25, 0xde, 0x44, 0x79, 0xc7, 0x33, 0x4c, 0xaf,
	0x5a, 0x5e, 0x51, 0xae, 0xce, 0xae, 0xe3, 0xa4, 0xff, 0x3d, 0x75, 0xbc, 0x80, 0xf9, 0x1e, 0x3c,
	0x24, 0x7c, 0x0f, 0x8a, 0x44, 0x63, 0x30, 0x75, 0x35, 0xd7, 0xae, 0x22, 0xe1, 0x6a, 0xae, 0x2d,
	0x5c, 0xcd, 0xb5, 0x89, 0x96, 0x71, 0xc1, 0x1f, 0x5d, 0xbf, 0x3a, 0x25, 0x3d, 0xe4, 0x4b, 0x0f,
	0xf9, 0xf4, 0x21, 0x9f, 0xfc, 0xa5, 0x82, 0xce, 0xf4, 0x30, 0x52, 0xdf, 0xc5, 0x9b, 0x28, 0xe7,
	0xea, 0x0d, 0x13, 0x4c, 0xb4, 0x2b, 0x4e, 0x3c, 0xd1, 0x1b, 0xe6, 0xb6, 0xbd, 0xeb, 0x6c, 0x9c,
	0x3d, 0x0e, 0x55, 0x78, 0xae, 0x13, 0xaa, 0x53, 0x91, 0x43, 0x35, 0x4c, 0xa2, 0x01, 0x88, 0xdf,
	0x43, 0x2c, 0x88, 0x54, 0x33, 0x10, 0x6d, 0x56, 0x92, 0x52, 0x92, 0xbd, 0x82, 0xbc, 0x01, 0x71,
	0x87, 0xc1, 0xe4, 0xbb, 0x39, 0x54, 0x86, 0x86, 0xf4, 0xf9, 0xe1, 0x82, 0xce, 0x2d, 0xe1, 0x70,
	0x52, 0x20, 0x15, 0x0e, 0x37, 0x9b, 0x74, 0xb8, 0xd8, 0xb9, 0xae, 0xa3, 0x9c, 0xad, 0xb7, 0x4c,
	0xf0, 0x8d, 0x32, 0x7b, 0x55, 0x5a, 0x16, 0xaf, 0x4a, 0x4b, 0x44, 0x03, 0x10, 0xaf, 0xa3, 0x42,
	0xbd, 0x06, 0x8f, 0xb3, 0x30, 0x01, 0xe6, 0xcc, 0x10, 0x61, 0xce, 0xac, 0x4c, 0xb4, 0x7c, 0xfd,
	0x31, 0x6d, 0x73, 0x13, 0x15, 0x9c, 0x43, 0xdb, 0xf4, 0x98, 0x0b, 0xf0, 0x36, 0x0c, 0x11, 0x6d,
	0x58, 0x99, 0x68, 0xbc, 0x02, 0x6f, 0xa1, 0x29, 0xc3, 0xf4, 0xeb, 0x9e, 0xe5, 0xd2, 0xb0, 0x0b,
	0x5e, 0xc0, 0xcd, 0x58, 0x82, 0x85, 0x19, 0x4b, 0x20, 0xd1, 0xe4, 0x47, 0xe8, 0xb0, 0xd8, 0x4e,
	0x6d, 0xcf, 0xf1, 0x03, 0xf0, 0x85, 0x12, 0x1b, 0x16, 0x0e, 0x89, 0x61, 0xe1, 0x00, 0xd1, 0x0a,
	0xb6, 0xf3, 0xb6, 0xe3, 0x07, 0xd4, 0xfe, 0x5d, 0xcf, 0x72, 0x3c, 0x2b, 0x38, 0x02, 0xfb, 0x8f,
	0x9c, 0x9e, 0x63, 0x92, 0xd3, 0x73, 0x84, 0x68, 0x71, 0x25, 0xbe, 0x8f, 0xa6, 0x2c, 0x3f, 0x8a,
	0xb6, 0x36, 0x78, 0x41, 0x89, 0x69, 0x2f, 0xc1, 0x42, 0x7b, 0x09, 0x24, 0x5a, 0xd9, 0xf2, 0x59,
	0x54, 0xb6, 0xc9, 0x47, 0xa8, 0x14, 0xd9, 0x20, 0x56, 0x51, 0x3e, 0x70, 0x02, 0xbd, 0xc9, 0xcd,
	0xa0, 0x4c, 0x4d, 0x08, 0x00, 0x8d, 0xfd, 0x83, 0x17, 0xc1, 0x5d, 0x58, 0x7c, 0x2c, 0x30, 0x77,
	0x01, 0x0f, 0x59, 0x04, 0x0f, 0xc9, 0x4a, 0xb8, 0x0f, 0x4e, 0xf1, 0x10, 0xcd, 0x45, 0x3e, 0x41,
	0x3b, 0xa0, 0x31, 0xfb, 0xb6, 0x64, 0x67, 0x57, 0x62, 0x3b, 0xbb, 0x18, 0xdb, 0x59, 0xcf, 0x20,
	0x9d, 0xb1, 0x0c, 0xe2, 0xa0, 0x4a, 0x52, 0x96, 0xef, 0xe2, 0x8f, 0x10, 0x02, 0x1f, 0xa8, 0x59,
	0xf6, 0xae, 0xc3, 0x1d, 0xec, 0x6c, 0x0f, 0xd7, 0x00, 0x8f, 0xb8, 0x74, 0x1c, 0xaa, 0xd2, 0xe3,
	0x9d, 0x50, 0x9d, 0x67, 0xbd, 0x0a, 0x8c, 0x68, 0xe5, 0x20, 0x7a, 0x9e, 0xfc, 0x8f, 0x82, 0x2a,
	0xef, 0x58, 0x7e, 0x52, 0xfd, 0x5b, 0xe9, 0x25, 0x67, 0x44, 0x0f, 0xc8, 0x8c, 0xe6, 0x01, 0xd9,
	0xa1, 0x3d, 0x80, 0x05, 0xa9, 0xdc, 0xc0, 0x20, 0xc5, 0xc3, 0x5d, 0x7e, 0x60, 0xb8, 0x23, 0x7f,
	0xab, 0xa0, 0xf9, 0xd4, 0x7b, 0xfb, 0x2e, 0x7e, 0x07, 0x95, 0x69, 0x20, 0x92, 0x47, 0x7a, 0xe4,
	0x50, 0x56, 0x72, 0x23, 0x4b, 0x7b, 0x2f, 0x31, 0x71, 0x2c, 0xa6, 0xf5, 0x9d, 0xb8, 0x41, 0x14,
	0x4a, 0x4c, 0xd7, 0x23, 0x84, 0xdf, 0x32, 0x9b, 0x66, 0x60, 0x9e, 0x8c, 0xb9, 0x7d, 0x2f, 0x87,
	0xf0, 0xfb, 0x2e, 0xad, 0x49, 0xc8, 0xfb, 0x2a, 0x4c, 0xfe, 0x62, 0x86, 0xc9, 0xef, 0xe5, 0xd0,
	0xdc, 0x3d, 0xc3, 0x48, 0xd8, 0xc2, 0x49, 0xd2, 0xcf, 0xbb, 0x89, 0xf8, 0x70, 0x5d, 0x9a, 0x7a,
	0x55, 0x9a, 0xfa, 0x9e, 0x22, 0xc6, 0x8f, 0x19, 0xc2, 0x1c, 0x72, 0x63, 0x9b, 0x43, 0xfe, 0x24,
	0xcc, 0xa1, 0x30, 0xae, 0x39, 0x14, 0x27, 0x34, 0x87, 0xd2, 0x98, 0xe6, 0xf0, 0xd3, 0x1c, 0x3a,
	0x1d, 0x99, 0x43, 0x22, 0x25, 0x79, 0x8c, 0x4a, 0x3c, 0xb0, 0x45, 0x51, 0xe2, 0x26, 0x55, 0x2e,
	0xc2, 0x3a, 0xa1, 0x7a, 0x29, 0xb1, 0xe8, 0xf4, 0x89, 0x40, 0x45, 0x16, 0xd7, 0x92, 0x79, 0x41,
	0x66, 0xc4, 0xbc, 0x40, 0xa6, 0xf8, 0xd9, 0x11, 0x29, 0xfe, 0x63, 0xd6, 0x56, 0x8a, 0x2f, 0x37,
	0xa3, 0xb6, 0xdc, 0xa4, 0x2e, 0x89, 0xb6, 0xfd, 0x6d, 0x93, 0xca, 0x03, 0x53, 0xbb, 0x87, 0x50,
	0xdd, 0xaa, 0x99, 0xf6, 0x41, 0xed, 0x40, 0xf7, 0xb8, 0xd1, 0xc0, 0x82, 0x2c, 0x50, 0xb1, 0x20,
	0x0b, 0x8c, 0x68, 0xa5, 0xba, 0x75, 0xdf, 0x3e, 0xf8, 0x40, 0xf7, 0x4e, 0x2e, 0x0e, 0x3d, 0x46,
	0x33, 0xfe, 0x9e, 0xd3, 0x6e, 0x1a, 0x35, 0xdb, 0x09, 0xac, 0xdd, 0x23, 0x1e, 0x8d, 0xae, 0x1d,
	0x87, 0x6a, 0xb2, 0xa2, 0x13, 0xaa, 0xa7, 0x79, 0xf6, 0x24, 0xc3, 0x44, 0x9b, 0x66, 0xe5, 0xc7,
	0x50, 0xc4, 0xef, 0xa0, 0x19, 0xc3, 0x74, 0x6b, 0x71, 0x6a, 0xc7, 0x83, 0x14, 0xc8, 0x4b, 0x54,
	0x08, 0x79, 0x09, 0x98, 0x68, 0xc8, 0x30, 0xdd, 0xad, 0x26, 0x64, 0x82, 0xe4, 0x1f, 0x4b, 0xe8,
	0x4c, 0xbc, 0xfc, 0x26, 0x6c, 0xeb, 0x1b, 0x48, 0x64, 0x94, 0xdc, 0xb8, 0x86, 0x48, 0x33, 0x8b,
	0x0d, 0x26, 0xb8, 0x5b, 0xcd, 0xe9, 0x09, 0xd4, 0xec, 0x32, 0xcc, 0xfc, 0x58, 0x09, 0x6b, 0x16,
	0x5a, 0x0e, 0x95, 0xb0, 0xae, 0xa1, 0x3c, 0xfd, 0xcb, 0xac, 0xce, 0x42, 0x1b, 0x20, 0x05, 0x00,
	0x08, 0x52, 0x00, 0x45, 0xa2, 0x31, 0x18, 0x37, 0x24, 0xf3, 0xcf, 0x41, 0x8e, 0x78, 0x3d, 0xc9,
	0x30, 0x7a, 0x8e, 0xf2, 0xea, 0x16, 0xf3, 0x80, 0x11, 0x7c, 0xe5, 0x26, 0x2a, 0xd4, 0x9d, 0x56,
	0xcb, 0x0a, 0xaa, 0x33, 0x52, 0xe8, 0x05, 0x44, 0x0a, 0xbd, 0x50, 0x26, 0x1a, 0xaf, 0x88, 0x9c,
	0x13, 0x1c, 0x2c, 0x2f, 0x72, 0x5f, 0xc9, 0xc1, 0xe6, 0x52, 0x0e, 0x26, 0x9c, 0x49, 0xce, 0x9b,
	0x0b, 0xa3, 0xe6, 0xcd, 0x77, 0xa4, 0x08, 0x25, 0x85, 0x4f, 0x29, 0x42, 0xcd, 0xa5, 0x22, 0x94,
	0x88, 0x46, 0x0d, 0x54, 0x82, 0xbc, 0xb9, 0xb6, 0xc3, 0x56, 0xe2, 0x21, 0x87, 0xf4, 0x5d, 0xda,
	0x66, 0xe3, 0x88, 0x6b, 0xc9, 0x05, 0x48, 0x5a, 0x72, 0x84, 0x68, 0x45, 0x87, 0x3d, 0x49, 0x97,
	0x43, 0xdf, 0xf1, 0x82, 0x01, 0xb9, 0x3d, 0xb0, 0x23, 0xfa, 0x8c, 0x60, 0x47, 0xb4, 0x44, 0x34,
	0x00, 0x4f, 0x2e, 0xb1, 0x97, 0xc9, 0xdc, 0xdc, 0x28, 0x64, 0xee, 0x16, 0x2a, 0xba, 0x6d, 0x7f,
	0xaf, 0x56, 0x37, 0xaa, 0x15, 0xd1, 0x8e, 0x43, 0xa2, 0x1d, 0x07, 0x88, 0x56, 0xa0, 0x7f, 0x6d,
	0x1a, 0xe4, 0x15, 0x54, 0xe4, 0x26, 0x88, 0x11, 0x2a, 0x6c, 0x68, 0xf7, 0x1e, 0x6f, 0xbe, 0x5d,
	0x39, 0x85, 0x8b, 0x28, 0xfb, 0xec, 0xde, 0x56, 0x45, 0xa1, 0xe0, 0xe6, 0xbb, 0x8f, 0x1e, 0x6d,
	0x3f, 0xab, 0x64, 0xc8, 0x05, 0x54, 0xe4, 0x63, 0x8b, 0xcb, 0x28, 0xbf, 0xf9, 0x6c, 0xfb, 0xd1,
	0xfd, 0xca, 0x29, 0x5c, 0x40, 0x99, 0xed, 0xb7, 0x2a, 0x0a, 0xf9, 0xa9, 0x82, 0x16, 0x7b, 0x4d,
	0x88, 0xef, 0x62, 0x17, 0x2d, 0xb2, 0xe9, 0x65, 0xab, 0x9b, 0xab, 0xd7, 0xf7, 0x81, 0x8a, 0x47,
	0xbb, 0x99, 0x13, 0xed, 0x2f, 0x2c, 0x04, 0x5d, 0x8f, 0xfb, 0xc9, 0xfc, 0x21, 0x33, 0x61, 0xfe,
	0x40, 0xfe, 0xae, 0x82, 0x70, 0xb7, 0x52, 0xc3, 0xb1, 0x73, 0xd9, 0x01, 0x32, 0x23, 0x3a, 0x40,
	0x22, 0x04, 0x67, 0x27, 0x0f, 0xc1, 0xb9, 0x49, 0x42, 0xf0, 0x3a, 0xa2, 0xb6, 0x46, 0xc5, 0x48,
	0x6c, 0x9e, 0x21, 0x22, 0xee, 0xb0, 0x32, 0xd1, 0xf2, 0xba, 0xeb, 0x6e, 0x27, 0x52, 0x93, 0xc2,
	0x28, 0xd6, 0xcc, 0xc3, 0x95, 0xab, 0x07, 0x7b, 0x7c, 0xbf, 0x2f, 0x0e, 0x57, 0x14, 0x4b, 0x86,
	0x2b, 0x8a, 0xb0, 0x70, 0xf5, 0x44, 0x0f, 0xf6, 0x12, 0x3c, 0xa4, 0x24, 0x96, 0x8a, 0xa1, 0x62,
	0xab, 0x1c, 0x26, 0xcb, 0x23, 0x86, 0x49, 0x11, 0x97, 0xd1, 0x48, 0x71, 0x39, 0x5e, 0xd7, 0xa6,
	0x46, 0x5c, 0xd7, 0xe4, 0xb8, 0x3c, 0x3d, 0x6a, 0x5c, 0xbe, 0x8e, 0x72, 0xbe, 0xf5, 0x89, 0x09,
	0x6b, 0x48, 0x96, 0x87, 0x37, 0xeb, 0x13, 0xc9, 0x07, 0x68, 0x89, 0x86, 0x37, 0xeb, 0x13, 0x13,
	0x5f, 0x41, 0xd9, 0x96, 0xf1, 0x06, 0x2c, 0x85, 0xe5, 0x8d, 0x33, 0xc7, 0xa1, 0x4a, 0x8b, 0x9d,
	0x50, 0x45, 0xec, 0xd1, 0x96, 0xf1, 0x06, 0xd1, 0x28, 0x14, 0xbd, 0x0e, 0xcc, 0xdb, 0x9c, 0x50,
	0x29, 0xc2, 0x92, 0xaf, 0xc3, 0xe7, 0xcd, 0xdd, 0x6f, 0xc0, 0xbc, 0xd1, 0x08, 0xb6, 0xdf, 0xa8,
	0xb5, 0xbd, 0x66, 0x22, 0x82, 0x31, 0x48, 0x8a, 0x60, 0x0c, 0xa0, 0x11, 0x6c, 0xbf, 0xf1, 0xbe,
	0xd7, 0xc4, 0x0f, 0xd0, 0x54, 0x4b, 0x77, 0x5d, 0xcb, 0x66, 0x6d, 0xe7, 0x05, 0x51, 0x93, 0x60,
	0x41, 0xd4, 0x24, 0x90, 0x68, 0x88, 0x97, 0xa8, 0x9c, 0x5b, 0xa8, 0xb8, 0xb3, 0xe3, 0x81, 0x0c,
	0x2c, 0xfa, 0xe7, 0x90, 0xe8, 0x9f, 0x03, 0x44, 0x2b, 0xec, 0xec, 0x78, 0xb4, 0x5d, 0xcc, 0x14,
	0x16, 0x86, 0x64, 0x0a, 0x82, 0x8f, 0x9c, 0x1e, 0x9e, 0x8f, 0xdc, 0x41, 0x25, 0xc3, 0x32, 0x6a,
	0x34, 0x6a, 0x57, 0xcf, 0x08, 0x43, 0x89, 0x30, 0x31, 0xb2, 0x11, 0x42, 0xb4, 0xa2, 0x61, 0x19,
	0x4f, 0xda, 0xfe, 0x1e, 0xde, 0x40, 0xa8, 0xbe, 0xa7, 0xdb, 0x0d, 0xb3, 0xd6, 0x74, 0x1a, 0xd5,
	0x45, 0x89, 0x0d, 0xc7, 0xa8, 0xc4, 0x86, 0x63, 0x8c, 0x68, 0x65, 0x56, 0x78, 0xc7, 0x69, 0xe0,
	0x87, 0x68, 0x9a, 0xd1, 0xd1, 0x5a, 0xc3, 0x73, 0xda, 0x6e, 0xf5, 0x2c, 0x90, 0xd8, 0x2b, 0xc7,
	0xa1, 0x9a, 0xc0, 0x3b, 0xa1, 0xba, 0x10, 0x25, 0x52, 0x02, 0x25, 0xda, 0x14, 0x2b, 0x6e, 0xd1,
	0x12, 0xcd, 0x8a, 0x04, 0xe7, 0xf6, 0xab, 0x55, 0x31, 0x63, 0x12, 0x2c, 0x66, 0x4c, 0x02, 0xa9,
	0x4a, 0x9c, 0xa0, 0xfb, 0xf8, 0x43, 0x54, 0x61, 0xeb, 0x89, 0x1f, 0xe8, 0x5e, 0x50, 0x0b, 0xac,
	0x96, 0x59, 0x3d, 0x27, 0xce, 0xa4, 0xd2, 0x75, 0xe2, 0x4c, 0x2a, 0x5d, 0x43, 0xb4, 0x59, 0x80,
	0x9e, 0x52, 0xe4, 0x99, 0xd5, 0x32, 0xf1, 0x7b, 0x88, 0x21, 0x35, 0xd3, 0x36, 0x98, 0xe0, 0x25,
	0x10, 0x4c, 0x33, 0xe5, 0x54, 0x4d, 0x27, 0x54, 0xcf, 0xc8, 0x62, 0x23, 0x9c, 0x68, 0xd3, 0x00,
	0xdc, 0xb7, 0x0d, 0x10, 0x99, 0xca, 0x27, 0xce, 0x8f, 0x9d, 0x4f, 0xac, 0xa1, 0x7c, 0x1d, 0x54,
	0xba, 0x00, 0x2a, 0x81, 0xbd, 0xd5, 0xb9, 0x26, 0xdc, 0xde, 0xea, 0x4c, 0x01, 0x06, 0xd3, 0x06,
	0x2d, 0x68, 0x70, 0x51, 0x34, 0x68, 0x25, 0x1b, 0xb4, 0x78, 0x03, 0xf8, 0x97, 0x7a, 0x82, 0xe9,
	0x79, 0xb5, 0x96, 0xdf, 0xa8, 0x2e, 0x0b, 0x4f, 0xe0, 0x90, 0xf0, 0x04, 0x0e, 0x10, 0xad, 0x60,
	0x7a, 0xde, 0x23, 0xbf, 0x41, 0xdb, 0xd1, 0x85, 0x83, 0x7a, 0x90, 0x2a, 0xda, 0x71, 0x48, 0xb4,
	0xe3, 0x00, 0xd1, 0x0a, 0xdf, 0x76, 0x76, 0xa8, 0x07, 0x3d, 0x44, 0xd3, 0x07, 0xa6, 0xe7, 0x5b,
	0x8e, 0x5d, 0xab, 0x3b, 0x86, 0x59, 0x5d, 0x89, 0xf7, 0xcf, 0x12, 0xb8, 0xb0, 0x2d, 0x19, 0x25,
	0xda, 0x14, 0x2f, 0x6e, 0x3a, 0x86, 0x29, 0xcb, 0x82, 0x28, 0xfe, 0x12, 0x28, 0x92, 0x90, 0xc5,
	0x23, 0x79, 0x4a, 0x16, 0x8b, 0xe6, 0x91, 0x2c, 0x88, 0xe8, 0x0f, 0xe8, 0x94, 0xb9, 0xb5, 0xe8,
	0x18, 0x91, 0xc8, 0x53, 0x16, 0xc3, 0xf2, 0x94, 0xc5, 0x20, 0x5b, 0x39, 0x1f, 0xf0, 0xc2, 0x53,
	0x54, 0xed, 0x3a, 0xab, 0x99, 0x78, 0xc7, 0xf0, 0x2f, 0x14, 0x74, 0xae, 0x8f, 0x54, 0xdf, 0xc5,
	0x9f, 0x2a, 0xe8, 0x4c, 0x4f, 0xca, 0xc5, 0x37, 0x53, 0x5f, 0xcc, 0xb8, 0xbe, 0x7e, 0x1c, 0xaa,
	0xbd, 0x45, 0x74, 0x42, 0xf5, 0x82, 0x4c, 0x59, 0x52, 0xd5, 0x44, 0xc3, 0xdd, 0x8c, 0x8c, 0xfc,
	0x93, 0x82, 0xce, 0xd1, 0x60, 0x94, 0xec, 0xe9, 0x99, 0xb3, 0xf9, 0x16, 0x1d, 0x85, 0xe7, 0x68,
	0xa1, 0x5b, 0x56, 0x34, 0x2c, 0xdb, 0xc7, 0xa1, 0xda, 0xab, 0xba, 0x13, 0xaa, 0xab, 0xfd, 0xf4,
	0xe8, 0x33, 0x70, 0x95, 0x94, 0x66, 0x06, 0x7e, 0x3b, 0xe9, 0x96, 0x6c, 0x43, 0xec, 0xe5, 0x6e,
	0xb7, 0x5c, 0xe8, 0x76, 0xcb, 0x95, 0x84, 0x5f, 0x92, 0x7f, 0xcf, 0xa1, 0x65, 0x69, 0x0b, 0x37,
	0xee, 0x64, 0xcb, 0x0a, 0xa2, 0xc9, 0xfe, 0xf2, 0x5e, 0xf3, 0xbd, 0x78, 0xcd, 0xc9, 0x40, 0x8e,
	0x73, 0x21, 0x39, 0xff, 0x9b, 0x7a, 0xb3, 0xb9, 0xa3, 0xd7, 0xf7, 0x9f, 0xc2, 0x33, 0xc3, 0xad,
	0x48, 0x8f, 0x7a, 0x1f, 0x45, 0x03, 0xbb, 0x4c, 0x54, 0x08, 0x76, 0x99, 0x80, 0xbb, 0x8f, 0xa4,
	0x63, 0xca, 0x97, 0x1b, 0x91, 0xf2, 0x09, 0xea, 0x95, 0x1f, 0x9e, 0x7a, 0xf5, 0x5a, 0x3e, 0x0a,
	0x27, 0xb3, 0x7c, 0xfc, 0x1a, 0x9a, 0x07, 0x22, 0x9d, 0x18, 0x1e, 0x96, 0xfd, 0xbe, 0x76, 0x1c,
	0xaa, 0xdd, 0x95, 0x9d, 0x50, 0xad, 0x4a, 0x04, 0x3c, 0x39, 0x4c, 0xb3, 0x94, 0x84, 0x8b, 0x91,
	0x22, 0xff, 0x51, 0xe8, 0x6d, 0x68, 0x4f, 0xf6, 0x1b, 0xff, 0x2f, 0x0d, 0xed, 0x3a, 0xca, 0xed,
	0x5a, 0x4d, 0xb6, 0xa9, 0x38, 0xcd, 0xa8, 0x2a, 0x2d, 0x0b, 0xaa, 0x4a, 0x4b, 0x44, 0x03, 0x30,
	0xc5, 0x75, 0x72, 0x63, 0x71, 0x1d, 0x99, 0xc5, 0x4a, 0x9b, 0x25, 0xba, 0xbb, 0x9f, 0x32, 0xc5,
	0x08, 0x91, 0x58, 0xec, 0x43, 0x34, 0x1d, 0x31, 0x4c, 0x68, 0x5f, 0x10, 0xeb, 0x8f, 0x8c, 0x8b,
	0x88, 0x22, 0xa3, 0x44, 0x8b, 0x38, 0x6b, 0x94, 0xc9, 0x50, 0xb6, 0x99, 0xce, 0x82, 0x22, 0x4c,
	0xe8, 0x11, 0x21, 0x44, 0xa3, 0x7c, 0x15, 0xda, 0x76, 0x33, 0x98, 0xd2, 0xa4, 0x0c, 0x26, 0xbd,
	0x4c, 0x97, 0x4f, 0x70, 0x99, 0x9e, 0x9e, 0x60, 0x99, 0x5e, 0x43, 0xf9, 0xb6, 0xfd, 0x89, 0xe5,
	0x42, 0xde, 0x55, 0x62, 0xfc, 0x06, 0x00, 0xc1, 0x6f, 0xa0, 0x48, 0x34, 0x06, 0x47, 0xe9, 0xcc,
	0xd4, 0x8b, 0xd2, 0x19, 0xf2, 0x33, 0x05, 0xa9, 0x03, 0x3d, 0xcd, 0x77, 0xf1, 0x36, 0x9d, 0x70,
	0xcb, 0xae, 0x51, 0x5b, 0xa0, 0xcc, 0x47, 0x91, 0x27, 0x5c, 0xe0, 0xf2, 0x84, 0x0b, 0x14, 0x32,
	0x10, 0xcb, 0xbe, 0xe7, 0xee, 0x53, 0x1e, 0x14, 0x89, 0x8a, 0xd2, 0x90, 0x4c, 0x4a, 0x94, 0xc8,
	0x45, 0x64, 0x51, 0x71, 0x42, 0x02, 0xa2, 0x36, 0x58, 0x52, 0x92, 0x4a, 0x8a, 0xb2, 0x63, 0x26,
	0x45, 0xe4, 0xfb, 0x0a, 0x3a, 0xbb, 0xa9, 0xdb, 0x75, 0xb3, 0xd9, 0xbd, 0x41, 0xdc, 0x27, 0xc8,
	0x64, 0x3e, 0xf7, 0x20, 0x43, 0x3e, 0xcd, 0x4a, 0x67, 0xe5, 0x9f, 0xd7, 0x59, 0xc8, 0x9b, 0x28,
	0x6b, 0xda, 0x07, 0x7c, 0x12, 0xe8, 0xaa, 0x46, 0x8b, 0x9d, 0x50, 0x5d, 0xe6, 0xec, 0xd7, 0x3e,
	0xe8, 0x2d, 0x80, 0x3e, 0x26, 0x92, 0xc2, 0xec, 0x90, 0x49, 0xe1, 0x6d, 0xe9, 0x40, 0xfd, 0x4a,
	0xbc, 0x39, 0x78, 0x31, 0xde, 0x1c, 0xec, 0xcd, 0x03, 0x5d, 0x1f, 0x1a, 0x46, 0x87, 0xec, 0x57,
	0xe2, 0xad, 0xc7, 0x8b, 0xf1, 0xd6, 0x63, 0x9f, 0x86, 0xb6, 0x7c, 0x9e, 0x58, 0x98, 0xf0, 0x3c,
	0x91, 0xfc, 0x83, 0x7c, 0x88, 0x1f, 0x6f, 0xfb, 0x9d, 0xec, 0x21, 0xfe, 0xaf, 0xa3, 0xf9, 0x28,
	0x08, 0x08, 0x36, 0xcb, 0xce, 0xf2, 0xcf, 0x25, 0xa5, 0x7e, 0xc0, 0x1e, 0xa3, 0x7a, 0x0c, 0xda,
	0x38, 0x9c, 0x3b, 0x10, 0xcf, 0x01, 0x47, 0xfd, 0x33, 0x05, 0x4d, 0x49, 0x6d, 0xbb, 0x82, 0x94,
	0x32, 0x41, 0x90, 0x7a, 0x4c, 0xc7, 0x22, 0xa9, 0x75, 0xd7, 0x58, 0xbc, 0x78, 0xaf, 0xb3, 0xe4,
	0x46, 0xba, 0xfe, 0x30, 0x83, 0x4e, 0x6f, 0x3a, 0xf6, 0xae, 0xd5, 0xe0, 0x1a, 0x3f, 0x68, 0x3a,
	0x87, 0xd4, 0x0d, 0xee, 0x74, 0xb9, 0xc1, 0xf0, 0xfb, 0x8d, 0x57, 0x64, 0x93, 0x3f, 0x23, 0x4c,
	0x1e, 0x09, 0x93, 0x67, 0xe6, 0xbd, 0x81, 0x50, 0xf4, 0xae, 0x31, 0xf1, 0x83, 0x55, 0x56, 0xa0,
	0x62, 0x95, 0x15, 0x18, 0xd1, 0xca, 0xbc, 0x90, 0xdc, 0x1b, 0xcc, 0x8d, 0xb2, 0x37, 0x78, 0x17,
	0xe5, 0x76, 0x9b, 0xce, 0x61, 0x35, 0x0f, 0x83, 0x98, 0xda, 0xac, 0xa7, 0xa3, 0xc0, 0x29, 0x42,
	0xd3, 0x39, 0x94, 0x28, 0x42, 0xd3, 0x39, 0xa4, 0x14, 0x81, 0xfe, 0xf3, 0xc3, 0x0c, 0xca, 0xd1,
	0xe7, 0x80, 0x58, 0x78, 0x4e, 0x8b, 0x0f, 0x13, 0x6b, 0xe5, 0x39, 0x2d, 0xa9, 0x95, 0xe7, 0xb4,
	0x68, 0x2b, 0xcf, 0x69, 0xe1, 0x4b, 0x28, 0x13, 0x38, 0x3c, 0xb8, 0xc1, 0x66, 0x6f, 0xe0, 0x88,
	0xcd, 0xde, 0xc0, 0x21, 0x5a, 0x26, 0x70, 0xf0, 0x5d, 0x84, 0x28, 0x3d, 0x1d, 0x75, 0xc7, 0x96,
	0xb2, 0x5c, 0xc6, 0x82, 0xe3, 0xe4, 0x3e, 0x37, 0x6a, 0x72, 0x9f, 0x1f, 0x32, 0xb9, 0x9f, 0xe4,
	0x34, 0x87, 0xfc, 0x5e, 0x0e, 0x9d, 0x4d, 0x58, 0xdd, 0xfb, 0x6e, 0xc3, 0xd3, 0x0d, 0x73, 0x92,
	0xbb, 0x4a, 0x72, 0xdc, 0x2e, 0x7c, 0xd9, 0x71, 0x5b, 0x47, 0x33, 0xac, 0x9b, 0x68, 0x35, 0x63,
	0x73, 0xf8, 0x0d, 0x9a, 0xd4, 0x24, 0x2a, 0x3a, 0xa1, 0x7a, 0x55, 0x56, 0x6b, 0xe0, 0x0a, 0x36,
	0x15, 0x44, 0x71, 0x71, 0xdb, 0xc0, 0x26, 0x5a, 0xa8, 0xef, 0x39, 0xbe, 0x69, 0xd7, 0x12, 0x6c,
	0x2a, 0xb7, 0x92, 0xbd, 0x5a, 0xde, 0x78, 0x83, 0x2e, 0x9b, 0x3d, 0xaa, 0x3b, 0xa1, 0xba, 0x14,
	0x71, 0xd6, 0xae, 0x4a, 0xa2, 0xcd, 0x33, 0xf4, 0x03, 0x89, 0x61, 0xb5, 0xd0, 0x19, 0x48, 0x51,
	0xe8, 0xb2, 0x9e, 0xe8, 0x28, 0x0f, 0x1d, 0x41, 0x7a, 0xdf, 0xf3, 0x01, 0x91, 0xde, 0xf7, 0xac,
	0x26, 0xda, 0x42, 0x84, 0x4b, 0xdd, 0x91, 0x75, 0x34, 0xcd, 0x8b, 0x1a, 0xa5, 0xd1, 0xb8, 0x82,
	0xb2, 0x2d, 0xcb, 0x66, 0x96, 0xa0, 0xd1, 0x3f, 0x01, 0xd1, 0x9f, 0xb3, 0x79, 0xd1, 0xe8, 0x9f,
	0xe4, 0x53, 0x05, 0x4d, 0xc3, 0xb2, 0xce, 0x5b, 0xa6, 0xc2, 0x8a, 0x32, 0x56, 0x58, 0xa1, 0xa4,
	0x59, 0xdc, 0x50, 0xcf, 0x46, 0xf1, 0x4f, 0xba, 0x40, 0x3e, 0x27, 0x93, 0x5d, 0x88, 0x7f, 0x3b,
	0xec, 0xce, 0x38, 0xf9, 0xa3, 0x39, 0x54, 0x1a, 0xed, 0x74, 0x47, 0x1c, 0x8a, 0x64, 0xc6, 0x39,
	0x14, 0xc9, 0x8e, 0xe2, 0x28, 0x3c, 0x3a, 0xe7, 0x5e, 0x18, 0x9d, 0xe5, 0x25, 0x20, 0x3f, 0xc9,
	0x91, 0x53, 0x61, 0xf2, 0x23, 0xa7, 0xe2, 0x24, 0x47, 0x4e, 0x49, 0x7b, 0x28, 0x8d, 0x6b, 0x0f,
	0xf1, 0x71, 0x50, 0x79, 0x82, 0xe3, 0x20, 0x34, 0xf6, 0x71, 0xd0, 0xd4, 0xf0, 0x7b, 0x12, 0xdf,
	0xe4, 0x2c, 0x01, 0xb4, 0x9d, 0x06, 0x6d, 0x61, 0xf4, 0x63, 0x50, 0x8c, 0x7e, 0x0c, 0x71, 0x56,
	0x00, 0x0a, 0x27, 0xb3, 0xdf, 0x99, 0xb1, 0xb2, 0x5f, 0x79, 0x81, 0x98, 0x1d, 0xf7, 0x58, 0x69,
	0x6e, 0x84, 0x63, 0xa5, 0xca, 0x0b, 0x8f, 0x95, 0xa2, 0x61, 0x81, 0x4c, 0x98, 0x1d, 0xf0, 0x88,
	0x61, 0xe1, 0xa9, 0xb0, 0x3c, 0x2c, 0x2c, 0x17, 0x86, 0x61, 0x89, 0x12, 0x69, 0xc0, 0xc5, 0xd9,
	0x0e, 0x3b, 0x96, 0xe2, 0x98, 0x74, 0x2c, 0xc5, 0x11, 0x9a, 0xd0, 0xeb, 0xf5, 0xfd, 0x1e, 0x99,
	0xd4, 0xc2, 0x09, 0x1c, 0x2f, 0x9d, 0x1e, 0xe5, 0x78, 0xe9, 0x16, 0x2a, 0xd6, 0x0d, 0x1b, 0xda,
	0x9d, 0x11, 0xed, 0x38, 0x24, 0xda, 0x71, 0x80, 0x9a, 0x92, 0x61, 0xd3, 0x76, 0xa9, 0xf3, 0x86,
	0xc5, 0x49, 0xce, 0x1b, 0x18, 0xc3, 0xa8, 0x0e, 0xc9, 0x30, 0x62, 0x0e, 0x73, 0x6e, 0x48, 0x0e,
	0x13, 0x31, 0xba, 0x25, 0x48, 0x11, 0x46, 0x67, 0x74, 0xf8, 0x39, 0x9a, 0x66, 0x33, 0xc7, 0xd8,
	0x08, 0x1c, 0x4e, 0x4d, 0xad, 0xbf, 0x9a, 0x14, 0xb4, 0x65, 0x06, 0x8c, 0xba, 0xd0, 0x08, 0xcf,
	0x79, 0xcb, 0x03, 0xab, 0x19, 0x98, 0x1e, 0x4d, 0x56, 0x18, 0xad, 0x97, 0xa5, 0x08, 0x5a, 0x2f,
	0xa3, 0x44, 0x9b, 0x72, 0x45, 0x7b, 0xf9, 0xc8, 0xe3, 0xfc, 0x28, 0x47, 0x1e, 0x1f, 0x89, 0xd4,
	0x02, 0x32, 0x82, 0x0b, 0xa0, 0x71, 0xef, 0x3c, 0x06, 0x92, 0x02, 0x90, 0xcb, 0x9b, 0x08, 0xb9,
	0x1c, 0x10, 0xb9, 0x06, 0xac, 0x5c, 0x8f, 0xd1, 0x4c, 0x53, 0xf7, 0x83, 0x5a, 0xec, 0xc6, 0x17,
	0x63, 0x2e, 0x94, 0xac, 0x10, 0x41, 0x38, 0x01, 0x13, 0x6d, 0x9a, 0x96, 0xdf, 0x8d, 0x9c, 0x7a,
	0x03, 0x21, 0xa8, 0x67, 0x66, 0xb0, 0x2c, 0xc2, 0xb0, 0x40, 0x45, 0x54, 0x11, 0x18, 0xd1, 0xca,
	0xb4, 0xf0, 0x08, 0xe6, 0x38, 0x75, 0x96, 0xa2, 0x8e, 0x7b, 0x96, 0xf2, 0xa7, 0xd9, 0x38, 0x47,
	0x83, 0x77, 0xe5, 0x8b, 0xa2, 0xf2, 0xc2, 0x45, 0xf1, 0x9b, 0xa8, 0x6c, 0xf9, 0x35, 0xbd, 0x1e,
	0x58, 0x07, 0xec, 0x0a, 0x59, 0x89, 0xc5, 0x90, 0x18, 0x14, 0x31, 0x24, 0x86, 0x88, 0x56, 0xb2,
	0xfc, 0x7b, 0xf0, 0x67, 0xd7, 0xee, 0x57, 0xb6, 0x3b, 0x19, 0x1c, 0x7a, 0xf7, 0x2b, 0xb9, 0xae,
	0xe5, 0xc6, 0x5a, 0xd7, 0x62, 0x2f, 0xcb, 0x8f, 0x9a, 0x29, 0x14, 0xc6, 0xc8, 0x14, 0x8a, 0xa3,
	0x66, 0x0a, 0xff, 0xa9, 0xa0, 0x0a, 0x1b, 0xb9, 0x88, 0x16, 0x4e, 0x90, 0x22, 0x8c, 0x99, 0x97,
	0x8e, 0x37, 0xb0, 0x37, 0x51, 0x81, 0x5b, 0x49, 0x1e, 0xac, 0x84, 0x51, 0xba, 0xc8, 0x44, 0x22,
	0x4a, 0xc7, 0xed, 0x83, 0x57, 0x90, 0xff, 0x56, 0xd0, 0xfc, 0x96, 0x19, 0xa4, 0x72, 0xf1, 0x71,
	0xdf, 0x77, 0x92, 0x3b, 0x43, 0x7c, 0xac, 0xb2, 0x5f, 0xc4, 0x58, 0x91, 0x0f, 0x11, 0x4e, 0xbf,
	0x35, 0x7c, 0x82, 0x96, 0xa7, 0x61, 0x39, 0xba, 0xdd, 0xd5, 0x2b, 0xa0, 0x0f, 0xfa, 0x5e, 0x0c,
	0xda, 0x92, 0x1f, 0x2b, 0x68, 0x29, 0x0e, 0xd9, 0xdd, 0xd9, 0xe6, 0x17, 0xb2, 0xcd, 0xf1, 0xa8,
	0x77, 0x36, 0x78, 0xad, 0x57, 0x36, 0x78, 0xba, 0x57, 0x36, 0x98, 0xc8, 0xfc, 0xc8, 0x7f, 0x29,
	0xe8, 0x7c, 0xdf, 0x57, 0xf2, 0xdd, 0x7e, 0x99, 0xa1, 0xf2, 0x45, 0x65, 0x86, 0x99, 0xcf, 0x25,
	0x33, 0xfc, 0x9b, 0x02, 0x5a, 0xea, 0xbb, 0xf0, 0xfe, 0x9c, 0x6d, 0xdb, 0x7e, 0x01, 0xe9, 0xff,
	0x6d, 0x54, 0xb4, 0xcd, 0xe0, 0xd0, 0xf1, 0xf6, 0xe5, 0x6d, 0x2f, 0x0e, 0x49, 0xdf, 0x21, 0x30,
	0x80, 0x68, 0x51, 0x15, 0xb5, 0x5a, 0xcb, 0x77, 0xf9, 0x81, 0x14, 0x58, 0xad, 0xe5, 0xbb, 0xc2,
	0x6a, 0x2d, 0xdf, 0x25, 0x1a, 0x85, 0x68, 0x0f, 0x94, 0xcd, 0xdb, 0x66, 0x53, 0xbe, 0x74, 0xc7,
	0x21, 0x89, 0x31, 0x32, 0x80, 0x68, 0x51, 0x15, 0x25, 0xef, 0xf5, 0xe8, 0x33, 0x07, 0xfe, 0x41,
	0x50, 0x9d, 0x7d, 0xe2, 0x30, 0x15, 0xdd, 0xc4, 0x09, 0x8e, 0x88, 0x06, 0x20, 0x7e, 0x80, 0x72,
	0xf1, 0x15, 0xbb, 0xd9, 0x34, 0x73, 0xe1, 0xb3, 0x0c, 0x37, 0x9b, 0x41, 0x0e, 0xcf, 0x5d, 0xb8,
	0x1c, 0x96, 0xb6, 0x00, 0x28, 0x6f, 0x43, 0xa3, 0x13, 0xf8, 0xf2, 0xde, 0x35, 0xbd, 0xba, 0x69,
	0x07, 0xfc, 0x9a, 0x2d, 0xbb, 0x42, 0xc6, 0x20, 0xe9, 0x0a, 0x19, 0x03, 0x28, 0xc9, 0x67, 0x7f,
	0xe1, 0xaf, 0xa1, 0xb2, 0x61, 0x1e, 0x58, 0x75, 0xb0, 0xc2, 0xb2, 0xc8, 0xd7, 0x18, 0x28, 0xc2,
	0x3e, 0x2b, 0x13, 0xad, 0xc4, 0xfe, 0xd8, 0x36, 0xf0, 0x07, 0x68, 0xce, 0x7c, 0x5e, 0x6f, 0xb6,
	0x0d, 0xd3, 0xaf, 0xf9, 0x47, 0x7e, 0x60, 0xb6, 0xf8, 0x59, 0x16, 0x7c, 0xbd, 0x9e, 0xaa, 0x12,
	0x5f, 0xaf, 0xa7, 0x2a, 0x88, 0x36, 0x1b, 0x21, 0x4f, 0x19, 0xf0, 0x27, 0x45, 0xb4, 0x3c, 0x98,
	0xb1, 0xfe, 0x7c, 0x79, 0xce, 0x63, 0x69, 0xdb, 0x25, 0x2b, 0x94, 0x91, 0xb6, 0x5d, 0x2e, 0xa5,
	0xb6, 0x5d, 0x7a, 0x2b, 0xb3, 0x23, 0x3e, 0xdf, 0xff, 0xca, 0x4d, 0x24, 0x37, 0xf9, 0x12, 0x4c,
	0x9b, 0xe6, 0xf2, 0x7a, 0x33, 0xe0, 0xf6, 0xcc, 0x72, 0x79, 0xbd, 0x29, 0xdf, 0x80, 0xd7, 0x9b,
	0x70, 0x03, 0x5e, 0x6f, 0x06, 0xbd, 0xfc, 0x60, 0xe6, 0x04, 0xfc, 0x60, 0xb2, 0xdd, 0x88, 0x98,
	0x23, 0xcf, 0x8d, 0xca, 0x91, 0x2b, 0xc3, 0x71, 0x64, 0xf2, 0xf7, 0x0a, 0x9a, 0xbf, 0x7f, 0xe0,
	0x34, 0xdb, 0x34, 0x55, 0x86, 0xd3, 0x2f, 0xba, 0xa6, 0x75, 0x2d, 0x23, 0xca, 0x89, 0x2f, 0x23,
	0x5b, 0xbd, 0xee, 0x2d, 0x8d, 0x91, 0xde, 0x93, 0x9f, 0x28, 0xe8, 0xe2, 0xa0, 0x40, 0xf3, 0x7f,
	0x92, 0x6a, 0xbd, 0x72, 0x0e, 0xe5, 0x9e, 0x3a, 0x5e, 0x80, 0x4b, 0x28, 0xf7, 0xd6, 0xfd, 0xa7,
	0x9b, 0xec, 0x8b, 0x86, 0x7b, 0x4f, 0x37, 0x2b, 0xca, 0x2b, 0xeb, 0x68, 0x36, 0x79, 0x0b, 0x05,
	0x4f, 0xa1, 0xe2, 0xd3, 0x76, 0xbd, 0x6e, 0xfa, 0x7e, 0xe5, 0x14, 0x5e, 0x40, 0x85, 0x07, 0xba,
	0xd5, 0x34, 0x8d, 0xca, 0xcf, 0xa2, 0xff, 0x29, 0xaf, 0xbc, 0x8a, 0xa6, 0x24, 0x5f, 0x85, 0x8f,
	0x22, 0xda, 0x7e, 0xe0, 0xb4, 0xb8, 0xdc, 0x66, 0xb3, 0xa2, 0xd0, 0xae, 0x9e, 0x99, 0x7e, 0x50,
	0xc9, 0xac, 0xff, 0x61, 0x15, 0xe5, 0xc1, 0x16, 0x70, 0x13, 0x4d, 0xcb, 0x9f, 0x71, 0xe2, 0x8b,
	0x49, 0xff, 0x4f, 0x7d, 0xe2, 0xb9, 0xb4, 0xb8, 0xca, 0x7e, 0xbb, 0x66, 0x35, 0xfa, 0xed, 0x9a,
	0xd5, 0xfb, 0x2d, 0x37, 0x38, 0x22, 0x97, 0xbf, 0xf3, 0x93, 0x7f, 0xfb, 0x7e, 0x46, 0x25, 0x17,
	0xd7, 0x9e, 0xaf, 0xe9, 0x46, 0xcb, 0xb2, 0xa3, 0x1f, 0xda, 0x11, 0x3f, 0xae, 0xa3, 0x1b, 0x06,
	0x6e, 0xa3, 0x69, 0xf9, 0x9b, 0xf5, 0x74, 0x6f, 0xa9, 0x6f, 0xe3, 0x97, 0x96, 0x07, 0x55, 0xfb,
	0x2e, 0x79, 0x19, 0x7a, 0x5d, 0xc1, 0xcb, 0xfd, 0x7b, 0xb5, 0x68, 0x37, 0xcf, 0xd1, 0x4c, 0xe2,
	0x03, 0x6e, 0xbc, 0xdc, 0xe7, 0x2b, 0x9d, 0xa8, 0x63, 0x75, 0x60, 0xfd, 0x70, 0x3d, 0x37, 0x2d,
	0x3f, 0xc0, 0x6d, 0x34, 0x97, 0xfa, 0x08, 0x1b, 0xa7, 0x2e, 0x36, 0x76, 0x7f, 0xa3, 0xdd, 0x77,
	0x90, 0xaf, 0x42, 0xa7, 0x84, 0xac, 0xf4, 0xef, 0xd4, 0x00, 0x69, 0xb4, 0xdb, 0xd4, 0xb7, 0xda,
	0xe9, 0x6e, 0xbb, 0x3f, 0xe5, 0x9e, 0xa4, 0xdb, 0x36, 0x48, 0xc3, 0x47, 0x68, 0xbe, 0xeb, 0x23,
	0x50, 0x4c, 0x7a, 0x5b, 0x94, 0x7c, 0x51, 0x63, 0x92, 0xae, 0xeb, 0x16, 0x58, 0xd6, 0x6f, 0x29,
	0x08, 0x77, 0x7f, 0xdb, 0x83, 0x2f, 0x0d, 0xf1, 0x39, 0xd6, 0xd2, 0x2f, 0xbd, 0xf8, 0x21, 0xdf,
	0x25, 0xd7, 0x40, 0x97, 0x4b, 0xf8, 0xa5, 0x81, 0xba, 0xc0, 0xac, 0xff, 0x81, 0x82, 0xce, 0x0f,
	0xb8, 0x68, 0x89, 0x5f, 0xed, 0x3b, 0x17, 0x3d, 0xee, 0x64, 0xf6, 0x1d, 0x9c, 0xd7, 0x41, 0xa1,
	0x55, 0xf2, 0x6a, 0x5a, 0xa1, 0x9d, 0xb6, 0x6f, 0xd9, 0xa6, 0xef, 0x0b, 0xad, 0x1a, 0x56, 0x10,
	0xcd, 0xd1, 0x5f, 0xf5, 0xd1, 0x8d, 0xdf, 0x18, 0x1a, 0x46, 0x37, 0x71, 0x8d, 0x6f, 0xe9, 0xc6,
	0x08, 0x4f, 0xfb, 0xee, 0x28, 0x2a, 0xbb, 0xfb, 0x8d, 0x48, 0xe5, 0xdf, 0xe9, 0xf5, 0x53, 0x32,
	0xa0, 0xec, 0xcb, 0xbd, 0x03, 0x44, 0xfa, 0x0e, 0xf3, 0xd2, 0x95, 0xa1, 0x9e, 0xf3, 0xdd, 0xc8,
	0xe0, 0xf0, 0x60, 0x83, 0x6b, 0x98, 0x01, 0xfe, 0x8e, 0x82, 0x4e, 0xf7, 0xba, 0x77, 0x84, 0x2f,
	0xa7, 0xef, 0x13, 0xf6, 0xbc, 0x9b, 0xd4, 0x77, 0x56, 0xaf, 0x83, 0x06, 0x97, 0xf1, 0xa5, 0x81,
	0x1a, 0xd4, 0x41, 0x2a, 0xb5, 0xfa, 0xc5, 0xde, 0x77, 0x96, 0x71, 0xea, 0x95, 0xfb, 0xde, 0x6c,
	0xee, 0xab, 0xc8, 0x1a, 0x28, 0x72, 0x8d, 0x5c, 0x19, 0xa8, 0x88, 0xdb, 0xf6, 0xf7, 0xd6, 0x02,
	0x67, 0xad, 0x6e, 0xe0, 0xdf, 0x90, 0xa2, 0x2c, 0x8c, 0x44, 0xbf, 0x28, 0x1b, 0x0d, 0x81, 0x3a,
	0xb0, 0x7e, 0x48, 0x97, 0x33, 0x98, 0xcb, 0xfd, 0x26, 0xc2, 0x49, 0x96, 0x03, 0x1a, 0xa4, 0x7a,
	0xe8, 0xe2, 0x41, 0x7d, 0x5f, 0x7e, 0x15, 0x7a, 0xbe, 0x4a, 0x5e, 0x1e, 0xd8, 0xb3, 0x19, 0xc9,
	0xc3, 0xdf, 0x55, 0xd0, 0x4c, 0x62, 0x33, 0x31, 0xfd, 0xf2, 0xe9, 0x9d, 0xc6, 0xbe, 0x3d, 0xdf,
	0x81, 0x9e, 0x5f, 0x27, 0xeb, 0x03, 0x7b, 0xae, 0x03, 0x19, 0x5a, 0xe3, 0x9b, 0x1b, 0x6b, 0x6c,
	0x8f, 0x0f, 0xff, 0xb6, 0x82, 0xe6, 0xbb, 0xae, 0xdc, 0xa4, 0x03, 0x70, 0xaf, 0x3b, 0x39, 0x7d,
	0xb5, 0xf9, 0x15, 0xd0, 0xe6, 0x16, 0x79, 0x7d, 0x14, 0x6d, 0x76, 0x9b, 0xce, 0xe1, 0x9a, 0x6f,
	0x06, 0x54, 0x9f, 0xd9, 0xe4, 0xee, 0x5b, 0x7a, 0x46, 0xba, 0x76, 0x24, 0x97, 0x56, 0x06, 0x3f,
	0xe0, 0xbb, 0xe4, 0x6b, 0xa0, 0xd3, 0x3a, 0xfe, 0xe5, 0x51, 0x75, 0xc2, 0xbf, 0xab, 0xa4, 0xae,
	0x24, 0x45, 0x87, 0x24, 0x97, 0x07, 0x0c, 0x91, 0xd8, 0xd2, 0xeb, 0x3b, 0x4a, 0x77, 0x41, 0xa3,
	0xaf, 0x93, 0xdb, 0xa3, 0x68, 0xc4, 0x8f, 0x6b, 0x60, 0xa0, 0xfe, 0x5c, 0x41, 0x67, 0xfb, 0xec,
	0xbb, 0xe1, 0xab, 0x7d, 0x0e, 0x89, 0xba, 0xd5, 0xbb, 0x36, 0xe4, 0x93, 0xbe, 0x4b, 0xde, 0x04,
	0x8d, 0xdf, 0xc0, 0x37, 0xc7, 0xd0, 0x98, 0x2e, 0x6f, 0x67, 0xfb, 0xb0, 0xf1, 0xb4, 0xb6, 0xfd,
	0x49, 0xfb, 0xc9, 0x98, 0x1c, 0xe5, 0xd6, 0x89, 0x91, 0xfc, 0x6b, 0x79, 0x53, 0xb6, 0x5b, 0xbd,
	0xeb, 0xc3, 0x9f, 0xb8, 0x7d, 0xbc, 0x34, 0xd2, 0xf1, 0xdc, 0x68, 0x66, 0x29, 0xeb, 0x8d, 0x3f,
	0x55, 0xe0, 0xa7, 0x9c, 0x12, 0x3f, 0xab, 0x88, 0x5f, 0xea, 0xea, 0x3c, 0xfd, 0x93, 0x90, 0x4b,
	0xe4, 0x45, 0x8f, 0xf8, 0x2e, 0xb9, 0x09, 0x5a, 0xdd, 0xc0, 0xd7, 0x07, 0x6a, 0x05, 0xea, 0xc4,
	0xbf, 0xbe, 0xb8, 0x71, 0xfe, 0x47, 0xff, 0xb2, 0x7c, 0xea, 0x47, 0x9f, 0x2d, 0x2b, 0x3f, 0xfe,
	0x6c, 0x59, 0xf9, 0xe7, 0xcf, 0x96, 0x95, 0xdf, 0xff, 0xd7, 0xe5, 0x53, 0xbf, 0x9a, 0x87, 0xc7,
	0x77, 0x0a, 0x30, 0x5f, 0x37, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x9c, 0xe6, 0xc2, 0x1b, 0x62,
	0x53, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TribeClient is the client API for Tribe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TribeClient interface {
	AddTribeInfo(ctx context.Context, in *AddTribeInfoReq, opts ...grpc.CallOption) (*empty.Empty, error)
	GetTribeInfo(ctx context.Context, in *GetTribeInfoReq, opts ...grpc.CallOption) (*GetTribeInfoResp, error)
	ListTribeInfo(ctx context.Context, in *ListTribeInfoReq, opts ...grpc.CallOption) (*ListTribeInfoResp, error)
	DeleteTribeInfo(ctx context.Context, in *DeleteTribeInfoReq, opts ...grpc.CallOption) (*empty.Empty, error)
	UpdateTribeInfo(ctx context.Context, in *UpdateTribeInfoReq, opts ...grpc.CallOption) (*empty.Empty, error)
	AddTribeBuildPack(ctx context.Context, in *AddTribeBuildPackReq, opts ...grpc.CallOption) (*empty.Empty, error)
	ListTribeBuildPack(ctx context.Context, in *ListTribeBuildPackReq, opts ...grpc.CallOption) (*ListTribeBuildPackResp, error)
	UpdateTribeBuildPackGitInfo(ctx context.Context, in *UpdateTribeBuildPackGitInfoReq, opts ...grpc.CallOption) (*empty.Empty, error)
	UpdateTribeBuildPackPkgInfo(ctx context.Context, in *UpdateTribeBuildPackPkgInfoReq, opts ...grpc.CallOption) (*UpdateTribeBuildPackPkgInfoResp, error)
	GetTribeBuildPackInfo(ctx context.Context, in *GetTribeBuildPackInfoReq, opts ...grpc.CallOption) (*GetTribeBuildPackInfoResp, error)
	CancelTribeBuildPack(ctx context.Context, in *CancelTribeBuildPackReq, opts ...grpc.CallOption) (*empty.Empty, error)
	PushTribeBuildPackToCD(ctx context.Context, in *PushTribeBuildPackToCDReq, opts ...grpc.CallOption) (*empty.Empty, error)
	ListTribePack(ctx context.Context, in *ListTribePackReq, opts ...grpc.CallOption) (*ListTribePackResp, error)
	EvolutionTribePack(ctx context.Context, in *EvolutionTribeReq, opts ...grpc.CallOption) (*empty.Empty, error)
	ActiveVersion(ctx context.Context, in *ActiveVersionReq, opts ...grpc.CallOption) (*empty.Empty, error)
	ConfigVersionFlow(ctx context.Context, in *ConfigVersionFlowReq, opts ...grpc.CallOption) (*empty.Empty, error)
	GetVersionFlow(ctx context.Context, in *GetVersionFlowReq, opts ...grpc.CallOption) (*GetVersionFlowResp, error)
	ConfigVersionUpgrade(ctx context.Context, in *ConfigVersionUpgradeReq, opts ...grpc.CallOption) (*empty.Empty, error)
	GetConfigVersionUpgrade(ctx context.Context, in *GetConfigVersionUpgradeReq, opts ...grpc.CallOption) (*GetConfigVersionUpgradeResp, error)
	ConfigPackUpgradeFilter(ctx context.Context, in *ConfigPackUpgradeFilterReq, opts ...grpc.CallOption) (*empty.Empty, error)
	GetConfigPackUpgradeFilter(ctx context.Context, in *GetConfigPackUpgradeFilterReq, opts ...grpc.CallOption) (*GetConfigPackUpgradeFilterResp, error)
	// 
	GetPackRelations(ctx context.Context, in *GetPackRelationsReq, opts ...grpc.CallOption) (*GetPackRelationsResp, error)
}

type tribeClient struct {
	cc *grpc.ClientConn
}

func NewTribeClient(cc *grpc.ClientConn) TribeClient {
	return &tribeClient{cc}
}

func (c *tribeClient) AddTribeInfo(ctx context.Context, in *AddTribeInfoReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/AddTribeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) GetTribeInfo(ctx context.Context, in *GetTribeInfoReq, opts ...grpc.CallOption) (*GetTribeInfoResp, error) {
	out := new(GetTribeInfoResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/GetTribeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) ListTribeInfo(ctx context.Context, in *ListTribeInfoReq, opts ...grpc.CallOption) (*ListTribeInfoResp, error) {
	out := new(ListTribeInfoResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/ListTribeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) DeleteTribeInfo(ctx context.Context, in *DeleteTribeInfoReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/DeleteTribeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) UpdateTribeInfo(ctx context.Context, in *UpdateTribeInfoReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/UpdateTribeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) AddTribeBuildPack(ctx context.Context, in *AddTribeBuildPackReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/AddTribeBuildPack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) ListTribeBuildPack(ctx context.Context, in *ListTribeBuildPackReq, opts ...grpc.CallOption) (*ListTribeBuildPackResp, error) {
	out := new(ListTribeBuildPackResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/ListTribeBuildPack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) UpdateTribeBuildPackGitInfo(ctx context.Context, in *UpdateTribeBuildPackGitInfoReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/UpdateTribeBuildPackGitInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) UpdateTribeBuildPackPkgInfo(ctx context.Context, in *UpdateTribeBuildPackPkgInfoReq, opts ...grpc.CallOption) (*UpdateTribeBuildPackPkgInfoResp, error) {
	out := new(UpdateTribeBuildPackPkgInfoResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/UpdateTribeBuildPackPkgInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) GetTribeBuildPackInfo(ctx context.Context, in *GetTribeBuildPackInfoReq, opts ...grpc.CallOption) (*GetTribeBuildPackInfoResp, error) {
	out := new(GetTribeBuildPackInfoResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/GetTribeBuildPackInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) CancelTribeBuildPack(ctx context.Context, in *CancelTribeBuildPackReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/CancelTribeBuildPack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) PushTribeBuildPackToCD(ctx context.Context, in *PushTribeBuildPackToCDReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/PushTribeBuildPackToCD", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) ListTribePack(ctx context.Context, in *ListTribePackReq, opts ...grpc.CallOption) (*ListTribePackResp, error) {
	out := new(ListTribePackResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/ListTribePack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) EvolutionTribePack(ctx context.Context, in *EvolutionTribeReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/EvolutionTribePack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) ActiveVersion(ctx context.Context, in *ActiveVersionReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/ActiveVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) ConfigVersionFlow(ctx context.Context, in *ConfigVersionFlowReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/ConfigVersionFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) GetVersionFlow(ctx context.Context, in *GetVersionFlowReq, opts ...grpc.CallOption) (*GetVersionFlowResp, error) {
	out := new(GetVersionFlowResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/GetVersionFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) ConfigVersionUpgrade(ctx context.Context, in *ConfigVersionUpgradeReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/ConfigVersionUpgrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) GetConfigVersionUpgrade(ctx context.Context, in *GetConfigVersionUpgradeReq, opts ...grpc.CallOption) (*GetConfigVersionUpgradeResp, error) {
	out := new(GetConfigVersionUpgradeResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/GetConfigVersionUpgrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) ConfigPackUpgradeFilter(ctx context.Context, in *ConfigPackUpgradeFilterReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/ConfigPackUpgradeFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) GetConfigPackUpgradeFilter(ctx context.Context, in *GetConfigPackUpgradeFilterReq, opts ...grpc.CallOption) (*GetConfigPackUpgradeFilterResp, error) {
	out := new(GetConfigPackUpgradeFilterResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/GetConfigPackUpgradeFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tribeClient) GetPackRelations(ctx context.Context, in *GetPackRelationsReq, opts ...grpc.CallOption) (*GetPackRelationsResp, error) {
	out := new(GetPackRelationsResp)
	err := c.cc.Invoke(ctx, "/app.tribe.v1.Tribe/GetPackRelations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TribeServer is the server API for Tribe service.
type TribeServer interface {
	AddTribeInfo(context.Context, *AddTribeInfoReq) (*empty.Empty, error)
	GetTribeInfo(context.Context, *GetTribeInfoReq) (*GetTribeInfoResp, error)
	ListTribeInfo(context.Context, *ListTribeInfoReq) (*ListTribeInfoResp, error)
	DeleteTribeInfo(context.Context, *DeleteTribeInfoReq) (*empty.Empty, error)
	UpdateTribeInfo(context.Context, *UpdateTribeInfoReq) (*empty.Empty, error)
	AddTribeBuildPack(context.Context, *AddTribeBuildPackReq) (*empty.Empty, error)
	ListTribeBuildPack(context.Context, *ListTribeBuildPackReq) (*ListTribeBuildPackResp, error)
	UpdateTribeBuildPackGitInfo(context.Context, *UpdateTribeBuildPackGitInfoReq) (*empty.Empty, error)
	UpdateTribeBuildPackPkgInfo(context.Context, *UpdateTribeBuildPackPkgInfoReq) (*UpdateTribeBuildPackPkgInfoResp, error)
	GetTribeBuildPackInfo(context.Context, *GetTribeBuildPackInfoReq) (*GetTribeBuildPackInfoResp, error)
	CancelTribeBuildPack(context.Context, *CancelTribeBuildPackReq) (*empty.Empty, error)
	PushTribeBuildPackToCD(context.Context, *PushTribeBuildPackToCDReq) (*empty.Empty, error)
	ListTribePack(context.Context, *ListTribePackReq) (*ListTribePackResp, error)
	EvolutionTribePack(context.Context, *EvolutionTribeReq) (*empty.Empty, error)
	ActiveVersion(context.Context, *ActiveVersionReq) (*empty.Empty, error)
	ConfigVersionFlow(context.Context, *ConfigVersionFlowReq) (*empty.Empty, error)
	GetVersionFlow(context.Context, *GetVersionFlowReq) (*GetVersionFlowResp, error)
	ConfigVersionUpgrade(context.Context, *ConfigVersionUpgradeReq) (*empty.Empty, error)
	GetConfigVersionUpgrade(context.Context, *GetConfigVersionUpgradeReq) (*GetConfigVersionUpgradeResp, error)
	ConfigPackUpgradeFilter(context.Context, *ConfigPackUpgradeFilterReq) (*empty.Empty, error)
	GetConfigPackUpgradeFilter(context.Context, *GetConfigPackUpgradeFilterReq) (*GetConfigPackUpgradeFilterResp, error)
	// 
	GetPackRelations(context.Context, *GetPackRelationsReq) (*GetPackRelationsResp, error)
}

// UnimplementedTribeServer can be embedded to have forward compatible implementations.
type UnimplementedTribeServer struct {
}

func (*UnimplementedTribeServer) AddTribeInfo(ctx context.Context, req *AddTribeInfoReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTribeInfo not implemented")
}
func (*UnimplementedTribeServer) GetTribeInfo(ctx context.Context, req *GetTribeInfoReq) (*GetTribeInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTribeInfo not implemented")
}
func (*UnimplementedTribeServer) ListTribeInfo(ctx context.Context, req *ListTribeInfoReq) (*ListTribeInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTribeInfo not implemented")
}
func (*UnimplementedTribeServer) DeleteTribeInfo(ctx context.Context, req *DeleteTribeInfoReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTribeInfo not implemented")
}
func (*UnimplementedTribeServer) UpdateTribeInfo(ctx context.Context, req *UpdateTribeInfoReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTribeInfo not implemented")
}
func (*UnimplementedTribeServer) AddTribeBuildPack(ctx context.Context, req *AddTribeBuildPackReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTribeBuildPack not implemented")
}
func (*UnimplementedTribeServer) ListTribeBuildPack(ctx context.Context, req *ListTribeBuildPackReq) (*ListTribeBuildPackResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTribeBuildPack not implemented")
}
func (*UnimplementedTribeServer) UpdateTribeBuildPackGitInfo(ctx context.Context, req *UpdateTribeBuildPackGitInfoReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTribeBuildPackGitInfo not implemented")
}
func (*UnimplementedTribeServer) UpdateTribeBuildPackPkgInfo(ctx context.Context, req *UpdateTribeBuildPackPkgInfoReq) (*UpdateTribeBuildPackPkgInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTribeBuildPackPkgInfo not implemented")
}
func (*UnimplementedTribeServer) GetTribeBuildPackInfo(ctx context.Context, req *GetTribeBuildPackInfoReq) (*GetTribeBuildPackInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTribeBuildPackInfo not implemented")
}
func (*UnimplementedTribeServer) CancelTribeBuildPack(ctx context.Context, req *CancelTribeBuildPackReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTribeBuildPack not implemented")
}
func (*UnimplementedTribeServer) PushTribeBuildPackToCD(ctx context.Context, req *PushTribeBuildPackToCDReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushTribeBuildPackToCD not implemented")
}
func (*UnimplementedTribeServer) ListTribePack(ctx context.Context, req *ListTribePackReq) (*ListTribePackResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTribePack not implemented")
}
func (*UnimplementedTribeServer) EvolutionTribePack(ctx context.Context, req *EvolutionTribeReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvolutionTribePack not implemented")
}
func (*UnimplementedTribeServer) ActiveVersion(ctx context.Context, req *ActiveVersionReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActiveVersion not implemented")
}
func (*UnimplementedTribeServer) ConfigVersionFlow(ctx context.Context, req *ConfigVersionFlowReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigVersionFlow not implemented")
}
func (*UnimplementedTribeServer) GetVersionFlow(ctx context.Context, req *GetVersionFlowReq) (*GetVersionFlowResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionFlow not implemented")
}
func (*UnimplementedTribeServer) ConfigVersionUpgrade(ctx context.Context, req *ConfigVersionUpgradeReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigVersionUpgrade not implemented")
}
func (*UnimplementedTribeServer) GetConfigVersionUpgrade(ctx context.Context, req *GetConfigVersionUpgradeReq) (*GetConfigVersionUpgradeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigVersionUpgrade not implemented")
}
func (*UnimplementedTribeServer) ConfigPackUpgradeFilter(ctx context.Context, req *ConfigPackUpgradeFilterReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigPackUpgradeFilter not implemented")
}
func (*UnimplementedTribeServer) GetConfigPackUpgradeFilter(ctx context.Context, req *GetConfigPackUpgradeFilterReq) (*GetConfigPackUpgradeFilterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigPackUpgradeFilter not implemented")
}
func (*UnimplementedTribeServer) GetPackRelations(ctx context.Context, req *GetPackRelationsReq) (*GetPackRelationsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPackRelations not implemented")
}

func RegisterTribeServer(s *grpc.Server, srv TribeServer) {
	s.RegisterService(&_Tribe_serviceDesc, srv)
}

func _Tribe_AddTribeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTribeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).AddTribeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/AddTribeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).AddTribeInfo(ctx, req.(*AddTribeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_GetTribeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTribeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).GetTribeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/GetTribeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).GetTribeInfo(ctx, req.(*GetTribeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_ListTribeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTribeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).ListTribeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/ListTribeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).ListTribeInfo(ctx, req.(*ListTribeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_DeleteTribeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTribeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).DeleteTribeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/DeleteTribeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).DeleteTribeInfo(ctx, req.(*DeleteTribeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_UpdateTribeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTribeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).UpdateTribeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/UpdateTribeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).UpdateTribeInfo(ctx, req.(*UpdateTribeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_AddTribeBuildPack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTribeBuildPackReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).AddTribeBuildPack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/AddTribeBuildPack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).AddTribeBuildPack(ctx, req.(*AddTribeBuildPackReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_ListTribeBuildPack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTribeBuildPackReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).ListTribeBuildPack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/ListTribeBuildPack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).ListTribeBuildPack(ctx, req.(*ListTribeBuildPackReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_UpdateTribeBuildPackGitInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTribeBuildPackGitInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).UpdateTribeBuildPackGitInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/UpdateTribeBuildPackGitInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).UpdateTribeBuildPackGitInfo(ctx, req.(*UpdateTribeBuildPackGitInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_UpdateTribeBuildPackPkgInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTribeBuildPackPkgInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).UpdateTribeBuildPackPkgInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/UpdateTribeBuildPackPkgInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).UpdateTribeBuildPackPkgInfo(ctx, req.(*UpdateTribeBuildPackPkgInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_GetTribeBuildPackInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTribeBuildPackInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).GetTribeBuildPackInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/GetTribeBuildPackInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).GetTribeBuildPackInfo(ctx, req.(*GetTribeBuildPackInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_CancelTribeBuildPack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTribeBuildPackReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).CancelTribeBuildPack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/CancelTribeBuildPack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).CancelTribeBuildPack(ctx, req.(*CancelTribeBuildPackReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_PushTribeBuildPackToCD_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushTribeBuildPackToCDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).PushTribeBuildPackToCD(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/PushTribeBuildPackToCD",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).PushTribeBuildPackToCD(ctx, req.(*PushTribeBuildPackToCDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_ListTribePack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTribePackReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).ListTribePack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/ListTribePack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).ListTribePack(ctx, req.(*ListTribePackReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_EvolutionTribePack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvolutionTribeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).EvolutionTribePack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/EvolutionTribePack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).EvolutionTribePack(ctx, req.(*EvolutionTribeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_ActiveVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveVersionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).ActiveVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/ActiveVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).ActiveVersion(ctx, req.(*ActiveVersionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_ConfigVersionFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigVersionFlowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).ConfigVersionFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/ConfigVersionFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).ConfigVersionFlow(ctx, req.(*ConfigVersionFlowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_GetVersionFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionFlowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).GetVersionFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/GetVersionFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).GetVersionFlow(ctx, req.(*GetVersionFlowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_ConfigVersionUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigVersionUpgradeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).ConfigVersionUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/ConfigVersionUpgrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).ConfigVersionUpgrade(ctx, req.(*ConfigVersionUpgradeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_GetConfigVersionUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigVersionUpgradeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).GetConfigVersionUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/GetConfigVersionUpgrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).GetConfigVersionUpgrade(ctx, req.(*GetConfigVersionUpgradeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_ConfigPackUpgradeFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigPackUpgradeFilterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).ConfigPackUpgradeFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/ConfigPackUpgradeFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).ConfigPackUpgradeFilter(ctx, req.(*ConfigPackUpgradeFilterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_GetConfigPackUpgradeFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigPackUpgradeFilterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).GetConfigPackUpgradeFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/GetConfigPackUpgradeFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).GetConfigPackUpgradeFilter(ctx, req.(*GetConfigPackUpgradeFilterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tribe_GetPackRelations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPackRelationsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TribeServer).GetPackRelations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.tribe.v1.Tribe/GetPackRelations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TribeServer).GetPackRelations(ctx, req.(*GetPackRelationsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Tribe_serviceDesc = grpc.ServiceDesc{
	ServiceName: "app.tribe.v1.Tribe",
	HandlerType: (*TribeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTribeInfo",
			Handler:    _Tribe_AddTribeInfo_Handler,
		},
		{
			MethodName: "GetTribeInfo",
			Handler:    _Tribe_GetTribeInfo_Handler,
		},
		{
			MethodName: "ListTribeInfo",
			Handler:    _Tribe_ListTribeInfo_Handler,
		},
		{
			MethodName: "DeleteTribeInfo",
			Handler:    _Tribe_DeleteTribeInfo_Handler,
		},
		{
			MethodName: "UpdateTribeInfo",
			Handler:    _Tribe_UpdateTribeInfo_Handler,
		},
		{
			MethodName: "AddTribeBuildPack",
			Handler:    _Tribe_AddTribeBuildPack_Handler,
		},
		{
			MethodName: "ListTribeBuildPack",
			Handler:    _Tribe_ListTribeBuildPack_Handler,
		},
		{
			MethodName: "UpdateTribeBuildPackGitInfo",
			Handler:    _Tribe_UpdateTribeBuildPackGitInfo_Handler,
		},
		{
			MethodName: "UpdateTribeBuildPackPkgInfo",
			Handler:    _Tribe_UpdateTribeBuildPackPkgInfo_Handler,
		},
		{
			MethodName: "GetTribeBuildPackInfo",
			Handler:    _Tribe_GetTribeBuildPackInfo_Handler,
		},
		{
			MethodName: "CancelTribeBuildPack",
			Handler:    _Tribe_CancelTribeBuildPack_Handler,
		},
		{
			MethodName: "PushTribeBuildPackToCD",
			Handler:    _Tribe_PushTribeBuildPackToCD_Handler,
		},
		{
			MethodName: "ListTribePack",
			Handler:    _Tribe_ListTribePack_Handler,
		},
		{
			MethodName: "EvolutionTribePack",
			Handler:    _Tribe_EvolutionTribePack_Handler,
		},
		{
			MethodName: "ActiveVersion",
			Handler:    _Tribe_ActiveVersion_Handler,
		},
		{
			MethodName: "ConfigVersionFlow",
			Handler:    _Tribe_ConfigVersionFlow_Handler,
		},
		{
			MethodName: "GetVersionFlow",
			Handler:    _Tribe_GetVersionFlow_Handler,
		},
		{
			MethodName: "ConfigVersionUpgrade",
			Handler:    _Tribe_ConfigVersionUpgrade_Handler,
		},
		{
			MethodName: "GetConfigVersionUpgrade",
			Handler:    _Tribe_GetConfigVersionUpgrade_Handler,
		},
		{
			MethodName: "ConfigPackUpgradeFilter",
			Handler:    _Tribe_ConfigPackUpgradeFilter_Handler,
		},
		{
			MethodName: "GetConfigPackUpgradeFilter",
			Handler:    _Tribe_GetConfigPackUpgradeFilter_Handler,
		},
		{
			MethodName: "GetPackRelations",
			Handler:    _Tribe_GetPackRelations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go-gateway/app/app-svr/fawkes/service/api/app/tribe/tribe.proto",
}

func (m *GetPackRelationsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPackRelationsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPackRelationsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Feature) > 0 {
		i -= len(m.Feature)
		copy(dAtA[i:], m.Feature)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Feature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPackRelationsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPackRelationsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPackRelationsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Relations) > 0 {
		for iNdEx := len(m.Relations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Feature) > 0 {
		i -= len(m.Feature)
		copy(dAtA[i:], m.Feature)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Feature)))
		i--
		dAtA[i] = 0x22
	}
	if m.ParentBuildId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.ParentBuildId))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentBuildId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.CurrentBuildId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTribeBuildPackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTribeBuildPackReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTribeBuildPackReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ps != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x58
	}
	if m.Pn != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x50
	}
	if m.Order != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GitKeyword) > 0 {
		i -= len(m.GitKeyword)
		copy(dAtA[i:], m.GitKeyword)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.GitKeyword)))
		i--
		dAtA[i] = 0x3a
	}
	if m.GitType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitType))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.PkgType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.PkgType))
		i--
		dAtA[i] = 0x20
	}
	if m.GitlabJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitlabJobId))
		i--
		dAtA[i] = 0x18
	}
	if m.IdType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.IdType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTribeBuildPackResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTribeBuildPackResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTribeBuildPackResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TribeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TribeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TribeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsBuildIn {
		i--
		if m.IsBuildIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Priority != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x40
	}
	if m.NoHost {
		i--
		if m.NoHost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Owners) > 0 {
		i -= len(m.Owners)
		copy(dAtA[i:], m.Owners)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Owners)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CName) > 0 {
		i -= len(m.CName)
		copy(dAtA[i:], m.CName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.CName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ps != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTribeInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTribeInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTribeInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTribeInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTribeInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTribeInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TribeInfo != nil {
		{
			size, err := m.TribeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListTribeInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTribeInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTribeInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pn != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x28
	}
	if m.Ps != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CName) > 0 {
		i -= len(m.CName)
		copy(dAtA[i:], m.CName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.CName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListTribeInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTribeInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTribeInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TribeInfo) > 0 {
		for iNdEx := len(m.TribeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TribeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PageInfo != nil {
		{
			size, err := m.PageInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTribeInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTribeInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTribeInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTribeInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTribeInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTribeInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsBuildIn {
		i--
		if m.IsBuildIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Priority != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x40
	}
	if m.NoHost {
		i--
		if m.NoHost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Owners) > 0 {
		i -= len(m.Owners)
		copy(dAtA[i:], m.Owners)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Owners)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CName) > 0 {
		i -= len(m.CName)
		copy(dAtA[i:], m.CName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.CName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddTribeInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTribeInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTribeInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsBuildIn {
		i--
		if m.IsBuildIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Priority != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x38
	}
	if m.NoHost {
		i--
		if m.NoHost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Owners) > 0 {
		i -= len(m.Owners)
		copy(dAtA[i:], m.Owners)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Owners)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CName) > 0 {
		i -= len(m.CName)
		copy(dAtA[i:], m.CName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.CName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddTribeBuildPackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTribeBuildPackReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTribeBuildPackReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DepGlJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.DepGlJobId))
		i--
		dAtA[i] = 0x40
	}
	if m.ShouldNotify {
		i--
		if m.ShouldNotify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CiEnvVar) > 0 {
		i -= len(m.CiEnvVar)
		copy(dAtA[i:], m.CiEnvVar)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.CiEnvVar)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GitName) > 0 {
		i -= len(m.GitName)
		copy(dAtA[i:], m.GitName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.GitName)))
		i--
		dAtA[i] = 0x22
	}
	if m.GitType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitType))
		i--
		dAtA[i] = 0x18
	}
	if m.PkgType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.PkgType))
		i--
		dAtA[i] = 0x10
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListTribeBuildPackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTribeBuildPackReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTribeBuildPackReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PushCd) > 0 {
		i -= len(m.PushCd)
		copy(dAtA[i:], m.PushCd)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.PushCd)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x7a
	}
	if m.State != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x70
	}
	if len(m.Commit) > 0 {
		i -= len(m.Commit)
		copy(dAtA[i:], m.Commit)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Commit)))
		i--
		dAtA[i] = 0x6a
	}
	if m.DepGlJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.DepGlJobId))
		i--
		dAtA[i] = 0x60
	}
	if m.Ps != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x58
	}
	if m.Pn != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x50
	}
	if m.Sort != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x48
	}
	if m.OrderBy != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.OrderBy))
		i--
		dAtA[i] = 0x40
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GitName) > 0 {
		i -= len(m.GitName)
		copy(dAtA[i:], m.GitName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.GitName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GitType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitType))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.PkgType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.PkgType))
		i--
		dAtA[i] = 0x10
	}
	if m.GlJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GlJobId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListTribeBuildPackResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTribeBuildPackResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTribeBuildPackResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PageInfo != nil {
		{
			size, err := m.PageInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TribeBuildPackInfos) > 0 {
		for iNdEx := len(m.TribeBuildPackInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TribeBuildPackInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TribeBuildPackInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TribeBuildPackInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TribeBuildPackInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DepFeature) > 0 {
		i -= len(m.DepFeature)
		copy(dAtA[i:], m.DepFeature)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.DepFeature)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.VersionName) > 0 {
		i -= len(m.VersionName)
		copy(dAtA[i:], m.VersionName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.VersionName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.VersionCode != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionCode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if len(m.JobUrl) > 0 {
		i -= len(m.JobUrl)
		copy(dAtA[i:], m.JobUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.JobUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Mtime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.Ctime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.BuildEndTime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.BuildEndTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.BuildStartTime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.BuildStartTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.CiEnvVars) > 0 {
		i -= len(m.CiEnvVars)
		copy(dAtA[i:], m.CiEnvVars)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.CiEnvVars)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.NotifyGroup {
		i--
		if m.NotifyGroup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.ChangeLog) > 0 {
		i -= len(m.ChangeLog)
		copy(dAtA[i:], m.ChangeLog)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.ChangeLog)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.DidPush != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.DidPush))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Status != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.State != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.BbrUrl) > 0 {
		i -= len(m.BbrUrl)
		copy(dAtA[i:], m.BbrUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.BbrUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.MappingUrl) > 0 {
		i -= len(m.MappingUrl)
		copy(dAtA[i:], m.MappingUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.MappingUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PkgUrl) > 0 {
		i -= len(m.PkgUrl)
		copy(dAtA[i:], m.PkgUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.PkgUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.PkgPath) > 0 {
		i -= len(m.PkgPath)
		copy(dAtA[i:], m.PkgPath)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.PkgPath)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x72
	}
	if m.Size_ != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x62
	}
	if m.PkgType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.PkgType))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Commit) > 0 {
		i -= len(m.Commit)
		copy(dAtA[i:], m.Commit)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Commit)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.GitName) > 0 {
		i -= len(m.GitName)
		copy(dAtA[i:], m.GitName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.GitName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.GitType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitType))
		i--
		dAtA[i] = 0x40
	}
	if len(m.GitPath) > 0 {
		i -= len(m.GitPath)
		copy(dAtA[i:], m.GitPath)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.GitPath)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AppId) > 0 {
		i -= len(m.AppId)
		copy(dAtA[i:], m.AppId)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DepGlJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.DepGlJobId))
		i--
		dAtA[i] = 0x20
	}
	if m.GlJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GlJobId))
		i--
		dAtA[i] = 0x18
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTribeBuildPackInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTribeBuildPackInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTribeBuildPackInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTribeBuildPackInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTribeBuildPackInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTribeBuildPackInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TribeBuildPackInfo != nil {
		{
			size, err := m.TribeBuildPackInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushTribeBuildPackToCDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushTribeBuildPackToCDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushTribeBuildPackToCDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribeBuildPackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeBuildPackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTribeBuildPackGitInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTribeBuildPackGitInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTribeBuildPackGitInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DepGitlabJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.DepGitlabJobId))
		i--
		dAtA[i] = 0x38
	}
	if m.BuildStartTime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.BuildStartTime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Commit) > 0 {
		i -= len(m.Commit)
		copy(dAtA[i:], m.Commit)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Commit)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GitPath) > 0 {
		i -= len(m.GitPath)
		copy(dAtA[i:], m.GitPath)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.GitPath)))
		i--
		dAtA[i] = 0x22
	}
	if m.GitlabJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitlabJobId))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.TribeBuildPackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeBuildPackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTribeBuildPackPkgInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTribeBuildPackPkgInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTribeBuildPackPkgInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VersionName) > 0 {
		i -= len(m.VersionName)
		copy(dAtA[i:], m.VersionName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.VersionName)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Unzip {
		i--
		if m.Unzip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.VersionCode != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionCode))
		i--
		dAtA[i] = 0x48
	}
	if m.BuildEndTime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.BuildEndTime))
		i--
		dAtA[i] = 0x40
	}
	if len(m.BbrPath) > 0 {
		i -= len(m.BbrPath)
		copy(dAtA[i:], m.BbrPath)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.BbrPath)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MappingPath) > 0 {
		i -= len(m.MappingPath)
		copy(dAtA[i:], m.MappingPath)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.MappingPath)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PkgPath) > 0 {
		i -= len(m.PkgPath)
		copy(dAtA[i:], m.PkgPath)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.PkgPath)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ChangeLog) > 0 {
		i -= len(m.ChangeLog)
		copy(dAtA[i:], m.ChangeLog)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.ChangeLog)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.TribeBuildPackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeBuildPackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTribeBuildPackPkgInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTribeBuildPackPkgInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTribeBuildPackPkgInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MappingUrl) > 0 {
		i -= len(m.MappingUrl)
		copy(dAtA[i:], m.MappingUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.MappingUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MainBbrUrl) > 0 {
		i -= len(m.MainBbrUrl)
		copy(dAtA[i:], m.MainBbrUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.MainBbrUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MainApkUrl) > 0 {
		i -= len(m.MainApkUrl)
		copy(dAtA[i:], m.MainApkUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.MainApkUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelTribeBuildPackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelTribeBuildPackReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelTribeBuildPackReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TribeBuildPackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeBuildPackId))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ListTribePackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTribePackReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTribePackReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x32
	}
	if m.Pn != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x28
	}
	if m.Ps != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListTribePackResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTribePackResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTribePackResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VersionPackInfo) > 0 {
		for iNdEx := len(m.VersionPackInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VersionPackInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PageInfo != nil {
		{
			size, err := m.PageInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionPack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionPack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionPack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PackInfo) > 0 {
		for iNdEx := len(m.PackInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.VersionName) > 0 {
		i -= len(m.VersionName)
		copy(dAtA[i:], m.VersionName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigVersionFlowReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigVersionFlowReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigVersionFlowReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Flow) > 0 {
		for iNdEx := len(m.Flow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.VersionId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Flow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x32
	}
	if m.Mtime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if m.Ctime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x20
	}
	if m.GitJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitJobId))
		i--
		dAtA[i] = 0x18
	}
	if m.To != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConfigVersionUpgradeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigVersionUpgradeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigVersionUpgradeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.StartingVersionCode) > 0 {
		for iNdEx := len(m.StartingVersionCode) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StartingVersionCode[iNdEx])
			copy(dAtA[i:], m.StartingVersionCode[iNdEx])
			i = encodeVarintTribe(dAtA, i, uint64(len(m.StartingVersionCode[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ChosenVersionCode) > 0 {
		for iNdEx := len(m.ChosenVersionCode) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChosenVersionCode[iNdEx])
			copy(dAtA[i:], m.ChosenVersionCode[iNdEx])
			i = encodeVarintTribe(dAtA, i, uint64(len(m.ChosenVersionCode[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TribePackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribePackId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Max) > 0 {
		i -= len(m.Max)
		copy(dAtA[i:], m.Max)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Max)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Min) > 0 {
		i -= len(m.Min)
		copy(dAtA[i:], m.Min)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Min)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BuildId) > 0 {
		dAtA8 := make([]byte, len(m.BuildId)*10)
		var j7 int
		for _, num1 := range m.BuildId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTribe(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PackInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PackInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DepFeature) > 0 {
		i -= len(m.DepFeature)
		copy(dAtA[i:], m.DepFeature)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.DepFeature)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.LastMtime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.LastMtime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.LastOperator) > 0 {
		i -= len(m.LastOperator)
		copy(dAtA[i:], m.LastOperator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.LastOperator)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.VersionInfo != nil {
		{
			size, err := m.VersionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.JobUrl) > 0 {
		i -= len(m.JobUrl)
		copy(dAtA[i:], m.JobUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.JobUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.Flow != nil {
		{
			size, err := m.Flow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.Ctime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Mtime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.PackUpgrade != nil {
		{
			size, err := m.PackUpgrade.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTribe(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.CdnUrl) > 0 {
		i -= len(m.CdnUrl)
		copy(dAtA[i:], m.CdnUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.CdnUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.BbrUrl) > 0 {
		i -= len(m.BbrUrl)
		copy(dAtA[i:], m.BbrUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.BbrUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.MappingUrl) > 0 {
		i -= len(m.MappingUrl)
		copy(dAtA[i:], m.MappingUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.MappingUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.PackUrl) > 0 {
		i -= len(m.PackUrl)
		copy(dAtA[i:], m.PackUrl)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.PackUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.PackPath) > 0 {
		i -= len(m.PackPath)
		copy(dAtA[i:], m.PackPath)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.PackPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Size_ != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ChangeLog) > 0 {
		i -= len(m.ChangeLog)
		copy(dAtA[i:], m.ChangeLog)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.ChangeLog)))
		i--
		dAtA[i] = 0x6a
	}
	if m.PackType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.PackType))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Commit) > 0 {
		i -= len(m.Commit)
		copy(dAtA[i:], m.Commit)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Commit)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.GitName) > 0 {
		i -= len(m.GitName)
		copy(dAtA[i:], m.GitName)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.GitName)))
		i--
		dAtA[i] = 0x52
	}
	if m.GitType != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GitType))
		i--
		dAtA[i] = 0x48
	}
	if m.VersionId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionId))
		i--
		dAtA[i] = 0x40
	}
	if m.DepGlJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.DepGlJobId))
		i--
		dAtA[i] = 0x38
	}
	if m.GlJobId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.GlJobId))
		i--
		dAtA[i] = 0x30
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppId) > 0 {
		i -= len(m.AppId)
		copy(dAtA[i:], m.AppId)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VersionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Mtime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x30
	}
	if m.Ctime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x28
	}
	if m.VersionId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.VersionCode) > 0 {
		i -= len(m.VersionCode)
		copy(dAtA[i:], m.VersionCode)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.VersionCode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActiveVersionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveVersionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveVersionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.VersionId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetVersionFlowReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVersionFlowReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetVersionFlowReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VersionId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.VersionId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetVersionFlowResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVersionFlowResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetVersionFlowResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Flows) > 0 {
		for iNdEx := len(m.Flows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTribe(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigVersionUpgradeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigVersionUpgradeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigVersionUpgradeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TribePackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribePackId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigVersionUpgradeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigVersionUpgradeResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigVersionUpgradeResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StartingVersionCode) > 0 {
		for iNdEx := len(m.StartingVersionCode) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StartingVersionCode[iNdEx])
			copy(dAtA[i:], m.StartingVersionCode[iNdEx])
			i = encodeVarintTribe(dAtA, i, uint64(len(m.StartingVersionCode[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ChosenVersionCode) > 0 {
		for iNdEx := len(m.ChosenVersionCode) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChosenVersionCode[iNdEx])
			copy(dAtA[i:], m.ChosenVersionCode[iNdEx])
			i = encodeVarintTribe(dAtA, i, uint64(len(m.ChosenVersionCode[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConfigPackUpgradeFilterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigPackUpgradeFilterReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigPackUpgradeFilterReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExcludesSystem) > 0 {
		i -= len(m.ExcludesSystem)
		copy(dAtA[i:], m.ExcludesSystem)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.ExcludesSystem)))
		i--
		dAtA[i] = 0x62
	}
	if m.Percent != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Percent))
		i--
		dAtA[i] = 0x58
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Type != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x40
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Isp) > 0 {
		i -= len(m.Isp)
		copy(dAtA[i:], m.Isp)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Isp)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0x22
	}
	if m.TribePackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribePackId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigPackUpgradeFilterResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigPackUpgradeFilterResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigPackUpgradeFilterResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Ctime != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ExcludesSystem) > 0 {
		i -= len(m.ExcludesSystem)
		copy(dAtA[i:], m.ExcludesSystem)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.ExcludesSystem)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x62
	}
	if m.Percent != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Percent))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Type != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x40
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Isp) > 0 {
		i -= len(m.Isp)
		copy(dAtA[i:], m.Isp)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Isp)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0x22
	}
	if m.BuildId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.BuildId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvolutionTribeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvolutionTribeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvolutionTribeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribePackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribePackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigPackUpgradeFilterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigPackUpgradeFilterReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigPackUpgradeFilterReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TribePackId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribePackId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintTribe(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x12
	}
	if m.TribeId != 0 {
		i = encodeVarintTribe(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTribe(dAtA []byte, offset int, v uint64) int {
	offset -= sovTribe(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetPackRelationsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Feature)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPackRelationsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Relation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	if m.CurrentBuildId != 0 {
		n += 1 + sovTribe(uint64(m.CurrentBuildId))
	}
	if m.ParentBuildId != 0 {
		n += 1 + sovTribe(uint64(m.ParentBuildId))
	}
	l = len(m.Feature)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTribeBuildPackReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.IdType != 0 {
		n += 1 + sovTribe(uint64(m.IdType))
	}
	if m.GitlabJobId != 0 {
		n += 1 + sovTribe(uint64(m.GitlabJobId))
	}
	if m.PkgType != 0 {
		n += 1 + sovTribe(uint64(m.PkgType))
	}
	if m.Status != 0 {
		n += 1 + sovTribe(uint64(m.Status))
	}
	if m.GitType != 0 {
		n += 1 + sovTribe(uint64(m.GitType))
	}
	l = len(m.GitKeyword)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovTribe(uint64(m.Order))
	}
	if m.Pn != 0 {
		n += 1 + sovTribe(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovTribe(uint64(m.Ps))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTribeBuildPackResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovTribe(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TribeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.CName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Owners)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.NoHost {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovTribe(uint64(m.Priority))
	}
	if m.IsBuildIn {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovTribe(uint64(m.Total))
	}
	if m.Pn != 0 {
		n += 1 + sovTribe(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovTribe(uint64(m.Ps))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTribeInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTribeInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeInfo != nil {
		l = m.TribeInfo.Size()
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTribeInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.CName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Ps != 0 {
		n += 1 + sovTribe(uint64(m.Ps))
	}
	if m.Pn != 0 {
		n += 1 + sovTribe(uint64(m.Pn))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTribeInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageInfo != nil {
		l = m.PageInfo.Size()
		n += 1 + l + sovTribe(uint64(l))
	}
	if len(m.TribeInfo) > 0 {
		for _, e := range m.TribeInfo {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteTribeInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTribeInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.CName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Owners)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.NoHost {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovTribe(uint64(m.Priority))
	}
	if m.IsBuildIn {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddTribeInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.CName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Owners)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.NoHost {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovTribe(uint64(m.Priority))
	}
	if m.IsBuildIn {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddTribeBuildPackReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	if m.PkgType != 0 {
		n += 1 + sovTribe(uint64(m.PkgType))
	}
	if m.GitType != 0 {
		n += 1 + sovTribe(uint64(m.GitType))
	}
	l = len(m.GitName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.CiEnvVar)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.ShouldNotify {
		n += 2
	}
	if m.DepGlJobId != 0 {
		n += 1 + sovTribe(uint64(m.DepGlJobId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTribeBuildPackReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GlJobId != 0 {
		n += 1 + sovTribe(uint64(m.GlJobId))
	}
	if m.PkgType != 0 {
		n += 1 + sovTribe(uint64(m.PkgType))
	}
	if m.Status != 0 {
		n += 1 + sovTribe(uint64(m.Status))
	}
	if m.GitType != 0 {
		n += 1 + sovTribe(uint64(m.GitType))
	}
	l = len(m.GitName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	if m.OrderBy != 0 {
		n += 1 + sovTribe(uint64(m.OrderBy))
	}
	if m.Sort != 0 {
		n += 1 + sovTribe(uint64(m.Sort))
	}
	if m.Pn != 0 {
		n += 1 + sovTribe(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovTribe(uint64(m.Ps))
	}
	if m.DepGlJobId != 0 {
		n += 1 + sovTribe(uint64(m.DepGlJobId))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTribe(uint64(m.State))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.PushCd)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTribeBuildPackResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TribeBuildPackInfos) > 0 {
		for _, e := range m.TribeBuildPackInfos {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.PageInfo != nil {
		l = m.PageInfo.Size()
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TribeBuildPackInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	if m.GlJobId != 0 {
		n += 1 + sovTribe(uint64(m.GlJobId))
	}
	if m.DepGlJobId != 0 {
		n += 1 + sovTribe(uint64(m.DepGlJobId))
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.GitPath)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.GitType != 0 {
		n += 1 + sovTribe(uint64(m.GitType))
	}
	l = len(m.GitName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.PkgType != 0 {
		n += 1 + sovTribe(uint64(m.PkgType))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTribe(uint64(m.Size_))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.PkgPath)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.PkgUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.MappingUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.BbrUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.State != 0 {
		n += 2 + sovTribe(uint64(m.State))
	}
	if m.Status != 0 {
		n += 2 + sovTribe(uint64(m.Status))
	}
	if m.DidPush != 0 {
		n += 2 + sovTribe(uint64(m.DidPush))
	}
	l = len(m.ChangeLog)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.NotifyGroup {
		n += 3
	}
	l = len(m.CiEnvVars)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.BuildStartTime != 0 {
		n += 2 + sovTribe(uint64(m.BuildStartTime))
	}
	if m.BuildEndTime != 0 {
		n += 2 + sovTribe(uint64(m.BuildEndTime))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.Ctime != 0 {
		n += 2 + sovTribe(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 2 + sovTribe(uint64(m.Mtime))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.JobUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.VersionCode != 0 {
		n += 2 + sovTribe(uint64(m.VersionCode))
	}
	l = len(m.VersionName)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.DepFeature)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTribeBuildPackInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTribeBuildPackInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeBuildPackInfo != nil {
		l = m.TribeBuildPackInfo.Size()
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushTribeBuildPackToCDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeBuildPackId != 0 {
		n += 1 + sovTribe(uint64(m.TribeBuildPackId))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTribeBuildPackGitInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeBuildPackId != 0 {
		n += 1 + sovTribe(uint64(m.TribeBuildPackId))
	}
	if m.Status != 0 {
		n += 1 + sovTribe(uint64(m.Status))
	}
	if m.GitlabJobId != 0 {
		n += 1 + sovTribe(uint64(m.GitlabJobId))
	}
	l = len(m.GitPath)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.BuildStartTime != 0 {
		n += 1 + sovTribe(uint64(m.BuildStartTime))
	}
	if m.DepGitlabJobId != 0 {
		n += 1 + sovTribe(uint64(m.DepGitlabJobId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTribeBuildPackPkgInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeBuildPackId != 0 {
		n += 1 + sovTribe(uint64(m.TribeBuildPackId))
	}
	if m.Status != 0 {
		n += 1 + sovTribe(uint64(m.Status))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.ChangeLog)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.PkgPath)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.MappingPath)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.BbrPath)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.BuildEndTime != 0 {
		n += 1 + sovTribe(uint64(m.BuildEndTime))
	}
	if m.VersionCode != 0 {
		n += 1 + sovTribe(uint64(m.VersionCode))
	}
	if m.Unzip {
		n += 2
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.VersionName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTribeBuildPackPkgInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MainApkUrl)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.MainBbrUrl)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.MappingUrl)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelTribeBuildPackReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeBuildPackId != 0 {
		n += 1 + sovTribe(uint64(m.TribeBuildPackId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTribePackReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTribe(uint64(m.State))
	}
	if m.Ps != 0 {
		n += 1 + sovTribe(uint64(m.Ps))
	}
	if m.Pn != 0 {
		n += 1 + sovTribe(uint64(m.Pn))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTribePackResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageInfo != nil {
		l = m.PageInfo.Size()
		n += 1 + l + sovTribe(uint64(l))
	}
	if len(m.VersionPackInfo) > 0 {
		for _, e := range m.VersionPackInfo {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionPack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VersionName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if len(m.PackInfo) > 0 {
		for _, e := range m.PackInfo {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigVersionFlowReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.VersionId != 0 {
		n += 1 + sovTribe(uint64(m.VersionId))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if len(m.Flow) > 0 {
		for _, e := range m.Flow {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Flow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovTribe(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovTribe(uint64(m.To))
	}
	if m.GitJobId != 0 {
		n += 1 + sovTribe(uint64(m.GitJobId))
	}
	if m.Ctime != 0 {
		n += 1 + sovTribe(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovTribe(uint64(m.Mtime))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigVersionUpgradeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.TribePackId != 0 {
		n += 1 + sovTribe(uint64(m.TribePackId))
	}
	if len(m.ChosenVersionCode) > 0 {
		for _, s := range m.ChosenVersionCode {
			l = len(s)
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if len(m.StartingVersionCode) > 0 {
		for _, s := range m.StartingVersionCode {
			l = len(s)
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Min)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Max)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionId != 0 {
		n += 1 + sovTribe(uint64(m.VersionId))
	}
	if len(m.BuildId) > 0 {
		l = 0
		for _, e := range m.BuildId {
			l += sovTribe(uint64(e))
		}
		n += 1 + sovTribe(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PackInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTribe(uint64(m.Id))
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	if m.GlJobId != 0 {
		n += 1 + sovTribe(uint64(m.GlJobId))
	}
	if m.DepGlJobId != 0 {
		n += 1 + sovTribe(uint64(m.DepGlJobId))
	}
	if m.VersionId != 0 {
		n += 1 + sovTribe(uint64(m.VersionId))
	}
	if m.GitType != 0 {
		n += 1 + sovTribe(uint64(m.GitType))
	}
	l = len(m.GitName)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.PackType != 0 {
		n += 1 + sovTribe(uint64(m.PackType))
	}
	l = len(m.ChangeLog)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTribe(uint64(m.Size_))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.PackPath)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.PackUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.MappingUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.BbrUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.CdnUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.PackUpgrade != nil {
		l = m.PackUpgrade.Size()
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.Mtime != 0 {
		n += 2 + sovTribe(uint64(m.Mtime))
	}
	if m.Ctime != 0 {
		n += 2 + sovTribe(uint64(m.Ctime))
	}
	if m.Flow != nil {
		l = m.Flow.Size()
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.JobUrl)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.VersionInfo != nil {
		l = m.VersionInfo.Size()
		n += 2 + l + sovTribe(uint64(l))
	}
	l = len(m.LastOperator)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.LastMtime != 0 {
		n += 2 + sovTribe(uint64(m.LastMtime))
	}
	l = len(m.DepFeature)
	if l > 0 {
		n += 2 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	l = len(m.VersionCode)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.VersionId != 0 {
		n += 1 + sovTribe(uint64(m.VersionId))
	}
	if m.Ctime != 0 {
		n += 1 + sovTribe(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovTribe(uint64(m.Mtime))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActiveVersionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.VersionId != 0 {
		n += 1 + sovTribe(uint64(m.VersionId))
	}
	if m.Active {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVersionFlowReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.VersionId != 0 {
		n += 1 + sovTribe(uint64(m.VersionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVersionFlowResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for _, e := range m.Flows {
			l = e.Size()
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigVersionUpgradeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.TribePackId != 0 {
		n += 1 + sovTribe(uint64(m.TribePackId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigVersionUpgradeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChosenVersionCode) > 0 {
		for _, s := range m.ChosenVersionCode {
			l = len(s)
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if len(m.StartingVersionCode) > 0 {
		for _, s := range m.StartingVersionCode {
			l = len(s)
			n += 1 + l + sovTribe(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigPackUpgradeFilterReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.TribePackId != 0 {
		n += 1 + sovTribe(uint64(m.TribePackId))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Isp)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTribe(uint64(m.Type))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Percent != 0 {
		n += 1 + sovTribe(uint64(m.Percent))
	}
	l = len(m.ExcludesSystem)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigPackUpgradeFilterResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.BuildId != 0 {
		n += 1 + sovTribe(uint64(m.BuildId))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Isp)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTribe(uint64(m.Type))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Percent != 0 {
		n += 1 + sovTribe(uint64(m.Percent))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.ExcludesSystem)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovTribe(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 2 + sovTribe(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvolutionTribeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribePackId != 0 {
		n += 1 + sovTribe(uint64(m.TribePackId))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigPackUpgradeFilterReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovTribe(uint64(m.TribeId))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovTribe(uint64(l))
	}
	if m.TribePackId != 0 {
		n += 1 + sovTribe(uint64(m.TribePackId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTribe(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTribe(x uint64) (n int) {
	return sovTribe(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetPackRelationsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPackRelationsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPackRelationsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPackRelationsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPackRelationsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPackRelationsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBuildId", wireType)
			}
			m.CurrentBuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBuildId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentBuildId", wireType)
			}
			m.ParentBuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentBuildId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTribeBuildPackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTribeBuildPackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTribeBuildPackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			m.IdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitlabJobId", wireType)
			}
			m.GitlabJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitlabJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgType", wireType)
			}
			m.PkgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitType", wireType)
			}
			m.GitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitKeyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitKeyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= Sort(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTribeBuildPackResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTribeBuildPackResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTribeBuildPackResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Page == nil {
				m.Page = &PageInfo{}
			}
			if err := m.Page.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &TribeBuildPackInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TribeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TribeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TribeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owners = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoHost = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuildIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuildIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTribeInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTribeInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTribeInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTribeInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTribeInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTribeInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TribeInfo == nil {
				m.TribeInfo = &TribeInfo{}
			}
			if err := m.TribeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTribeInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTribeInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTribeInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTribeInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTribeInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTribeInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageInfo == nil {
				m.PageInfo = &PageInfo{}
			}
			if err := m.PageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TribeInfo = append(m.TribeInfo, &TribeInfo{})
			if err := m.TribeInfo[len(m.TribeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTribeInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTribeInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTribeInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTribeInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTribeInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTribeInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owners = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoHost = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuildIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuildIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTribeInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTribeInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTribeInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owners = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoHost = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuildIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuildIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTribeBuildPackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTribeBuildPackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTribeBuildPackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgType", wireType)
			}
			m.PkgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitType", wireType)
			}
			m.GitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CiEnvVar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CiEnvVar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShouldNotify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShouldNotify = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepGlJobId", wireType)
			}
			m.DepGlJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepGlJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTribeBuildPackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTribeBuildPackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTribeBuildPackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlJobId", wireType)
			}
			m.GlJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgType", wireType)
			}
			m.PkgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitType", wireType)
			}
			m.GitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitType |= ListTribeBuildPackReq_GitType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			m.OrderBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderBy |= ListTribeBuildPackReq_OrderBy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= Sort(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepGlJobId", wireType)
			}
			m.DepGlJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepGlJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushCd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushCd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTribeBuildPackResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTribeBuildPackResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTribeBuildPackResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeBuildPackInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TribeBuildPackInfos = append(m.TribeBuildPackInfos, &TribeBuildPackInfo{})
			if err := m.TribeBuildPackInfos[len(m.TribeBuildPackInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageInfo == nil {
				m.PageInfo = &PageInfo{}
			}
			if err := m.PageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TribeBuildPackInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TribeBuildPackInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TribeBuildPackInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlJobId", wireType)
			}
			m.GlJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepGlJobId", wireType)
			}
			m.DepGlJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepGlJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitType", wireType)
			}
			m.GitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgType", wireType)
			}
			m.PkgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkgPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappingUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BbrUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BbrUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidPush", wireType)
			}
			m.DidPush = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DidPush |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyGroup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotifyGroup = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CiEnvVars", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CiEnvVars = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildStartTime", wireType)
			}
			m.BuildStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildEndTime", wireType)
			}
			m.BuildEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildEndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCode", wireType)
			}
			m.VersionCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepFeature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepFeature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTribeBuildPackInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTribeBuildPackInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTribeBuildPackInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTribeBuildPackInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTribeBuildPackInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTribeBuildPackInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeBuildPackInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TribeBuildPackInfo == nil {
				m.TribeBuildPackInfo = &TribeBuildPackInfo{}
			}
			if err := m.TribeBuildPackInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushTribeBuildPackToCDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushTribeBuildPackToCDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushTribeBuildPackToCDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeBuildPackId", wireType)
			}
			m.TribeBuildPackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeBuildPackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTribeBuildPackGitInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTribeBuildPackGitInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTribeBuildPackGitInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeBuildPackId", wireType)
			}
			m.TribeBuildPackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeBuildPackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CallbackStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitlabJobId", wireType)
			}
			m.GitlabJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitlabJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildStartTime", wireType)
			}
			m.BuildStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepGitlabJobId", wireType)
			}
			m.DepGitlabJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepGitlabJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTribeBuildPackPkgInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTribeBuildPackPkgInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTribeBuildPackPkgInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeBuildPackId", wireType)
			}
			m.TribeBuildPackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeBuildPackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CallbackStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File[:0], dAtA[iNdEx:postIndex]...)
			if m.File == nil {
				m.File = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkgPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappingPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BbrPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BbrPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildEndTime", wireType)
			}
			m.BuildEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildEndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCode", wireType)
			}
			m.VersionCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unzip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unzip = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTribeBuildPackPkgInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTribeBuildPackPkgInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTribeBuildPackPkgInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainApkUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainApkUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainBbrUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainBbrUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappingUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelTribeBuildPackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTribeBuildPackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTribeBuildPackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeBuildPackId", wireType)
			}
			m.TribeBuildPackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeBuildPackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTribePackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTribePackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTribePackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTribePackResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTribePackResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTribePackResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageInfo == nil {
				m.PageInfo = &PageInfo{}
			}
			if err := m.PageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionPackInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionPackInfo = append(m.VersionPackInfo, &VersionPack{})
			if err := m.VersionPackInfo[len(m.VersionPackInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionPack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionPack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionPack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackInfo = append(m.PackInfo, &PackInfo{})
			if err := m.PackInfo[len(m.PackInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigVersionFlowReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigVersionFlowReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigVersionFlowReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			m.VersionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = append(m.Flow, &Flow{})
			if err := m.Flow[len(m.Flow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitJobId", wireType)
			}
			m.GitJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigVersionUpgradeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigVersionUpgradeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigVersionUpgradeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribePackId", wireType)
			}
			m.TribePackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribePackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChosenVersionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChosenVersionCode = append(m.ChosenVersionCode, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingVersionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartingVersionCode = append(m.StartingVersionCode, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Min = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Max = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			m.VersionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTribe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuildId = append(m.BuildId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTribe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTribe
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTribe
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuildId) == 0 {
					m.BuildId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTribe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuildId = append(m.BuildId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlJobId", wireType)
			}
			m.GlJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepGlJobId", wireType)
			}
			m.DepGlJobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepGlJobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			m.VersionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitType", wireType)
			}
			m.GitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GitType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackType", wireType)
			}
			m.PackType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappingUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BbrUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BbrUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackUpgrade", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PackUpgrade == nil {
				m.PackUpgrade = &GetConfigPackUpgradeFilterResp{}
			}
			if err := m.PackUpgrade.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flow == nil {
				m.Flow = &Flow{}
			}
			if err := m.Flow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionInfo == nil {
				m.VersionInfo = &VersionInfo{}
			}
			if err := m.VersionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOperator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastOperator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMtime", wireType)
			}
			m.LastMtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepFeature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepFeature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			m.VersionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveVersionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveVersionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveVersionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			m.VersionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVersionFlowReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVersionFlowReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVersionFlowReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			m.VersionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVersionFlowResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVersionFlowResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVersionFlowResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, &Flow{})
			if err := m.Flows[len(m.Flows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigVersionUpgradeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigVersionUpgradeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigVersionUpgradeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribePackId", wireType)
			}
			m.TribePackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribePackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigVersionUpgradeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigVersionUpgradeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigVersionUpgradeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChosenVersionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChosenVersionCode = append(m.ChosenVersionCode, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingVersionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartingVersionCode = append(m.StartingVersionCode, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigPackUpgradeFilterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigPackUpgradeFilterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigPackUpgradeFilterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribePackId", wireType)
			}
			m.TribePackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribePackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UpgradeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			m.Percent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Percent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludesSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludesSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigPackUpgradeFilterResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigPackUpgradeFilterResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigPackUpgradeFilterResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			m.BuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UpgradeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			m.Percent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Percent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludesSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludesSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvolutionTribeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvolutionTribeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvolutionTribeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribePackId", wireType)
			}
			m.TribePackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribePackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigPackUpgradeFilterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigPackUpgradeFilterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigPackUpgradeFilterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTribe
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTribe
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribePackId", wireType)
			}
			m.TribePackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribePackId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTribe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTribe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTribe(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTribe
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTribe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTribe
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTribe
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTribe
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTribe        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTribe          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTribe = fmt.Errorf("proto: unexpected end of group")
)
