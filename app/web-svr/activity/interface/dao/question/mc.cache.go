// Code generated by kratos tool mcgen. DO NOT EDIT.

/*
  Package question is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=detailKey -struct_name=Dao
		CacheDetail(c context.Context, id int64) (*question.Detail, error)
		// mc: -key=detailKey -expire=d.questionExpire -encode=pb -struct_name=Dao
		AddCacheDetail(c context.Context, id int64, data *question.Detail) error
		// mc: -key=detailKey -struct_name=Dao
		DelCacheDetail(c context.Context, id int64) error
		// mc: -key=detailKey -struct_name=Dao
		CacheDetails(c context.Context, ids []int64) (map[int64]*question.Detail, error)
		// mc: -key=detailKey -expire=d.questionExpire -encode=pb -struct_name=Dao
		AddCacheDetails(c context.Context, data map[int64]*question.Detail) error
		// mc: -key=lastLogKey -struct_name=Dao
		CacheLastQuesLog(c context.Context, mid int64, baseID int64) (*question.UserAnswerLog, error)
		// mc: -key=lastLogKey -expire=d.lastLogExpire -encode=pb -struct_name=Dao
		AddCacheLastQuesLog(c context.Context, mid int64, data *question.UserAnswerLog, baseID int64) error
	}
*/

package question

import (
	"context"
	"fmt"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-gateway/app/web-svr/activity/interface/model/question"
)

var _ _mc

// CacheDetail get data from mc
func (d *Dao) CacheDetail(c context.Context, id int64) (res *question.Detail, err error) {
	key := detailKey(id)
	res = &question.Detail{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheDetail", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheDetail Set data to mc
func (d *Dao) AddCacheDetail(c context.Context, id int64, val *question.Detail) (err error) {
	if val == nil {
		return
	}
	key := detailKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.questionExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheDetail", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheDetail delete data from mc
func (d *Dao) DelCacheDetail(c context.Context, id int64) (err error) {
	key := detailKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheDetail", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheDetails get data from mc
func (d *Dao) CacheDetails(c context.Context, ids []int64) (res map[int64]*question.Detail, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := detailKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheDetails", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &question.Detail{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheDetails", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*question.Detail, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheDetails Set data to mc
func (d *Dao) AddCacheDetails(c context.Context, values map[int64]*question.Detail) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := detailKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.questionExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheDetails", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheLastQuesLog get data from mc
func (d *Dao) CacheLastQuesLog(c context.Context, id int64, baseID int64) (res *question.UserAnswerLog, err error) {
	key := lastLogKey(id, baseID)
	res = &question.UserAnswerLog{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheLastQuesLog", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheLastQuesLog Set data to mc
func (d *Dao) AddCacheLastQuesLog(c context.Context, id int64, val *question.UserAnswerLog, baseID int64) (err error) {
	if val == nil {
		return
	}
	key := lastLogKey(id, baseID)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.lastLogExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheLastQuesLog", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
