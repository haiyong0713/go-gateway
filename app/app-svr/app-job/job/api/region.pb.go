// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: region.proto

// use {app_id}.{version} as package name

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Region struct {
	// region ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 一级分区ID
	Rid int32 `protobuf:"varint,2,opt,name=rid,proto3" json:"rid,omitempty"`
	// 父级ID
	Reid int32 `protobuf:"varint,3,opt,name=reid,proto3" json:"reid,omitempty"`
	// 分区名
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// 图片地址
	Logo string `protobuf:"bytes,5,opt,name=logo,proto3" json:"logo,omitempty"`
	// 默认为av
	Goto string `protobuf:"bytes,6,opt,name=goto,proto3" json:"goto,omitempty"`
	// 数据参数
	Param string `protobuf:"bytes,7,opt,name=param,proto3" json:"param,omitempty"`
	// 排行榜
	Rank string `protobuf:"bytes,8,opt,name=rank,proto3" json:"rank,omitempty"`
	// 客户端平台
	Plat int32 `protobuf:"varint,9,opt,name=plat,proto3" json:"plat,omitempty"`
	// 区域
	Area string `protobuf:"bytes,10,opt,name=area,proto3" json:"area,omitempty"`
	// 使用语言
	Language string `protobuf:"bytes,11,opt,name=language,proto3" json:"language,omitempty"`
	// build号
	Build int32 `protobuf:"varint,12,opt,name=build,proto3" json:"build,omitempty"`
	// 状态字段
	Condition string `protobuf:"bytes,13,opt,name=condition,proto3" json:"condition,omitempty"`
	// uri
	Uri string `protobuf:"bytes,14,opt,name=uri,proto3" json:"uri,omitempty"`
	// logo确认
	IsLogo int32 `protobuf:"varint,15,opt,name=is_logo,json=isLogo,proto3" json:"is_logo,omitempty"`
	// 分区类型
	Rtype int32 `protobuf:"varint,16,opt,name=rtype,proto3" json:"rtype,omitempty"`
	// 业务id
	Entrance             int32    `protobuf:"varint,17,opt,name=entrance,proto3" json:"entrance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Region) Reset()         { *m = Region{} }
func (m *Region) String() string { return proto.CompactTextString(m) }
func (*Region) ProtoMessage()    {}
func (*Region) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{0}
}
func (m *Region) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Region) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Region.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Region) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Region.Merge(m, src)
}
func (m *Region) XXX_Size() int {
	return m.Size()
}
func (m *Region) XXX_DiscardUnknown() {
	xxx_messageInfo_Region.DiscardUnknown(m)
}

var xxx_messageInfo_Region proto.InternalMessageInfo

func (m *Region) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Region) GetRid() int32 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *Region) GetReid() int32 {
	if m != nil {
		return m.Reid
	}
	return 0
}

func (m *Region) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Region) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

func (m *Region) GetGoto() string {
	if m != nil {
		return m.Goto
	}
	return ""
}

func (m *Region) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

func (m *Region) GetRank() string {
	if m != nil {
		return m.Rank
	}
	return ""
}

func (m *Region) GetPlat() int32 {
	if m != nil {
		return m.Plat
	}
	return 0
}

func (m *Region) GetArea() string {
	if m != nil {
		return m.Area
	}
	return ""
}

func (m *Region) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Region) GetBuild() int32 {
	if m != nil {
		return m.Build
	}
	return 0
}

func (m *Region) GetCondition() string {
	if m != nil {
		return m.Condition
	}
	return ""
}

func (m *Region) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Region) GetIsLogo() int32 {
	if m != nil {
		return m.IsLogo
	}
	return 0
}

func (m *Region) GetRtype() int32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *Region) GetEntrance() int32 {
	if m != nil {
		return m.Entrance
	}
	return 0
}

type RegionReply struct {
	// []*v1.Region
	Regions              []*Region `protobuf:"bytes,1,rep,name=regions,proto3" json:"regions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RegionReply) Reset()         { *m = RegionReply{} }
func (m *RegionReply) String() string { return proto.CompactTextString(m) }
func (*RegionReply) ProtoMessage()    {}
func (*RegionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{1}
}
func (m *RegionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionReply.Merge(m, src)
}
func (m *RegionReply) XXX_Size() int {
	return m.Size()
}
func (m *RegionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionReply.DiscardUnknown(m)
}

var xxx_messageInfo_RegionReply proto.InternalMessageInfo

func (m *RegionReply) GetRegions() []*Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

type Limit struct {
	// limit Id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 区域id
	Rid int64 `protobuf:"varint,2,opt,name=rid,proto3" json:"rid,omitempty"`
	// build号
	Build int32 `protobuf:"varint,3,opt,name=build,proto3" json:"build,omitempty"`
	// 状态字段
	Condition            string   `protobuf:"bytes,4,opt,name=condition,proto3" json:"condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Limit) Reset()         { *m = Limit{} }
func (m *Limit) String() string { return proto.CompactTextString(m) }
func (*Limit) ProtoMessage()    {}
func (*Limit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{2}
}
func (m *Limit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limit.Merge(m, src)
}
func (m *Limit) XXX_Size() int {
	return m.Size()
}
func (m *Limit) XXX_DiscardUnknown() {
	xxx_messageInfo_Limit.DiscardUnknown(m)
}

var xxx_messageInfo_Limit proto.InternalMessageInfo

func (m *Limit) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Limit) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *Limit) GetBuild() int32 {
	if m != nil {
		return m.Build
	}
	return 0
}

func (m *Limit) GetCondition() string {
	if m != nil {
		return m.Condition
	}
	return ""
}

type RegionLtMap struct {
	Key                  int64    `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Limits               []*Limit `protobuf:"bytes,2,rep,name=limits,proto3" json:"limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegionLtMap) Reset()         { *m = RegionLtMap{} }
func (m *RegionLtMap) String() string { return proto.CompactTextString(m) }
func (*RegionLtMap) ProtoMessage()    {}
func (*RegionLtMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{3}
}
func (m *RegionLtMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionLtMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionLtMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionLtMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionLtMap.Merge(m, src)
}
func (m *RegionLtMap) XXX_Size() int {
	return m.Size()
}
func (m *RegionLtMap) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionLtMap.DiscardUnknown(m)
}

var xxx_messageInfo_RegionLtMap proto.InternalMessageInfo

func (m *RegionLtMap) GetKey() int64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *RegionLtMap) GetLimits() []*Limit {
	if m != nil {
		return m.Limits
	}
	return nil
}

type RegionLtmReply struct {
	Ltm                  []*RegionLtMap `protobuf:"bytes,1,rep,name=ltm,proto3" json:"ltm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RegionLtmReply) Reset()         { *m = RegionLtmReply{} }
func (m *RegionLtmReply) String() string { return proto.CompactTextString(m) }
func (*RegionLtmReply) ProtoMessage()    {}
func (*RegionLtmReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{4}
}
func (m *RegionLtmReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionLtmReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionLtmReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionLtmReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionLtmReply.Merge(m, src)
}
func (m *RegionLtmReply) XXX_Size() int {
	return m.Size()
}
func (m *RegionLtmReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionLtmReply.DiscardUnknown(m)
}

var xxx_messageInfo_RegionLtmReply proto.InternalMessageInfo

func (m *RegionLtmReply) GetLtm() []*RegionLtMap {
	if m != nil {
		return m.Ltm
	}
	return nil
}

type Config struct {
	// config Id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 区域id
	Rid int64 `protobuf:"varint,2,opt,name=rid,proto3" json:"rid,omitempty"`
	// 场景id
	ScenesId int32 `protobuf:"varint,3,opt,name=scenes_id,json=scenesId,proto3" json:"scenes_id,omitempty"`
	// 展示场景（白名单）
	ScenesName string `protobuf:"bytes,4,opt,name=scenes_name,json=scenesName,proto3" json:"scenes_name,omitempty"`
	// 展示样式
	ScenesType           string   `protobuf:"bytes,5,opt,name=scenes_type,json=scenesType,proto3" json:"scenes_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{5}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Config) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *Config) GetScenesId() int32 {
	if m != nil {
		return m.ScenesId
	}
	return 0
}

func (m *Config) GetScenesName() string {
	if m != nil {
		return m.ScenesName
	}
	return ""
}

func (m *Config) GetScenesType() string {
	if m != nil {
		return m.ScenesType
	}
	return ""
}

type RegionCfgMap struct {
	Key                  int64     `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Configs              []*Config `protobuf:"bytes,2,rep,name=configs,proto3" json:"configs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RegionCfgMap) Reset()         { *m = RegionCfgMap{} }
func (m *RegionCfgMap) String() string { return proto.CompactTextString(m) }
func (*RegionCfgMap) ProtoMessage()    {}
func (*RegionCfgMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{6}
}
func (m *RegionCfgMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionCfgMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionCfgMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionCfgMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionCfgMap.Merge(m, src)
}
func (m *RegionCfgMap) XXX_Size() int {
	return m.Size()
}
func (m *RegionCfgMap) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionCfgMap.DiscardUnknown(m)
}

var xxx_messageInfo_RegionCfgMap proto.InternalMessageInfo

func (m *RegionCfgMap) GetKey() int64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *RegionCfgMap) GetConfigs() []*Config {
	if m != nil {
		return m.Configs
	}
	return nil
}

type RegionCfgmReply struct {
	Cfgm                 []*RegionCfgMap `protobuf:"bytes,1,rep,name=cfgm,proto3" json:"cfgm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RegionCfgmReply) Reset()         { *m = RegionCfgmReply{} }
func (m *RegionCfgmReply) String() string { return proto.CompactTextString(m) }
func (*RegionCfgmReply) ProtoMessage()    {}
func (*RegionCfgmReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eef30384a8831dd, []int{7}
}
func (m *RegionCfgmReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionCfgmReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionCfgmReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionCfgmReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionCfgmReply.Merge(m, src)
}
func (m *RegionCfgmReply) XXX_Size() int {
	return m.Size()
}
func (m *RegionCfgmReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionCfgmReply.DiscardUnknown(m)
}

var xxx_messageInfo_RegionCfgmReply proto.InternalMessageInfo

func (m *RegionCfgmReply) GetCfgm() []*RegionCfgMap {
	if m != nil {
		return m.Cfgm
	}
	return nil
}

func init() {
	proto.RegisterType((*Region)(nil), "app.job.v1.Region")
	proto.RegisterType((*RegionReply)(nil), "app.job.v1.RegionReply")
	proto.RegisterType((*Limit)(nil), "app.job.v1.Limit")
	proto.RegisterType((*RegionLtMap)(nil), "app.job.v1.RegionLtMap")
	proto.RegisterType((*RegionLtmReply)(nil), "app.job.v1.RegionLtmReply")
	proto.RegisterType((*Config)(nil), "app.job.v1.Config")
	proto.RegisterType((*RegionCfgMap)(nil), "app.job.v1.RegionCfgMap")
	proto.RegisterType((*RegionCfgmReply)(nil), "app.job.v1.RegionCfgmReply")
}

func init() { proto.RegisterFile("region.proto", fileDescriptor_6eef30384a8831dd) }

var fileDescriptor_6eef30384a8831dd = []byte{
	// 517 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xc5, 0x76, 0xec, 0x24, 0x93, 0x90, 0xb6, 0xab, 0x48, 0x5d, 0x01, 0x0a, 0x91, 0x4f, 0xa9,
	0x54, 0x45, 0x2a, 0x1c, 0x7b, 0x40, 0xa2, 0x27, 0x50, 0xe8, 0xc1, 0xe2, 0x84, 0x84, 0xaa, 0x4d,
	0xbc, 0xb1, 0x96, 0xda, 0xbb, 0x96, 0xed, 0x54, 0xca, 0x27, 0xf0, 0x07, 0x7c, 0x12, 0x47, 0x3e,
	0x01, 0x85, 0xaf, 0xe0, 0x86, 0x66, 0xd6, 0x76, 0x02, 0x05, 0xd4, 0xdb, 0x9b, 0xb7, 0xcf, 0x33,
	0xf3, 0x66, 0xc6, 0x30, 0x2c, 0x64, 0xa2, 0x8c, 0x9e, 0xe7, 0x85, 0xa9, 0x0c, 0x03, 0x91, 0xe7,
	0xf3, 0x4f, 0x66, 0x39, 0xbf, 0xbb, 0x08, 0x7f, 0xba, 0x10, 0x44, 0xf4, 0xc8, 0x46, 0xe0, 0xaa,
	0x98, 0x3b, 0x53, 0x67, 0xe6, 0x45, 0xae, 0x8a, 0xd9, 0x31, 0x78, 0x85, 0x8a, 0xb9, 0x3b, 0x75,
	0x66, 0x7e, 0x84, 0x90, 0x31, 0xe8, 0x14, 0x52, 0xc5, 0xdc, 0x23, 0x8a, 0x30, 0x72, 0x5a, 0x64,
	0x92, 0x77, 0xa6, 0xce, 0xac, 0x1f, 0x11, 0x46, 0x2e, 0x35, 0x89, 0xe1, 0xbe, 0xe5, 0x10, 0x23,
	0x97, 0x98, 0xca, 0xf0, 0xc0, 0x72, 0x88, 0xd9, 0x18, 0xfc, 0x5c, 0x14, 0x22, 0xe3, 0x5d, 0x22,
	0x6d, 0x40, 0x55, 0x84, 0xbe, 0xe5, 0x3d, 0xab, 0x44, 0x8c, 0x5c, 0x9e, 0x8a, 0x8a, 0xf7, 0x6d,
	0x65, 0xc4, 0xc8, 0x89, 0x42, 0x0a, 0x0e, 0x56, 0x87, 0x98, 0x3d, 0x81, 0x5e, 0x2a, 0x74, 0xb2,
	0x11, 0x89, 0xe4, 0x03, 0xe2, 0xdb, 0x18, 0xab, 0x2d, 0x37, 0x2a, 0x8d, 0xf9, 0x90, 0x92, 0xd8,
	0x80, 0x3d, 0x83, 0xfe, 0xca, 0xe8, 0x58, 0x55, 0xca, 0x68, 0xfe, 0x98, 0x3e, 0xd9, 0x13, 0x38,
	0x83, 0x4d, 0xa1, 0xf8, 0x88, 0x78, 0x84, 0xec, 0x14, 0xba, 0xaa, 0xbc, 0x21, 0x7b, 0x47, 0x94,
	0x27, 0x50, 0xe5, 0x02, 0x0d, 0x8e, 0xc1, 0x2f, 0xaa, 0x6d, 0x2e, 0xf9, 0xb1, 0x4d, 0x4f, 0x01,
	0x36, 0x24, 0x75, 0x55, 0x08, 0xbd, 0x92, 0xfc, 0x84, 0x1e, 0xda, 0x38, 0xbc, 0x84, 0x81, 0x1d,
	0x7d, 0x24, 0xf3, 0x74, 0xcb, 0xce, 0xa1, 0x6b, 0xd7, 0x54, 0x72, 0x67, 0xea, 0xcd, 0x06, 0x2f,
	0xd8, 0x7c, 0xbf, 0xa8, 0x79, 0xad, 0x6c, 0x24, 0xe1, 0x47, 0xf0, 0x17, 0x2a, 0x53, 0xd5, 0xff,
	0xd6, 0xe6, 0xd9, 0xb5, 0xb5, 0xc6, 0xbd, 0x7f, 0x1a, 0xef, 0xfc, 0x61, 0x3c, 0x7c, 0xdb, 0xf4,
	0xb6, 0xa8, 0xde, 0x89, 0x1c, 0x93, 0xde, 0xca, 0x6d, 0x5d, 0x05, 0x21, 0x3b, 0x83, 0x20, 0xc5,
	0xfa, 0x25, 0x77, 0xa9, 0xd9, 0x93, 0xc3, 0x66, 0xa9, 0xb3, 0xa8, 0x16, 0x84, 0x97, 0x30, 0x6a,
	0x72, 0x65, 0xd6, 0xea, 0x19, 0x78, 0x69, 0x95, 0xd5, 0x36, 0x4f, 0xef, 0xdb, 0xa4, 0xa2, 0x11,
	0x6a, 0xc2, 0xcf, 0x0e, 0x04, 0x57, 0x46, 0xaf, 0x55, 0xf2, 0x00, 0xa7, 0x4f, 0xa1, 0x5f, 0xae,
	0xa4, 0x96, 0xe5, 0x4d, 0x7b, 0xa5, 0x3d, 0x4b, 0xbc, 0x89, 0xd9, 0x73, 0x18, 0xd4, 0x8f, 0x07,
	0x07, 0x0b, 0x96, 0xba, 0xc6, 0xb3, 0xdd, 0x0b, 0x68, 0x8f, 0xfe, 0xa1, 0xe0, 0xfd, 0x36, 0x97,
	0xe1, 0x35, 0x0c, 0x6d, 0x7f, 0x57, 0xeb, 0xe4, 0xef, 0x53, 0x39, 0x87, 0xee, 0x8a, 0x9a, 0x6d,
	0xc6, 0xf2, 0xdb, 0x0e, 0xad, 0x8f, 0xa8, 0x91, 0x84, 0xaf, 0xe0, 0xa8, 0xcd, 0x97, 0x35, 0x47,
	0xd0, 0x59, 0xad, 0x93, 0x66, 0x34, 0xfc, 0xfe, 0x68, 0x6c, 0xe9, 0x88, 0x54, 0xaf, 0xc7, 0x5f,
	0x77, 0x13, 0xe7, 0xdb, 0x6e, 0xe2, 0x7c, 0xdf, 0x4d, 0x9c, 0x2f, 0x3f, 0x26, 0x8f, 0x3e, 0xb8,
	0x77, 0x17, 0xcb, 0x80, 0x7e, 0xf3, 0x97, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xbe, 0x85, 0x89,
	0x35, 0xf6, 0x03, 0x00, 0x00,
}

func (m *Region) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Region) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Region) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Entrance != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Entrance))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Rtype != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Rtype))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsLogo != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.IsLogo))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Condition) > 0 {
		i -= len(m.Condition)
		copy(dAtA[i:], m.Condition)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Condition)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Build != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Area) > 0 {
		i -= len(m.Area)
		copy(dAtA[i:], m.Area)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Area)))
		i--
		dAtA[i] = 0x52
	}
	if m.Plat != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Rank) > 0 {
		i -= len(m.Rank)
		copy(dAtA[i:], m.Rank)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Rank)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Goto) > 0 {
		i -= len(m.Goto)
		copy(dAtA[i:], m.Goto)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Goto)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Logo) > 0 {
		i -= len(m.Logo)
		copy(dAtA[i:], m.Logo)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Logo)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Reid != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Reid))
		i--
		dAtA[i] = 0x18
	}
	if m.Rid != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Regions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRegion(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Limit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Condition) > 0 {
		i -= len(m.Condition)
		copy(dAtA[i:], m.Condition)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Condition)))
		i--
		dAtA[i] = 0x22
	}
	if m.Build != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x18
	}
	if m.Rid != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionLtMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionLtMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionLtMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Limits) > 0 {
		for iNdEx := len(m.Limits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Limits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRegion(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Key != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionLtmReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionLtmReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionLtmReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ltm) > 0 {
		for iNdEx := len(m.Ltm) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ltm[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRegion(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ScenesType) > 0 {
		i -= len(m.ScenesType)
		copy(dAtA[i:], m.ScenesType)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.ScenesType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ScenesName) > 0 {
		i -= len(m.ScenesName)
		copy(dAtA[i:], m.ScenesName)
		i = encodeVarintRegion(dAtA, i, uint64(len(m.ScenesName)))
		i--
		dAtA[i] = 0x22
	}
	if m.ScenesId != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.ScenesId))
		i--
		dAtA[i] = 0x18
	}
	if m.Rid != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionCfgMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionCfgMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionCfgMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Configs) > 0 {
		for iNdEx := len(m.Configs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Configs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRegion(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Key != 0 {
		i = encodeVarintRegion(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionCfgmReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionCfgmReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionCfgmReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cfgm) > 0 {
		for iNdEx := len(m.Cfgm) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cfgm[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRegion(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintRegion(dAtA []byte, offset int, v uint64) int {
	offset -= sovRegion(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Region) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegion(uint64(m.Id))
	}
	if m.Rid != 0 {
		n += 1 + sovRegion(uint64(m.Rid))
	}
	if m.Reid != 0 {
		n += 1 + sovRegion(uint64(m.Reid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.Goto)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.Rank)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.Plat != 0 {
		n += 1 + sovRegion(uint64(m.Plat))
	}
	l = len(m.Area)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.Build != 0 {
		n += 1 + sovRegion(uint64(m.Build))
	}
	l = len(m.Condition)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.IsLogo != 0 {
		n += 1 + sovRegion(uint64(m.IsLogo))
	}
	if m.Rtype != 0 {
		n += 2 + sovRegion(uint64(m.Rtype))
	}
	if m.Entrance != 0 {
		n += 2 + sovRegion(uint64(m.Entrance))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovRegion(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Limit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegion(uint64(m.Id))
	}
	if m.Rid != 0 {
		n += 1 + sovRegion(uint64(m.Rid))
	}
	if m.Build != 0 {
		n += 1 + sovRegion(uint64(m.Build))
	}
	l = len(m.Condition)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionLtMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovRegion(uint64(m.Key))
	}
	if len(m.Limits) > 0 {
		for _, e := range m.Limits {
			l = e.Size()
			n += 1 + l + sovRegion(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionLtmReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ltm) > 0 {
		for _, e := range m.Ltm {
			l = e.Size()
			n += 1 + l + sovRegion(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegion(uint64(m.Id))
	}
	if m.Rid != 0 {
		n += 1 + sovRegion(uint64(m.Rid))
	}
	if m.ScenesId != 0 {
		n += 1 + sovRegion(uint64(m.ScenesId))
	}
	l = len(m.ScenesName)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.ScenesType)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionCfgMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovRegion(uint64(m.Key))
	}
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 1 + l + sovRegion(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionCfgmReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cfgm) > 0 {
		for _, e := range m.Cfgm {
			l = e.Size()
			n += 1 + l + sovRegion(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRegion(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRegion(x uint64) (n int) {
	return sovRegion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Region) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Region: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Region: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reid", wireType)
			}
			m.Reid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Area = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLogo", wireType)
			}
			m.IsLogo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsLogo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrance", wireType)
			}
			m.Entrance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Entrance |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &Region{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionLtMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionLtMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionLtMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limits = append(m.Limits, &Limit{})
			if err := m.Limits[len(m.Limits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionLtmReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionLtmReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionLtmReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ltm = append(m.Ltm, &RegionLtMap{})
			if err := m.Ltm[len(m.Ltm)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScenesId", wireType)
			}
			m.ScenesId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScenesId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScenesName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScenesName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScenesType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScenesType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionCfgMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionCfgMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionCfgMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &Config{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionCfgmReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionCfgmReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionCfgmReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cfgm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cfgm = append(m.Cfgm, &RegionCfgMap{})
			if err := m.Cfgm[len(m.Cfgm)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRegion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRegion
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRegion
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRegion
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRegion        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRegion          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRegion = fmt.Errorf("proto: unexpected end of group")
)
