// Code generated by kratos tool mcgen. DO NOT EDIT.

/*
  Package like is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=likeKey -struct_name=Dao
		CacheLike(c context.Context, id int64) (*likemdl.Item, error)
		// mc: -key=likeKey -struct_name=Dao
		CacheLikes(c context.Context, id []int64) (map[int64]*likemdl.Item, error)
		// mc: -key=likeKey -expire=d.mcRegularExpire -encode=json -struct_name=Dao
		AddCacheLikes(c context.Context, items map[int64]*likemdl.Item) error
		// mc: -key=likeKey -expire=d.mcRegularExpire -encode=json -struct_name=Dao
		AddCacheLike(c context.Context, key int64, value *likemdl.Item) error
		// mc: -key=actSubjectKey -struct_name=Dao
		CacheActSubject(c context.Context, id int64) (*likemdl.SubjectItem, error)
		// mc: -key=actSubjectKey -expire=d.mcRegularExpire -encode=pb -struct_name=Dao
		AddCacheActSubject(c context.Context, key int64, value *likemdl.SubjectItem) error
		// mc: -key=actSubjectKey -struct_name=Dao
		CacheActSubjects(c context.Context, ids []int64) (map[int64]*likemdl.SubjectItem, error)
		// mc: -key=actSubjectKey -expire=d.mcRegularExpire -encode=pb -struct_name=Dao
		AddCacheActSubjects(c context.Context, data map[int64]*likemdl.SubjectItem) error
		// mc: -key=actSubjectMaxIDKey -struct_name=Dao
		CacheActSubjectMaxID(c context.Context) (res int64, err error)
		// mc: -key=actSubjectMaxIDKey -expire=d.mcPerpetualExpire -encode=raw -struct_name=Dao
		AddCacheActSubjectMaxID(c context.Context, sid int64) error
		// mc: -key=likeMaxIDKey -struct_name=Dao
		CacheLikeMaxID(c context.Context) (res int64, err error)
		// mc: -key=likeMaxIDKey -expire=d.mcPerpetualExpire -encode=raw -struct_name=Dao
		AddCacheLikeMaxID(c context.Context, lid int64) error
		//mc: -key=likeMissionBuffKey -struct_name=Dao
		CacheLikeMissionBuff(c context.Context, sid int64, mid int64) (res int64, err error)
		//mc: -key=likeMissionBuffKey -expire=d.mcActMissionExpire -struct_name=Dao
		AddCacheLikeMissionBuff(c context.Context, sid int64, val int64, mid int64) error
		//mc: -key=likeMissionGroupIDkey -struct_name=Dao
		CacheMissionGroupItems(ctx context.Context, lids []int64) (map[int64]*likemdl.MissionGroup, error)
		//mc: -key=likeMissionGroupIDkey -expire=d.mcItemExpire -encode=pb -struct_name=Dao
		AddCacheMissionGroupItems(ctx context.Context, val map[int64]*likemdl.MissionGroup) error
		//mc: -key=likeActMissionKey -struct_name=Dao
		CacheActMission(c context.Context, sid int64, lid int64, mid int64) (res int64, err error)
		//mc: -key=likeActMissionKey -expire=d.mcActMissionExpire -encode=raw -struct_name=Dao
		AddCacheActMission(c context.Context, sid int64, val int64, lid int64, mid int64) error
		//mc: -key=actAchieveKey -struct_name=Dao
		CacheActLikeAchieves(c context.Context, sid int64) (res *likemdl.Achievements, err error)
		//mc: -key=actAchieveKey -expire=d.mcItemExpire -encode=pb -struct_name=Dao
		AddCacheActLikeAchieves(c context.Context, sid int64, res *likemdl.Achievements) error
		//mc: -key=actMissionFriendsKey -struct_name=Dao
		CacheActMissionFriends(c context.Context, sid int64, lid int64) (res *likemdl.ActMissionGroups, err error)
		//mc: -key=actMissionFriendsKey -struct_name=Dao
		DelCacheActMissionFriends(c context.Context, sid int64, lid int64) error
		//mc: -key=actMissionFriendsKey -expire=d.mcItemExpire -encode=pb -struct_name=Dao
		AddCacheActMissionFriends(c context.Context, sid int64, res *likemdl.ActMissionGroups, lid int64) error
		//mc: -key=actUserAchieveKey -struct_name=Dao
		CacheActUserAchieve(c context.Context, id int64) (res *likemdl.ActLikeUserAchievement, err error)
		//mc: -key=actUserAchieveKey -expire=d.mcItemExpire -encode=pb -struct_name=Dao
		AddCacheActUserAchieve(c context.Context, id int64, val *likemdl.ActLikeUserAchievement) error
		//mc: -key=actUserAchieveAwardKey -struct_name=Dao
		CacheActUserAward(c context.Context, id int64) (res int64, err error)
		//mc: -key=actUserAchieveAwardKey -expire=d.mcActMissionExpire -encode=raw -struct_name=Dao
		AddCacheActUserAward(c context.Context, id int64, val int64) error
		// mc: -key=subjectStatKey -struct_name=Dao
		CacheSubjectStat(c context.Context, sid int64) (*likemdl.SubjectStat, error)
		// mc: -key=subjectStatKey -expire=d.mcSubStatExpire -encode=json -struct_name=Dao
		AddCacheSubjectStat(c context.Context, sid int64, value *likemdl.SubjectStat) error
		// mc: -key=viewRankKey -struct_name=Dao
		CacheViewRank(c context.Context, sid int64, typ string) (string, error)
		// mc: -key=viewRankKey -expire=d.mcViewRankExpire -encode=raw -struct_name=Dao
		AddCacheViewRank(c context.Context, sid int64, value string, typ string) error
		// mc: -key=likeContentKey -struct_name=Dao
		CacheLikeContent(c context.Context, lids []int64) (res map[int64]*likemdl.LikeContent, err error)
		// mc: -key=likeContentKey -expire=d.mcRegularExpire -encode=pb -struct_name=Dao
		AddCacheLikeContent(c context.Context, val map[int64]*likemdl.LikeContent) error
		// mc: -key=sourceItemKey -struct_name=Dao
		CacheSourceItemData(c context.Context, sid int64) ([]int64, error)
		// mc: -key=sourceItemKey -expire=d.mcSourceItemExpire -encode=json -struct_name=Dao
		AddCacheSourceItemData(c context.Context, sid int64, lids []int64) error
		// mc: -key=subjectProtocolKey -struct_name=Dao
		CacheActSubjectProtocol(c context.Context, sid int64) (res *likemdl.ActSubjectProtocol, err error)
		// mc: -key=subjectProtocolKey -expire=d.mcRegularExpire -encode=pb -struct_name=Dao
		AddCacheActSubjectProtocol(c context.Context, sid int64, value *likemdl.ActSubjectProtocol) error
		// mc: -key=subjectProtocolKey -struct_name=Dao
		DelCacheActSubjectProtocol(c context.Context, sid int64) error
		// mc: -key=subjectProtocolKey -struct_name=Dao
		CacheActSubjectProtocols(c context.Context, sids []int64) (map[int64]*likemdl.ActSubjectProtocol, error)
		// mc: -key=subjectProtocolKey -expire=d.mcProtocolExpire -encode=pb -struct_name=Dao
		AddCacheActSubjectProtocols(c context.Context, data map[int64]*likemdl.ActSubjectProtocol) error
		// mc: -key=textOnlyOneKey -struct_name=Dao
		CacheTextOnly(c context.Context, sid int64, mid int64) (res int, err error)
		// mc: -key=textOnlyOneKey -expire=d.mcUserCheckExpire -encode=raw -struct_name=Dao
		AddCacheTextOnly(c context.Context, sid int64, val int, mid int64) error
		// mc: -key=ipRequestKey -struct_name=Dao
		CacheIPRequestCheck(c context.Context, ip string) (res int, err error)
		// mc: -key=ipRequestKey -expire=d.mcLikeIPExpire -encode=raw -struct_name=Dao
		AddCacheIPRequestCheck(c context.Context, ip string, val int) error
		// mc: -key=reserveOnlyKey -struct_name=Dao
		CacheReserveOnly(c context.Context, sid int64, mid int64) (res *likemdl.HasReserve, err error)
		// mc: -key=reserveOnlyKey -expire=d.mcReserveOnlyExpire -encode=pb -struct_name=Dao
		AddCacheReserveOnly(c context.Context, sid int64, val *likemdl.HasReserve, mid int64) error
		// mc: -key=reserveOnlyKey -struct_name=Dao
		DelCacheReserveOnly(c context.Context, sid int64, mid int64) error
		// mc: -key=actSubjectWithStateKey -struct_name=Dao
		CacheActSubjectWithState(c context.Context, id int64) (*likemdl.SubjectItem, error)
		// mc: -key=actSubjectWithStateKey -expire=d.mcRegularExpire -encode=pb -struct_name=Dao
		AddCacheActSubjectWithState(c context.Context, key int64, value *likemdl.SubjectItem) error
		// mc: -key=actSubjectWithStateKey -struct_name=Dao
		CacheActSubjectsWithState(c context.Context, ids []int64) (map[int64]*likemdl.SubjectItem, error)
		// mc: -key=actSubjectWithStateKey -expire=d.mcRegularExpire -encode=pb -struct_name=Dao
		AddCacheActSubjectsWithState(c context.Context, data map[int64]*likemdl.SubjectItem) error
		//  mc: -key=GetUpActReserveRelationInfoBySid -struct_name=Dao
		CacheGetUpActReserveRelationInfoBySid(c context.Context, sids []int64) (map[int64]*likemdl.UpActReserveRelationInfo, error)
		//  mc: -key=GetUpActReserveRelationInfoBySid -expire=d.mcRegularExpire -encode=json -struct_name=Dao
		AddCacheGetUpActReserveRelationInfoBySid(c context.Context, data map[int64]*likemdl.UpActReserveRelationInfo) (map[int64]*likemdl.UpActReserveRelationInfo, error)
		//  mc: -key=getReserveCounterGroupIDBySidKey -struct_name=Dao
		CacheGetReserveCounterGroupIDBySid(ctx context.Context, sid int64) (res []int64, err error)
		//  mc: -key=getReserveCounterGroupIDBySidKey -expire=d.mcRegularExpire -encode=json -struct_name=Dao
		AddCacheGetReserveCounterGroupIDBySid(ctx context.Context, sid int64, data []int64) error
		//  mc: -key=getReserveCounterGroupIDBySidKey -struct_name=Dao
		DelCacheGetReserveCounterGroupIDBySid(ctx context.Context, sid int64) error
		//  mc: -key=getReserveCounterGroupInfoByGidKey -struct_name=Dao
		CacheGetReserveCounterGroupInfoByGid(ctx context.Context, gid []int64) (res map[int64]*likemdl.ReserveCounterGroupItem, err error)
		//  mc: -key=getReserveCounterGroupInfoByGidKey -expire=d.mcRegularExpire -encode=json -struct_name=Dao
		AddCacheGetReserveCounterGroupInfoByGid(ctx context.Context, data map[int64]*likemdl.ReserveCounterGroupItem) error
		//  mc: -key=getReserveCounterGroupInfoByGidKey -struct_name=Dao
		DelCacheGetReserveCounterGroupInfoByGid(ctx context.Context, gid int64) error
		//  mc: -key=getReserveCounterNodeByGidKey -struct_name=Dao
		CacheGetReserveCounterNodeByGid(ctx context.Context, gid []int64) (res map[int64][]*likemdl.ReserveCounterNodeItem, err error)
		//  mc: -key=getReserveCounterNodeByGidKey -expire=d.mcRegularExpire -encode=json -struct_name=Dao
		AddCacheGetReserveCounterNodeByGid(ctx context.Context, data map[int64][]*likemdl.ReserveCounterNodeItem) error
		//  mc: -key=getReserveCounterNodeByGidKey -struct_name=Dao
		DelCacheGetReserveCounterNodeByGid(ctx context.Context, gid int64) error
		//  mc: -key=GetUpActReserveRelationInfo4SpaceCardIDs -struct_name=Dao
		CacheGetUpActReserveRelationInfo4SpaceCardIDs(c context.Context, mid int64) ([]int64, error)
		//  mc: -key=GetUpActReserveRelationInfo4SpaceCardIDs -expire=d.mcRegularExpire -encode=json -struct_name=Dao
		AddCacheGetUpActReserveRelationInfo4SpaceCardIDs(c context.Context, mid int64, ids []int64) ([]int64, error)
		//  mc: -key=GetUpActReserveRelationInfo4Live -struct_name=Dao
		CacheGetUpActReserveRelationInfo4Live(c context.Context, upmid int64) (int64, error)
		//  mc: -key=GetUpActReserveRelationInfo4Live -expire=d.mcRegularExpire -struct_name=Dao
		AddCacheGetUpActReserveRelationInfo4Live(c context.Context, upmid int64, sids int64) ([]int64, error)
		//  mc: -key=GetOnlineWebViewDataByVidKey -expire=d.mcSourceItemExpire -struct_name=Dao
		AddCacheGetOnlineWebViewDataByVid(c context.Context, vid int64, list []*likemdl.WebDataItem) error
		//  mc: -key=GetOnlineWebViewDataByVidKey -expire=d.mcSourceItemExpire -struct_name=Dao
		CacheGetOnlineWebViewDataByVid(c context.Context, vid int64) ([]*likemdl.WebDataItem, error)
		//  mc: -key=GetOnlineWebViewDataByVidKey -expire=d.mcSourceItemExpire -struct_name=Dao
		DelCacheGetOnlineWebViewDataByVid(c context.Context, vid int64) error
		//  mc: -key=GetWebViewDataByVidKey -expire=d.mcSourceItemExpire -struct_name=Dao
		AddCacheGetWebViewDataByVid(c context.Context, vid int64, list []*likemdl.WebDataItem) error
		//  mc: -key=GetWebViewDataByVidKey -expire=d.mcSourceItemExpire -struct_name=Dao
		CacheGetWebViewDataByVid(c context.Context, vid int64) ([]*likemdl.WebDataItem, error)
		//  mc: -key=GetWebViewDataByVidKey -expire=d.mcSourceItemExpire -struct_name=Dao
		DelCacheGetWebViewDataByVid(c context.Context, vid int64) error
	}
*/

package like

import (
	"context"
	"fmt"
	"strconv"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	likemdl "go-gateway/app/web-svr/activity/interface/model/like"
)

var _ _mc

// CacheLike get data from mc
func (d *Dao) CacheLike(c context.Context, id int64) (res *likemdl.Item, err error) {
	key := likeKey(id)
	res = &likemdl.Item{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheLike", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikes get data from mc
func (d *Dao) CacheLikes(c context.Context, ids []int64) (res map[int64]*likemdl.Item, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := likeKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheLikes", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.Item{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheLikes", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.Item, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheLikes Set data to mc
func (d *Dao) AddCacheLikes(c context.Context, values map[int64]*likemdl.Item) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := likeKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagJSON}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheLikes", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// AddCacheLike Set data to mc
func (d *Dao) AddCacheLike(c context.Context, id int64, val *likemdl.Item) (err error) {
	if val == nil {
		return
	}
	key := likeKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheLike", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubject get data from mc
func (d *Dao) CacheActSubject(c context.Context, id int64) (res *likemdl.SubjectItem, err error) {
	key := actSubjectKey(id)
	res = &likemdl.SubjectItem{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheActSubject", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActSubject Set data to mc
func (d *Dao) AddCacheActSubject(c context.Context, id int64, val *likemdl.SubjectItem) (err error) {
	if val == nil {
		return
	}
	key := actSubjectKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActSubject", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubjects get data from mc
func (d *Dao) CacheActSubjects(c context.Context, ids []int64) (res map[int64]*likemdl.SubjectItem, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := actSubjectKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheActSubjects", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.SubjectItem{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheActSubjects", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.SubjectItem, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheActSubjects Set data to mc
func (d *Dao) AddCacheActSubjects(c context.Context, values map[int64]*likemdl.SubjectItem) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := actSubjectKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheActSubjects", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheActSubjectMaxID get data from mc
func (d *Dao) CacheActSubjectMaxID(c context.Context) (res int64, err error) {
	key := actSubjectMaxIDKey()
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheActSubjectMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheActSubjectMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheActSubjectMaxID Set data to mc
func (d *Dao) AddCacheActSubjectMaxID(c context.Context, val int64) (err error) {
	key := actSubjectMaxIDKey()
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActSubjectMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikeMaxID get data from mc
func (d *Dao) CacheLikeMaxID(c context.Context) (res int64, err error) {
	key := likeMaxIDKey()
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheLikeMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheLikeMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheLikeMaxID Set data to mc
func (d *Dao) AddCacheLikeMaxID(c context.Context, val int64) (err error) {
	key := likeMaxIDKey()
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheLikeMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikeMissionBuff get data from mc
func (d *Dao) CacheLikeMissionBuff(c context.Context, id int64, mid int64) (res int64, err error) {
	key := likeMissionBuffKey(id, mid)
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheLikeMissionBuff", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheLikeMissionBuff", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheLikeMissionBuff Set data to mc
func (d *Dao) AddCacheLikeMissionBuff(c context.Context, id int64, val int64, mid int64) (err error) {
	key := likeMissionBuffKey(id, mid)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcActMissionExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheLikeMissionBuff", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheMissionGroupItems get data from mc
func (d *Dao) CacheMissionGroupItems(c context.Context, ids []int64) (res map[int64]*likemdl.MissionGroup, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := likeMissionGroupIDkey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheMissionGroupItems", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.MissionGroup{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheMissionGroupItems", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.MissionGroup, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheMissionGroupItems Set data to mc
func (d *Dao) AddCacheMissionGroupItems(c context.Context, values map[int64]*likemdl.MissionGroup) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := likeMissionGroupIDkey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheMissionGroupItems", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheActMission get data from mc
func (d *Dao) CacheActMission(c context.Context, id int64, lid int64, mid int64) (res int64, err error) {
	key := likeActMissionKey(id, lid, mid)
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheActMission", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheActMission", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheActMission Set data to mc
func (d *Dao) AddCacheActMission(c context.Context, id int64, val int64, lid int64, mid int64) (err error) {
	key := likeActMissionKey(id, lid, mid)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcActMissionExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActMission", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActLikeAchieves get data from mc
func (d *Dao) CacheActLikeAchieves(c context.Context, id int64) (res *likemdl.Achievements, err error) {
	key := actAchieveKey(id)
	res = &likemdl.Achievements{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheActLikeAchieves", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActLikeAchieves Set data to mc
func (d *Dao) AddCacheActLikeAchieves(c context.Context, id int64, val *likemdl.Achievements) (err error) {
	if val == nil {
		return
	}
	key := actAchieveKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActLikeAchieves", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActMissionFriends get data from mc
func (d *Dao) CacheActMissionFriends(c context.Context, id int64, lid int64) (res *likemdl.ActMissionGroups, err error) {
	key := actMissionFriendsKey(id, lid)
	res = &likemdl.ActMissionGroups{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheActMissionFriends", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheActMissionFriends delete data from mc
func (d *Dao) DelCacheActMissionFriends(c context.Context, id int64, lid int64) (err error) {
	key := actMissionFriendsKey(id, lid)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheActMissionFriends", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActMissionFriends Set data to mc
func (d *Dao) AddCacheActMissionFriends(c context.Context, id int64, val *likemdl.ActMissionGroups, lid int64) (err error) {
	if val == nil {
		return
	}
	key := actMissionFriendsKey(id, lid)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActMissionFriends", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActUserAchieve get data from mc
func (d *Dao) CacheActUserAchieve(c context.Context, id int64) (res *likemdl.ActLikeUserAchievement, err error) {
	key := actUserAchieveKey(id)
	res = &likemdl.ActLikeUserAchievement{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheActUserAchieve", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActUserAchieve Set data to mc
func (d *Dao) AddCacheActUserAchieve(c context.Context, id int64, val *likemdl.ActLikeUserAchievement) (err error) {
	if val == nil {
		return
	}
	key := actUserAchieveKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActUserAchieve", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActUserAward get data from mc
func (d *Dao) CacheActUserAward(c context.Context, id int64) (res int64, err error) {
	key := actUserAchieveAwardKey(id)
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheActUserAward", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheActUserAward", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheActUserAward Set data to mc
func (d *Dao) AddCacheActUserAward(c context.Context, id int64, val int64) (err error) {
	key := actUserAchieveAwardKey(id)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcActMissionExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActUserAward", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheSubjectStat get data from mc
func (d *Dao) CacheSubjectStat(c context.Context, id int64) (res *likemdl.SubjectStat, err error) {
	key := subjectStatKey(id)
	res = &likemdl.SubjectStat{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheSubjectStat", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheSubjectStat Set data to mc
func (d *Dao) AddCacheSubjectStat(c context.Context, id int64, val *likemdl.SubjectStat) (err error) {
	if val == nil {
		return
	}
	key := subjectStatKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcSubStatExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheSubjectStat", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheViewRank get data from mc
func (d *Dao) CacheViewRank(c context.Context, id int64, typ string) (res string, err error) {
	key := viewRankKey(id, typ)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheViewRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheViewRank Set data to mc
func (d *Dao) AddCacheViewRank(c context.Context, id int64, val string, typ string) (err error) {
	if len(val) == 0 {
		return
	}
	key := viewRankKey(id, typ)
	bs := []byte(val)
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcViewRankExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheViewRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikeContent get data from mc
func (d *Dao) CacheLikeContent(c context.Context, ids []int64) (res map[int64]*likemdl.LikeContent, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := likeContentKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheLikeContent", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.LikeContent{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheLikeContent", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.LikeContent, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheLikeContent Set data to mc
func (d *Dao) AddCacheLikeContent(c context.Context, values map[int64]*likemdl.LikeContent) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := likeContentKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheLikeContent", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheSourceItemData get data from mc
func (d *Dao) CacheSourceItemData(c context.Context, id int64) (res []int64, err error) {
	key := sourceItemKey(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheSourceItemData", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheSourceItemData Set data to mc
func (d *Dao) AddCacheSourceItemData(c context.Context, id int64, val []int64) (err error) {
	if len(val) == 0 {
		return
	}
	key := sourceItemKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcSourceItemExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheSourceItemData", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubjectProtocol get data from mc
func (d *Dao) CacheActSubjectProtocol(c context.Context, id int64) (res *likemdl.ActSubjectProtocol, err error) {
	key := subjectProtocolKey(id)
	res = &likemdl.ActSubjectProtocol{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheActSubjectProtocol", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActSubjectProtocol Set data to mc
func (d *Dao) AddCacheActSubjectProtocol(c context.Context, id int64, val *likemdl.ActSubjectProtocol) (err error) {
	if val == nil {
		return
	}
	key := subjectProtocolKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActSubjectProtocol", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheActSubjectProtocol delete data from mc
func (d *Dao) DelCacheActSubjectProtocol(c context.Context, id int64) (err error) {
	key := subjectProtocolKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheActSubjectProtocol", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubjectProtocols get data from mc
func (d *Dao) CacheActSubjectProtocols(c context.Context, ids []int64) (res map[int64]*likemdl.ActSubjectProtocol, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := subjectProtocolKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheActSubjectProtocols", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.ActSubjectProtocol{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheActSubjectProtocols", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.ActSubjectProtocol, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheActSubjectProtocols Set data to mc
func (d *Dao) AddCacheActSubjectProtocols(c context.Context, values map[int64]*likemdl.ActSubjectProtocol) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := subjectProtocolKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcProtocolExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheActSubjectProtocols", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheTextOnly get data from mc
func (d *Dao) CacheTextOnly(c context.Context, id int64, mid int64) (res int, err error) {
	key := textOnlyOneKey(id, mid)
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheTextOnly", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheTextOnly", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int(r)
	return
}

// AddCacheTextOnly Set data to mc
func (d *Dao) AddCacheTextOnly(c context.Context, id int64, val int, mid int64) (err error) {
	key := textOnlyOneKey(id, mid)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcUserCheckExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheTextOnly", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheIPRequestCheck get data from mc
func (d *Dao) CacheIPRequestCheck(c context.Context, id string) (res int, err error) {
	key := ipRequestKey(id)
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheIPRequestCheck", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheIPRequestCheck", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int(r)
	return
}

// AddCacheIPRequestCheck Set data to mc
func (d *Dao) AddCacheIPRequestCheck(c context.Context, id string, val int) (err error) {
	key := ipRequestKey(id)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcLikeIPExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheIPRequestCheck", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheReserveOnly get data from mc
func (d *Dao) CacheReserveOnly(c context.Context, id int64, mid int64) (res *likemdl.HasReserve, err error) {
	key := reserveOnlyKey(id, mid)
	res = &likemdl.HasReserve{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheReserveOnly", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheReserveOnly Set data to mc
func (d *Dao) AddCacheReserveOnly(c context.Context, id int64, val *likemdl.HasReserve, mid int64) (err error) {
	if val == nil {
		return
	}
	key := reserveOnlyKey(id, mid)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcReserveOnlyExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheReserveOnly", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheReserveOnly delete data from mc
func (d *Dao) DelCacheReserveOnly(c context.Context, id int64, mid int64) (err error) {
	key := reserveOnlyKey(id, mid)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheReserveOnly", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubjectWithState get data from mc
func (d *Dao) CacheActSubjectWithState(c context.Context, id int64) (res *likemdl.SubjectItem, err error) {
	key := actSubjectWithStateKey(id)
	res = &likemdl.SubjectItem{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheActSubjectWithState", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActSubjectWithState Set data to mc
func (d *Dao) AddCacheActSubjectWithState(c context.Context, id int64, val *likemdl.SubjectItem) (err error) {
	if val == nil {
		return
	}
	key := actSubjectWithStateKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActSubjectWithState", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubjectsWithState get data from mc
func (d *Dao) CacheActSubjectsWithState(c context.Context, ids []int64) (res map[int64]*likemdl.SubjectItem, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := actSubjectWithStateKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheActSubjectsWithState", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.SubjectItem{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheActSubjectsWithState", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.SubjectItem, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheActSubjectsWithState Set data to mc
func (d *Dao) AddCacheActSubjectsWithState(c context.Context, values map[int64]*likemdl.SubjectItem) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := actSubjectWithStateKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheActSubjectsWithState", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheGetUpActReserveRelationInfoBySid get data from mc
func (d *Dao) CacheGetUpActReserveRelationInfoBySid(c context.Context, ids []int64) (res map[int64]*likemdl.UpActReserveRelationInfo, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := GetUpActReserveRelationInfoBySid(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheGetUpActReserveRelationInfoBySid", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.UpActReserveRelationInfo{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheGetUpActReserveRelationInfoBySid", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.UpActReserveRelationInfo, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheGetUpActReserveRelationInfoBySid Set data to mc
func (d *Dao) AddCacheGetUpActReserveRelationInfoBySid(c context.Context, values map[int64]*likemdl.UpActReserveRelationInfo) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := GetUpActReserveRelationInfoBySid(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagJSON}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheGetUpActReserveRelationInfoBySid", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheGetReserveCounterGroupIDBySid get data from mc
func (d *Dao) CacheGetReserveCounterGroupIDBySid(c context.Context, id int64) (res []int64, err error) {
	key := getReserveCounterGroupIDBySidKey(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheGetReserveCounterGroupIDBySid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheGetReserveCounterGroupIDBySid Set data to mc
func (d *Dao) AddCacheGetReserveCounterGroupIDBySid(c context.Context, id int64, val []int64) (err error) {
	if len(val) == 0 {
		return
	}
	key := getReserveCounterGroupIDBySidKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheGetReserveCounterGroupIDBySid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheGetReserveCounterGroupIDBySid delete data from mc
func (d *Dao) DelCacheGetReserveCounterGroupIDBySid(c context.Context, id int64) (err error) {
	key := getReserveCounterGroupIDBySidKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheGetReserveCounterGroupIDBySid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheGetReserveCounterGroupInfoByGid get data from mc
func (d *Dao) CacheGetReserveCounterGroupInfoByGid(c context.Context, ids []int64) (res map[int64]*likemdl.ReserveCounterGroupItem, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := getReserveCounterGroupInfoByGidKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheGetReserveCounterGroupInfoByGid", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &likemdl.ReserveCounterGroupItem{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheGetReserveCounterGroupInfoByGid", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.ReserveCounterGroupItem, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheGetReserveCounterGroupInfoByGid Set data to mc
func (d *Dao) AddCacheGetReserveCounterGroupInfoByGid(c context.Context, values map[int64]*likemdl.ReserveCounterGroupItem) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := getReserveCounterGroupInfoByGidKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagJSON}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheGetReserveCounterGroupInfoByGid", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// DelCacheGetReserveCounterGroupInfoByGid delete data from mc
func (d *Dao) DelCacheGetReserveCounterGroupInfoByGid(c context.Context, id int64) (err error) {
	key := getReserveCounterGroupInfoByGidKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheGetReserveCounterGroupInfoByGid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheGetReserveCounterNodeByGid get data from mc
func (d *Dao) CacheGetReserveCounterNodeByGid(c context.Context, ids []int64) (res map[int64][]*likemdl.ReserveCounterNodeItem, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := getReserveCounterNodeByGidKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheGetReserveCounterNodeByGid", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := []*likemdl.ReserveCounterNodeItem{}
		err = replies.Scan(key, &v)
		if err != nil {
			log.Errorv(c, log.KV("CacheGetReserveCounterNodeByGid", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64][]*likemdl.ReserveCounterNodeItem, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheGetReserveCounterNodeByGid Set data to mc
func (d *Dao) AddCacheGetReserveCounterNodeByGid(c context.Context, values map[int64][]*likemdl.ReserveCounterNodeItem) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := getReserveCounterNodeByGidKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagJSON}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheGetReserveCounterNodeByGid", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// DelCacheGetReserveCounterNodeByGid delete data from mc
func (d *Dao) DelCacheGetReserveCounterNodeByGid(c context.Context, id int64) (err error) {
	key := getReserveCounterNodeByGidKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheGetReserveCounterNodeByGid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheGetUpActReserveRelationInfo4SpaceCardIDs get data from mc
func (d *Dao) CacheGetUpActReserveRelationInfo4SpaceCardIDs(c context.Context, id int64) (res []int64, err error) {
	key := GetUpActReserveRelationInfo4SpaceCardIDs(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheGetUpActReserveRelationInfo4SpaceCardIDs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheGetUpActReserveRelationInfo4SpaceCardIDs Set data to mc
func (d *Dao) AddCacheGetUpActReserveRelationInfo4SpaceCardIDs(c context.Context, id int64, val []int64) (err error) {
	if len(val) == 0 {
		return
	}
	key := GetUpActReserveRelationInfo4SpaceCardIDs(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcRegularExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheGetUpActReserveRelationInfo4SpaceCardIDs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheGetUpActReserveRelationInfo4Live get data from mc
func (d *Dao) CacheGetUpActReserveRelationInfo4Live(c context.Context, id int64) (res int64, err error) {
	key := GetUpActReserveRelationInfo4Live(id)
	var v string
	err = d.mc.Get(c, key).Scan(&v)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheGetUpActReserveRelationInfo4Live", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		log.Errorv(c, log.KV("CacheGetUpActReserveRelationInfo4Live", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheGetUpActReserveRelationInfo4Live Set data to mc
func (d *Dao) AddCacheGetUpActReserveRelationInfo4Live(c context.Context, id int64, val int64) (err error) {
	key := GetUpActReserveRelationInfo4Live(id)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcRegularExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheGetUpActReserveRelationInfo4Live", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheGetOnlineWebViewDataByVid Set data to mc
func (d *Dao) AddCacheGetOnlineWebViewDataByVid(c context.Context, id int64, val []*likemdl.WebDataItem) (err error) {
	if len(val) == 0 {
		return
	}
	key := GetOnlineWebViewDataByVidKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcSourceItemExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheGetOnlineWebViewDataByVid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheGetOnlineWebViewDataByVid get data from mc
func (d *Dao) CacheGetOnlineWebViewDataByVid(c context.Context, id int64) (res []*likemdl.WebDataItem, err error) {
	key := GetOnlineWebViewDataByVidKey(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheGetOnlineWebViewDataByVid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheGetOnlineWebViewDataByVid delete data from mc
func (d *Dao) DelCacheGetOnlineWebViewDataByVid(c context.Context, id int64) (err error) {
	key := GetOnlineWebViewDataByVidKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheGetOnlineWebViewDataByVid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheGetWebViewDataByVid Set data to mc
func (d *Dao) AddCacheGetWebViewDataByVid(c context.Context, id int64, val []*likemdl.WebDataItem) (err error) {
	if len(val) == 0 {
		return
	}
	key := GetWebViewDataByVidKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcSourceItemExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheGetWebViewDataByVid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheGetWebViewDataByVid get data from mc
func (d *Dao) CacheGetWebViewDataByVid(c context.Context, id int64) (res []*likemdl.WebDataItem, err error) {
	key := GetWebViewDataByVidKey(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheGetWebViewDataByVid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheGetWebViewDataByVid delete data from mc
func (d *Dao) DelCacheGetWebViewDataByVid(c context.Context, id int64) (err error) {
	key := GetWebViewDataByVidKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheGetWebViewDataByVid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
