// Code generated by kratos tool redisgen. DO NOT EDIT.

/*
  Package timemachine is a generated redis cache package.
  It is generated from:
  type _redis interface {
		// redis: -key=userYearReport2020Key -struct_name=Dao
		CacheUserYearReport2020(c context.Context, mid int64) (*timemachine.UserYearReport2020, error)
		// redis: -key=userYearReport2020Key -expire=d.UserYearReport2020Expire -encode=json -struct_name=Dao -check_null_code=$==nil||$.Mid==0
		AddCacheUserYearReport2020(c context.Context, mid int64, value *timemachine.UserYearReport2020) error
		// redis: -key=userYearReport2020UserInfoKey -struct_name=Dao
		CacheUserInfoByMid(c context.Context, mid int64) (*timemachine.UserInfo, error)
		// redis: -key=userYearReport2020UserInfoKey -expire=d.UserYearReport2020Expire -encode=json -struct_name=Dao -check_null_code=$==nil||$.Mid==0
		AddCacheUserInfoByMid(c context.Context, mid int64, value *timemachine.UserInfo) error
		// redis: -key=userYearReport2020UserInfoKey -struct_name=Dao
		DelCacheUserInfoByMid(c context.Context, mid int64) error
	}
*/

package timemachine

import (
	"context"
	"encoding/json"
	"go-common/library/cache/redis"
	"go-common/library/log"
	"go-gateway/app/web-svr/activity/interface/model/timemachine"
)

var _ _redis

// CacheUserYearReport2020 get data from redis
func (d *Dao) CacheUserYearReport2020(c context.Context, id int64) (res *timemachine.UserYearReport2020, err error) {
	key := userYearReport2020Key(id)
	reply, err1 := redis.Bytes(d.redis.Do(c, "GET", key))
	if err1 != nil {
		if err1 == redis.ErrNil {
			return
		}
		err = err1
		log.Errorc(c, "d.CacheUserYearReport2020(get key: %v) err: %+v", key, err)
		return
	}
	res = &timemachine.UserYearReport2020{}
	err = json.Unmarshal(reply, res)
	if err != nil {
		log.Errorc(c, "d.CacheUserYearReport2020(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// AddCacheUserYearReport2020 Set data to redis
func (d *Dao) AddCacheUserYearReport2020(c context.Context, id int64, val *timemachine.UserYearReport2020) (err error) {
	if val == nil {
		return
	}
	key := userYearReport2020Key(id)
	var bs []byte
	bs, err = json.Marshal(val)
	if err != nil {
		log.Errorc(c, "d.AddCacheUserYearReport2020(get key: %v) err: %+v", key, err)
		return
	}
	expire := d.UserYearReport2020Expire
	if val == nil || val.Mid == 0 {
		expire = 300
	}
	if _, err = d.redis.Do(c, "set", key, bs, "EX", expire); err != nil {
		log.Errorc(c, "d.AddCacheUserYearReport2020(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// CacheUserInfoByMid get data from redis
func (d *Dao) CacheUserInfoByMid(c context.Context, id int64) (res *timemachine.UserInfo, err error) {
	key := userYearReport2020UserInfoKey(id)
	reply, err1 := redis.Bytes(d.redis.Do(c, "GET", key))
	if err1 != nil {
		if err1 == redis.ErrNil {
			return
		}
		err = err1
		log.Errorc(c, "d.CacheUserInfoByMid(get key: %v) err: %+v", key, err)
		return
	}
	res = &timemachine.UserInfo{}
	err = json.Unmarshal(reply, res)
	if err != nil {
		log.Errorc(c, "d.CacheUserInfoByMid(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// AddCacheUserInfoByMid Set data to redis
func (d *Dao) AddCacheUserInfoByMid(c context.Context, id int64, val *timemachine.UserInfo) (err error) {
	if val == nil {
		return
	}
	key := userYearReport2020UserInfoKey(id)
	var bs []byte
	bs, err = json.Marshal(val)
	if err != nil {
		log.Errorc(c, "d.AddCacheUserInfoByMid(get key: %v) err: %+v", key, err)
		return
	}
	expire := d.UserYearReport2020Expire
	if val == nil || val.Mid == 0 {
		expire = 300
	}
	if _, err = d.redis.Do(c, "set", key, bs, "EX", expire); err != nil {
		log.Errorc(c, "d.AddCacheUserInfoByMid(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// DelCacheUserInfoByMid delete data from redis
func (d *Dao) DelCacheUserInfoByMid(c context.Context, id int64) (err error) {
	key := userYearReport2020UserInfoKey(id)
	if _, err = d.redis.Do(c, "del", key); err != nil {
		if err == redis.ErrNil {
			err = nil
			return
		}
		log.Errorc(c, "d.DelCacheUserInfoByMid(get key: %v) err: %+v", key, err)
		return
	}
	return
}
