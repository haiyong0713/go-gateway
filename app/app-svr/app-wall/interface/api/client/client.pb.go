// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-gateway/app/app-svr/app-wall/interface/api/client/client.proto

// use {app_id}.{version} as package name

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RuleRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RuleRequest) Reset()         { *m = RuleRequest{} }
func (m *RuleRequest) String() string { return proto.CompactTextString(m) }
func (*RuleRequest) ProtoMessage()    {}
func (*RuleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e39fb435a4529982, []int{0}
}
func (m *RuleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleRequest.Merge(m, src)
}
func (m *RuleRequest) XXX_Size() int {
	return m.Size()
}
func (m *RuleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RuleRequest proto.InternalMessageInfo

type RulesReply struct {
	RulesInfo map[string]*RulesInfo `protobuf:"bytes,1,rep,name=RulesInfo,proto3" json:"RulesInfo,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// RulesInfo的哈希值
	HashValue            string   `protobuf:"bytes,2,opt,name=HashValue,proto3" json:"HashValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RulesReply) Reset()         { *m = RulesReply{} }
func (m *RulesReply) String() string { return proto.CompactTextString(m) }
func (*RulesReply) ProtoMessage()    {}
func (*RulesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e39fb435a4529982, []int{1}
}
func (m *RulesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RulesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RulesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RulesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RulesReply.Merge(m, src)
}
func (m *RulesReply) XXX_Size() int {
	return m.Size()
}
func (m *RulesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RulesReply.DiscardUnknown(m)
}

var xxx_messageInfo_RulesReply proto.InternalMessageInfo

func (m *RulesReply) GetRulesInfo() map[string]*RulesInfo {
	if m != nil {
		return m.RulesInfo
	}
	return nil
}

func (m *RulesReply) GetHashValue() string {
	if m != nil {
		return m.HashValue
	}
	return ""
}

type RulesInfo struct {
	RulesInfo            []*RuleInfo `protobuf:"bytes,1,rep,name=RulesInfo,proto3" json:"RulesInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RulesInfo) Reset()         { *m = RulesInfo{} }
func (m *RulesInfo) String() string { return proto.CompactTextString(m) }
func (*RulesInfo) ProtoMessage()    {}
func (*RulesInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e39fb435a4529982, []int{2}
}
func (m *RulesInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RulesInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RulesInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RulesInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RulesInfo.Merge(m, src)
}
func (m *RulesInfo) XXX_Size() int {
	return m.Size()
}
func (m *RulesInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RulesInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RulesInfo proto.InternalMessageInfo

func (m *RulesInfo) GetRulesInfo() []*RuleInfo {
	if m != nil {
		return m.RulesInfo
	}
	return nil
}

type RuleInfo struct {
	// "tf"：traffic free缩写，表示是否免流
	Tf bool `protobuf:"varint,1,opt,name=tf,proto3" json:"tf,omitempty"`
	// "m": 表示操作模式,
	// break：表示无操作，
	// replace：表示用"a"的操作参数，替换原有URL中的host，
	// proxy：表示用"a"的操作参数为host，将原有URL作为query参数（具体转换见示例）
	M string `protobuf:"bytes,2,opt,name=m,proto3" json:"m,omitempty"`
	// "a"：表示操作参数（通常是一个host域名，支持HTTP与HTTPS连接）
	A string `protobuf:"bytes,3,opt,name=a,proto3" json:"a,omitempty"`
	// "p"：表示用于匹配的正则表达式；
	P                    string   `protobuf:"bytes,4,opt,name=p,proto3" json:"p,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RuleInfo) Reset()         { *m = RuleInfo{} }
func (m *RuleInfo) String() string { return proto.CompactTextString(m) }
func (*RuleInfo) ProtoMessage()    {}
func (*RuleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e39fb435a4529982, []int{3}
}
func (m *RuleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleInfo.Merge(m, src)
}
func (m *RuleInfo) XXX_Size() int {
	return m.Size()
}
func (m *RuleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RuleInfo proto.InternalMessageInfo

func (m *RuleInfo) GetTf() bool {
	if m != nil {
		return m.Tf
	}
	return false
}

func (m *RuleInfo) GetM() string {
	if m != nil {
		return m.M
	}
	return ""
}

func (m *RuleInfo) GetA() string {
	if m != nil {
		return m.A
	}
	return ""
}

func (m *RuleInfo) GetP() string {
	if m != nil {
		return m.P
	}
	return ""
}

func init() {
	proto.RegisterType((*RuleRequest)(nil), "bilibili.app.wall.v1.RuleRequest")
	proto.RegisterType((*RulesReply)(nil), "bilibili.app.wall.v1.RulesReply")
	proto.RegisterMapType((map[string]*RulesInfo)(nil), "bilibili.app.wall.v1.RulesReply.RulesInfoEntry")
	proto.RegisterType((*RulesInfo)(nil), "bilibili.app.wall.v1.RulesInfo")
	proto.RegisterType((*RuleInfo)(nil), "bilibili.app.wall.v1.RuleInfo")
}

func init() {
	proto.RegisterFile("go-gateway/app/app-svr/app-wall/interface/api/client/client.proto", fileDescriptor_e39fb435a4529982)
}

var fileDescriptor_e39fb435a4529982 = []byte{
	// 333 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xc1, 0x4a, 0xc3, 0x40,
	0x10, 0x86, 0xdd, 0xb4, 0x4a, 0x3b, 0xd5, 0x22, 0x4b, 0x0f, 0xa1, 0x48, 0xac, 0x39, 0xf5, 0xd2,
	0x0d, 0xad, 0x08, 0x22, 0x5e, 0x14, 0x05, 0x7b, 0x10, 0x61, 0x0f, 0x16, 0x04, 0x0f, 0xdb, 0xb2,
	0xa9, 0xc1, 0x6d, 0xb2, 0x26, 0xdb, 0x94, 0xbc, 0x89, 0x8f, 0xe4, 0xd1, 0xa3, 0x47, 0xa9, 0x2f,
	0x22, 0xbb, 0x8d, 0x4d, 0x45, 0xab, 0x87, 0x61, 0xf6, 0x1f, 0xe6, 0xff, 0x98, 0x61, 0x16, 0xce,
	0xc6, 0x51, 0x67, 0xcc, 0x14, 0x9f, 0xb1, 0xcc, 0x63, 0x52, 0xea, 0xe8, 0x24, 0x69, 0x6c, 0xf2,
	0x8c, 0x09, 0xe1, 0x05, 0xa1, 0xe2, 0xb1, 0xcf, 0x46, 0xdc, 0x63, 0x32, 0xf0, 0x46, 0x22, 0xe0,
	0xa1, 0xca, 0x13, 0x91, 0x71, 0xa4, 0x22, 0xdc, 0x18, 0x06, 0x22, 0xd0, 0x41, 0x98, 0x94, 0x44,
	0x9b, 0x48, 0xda, 0x75, 0x77, 0xa0, 0x46, 0xa7, 0x82, 0x53, 0xfe, 0x34, 0xe5, 0x89, 0x72, 0xdf,
	0x10, 0x80, 0xd6, 0x09, 0xe5, 0x52, 0x64, 0xf8, 0x1a, 0xaa, 0x46, 0xf5, 0x43, 0x3f, 0xb2, 0x51,
	0xab, 0xd4, 0xae, 0xf5, 0x3c, 0xf2, 0x1b, 0x87, 0x14, 0x26, 0xb2, 0x74, 0x5c, 0x86, 0x2a, 0xce,
	0x68, 0x41, 0xc0, 0x7b, 0x50, 0xbd, 0x62, 0xc9, 0xc3, 0x2d, 0x13, 0x53, 0x6e, 0x5b, 0x2d, 0xd4,
	0xae, 0xd2, 0xa2, 0xd0, 0xbc, 0x87, 0xfa, 0x77, 0x2b, 0xde, 0x85, 0xd2, 0x23, 0xcf, 0x6c, 0x64,
	0x3a, 0xf5, 0x13, 0x1f, 0xc1, 0x66, 0xba, 0x74, 0xd7, 0x7a, 0xfb, 0x7f, 0x0c, 0xa3, 0x31, 0x74,
	0xd1, 0x7d, 0x62, 0x1d, 0x23, 0xb7, 0xbf, 0xb2, 0x0b, 0x3e, 0xfd, 0xb9, 0x98, 0xb3, 0x9e, 0x65,
	0x50, 0x85, 0xc1, 0xbd, 0x80, 0xca, 0x57, 0x19, 0xd7, 0xc1, 0x52, 0xbe, 0x19, 0xb1, 0x42, 0x2d,
	0xe5, 0xe3, 0x6d, 0x40, 0x93, 0x7c, 0x37, 0x34, 0xd1, 0x8a, 0xd9, 0xa5, 0x85, 0x62, 0x5a, 0x49,
	0xbb, 0xbc, 0x50, 0xb2, 0x37, 0x80, 0xf2, 0x80, 0x09, 0x81, 0x6f, 0x56, 0x68, 0x07, 0xeb, 0x87,
	0xc8, 0x4f, 0xd4, 0x6c, 0xfd, 0x77, 0x80, 0xf3, 0xc6, 0xcb, 0xdc, 0x41, 0xaf, 0x73, 0x07, 0xbd,
	0xcf, 0x1d, 0xf4, 0xfc, 0xe1, 0x6c, 0xdc, 0x59, 0x69, 0x77, 0xb8, 0x65, 0xbe, 0xc1, 0xe1, 0x67,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x1b, 0x83, 0xfc, 0x20, 0x4b, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WallClient is the client API for Wall service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WallClient interface {
	// 获取免流规则信息
	RuleInfo(ctx context.Context, in *RuleRequest, opts ...grpc.CallOption) (*RulesReply, error)
}

type wallClient struct {
	cc *grpc.ClientConn
}

func NewWallClient(cc *grpc.ClientConn) WallClient {
	return &wallClient{cc}
}

func (c *wallClient) RuleInfo(ctx context.Context, in *RuleRequest, opts ...grpc.CallOption) (*RulesReply, error) {
	out := new(RulesReply)
	err := c.cc.Invoke(ctx, "/bilibili.app.wall.v1.Wall/RuleInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WallServer is the server API for Wall service.
type WallServer interface {
	// 获取免流规则信息
	RuleInfo(context.Context, *RuleRequest) (*RulesReply, error)
}

// UnimplementedWallServer can be embedded to have forward compatible implementations.
type UnimplementedWallServer struct {
}

func (*UnimplementedWallServer) RuleInfo(ctx context.Context, req *RuleRequest) (*RulesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleInfo not implemented")
}

func RegisterWallServer(s *grpc.Server, srv WallServer) {
	s.RegisterService(&_Wall_serviceDesc, srv)
}

func _Wall_RuleInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WallServer).RuleInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bilibili.app.wall.v1.Wall/RuleInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WallServer).RuleInfo(ctx, req.(*RuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Wall_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bilibili.app.wall.v1.Wall",
	HandlerType: (*WallServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RuleInfo",
			Handler:    _Wall_RuleInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go-gateway/app/app-svr/app-wall/interface/api/client/client.proto",
}

func (m *RuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RulesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RulesReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RulesReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HashValue) > 0 {
		i -= len(m.HashValue)
		copy(dAtA[i:], m.HashValue)
		i = encodeVarintClient(dAtA, i, uint64(len(m.HashValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RulesInfo) > 0 {
		for k := range m.RulesInfo {
			v := m.RulesInfo[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintClient(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RulesInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RulesInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RulesInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RulesInfo) > 0 {
		for iNdEx := len(m.RulesInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RulesInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RuleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.P) > 0 {
		i -= len(m.P)
		copy(dAtA[i:], m.P)
		i = encodeVarintClient(dAtA, i, uint64(len(m.P)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.A) > 0 {
		i -= len(m.A)
		copy(dAtA[i:], m.A)
		i = encodeVarintClient(dAtA, i, uint64(len(m.A)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.M) > 0 {
		i -= len(m.M)
		copy(dAtA[i:], m.M)
		i = encodeVarintClient(dAtA, i, uint64(len(m.M)))
		i--
		dAtA[i] = 0x12
	}
	if m.Tf {
		i--
		if m.Tf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintClient(dAtA []byte, offset int, v uint64) int {
	offset -= sovClient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RuleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RulesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RulesInfo) > 0 {
		for k, v := range m.RulesInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovClient(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovClient(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	l = len(m.HashValue)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RulesInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RulesInfo) > 0 {
		for _, e := range m.RulesInfo {
			l = e.Size()
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tf {
		n += 2
	}
	l = len(m.M)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	l = len(m.A)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	l = len(m.P)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovClient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClient(x uint64) (n int) {
	return sovClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RulesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RulesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RulesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RulesInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RulesInfo == nil {
				m.RulesInfo = make(map[string]*RulesInfo)
			}
			var mapkey string
			var mapvalue *RulesInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthClient
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthClient
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RulesInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RulesInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RulesInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RulesInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RulesInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RulesInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RulesInfo = append(m.RulesInfo, &RuleInfo{})
			if err := m.RulesInfo[len(m.RulesInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tf = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.M = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClient = fmt.Errorf("proto: unexpected end of group")
)
