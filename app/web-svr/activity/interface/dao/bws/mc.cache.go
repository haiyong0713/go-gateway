// Code generated by kratos tool mcgen. DO NOT EDIT.

/*
  Package bws is a generated mc cache package.
  It is generated from:
  type _mc interface {
		//mc: -key=midKey -struct_name=Dao
		CacheUsersMid(c context.Context, bid int64, mid int64) (*bwsmdl.Users, error)
		//mc: -key=midKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheUsersMid(c context.Context, bid int64, value *bwsmdl.Users, mid int64) error
		//mc: -key=midKey -struct_name=Dao
		DelCacheUsersMid(c context.Context, bid int64, mid int64) error
		//mc: -key=keyKey -struct_name=Dao
		CacheUsersKey(c context.Context, bid int64, userKey string) (*bwsmdl.Users, error)
		//mc: -key=keyKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheUsersKey(c context.Context, bid int64, value *bwsmdl.Users, userKey string) error
		//mc: -key=keyKey -struct_name=Dao
		DelCacheUsersKey(c context.Context, bid int64, userKey string) error
		//mc: -key=pointsKey -struct_name=Dao
		CachePoints(c context.Context, key int64) ([]int64, error)
		//mc: -key=pointsKey -expire=d.mcExpire -encode=json -struct_name=Dao
		AddCachePoints(c context.Context, key int64, value []int64) error
		//mc: -key=pointsKey -struct_name=Dao
		DelCachePoints(c context.Context, key int64) error
		//mc: -key=bwsSignKey -struct_name=Dao
		CacheBwsSign(c context.Context, ids []int64) (map[int64]*bwsmdl.PointSign, error)
		//mc: -key=bwsSignKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheBwsSign(c context.Context, val map[int64]*bwsmdl.PointSign) error
		//mc: -key=bwsSignKey -struct_name=Dao
		DelCacheBwsSign(c context.Context, ids []int64) error
		//mc: -key=pointSignKey -struct_name=Dao
		CacheSigns(c context.Context, pid int64) ([]int64, error)
		//mc: -key=pointSignKey -expire=d.mcExpire -encode=json -struct_name=Dao
		AddCacheSigns(c context.Context, pid int64, val []int64) error
		//mc: -key=pointSignKey -struct_name=Dao
		DelCacheSigns(c context.Context, pid int64) error
		//mc: -key=bwsPointsKey -struct_name=Dao
		CacheBwsPoints(c context.Context, ids []int64) (map[int64]*bwsmdl.Point, error)
		//mc: -key=bwsPointsKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheBwsPoints(c context.Context, val map[int64]*bwsmdl.Point) error
		//mc: -key=bwsPointsKey -struct_name=Dao
		DelCacheBwsPoints(c context.Context, ids []int64) error
		//mc: -key=achievesKey -struct_name=Dao
		CacheAchievements(c context.Context, key int64) (*bwsmdl.Achievements, error)
		//mc: -key=achievesKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheAchievements(c context.Context, key int64, value *bwsmdl.Achievements) error
		//mc: -key=achievesKey -struct_name=Dao
		DelCacheAchievements(c context.Context, key int64) error
		//mc: -key=rechargeLevelKey -struct_name=Dao
		CacheRechargeLevels(c context.Context, ids []int64) (map[int64]*bwsmdl.PointsLevel, error)
		//mc: -key=rechargeLevelKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheRechargeLevels(c context.Context, val map[int64]*bwsmdl.PointsLevel) error
		//mc: -key=rechargeLevelKey -struct_name=Dao
		DelCacheRechargeLevels(c context.Context, ids []int64) error
		//mc: -key=rechargeAwardKey -struct_name=Dao
		CacheRechargeAwards(c context.Context, ids []int64) (map[int64]*bwsmdl.PointsAward, error)
		//mc: -key=rechargeAwardKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheRechargeAwards(c context.Context, val map[int64]*bwsmdl.PointsAward) error
		//mc: -key=rechargeAwardKey -struct_name=Dao
		DelCacheRechargeAwards(c context.Context, ids []int64) error
		//mc: -key=fieldsListKey -struct_name=Dao
		CacheActFields(c context.Context, bid int64) (*bwsmdl.ActFields, error)
		//mc: -key=fieldsListKey -expire=d.mcItemExpire -encode=pb -struct_name=Dao
		AddCacheActFields(c context.Context, bid int64, val *bwsmdl.ActFields) error
		//mc: -key=usersVipKey -struct_name=Dao
		CacheUsersVipKey(c context.Context, bid int64, userKey string) (*bwsmdl.VipUsersToken, error)
		//mc: -key=usersVipKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheUsersVipKey(c context.Context, bid int64, value *bwsmdl.VipUsersToken, userKey string) error
		//mc: -key=usersVipKey -struct_name=Dao
		DelCacheUsersVipKey(c context.Context, bid int64, userKey string) error
		//mc: -key=usersVipMidDateKey -struct_name=Dao
		CacheUsersVipMidDate(c context.Context, bid int64, mid int64, date string) (*bwsmdl.VipUsersToken, error)
		//mc: -key=usersVipMidDateKey -expire=d.mcExpire -encode=pb -struct_name=Dao
		AddCacheUsersVipMidDate(c context.Context, bid int64, value *bwsmdl.VipUsersToken, mid int64, date string) error
		//mc: -key=usersVipMidDateKey -struct_name=Dao
		DelCacheUsersVipMidDate(c context.Context, bid int64, mid int64, date string) error
	}
*/

package bws

import (
	"context"
	"fmt"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	bwsmdl "go-gateway/app/web-svr/activity/interface/model/bws"
)

var _ _mc

// CacheUsersMid get data from mc
func (d *Dao) CacheUsersMid(c context.Context, id int64, mid int64) (res *bwsmdl.Users, err error) {
	key := midKey(id, mid)
	res = &bwsmdl.Users{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheUsersMid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheUsersMid Set data to mc
func (d *Dao) AddCacheUsersMid(c context.Context, id int64, val *bwsmdl.Users, mid int64) (err error) {
	if val == nil {
		return
	}
	key := midKey(id, mid)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheUsersMid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheUsersMid delete data from mc
func (d *Dao) DelCacheUsersMid(c context.Context, id int64, mid int64) (err error) {
	key := midKey(id, mid)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheUsersMid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheUsersKey get data from mc
func (d *Dao) CacheUsersKey(c context.Context, id int64, userKey string) (res *bwsmdl.Users, err error) {
	key := keyKey(id, userKey)
	res = &bwsmdl.Users{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheUsersKey", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheUsersKey Set data to mc
func (d *Dao) AddCacheUsersKey(c context.Context, id int64, val *bwsmdl.Users, userKey string) (err error) {
	if val == nil {
		return
	}
	key := keyKey(id, userKey)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheUsersKey", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheUsersKey delete data from mc
func (d *Dao) DelCacheUsersKey(c context.Context, id int64, userKey string) (err error) {
	key := keyKey(id, userKey)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheUsersKey", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CachePoints get data from mc
func (d *Dao) CachePoints(c context.Context, id int64) (res []int64, err error) {
	key := pointsKey(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CachePoints", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCachePoints Set data to mc
func (d *Dao) AddCachePoints(c context.Context, id int64, val []int64) (err error) {
	if len(val) == 0 {
		return
	}
	key := pointsKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCachePoints", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCachePoints delete data from mc
func (d *Dao) DelCachePoints(c context.Context, id int64) (err error) {
	key := pointsKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCachePoints", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheBwsSign get data from mc
func (d *Dao) CacheBwsSign(c context.Context, ids []int64) (res map[int64]*bwsmdl.PointSign, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := bwsSignKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheBwsSign", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &bwsmdl.PointSign{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheBwsSign", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*bwsmdl.PointSign, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheBwsSign Set data to mc
func (d *Dao) AddCacheBwsSign(c context.Context, values map[int64]*bwsmdl.PointSign) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := bwsSignKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheBwsSign", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// DelCacheBwsSign delete data from mc
func (d *Dao) DelCacheBwsSign(c context.Context, ids []int64) (err error) {
	if len(ids) == 0 {
		return
	}
	for _, id := range ids {
		key := bwsSignKey(id)
		if err = d.mc.Delete(c, key); err != nil {
			if err == memcache.ErrNotFound {
				err = nil
				continue
			}
			log.Errorv(c, log.KV("DelCacheBwsSign", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheSigns get data from mc
func (d *Dao) CacheSigns(c context.Context, id int64) (res []int64, err error) {
	key := pointSignKey(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheSigns", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheSigns Set data to mc
func (d *Dao) AddCacheSigns(c context.Context, id int64, val []int64) (err error) {
	if len(val) == 0 {
		return
	}
	key := pointSignKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheSigns", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheSigns delete data from mc
func (d *Dao) DelCacheSigns(c context.Context, id int64) (err error) {
	key := pointSignKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheSigns", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheBwsPoints get data from mc
func (d *Dao) CacheBwsPoints(c context.Context, ids []int64) (res map[int64]*bwsmdl.Point, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := bwsPointsKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheBwsPoints", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &bwsmdl.Point{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheBwsPoints", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*bwsmdl.Point, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheBwsPoints Set data to mc
func (d *Dao) AddCacheBwsPoints(c context.Context, values map[int64]*bwsmdl.Point) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := bwsPointsKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheBwsPoints", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// DelCacheBwsPoints delete data from mc
func (d *Dao) DelCacheBwsPoints(c context.Context, ids []int64) (err error) {
	if len(ids) == 0 {
		return
	}
	for _, id := range ids {
		key := bwsPointsKey(id)
		if err = d.mc.Delete(c, key); err != nil {
			if err == memcache.ErrNotFound {
				err = nil
				continue
			}
			log.Errorv(c, log.KV("DelCacheBwsPoints", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheAchievements get data from mc
func (d *Dao) CacheAchievements(c context.Context, id int64) (res *bwsmdl.Achievements, err error) {
	key := achievesKey(id)
	res = &bwsmdl.Achievements{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheAchievements", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheAchievements Set data to mc
func (d *Dao) AddCacheAchievements(c context.Context, id int64, val *bwsmdl.Achievements) (err error) {
	if val == nil {
		return
	}
	key := achievesKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheAchievements", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheAchievements delete data from mc
func (d *Dao) DelCacheAchievements(c context.Context, id int64) (err error) {
	key := achievesKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheAchievements", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheRechargeLevels get data from mc
func (d *Dao) CacheRechargeLevels(c context.Context, ids []int64) (res map[int64]*bwsmdl.PointsLevel, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := rechargeLevelKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheRechargeLevels", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &bwsmdl.PointsLevel{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheRechargeLevels", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*bwsmdl.PointsLevel, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheRechargeLevels Set data to mc
func (d *Dao) AddCacheRechargeLevels(c context.Context, values map[int64]*bwsmdl.PointsLevel) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := rechargeLevelKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheRechargeLevels", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// DelCacheRechargeLevels delete data from mc
func (d *Dao) DelCacheRechargeLevels(c context.Context, ids []int64) (err error) {
	if len(ids) == 0 {
		return
	}
	for _, id := range ids {
		key := rechargeLevelKey(id)
		if err = d.mc.Delete(c, key); err != nil {
			if err == memcache.ErrNotFound {
				err = nil
				continue
			}
			log.Errorv(c, log.KV("DelCacheRechargeLevels", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheRechargeAwards get data from mc
func (d *Dao) CacheRechargeAwards(c context.Context, ids []int64) (res map[int64]*bwsmdl.PointsAward, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := rechargeAwardKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheRechargeAwards", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &bwsmdl.PointsAward{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheRechargeAwards", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*bwsmdl.PointsAward, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheRechargeAwards Set data to mc
func (d *Dao) AddCacheRechargeAwards(c context.Context, values map[int64]*bwsmdl.PointsAward) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := rechargeAwardKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheRechargeAwards", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// DelCacheRechargeAwards delete data from mc
func (d *Dao) DelCacheRechargeAwards(c context.Context, ids []int64) (err error) {
	if len(ids) == 0 {
		return
	}
	for _, id := range ids {
		key := rechargeAwardKey(id)
		if err = d.mc.Delete(c, key); err != nil {
			if err == memcache.ErrNotFound {
				err = nil
				continue
			}
			log.Errorv(c, log.KV("DelCacheRechargeAwards", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheActFields get data from mc
func (d *Dao) CacheActFields(c context.Context, id int64) (res *bwsmdl.ActFields, err error) {
	key := fieldsListKey(id)
	res = &bwsmdl.ActFields{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheActFields", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActFields Set data to mc
func (d *Dao) AddCacheActFields(c context.Context, id int64, val *bwsmdl.ActFields) (err error) {
	if val == nil {
		return
	}
	key := fieldsListKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheActFields", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheUsersVipKey get data from mc
func (d *Dao) CacheUsersVipKey(c context.Context, id int64, userKey string) (res *bwsmdl.VipUsersToken, err error) {
	key := usersVipKey(id, userKey)
	res = &bwsmdl.VipUsersToken{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheUsersVipKey", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheUsersVipKey Set data to mc
func (d *Dao) AddCacheUsersVipKey(c context.Context, id int64, val *bwsmdl.VipUsersToken, userKey string) (err error) {
	if val == nil {
		return
	}
	key := usersVipKey(id, userKey)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheUsersVipKey", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheUsersVipKey delete data from mc
func (d *Dao) DelCacheUsersVipKey(c context.Context, id int64, userKey string) (err error) {
	key := usersVipKey(id, userKey)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheUsersVipKey", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheUsersVipMidDate get data from mc
func (d *Dao) CacheUsersVipMidDate(c context.Context, id int64, mid int64, date string) (res *bwsmdl.VipUsersToken, err error) {
	key := usersVipMidDateKey(id, mid, date)
	res = &bwsmdl.VipUsersToken{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheUsersVipMidDate", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheUsersVipMidDate Set data to mc
func (d *Dao) AddCacheUsersVipMidDate(c context.Context, id int64, val *bwsmdl.VipUsersToken, mid int64, date string) (err error) {
	if val == nil {
		return
	}
	key := usersVipMidDateKey(id, mid, date)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheUsersVipMidDate", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheUsersVipMidDate delete data from mc
func (d *Dao) DelCacheUsersVipMidDate(c context.Context, id int64, mid int64, date string) (err error) {
	key := usersVipMidDateKey(id, mid, date)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheUsersVipMidDate", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
