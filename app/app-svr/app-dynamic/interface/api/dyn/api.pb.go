// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package dyn

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type TabType int32

const (
	TabType_INVALID_TAB_TYPE TabType = 0
	TabType_TAB_TYPE_GENERAL TabType = 1
	TabType_TAB_TYPE_VIDEO   TabType = 2
)

var TabType_name = map[int32]string{
	0: "INVALID_TAB_TYPE",
	1: "TAB_TYPE_GENERAL",
	2: "TAB_TYPE_VIDEO",
}

var TabType_value = map[string]int32{
	"INVALID_TAB_TYPE": 0,
	"TAB_TYPE_GENERAL": 1,
	"TAB_TYPE_VIDEO":   2,
}

func (x TabType) String() string {
	return proto.EnumName(TabType_name, int32(x))
}

func (TabType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type DynBottomTypes int32

const (
	DynBottomTypes_BOTTOM_TYPE_NONE  DynBottomTypes = 0
	DynBottomTypes_BOTTOM_SDK_SOURCE DynBottomTypes = 1
	DynBottomTypes_BOTTOM_TOPIC_LINK DynBottomTypes = 2
)

var DynBottomTypes_name = map[int32]string{
	0: "BOTTOM_TYPE_NONE",
	1: "BOTTOM_SDK_SOURCE",
	2: "BOTTOM_TOPIC_LINK",
}

var DynBottomTypes_value = map[string]int32{
	"BOTTOM_TYPE_NONE":  0,
	"BOTTOM_SDK_SOURCE": 1,
	"BOTTOM_TOPIC_LINK": 2,
}

func (x DynBottomTypes) String() string {
	return proto.EnumName(DynBottomTypes_name, int32(x))
}

func (DynBottomTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type DynUidType int32

const (
	DynUidType_DYNAMIC_UID_DEFAULT DynUidType = 0
	DynUidType_DYNAMIC_UID_UP      DynUidType = 1
	DynUidType_DYNAMIC_UID_PGC     DynUidType = 2
	DynUidType_DYNAMIC_UID_AD      DynUidType = 3
	DynUidType_DYNAMIC_UID_CHEESE  DynUidType = 4
)

var DynUidType_name = map[int32]string{
	0: "DYNAMIC_UID_DEFAULT",
	1: "DYNAMIC_UID_UP",
	2: "DYNAMIC_UID_PGC",
	3: "DYNAMIC_UID_AD",
	4: "DYNAMIC_UID_CHEESE",
}

var DynUidType_value = map[string]int32{
	"DYNAMIC_UID_DEFAULT": 0,
	"DYNAMIC_UID_UP":      1,
	"DYNAMIC_UID_PGC":     2,
	"DYNAMIC_UID_AD":      3,
	"DYNAMIC_UID_CHEESE":  4,
}

func (x DynUidType) String() string {
	return proto.EnumName(DynUidType_name, int32(x))
}

func (DynUidType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type OffsetInfo struct {
	Tab                  uint32   `protobuf:"varint,1,opt,name=tab,proto3" json:"tab,omitempty"`
	TypeList             string   `protobuf:"bytes,2,opt,name=type_list,json=typeList,proto3" json:"type_list,omitempty"`
	Offset               string   `protobuf:"bytes,3,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OffsetInfo) Reset()         { *m = OffsetInfo{} }
func (m *OffsetInfo) String() string { return proto.CompactTextString(m) }
func (*OffsetInfo) ProtoMessage()    {}
func (*OffsetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *OffsetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OffsetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OffsetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OffsetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OffsetInfo.Merge(m, src)
}
func (m *OffsetInfo) XXX_Size() int {
	return m.Size()
}
func (m *OffsetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OffsetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OffsetInfo proto.InternalMessageInfo

func (m *OffsetInfo) GetTab() uint32 {
	if m != nil {
		return m.Tab
	}
	return 0
}

func (m *OffsetInfo) GetTypeList() string {
	if m != nil {
		return m.TypeList
	}
	return ""
}

func (m *OffsetInfo) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

type UpdateNumReq struct {
	Uid                  uint64        `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Offsets              []*OffsetInfo `protobuf:"bytes,2,rep,name=offsets,proto3" json:"offsets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateNumReq) Reset()         { *m = UpdateNumReq{} }
func (m *UpdateNumReq) String() string { return proto.CompactTextString(m) }
func (*UpdateNumReq) ProtoMessage()    {}
func (*UpdateNumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *UpdateNumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateNumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateNumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateNumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateNumReq.Merge(m, src)
}
func (m *UpdateNumReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateNumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateNumReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateNumReq proto.InternalMessageInfo

func (m *UpdateNumReq) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateNumReq) GetOffsets() []*OffsetInfo {
	if m != nil {
		return m.Offsets
	}
	return nil
}

type UpdateNumResp struct {
	RedType              string   `protobuf:"bytes,1,opt,name=red_type,json=redType,proto3" json:"red_type,omitempty"`
	UpdateNum            uint64   `protobuf:"varint,2,opt,name=update_num,json=updateNum,proto3" json:"update_num,omitempty"`
	DefaultTab           string   `protobuf:"bytes,3,opt,name=default_tab,json=defaultTab,proto3" json:"default_tab,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateNumResp) Reset()         { *m = UpdateNumResp{} }
func (m *UpdateNumResp) String() string { return proto.CompactTextString(m) }
func (*UpdateNumResp) ProtoMessage()    {}
func (*UpdateNumResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *UpdateNumResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateNumResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateNumResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateNumResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateNumResp.Merge(m, src)
}
func (m *UpdateNumResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateNumResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateNumResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateNumResp proto.InternalMessageInfo

func (m *UpdateNumResp) GetRedType() string {
	if m != nil {
		return m.RedType
	}
	return ""
}

func (m *UpdateNumResp) GetUpdateNum() uint64 {
	if m != nil {
		return m.UpdateNum
	}
	return 0
}

func (m *UpdateNumResp) GetDefaultTab() string {
	if m != nil {
		return m.DefaultTab
	}
	return ""
}

type VideoNewReq struct {
	Uid                  int64            `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	UpdateBaseline       string           `protobuf:"bytes,2,opt,name=update_baseline,json=updateBaseline,proto3" json:"update_baseline,omitempty"`
	AssistBaseline       string           `protobuf:"bytes,3,opt,name=assist_baseline,json=assistBaseline,proto3" json:"assist_baseline,omitempty"`
	TypeList             []string         `protobuf:"bytes,4,rep,name=type_list,json=typeList,proto3" json:"type_list,omitempty"`
	VersionCtrl          *VersionCtrlMeta `protobuf:"bytes,5,opt,name=version_ctrl,json=versionCtrl,proto3" json:"version_ctrl,omitempty"`
	InfoCtrl             *FeedInfoCtrl    `protobuf:"bytes,6,opt,name=info_ctrl,json=infoCtrl,proto3" json:"info_ctrl,omitempty"`
	AttentionInfo        *AttentionInfo   `protobuf:"bytes,7,opt,name=attention_info,json=attentionInfo,proto3" json:"attention_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *VideoNewReq) Reset()         { *m = VideoNewReq{} }
func (m *VideoNewReq) String() string { return proto.CompactTextString(m) }
func (*VideoNewReq) ProtoMessage()    {}
func (*VideoNewReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *VideoNewReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoNewReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoNewReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoNewReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoNewReq.Merge(m, src)
}
func (m *VideoNewReq) XXX_Size() int {
	return m.Size()
}
func (m *VideoNewReq) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoNewReq.DiscardUnknown(m)
}

var xxx_messageInfo_VideoNewReq proto.InternalMessageInfo

func (m *VideoNewReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *VideoNewReq) GetUpdateBaseline() string {
	if m != nil {
		return m.UpdateBaseline
	}
	return ""
}

func (m *VideoNewReq) GetAssistBaseline() string {
	if m != nil {
		return m.AssistBaseline
	}
	return ""
}

func (m *VideoNewReq) GetTypeList() []string {
	if m != nil {
		return m.TypeList
	}
	return nil
}

func (m *VideoNewReq) GetVersionCtrl() *VersionCtrlMeta {
	if m != nil {
		return m.VersionCtrl
	}
	return nil
}

func (m *VideoNewReq) GetInfoCtrl() *FeedInfoCtrl {
	if m != nil {
		return m.InfoCtrl
	}
	return nil
}

func (m *VideoNewReq) GetAttentionInfo() *AttentionInfo {
	if m != nil {
		return m.AttentionInfo
	}
	return nil
}

type VideoNewRsp struct {
	UpdateNum            int64       `protobuf:"varint,1,opt,name=update_num,json=updateNum,proto3" json:"update_num,omitempty"`
	HistoryOffset        string      `protobuf:"bytes,2,opt,name=history_offset,json=historyOffset,proto3" json:"history_offset,omitempty"`
	UpdateBaseline       string      `protobuf:"bytes,3,opt,name=update_baseline,json=updateBaseline,proto3" json:"update_baseline,omitempty"`
	HasMore              bool        `protobuf:"varint,4,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	Dyns                 []*DynBrief `protobuf:"bytes,5,rep,name=dyns,proto3" json:"dyns,omitempty"`
	FoldInfo             *FoldInfo   `protobuf:"bytes,6,opt,name=fold_info,json=foldInfo,proto3" json:"fold_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VideoNewRsp) Reset()         { *m = VideoNewRsp{} }
func (m *VideoNewRsp) String() string { return proto.CompactTextString(m) }
func (*VideoNewRsp) ProtoMessage()    {}
func (*VideoNewRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *VideoNewRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoNewRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoNewRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoNewRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoNewRsp.Merge(m, src)
}
func (m *VideoNewRsp) XXX_Size() int {
	return m.Size()
}
func (m *VideoNewRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoNewRsp.DiscardUnknown(m)
}

var xxx_messageInfo_VideoNewRsp proto.InternalMessageInfo

func (m *VideoNewRsp) GetUpdateNum() int64 {
	if m != nil {
		return m.UpdateNum
	}
	return 0
}

func (m *VideoNewRsp) GetHistoryOffset() string {
	if m != nil {
		return m.HistoryOffset
	}
	return ""
}

func (m *VideoNewRsp) GetUpdateBaseline() string {
	if m != nil {
		return m.UpdateBaseline
	}
	return ""
}

func (m *VideoNewRsp) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

func (m *VideoNewRsp) GetDyns() []*DynBrief {
	if m != nil {
		return m.Dyns
	}
	return nil
}

func (m *VideoNewRsp) GetFoldInfo() *FoldInfo {
	if m != nil {
		return m.FoldInfo
	}
	return nil
}

type VideoHistoryReq struct {
	Uid                  int64            `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Offset               string           `protobuf:"bytes,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Page                 int64            `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	TypeList             []string         `protobuf:"bytes,4,rep,name=type_list,json=typeList,proto3" json:"type_list,omitempty"`
	VersionCtrl          *VersionCtrlMeta `protobuf:"bytes,5,opt,name=version_ctrl,json=versionCtrl,proto3" json:"version_ctrl,omitempty"`
	InfoCtrl             *FeedInfoCtrl    `protobuf:"bytes,6,opt,name=info_ctrl,json=infoCtrl,proto3" json:"info_ctrl,omitempty"`
	AttentionInfo        *AttentionInfo   `protobuf:"bytes,7,opt,name=attention_info,json=attentionInfo,proto3" json:"attention_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *VideoHistoryReq) Reset()         { *m = VideoHistoryReq{} }
func (m *VideoHistoryReq) String() string { return proto.CompactTextString(m) }
func (*VideoHistoryReq) ProtoMessage()    {}
func (*VideoHistoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *VideoHistoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoHistoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoHistoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoHistoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoHistoryReq.Merge(m, src)
}
func (m *VideoHistoryReq) XXX_Size() int {
	return m.Size()
}
func (m *VideoHistoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoHistoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_VideoHistoryReq proto.InternalMessageInfo

func (m *VideoHistoryReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *VideoHistoryReq) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

func (m *VideoHistoryReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *VideoHistoryReq) GetTypeList() []string {
	if m != nil {
		return m.TypeList
	}
	return nil
}

func (m *VideoHistoryReq) GetVersionCtrl() *VersionCtrlMeta {
	if m != nil {
		return m.VersionCtrl
	}
	return nil
}

func (m *VideoHistoryReq) GetInfoCtrl() *FeedInfoCtrl {
	if m != nil {
		return m.InfoCtrl
	}
	return nil
}

func (m *VideoHistoryReq) GetAttentionInfo() *AttentionInfo {
	if m != nil {
		return m.AttentionInfo
	}
	return nil
}

type VideoHistoryRsp struct {
	HistoryOffset        string      `protobuf:"bytes,1,opt,name=history_offset,json=historyOffset,proto3" json:"history_offset,omitempty"`
	HasMore              bool        `protobuf:"varint,2,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	Dyns                 []*DynBrief `protobuf:"bytes,3,rep,name=dyns,proto3" json:"dyns,omitempty"`
	FoldInfo             *FoldInfo   `protobuf:"bytes,4,opt,name=fold_info,json=foldInfo,proto3" json:"fold_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VideoHistoryRsp) Reset()         { *m = VideoHistoryRsp{} }
func (m *VideoHistoryRsp) String() string { return proto.CompactTextString(m) }
func (*VideoHistoryRsp) ProtoMessage()    {}
func (*VideoHistoryRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *VideoHistoryRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoHistoryRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoHistoryRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoHistoryRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoHistoryRsp.Merge(m, src)
}
func (m *VideoHistoryRsp) XXX_Size() int {
	return m.Size()
}
func (m *VideoHistoryRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoHistoryRsp.DiscardUnknown(m)
}

var xxx_messageInfo_VideoHistoryRsp proto.InternalMessageInfo

func (m *VideoHistoryRsp) GetHistoryOffset() string {
	if m != nil {
		return m.HistoryOffset
	}
	return ""
}

func (m *VideoHistoryRsp) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

func (m *VideoHistoryRsp) GetDyns() []*DynBrief {
	if m != nil {
		return m.Dyns
	}
	return nil
}

func (m *VideoHistoryRsp) GetFoldInfo() *FoldInfo {
	if m != nil {
		return m.FoldInfo
	}
	return nil
}

type DynBriefsReq struct {
	DynIds               []int64          `protobuf:"varint,1,rep,packed,name=dyn_ids,json=dynIds,proto3" json:"dyn_ids,omitempty"`
	VersionCtrl          *VersionCtrlMeta `protobuf:"bytes,2,opt,name=version_ctrl,json=versionCtrl,proto3" json:"version_ctrl,omitempty"`
	InfoCtrl             *FeedInfoCtrl    `protobuf:"bytes,3,opt,name=info_ctrl,json=infoCtrl,proto3" json:"info_ctrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DynBriefsReq) Reset()         { *m = DynBriefsReq{} }
func (m *DynBriefsReq) String() string { return proto.CompactTextString(m) }
func (*DynBriefsReq) ProtoMessage()    {}
func (*DynBriefsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *DynBriefsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynBriefsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynBriefsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynBriefsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynBriefsReq.Merge(m, src)
}
func (m *DynBriefsReq) XXX_Size() int {
	return m.Size()
}
func (m *DynBriefsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DynBriefsReq.DiscardUnknown(m)
}

var xxx_messageInfo_DynBriefsReq proto.InternalMessageInfo

func (m *DynBriefsReq) GetDynIds() []int64 {
	if m != nil {
		return m.DynIds
	}
	return nil
}

func (m *DynBriefsReq) GetVersionCtrl() *VersionCtrlMeta {
	if m != nil {
		return m.VersionCtrl
	}
	return nil
}

func (m *DynBriefsReq) GetInfoCtrl() *FeedInfoCtrl {
	if m != nil {
		return m.InfoCtrl
	}
	return nil
}

type DynBriefsRsp struct {
	Dyns                 []*DynBrief `protobuf:"bytes,1,rep,name=dyns,proto3" json:"dyns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DynBriefsRsp) Reset()         { *m = DynBriefsRsp{} }
func (m *DynBriefsRsp) String() string { return proto.CompactTextString(m) }
func (*DynBriefsRsp) ProtoMessage()    {}
func (*DynBriefsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *DynBriefsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynBriefsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynBriefsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynBriefsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynBriefsRsp.Merge(m, src)
}
func (m *DynBriefsRsp) XXX_Size() int {
	return m.Size()
}
func (m *DynBriefsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DynBriefsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DynBriefsRsp proto.InternalMessageInfo

func (m *DynBriefsRsp) GetDyns() []*DynBrief {
	if m != nil {
		return m.Dyns
	}
	return nil
}

type VideoPersonalReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	HostUid              int64    `protobuf:"varint,2,opt,name=host_uid,json=hostUid,proto3" json:"host_uid,omitempty"`
	IsPreload            bool     `protobuf:"varint,3,opt,name=is_preload,json=isPreload,proto3" json:"is_preload,omitempty"`
	Offset               string   `protobuf:"bytes,4,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VideoPersonalReq) Reset()         { *m = VideoPersonalReq{} }
func (m *VideoPersonalReq) String() string { return proto.CompactTextString(m) }
func (*VideoPersonalReq) ProtoMessage()    {}
func (*VideoPersonalReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *VideoPersonalReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoPersonalReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoPersonalReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoPersonalReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoPersonalReq.Merge(m, src)
}
func (m *VideoPersonalReq) XXX_Size() int {
	return m.Size()
}
func (m *VideoPersonalReq) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoPersonalReq.DiscardUnknown(m)
}

var xxx_messageInfo_VideoPersonalReq proto.InternalMessageInfo

func (m *VideoPersonalReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *VideoPersonalReq) GetHostUid() int64 {
	if m != nil {
		return m.HostUid
	}
	return 0
}

func (m *VideoPersonalReq) GetIsPreload() bool {
	if m != nil {
		return m.IsPreload
	}
	return false
}

func (m *VideoPersonalReq) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

type VideoPersonalRsp struct {
	HasMore              bool        `protobuf:"varint,1,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	Offset               string      `protobuf:"bytes,2,opt,name=offset,proto3" json:"offset,omitempty"`
	ReadOffset           string      `protobuf:"bytes,3,opt,name=read_offset,json=readOffset,proto3" json:"read_offset,omitempty"`
	Dyns                 []*DynBrief `protobuf:"bytes,4,rep,name=dyns,proto3" json:"dyns,omitempty"`
	FoldInfo             *FoldInfo   `protobuf:"bytes,5,opt,name=fold_info,json=foldInfo,proto3" json:"fold_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VideoPersonalRsp) Reset()         { *m = VideoPersonalRsp{} }
func (m *VideoPersonalRsp) String() string { return proto.CompactTextString(m) }
func (*VideoPersonalRsp) ProtoMessage()    {}
func (*VideoPersonalRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *VideoPersonalRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoPersonalRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoPersonalRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoPersonalRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoPersonalRsp.Merge(m, src)
}
func (m *VideoPersonalRsp) XXX_Size() int {
	return m.Size()
}
func (m *VideoPersonalRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoPersonalRsp.DiscardUnknown(m)
}

var xxx_messageInfo_VideoPersonalRsp proto.InternalMessageInfo

func (m *VideoPersonalRsp) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

func (m *VideoPersonalRsp) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

func (m *VideoPersonalRsp) GetReadOffset() string {
	if m != nil {
		return m.ReadOffset
	}
	return ""
}

func (m *VideoPersonalRsp) GetDyns() []*DynBrief {
	if m != nil {
		return m.Dyns
	}
	return nil
}

func (m *VideoPersonalRsp) GetFoldInfo() *FoldInfo {
	if m != nil {
		return m.FoldInfo
	}
	return nil
}

type DynPostInfoReq struct {
	Uid                  uint64           `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Dyns                 []*DynPostItem   `protobuf:"bytes,2,rep,name=dyns,proto3" json:"dyns,omitempty"`
	VersionCtrl          *VersionCtrlMeta `protobuf:"bytes,3,opt,name=version_ctrl,json=versionCtrl,proto3" json:"version_ctrl,omitempty"`
	InfoCtrl             *PostInfoCtrl    `protobuf:"bytes,4,opt,name=info_ctrl,json=infoCtrl,proto3" json:"info_ctrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DynPostInfoReq) Reset()         { *m = DynPostInfoReq{} }
func (m *DynPostInfoReq) String() string { return proto.CompactTextString(m) }
func (*DynPostInfoReq) ProtoMessage()    {}
func (*DynPostInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *DynPostInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynPostInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynPostInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynPostInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynPostInfoReq.Merge(m, src)
}
func (m *DynPostInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *DynPostInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DynPostInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_DynPostInfoReq proto.InternalMessageInfo

func (m *DynPostInfoReq) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DynPostInfoReq) GetDyns() []*DynPostItem {
	if m != nil {
		return m.Dyns
	}
	return nil
}

func (m *DynPostInfoReq) GetVersionCtrl() *VersionCtrlMeta {
	if m != nil {
		return m.VersionCtrl
	}
	return nil
}

func (m *DynPostInfoReq) GetInfoCtrl() *PostInfoCtrl {
	if m != nil {
		return m.InfoCtrl
	}
	return nil
}

type DynPostInfoRsp struct {
	Dyns                 map[int64]*DynPostInfo `protobuf:"bytes,1,rep,name=dyns,proto3" json:"dyns,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DynPostInfoRsp) Reset()         { *m = DynPostInfoRsp{} }
func (m *DynPostInfoRsp) String() string { return proto.CompactTextString(m) }
func (*DynPostInfoRsp) ProtoMessage()    {}
func (*DynPostInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *DynPostInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynPostInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynPostInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynPostInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynPostInfoRsp.Merge(m, src)
}
func (m *DynPostInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *DynPostInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DynPostInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DynPostInfoRsp proto.InternalMessageInfo

func (m *DynPostInfoRsp) GetDyns() map[int64]*DynPostInfo {
	if m != nil {
		return m.Dyns
	}
	return nil
}

type TopicInfo struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	TopicName            string   `protobuf:"bytes,2,opt,name=topic_name,json=topicName,proto3" json:"topic_name,omitempty"`
	Stat                 int32    `protobuf:"varint,3,opt,name=stat,proto3" json:"stat,omitempty"`
	OriginTopicId        int64    `protobuf:"varint,4,opt,name=origin_topic_id,json=originTopicId,proto3" json:"origin_topic_id,omitempty"`
	OriginTopicName      string   `protobuf:"bytes,5,opt,name=origin_topic_name,json=originTopicName,proto3" json:"origin_topic_name,omitempty"`
	OriginType           int32    `protobuf:"varint,6,opt,name=origin_type,json=originType,proto3" json:"origin_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicInfo) Reset()         { *m = TopicInfo{} }
func (m *TopicInfo) String() string { return proto.CompactTextString(m) }
func (*TopicInfo) ProtoMessage()    {}
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *TopicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicInfo.Merge(m, src)
}
func (m *TopicInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicInfo proto.InternalMessageInfo

func (m *TopicInfo) GetTopicId() int64 {
	if m != nil {
		return m.TopicId
	}
	return 0
}

func (m *TopicInfo) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *TopicInfo) GetStat() int32 {
	if m != nil {
		return m.Stat
	}
	return 0
}

func (m *TopicInfo) GetOriginTopicId() int64 {
	if m != nil {
		return m.OriginTopicId
	}
	return 0
}

func (m *TopicInfo) GetOriginTopicName() string {
	if m != nil {
		return m.OriginTopicName
	}
	return ""
}

func (m *TopicInfo) GetOriginType() int32 {
	if m != nil {
		return m.OriginType
	}
	return 0
}

type DynExt struct {
	Lott                 *ExtLottery     `protobuf:"bytes,1,opt,name=lott,proto3" json:"lott,omitempty"`
	Vote                 *ExtVote        `protobuf:"bytes,2,opt,name=vote,proto3" json:"vote,omitempty"`
	Lbs                  *ExtLbs         `protobuf:"bytes,3,opt,name=lbs,proto3" json:"lbs,omitempty"`
	HighLight            []*ExtHighLight `protobuf:"bytes,4,rep,name=high_light,json=highLight,proto3" json:"high_light,omitempty"`
	TopicInfo            *ExtTopic       `protobuf:"bytes,5,opt,name=topic_info,json=topicInfo,proto3" json:"topic_info,omitempty"`
	OpenGoods            *ExtOpenGoods   `protobuf:"bytes,6,opt,name=open_goods,json=openGoods,proto3" json:"open_goods,omitempty"`
	EmojiType            int32           `protobuf:"varint,7,opt,name=emoji_type,json=emojiType,proto3" json:"emoji_type,omitempty"`
	Dispute              *DynDispute     `protobuf:"bytes,8,opt,name=dispute,proto3" json:"dispute,omitempty"`
	Bottom               *ExtBottom      `protobuf:"bytes,9,opt,name=bottom,proto3" json:"bottom,omitempty"`
	FlagCfg              *ExtFlagCfg     `protobuf:"bytes,10,opt,name=flag_cfg,json=flagCfg,proto3" json:"flag_cfg,omitempty"`
	LikeUsers            []int64         `protobuf:"varint,11,rep,packed,name=like_users,json=likeUsers,proto3" json:"like_users,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DynExt) Reset()         { *m = DynExt{} }
func (m *DynExt) String() string { return proto.CompactTextString(m) }
func (*DynExt) ProtoMessage()    {}
func (*DynExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *DynExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynExt.Merge(m, src)
}
func (m *DynExt) XXX_Size() int {
	return m.Size()
}
func (m *DynExt) XXX_DiscardUnknown() {
	xxx_messageInfo_DynExt.DiscardUnknown(m)
}

var xxx_messageInfo_DynExt proto.InternalMessageInfo

func (m *DynExt) GetLott() *ExtLottery {
	if m != nil {
		return m.Lott
	}
	return nil
}

func (m *DynExt) GetVote() *ExtVote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *DynExt) GetLbs() *ExtLbs {
	if m != nil {
		return m.Lbs
	}
	return nil
}

func (m *DynExt) GetHighLight() []*ExtHighLight {
	if m != nil {
		return m.HighLight
	}
	return nil
}

func (m *DynExt) GetTopicInfo() *ExtTopic {
	if m != nil {
		return m.TopicInfo
	}
	return nil
}

func (m *DynExt) GetOpenGoods() *ExtOpenGoods {
	if m != nil {
		return m.OpenGoods
	}
	return nil
}

func (m *DynExt) GetEmojiType() int32 {
	if m != nil {
		return m.EmojiType
	}
	return 0
}

func (m *DynExt) GetDispute() *DynDispute {
	if m != nil {
		return m.Dispute
	}
	return nil
}

func (m *DynExt) GetBottom() *ExtBottom {
	if m != nil {
		return m.Bottom
	}
	return nil
}

func (m *DynExt) GetFlagCfg() *ExtFlagCfg {
	if m != nil {
		return m.FlagCfg
	}
	return nil
}

func (m *DynExt) GetLikeUsers() []int64 {
	if m != nil {
		return m.LikeUsers
	}
	return nil
}

type BottomDetail struct {
	Type                 int64    `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Rid                  int64    `protobuf:"varint,2,opt,name=rid,proto3" json:"rid,omitempty"`
	Content              string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	JumpUrl              string   `protobuf:"bytes,4,opt,name=jump_url,json=jumpUrl,proto3" json:"jump_url,omitempty"`
	Status               int64    `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
	BottomType           int32    `protobuf:"varint,6,opt,name=bottom_type,json=bottomType,proto3" json:"bottom_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BottomDetail) Reset()         { *m = BottomDetail{} }
func (m *BottomDetail) String() string { return proto.CompactTextString(m) }
func (*BottomDetail) ProtoMessage()    {}
func (*BottomDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *BottomDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BottomDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BottomDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BottomDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BottomDetail.Merge(m, src)
}
func (m *BottomDetail) XXX_Size() int {
	return m.Size()
}
func (m *BottomDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BottomDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BottomDetail proto.InternalMessageInfo

func (m *BottomDetail) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BottomDetail) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *BottomDetail) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *BottomDetail) GetJumpUrl() string {
	if m != nil {
		return m.JumpUrl
	}
	return ""
}

func (m *BottomDetail) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *BottomDetail) GetBottomType() int32 {
	if m != nil {
		return m.BottomType
	}
	return 0
}

type BottomBusiness struct {
	Rid                  int64    `protobuf:"varint,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Type                 int64    `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BottomBusiness) Reset()         { *m = BottomBusiness{} }
func (m *BottomBusiness) String() string { return proto.CompactTextString(m) }
func (*BottomBusiness) ProtoMessage()    {}
func (*BottomBusiness) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *BottomBusiness) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BottomBusiness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BottomBusiness.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BottomBusiness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BottomBusiness.Merge(m, src)
}
func (m *BottomBusiness) XXX_Size() int {
	return m.Size()
}
func (m *BottomBusiness) XXX_DiscardUnknown() {
	xxx_messageInfo_BottomBusiness.DiscardUnknown(m)
}

var xxx_messageInfo_BottomBusiness proto.InternalMessageInfo

func (m *BottomBusiness) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *BottomBusiness) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

type ExtBottom struct {
	Business             []*BottomBusiness `protobuf:"bytes,1,rep,name=business,proto3" json:"business,omitempty"`
	BottomDetails        []*BottomDetail   `protobuf:"bytes,2,rep,name=bottom_details,json=bottomDetails,proto3" json:"bottom_details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ExtBottom) Reset()         { *m = ExtBottom{} }
func (m *ExtBottom) String() string { return proto.CompactTextString(m) }
func (*ExtBottom) ProtoMessage()    {}
func (*ExtBottom) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *ExtBottom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtBottom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtBottom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtBottom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtBottom.Merge(m, src)
}
func (m *ExtBottom) XXX_Size() int {
	return m.Size()
}
func (m *ExtBottom) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtBottom.DiscardUnknown(m)
}

var xxx_messageInfo_ExtBottom proto.InternalMessageInfo

func (m *ExtBottom) GetBusiness() []*BottomBusiness {
	if m != nil {
		return m.Business
	}
	return nil
}

func (m *ExtBottom) GetBottomDetails() []*BottomDetail {
	if m != nil {
		return m.BottomDetails
	}
	return nil
}

type ExtTopic struct {
	IsAttachTopic        bool         `protobuf:"varint,1,opt,name=is_attach_topic,json=isAttachTopic,proto3" json:"is_attach_topic,omitempty"`
	TopicInfos           []*TopicInfo `protobuf:"bytes,2,rep,name=topic_infos,json=topicInfos,proto3" json:"topic_infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ExtTopic) Reset()         { *m = ExtTopic{} }
func (m *ExtTopic) String() string { return proto.CompactTextString(m) }
func (*ExtTopic) ProtoMessage()    {}
func (*ExtTopic) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *ExtTopic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtTopic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtTopic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtTopic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtTopic.Merge(m, src)
}
func (m *ExtTopic) XXX_Size() int {
	return m.Size()
}
func (m *ExtTopic) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtTopic.DiscardUnknown(m)
}

var xxx_messageInfo_ExtTopic proto.InternalMessageInfo

func (m *ExtTopic) GetIsAttachTopic() bool {
	if m != nil {
		return m.IsAttachTopic
	}
	return false
}

func (m *ExtTopic) GetTopicInfos() []*TopicInfo {
	if m != nil {
		return m.TopicInfos
	}
	return nil
}

type ExtLottery struct {
	LotteryId            int64    `protobuf:"varint,1,opt,name=lottery_id,json=lotteryId,proto3" json:"lottery_id,omitempty"`
	Title                string   `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	LotteryTime          int64    `protobuf:"varint,3,opt,name=lottery_time,json=lotteryTime,proto3" json:"lottery_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtLottery) Reset()         { *m = ExtLottery{} }
func (m *ExtLottery) String() string { return proto.CompactTextString(m) }
func (*ExtLottery) ProtoMessage()    {}
func (*ExtLottery) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *ExtLottery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtLottery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtLottery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtLottery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtLottery.Merge(m, src)
}
func (m *ExtLottery) XXX_Size() int {
	return m.Size()
}
func (m *ExtLottery) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtLottery.DiscardUnknown(m)
}

var xxx_messageInfo_ExtLottery proto.InternalMessageInfo

func (m *ExtLottery) GetLotteryId() int64 {
	if m != nil {
		return m.LotteryId
	}
	return 0
}

func (m *ExtLottery) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ExtLottery) GetLotteryTime() int64 {
	if m != nil {
		return m.LotteryTime
	}
	return 0
}

type ExtVote struct {
	VoteId               int64    `protobuf:"varint,1,opt,name=vote_id,json=voteId,proto3" json:"vote_id,omitempty"`
	Title                string   `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtVote) Reset()         { *m = ExtVote{} }
func (m *ExtVote) String() string { return proto.CompactTextString(m) }
func (*ExtVote) ProtoMessage()    {}
func (*ExtVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *ExtVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtVote.Merge(m, src)
}
func (m *ExtVote) XXX_Size() int {
	return m.Size()
}
func (m *ExtVote) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtVote.DiscardUnknown(m)
}

var xxx_messageInfo_ExtVote proto.InternalMessageInfo

func (m *ExtVote) GetVoteId() int64 {
	if m != nil {
		return m.VoteId
	}
	return 0
}

func (m *ExtVote) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

type ExtLbs struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Distance             int64    `protobuf:"varint,2,opt,name=distance,proto3" json:"distance,omitempty"`
	Type                 int64    `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Poi                  string   `protobuf:"bytes,4,opt,name=poi,proto3" json:"poi,omitempty"`
	Location             *LbsLoc  `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
	ShowTitle            string   `protobuf:"bytes,6,opt,name=show_title,json=showTitle,proto3" json:"show_title,omitempty"`
	Title                string   `protobuf:"bytes,7,opt,name=title,proto3" json:"title,omitempty"`
	ShowDistance         string   `protobuf:"bytes,8,opt,name=show_distance,json=showDistance,proto3" json:"show_distance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtLbs) Reset()         { *m = ExtLbs{} }
func (m *ExtLbs) String() string { return proto.CompactTextString(m) }
func (*ExtLbs) ProtoMessage()    {}
func (*ExtLbs) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *ExtLbs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtLbs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtLbs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtLbs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtLbs.Merge(m, src)
}
func (m *ExtLbs) XXX_Size() int {
	return m.Size()
}
func (m *ExtLbs) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtLbs.DiscardUnknown(m)
}

var xxx_messageInfo_ExtLbs proto.InternalMessageInfo

func (m *ExtLbs) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ExtLbs) GetDistance() int64 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *ExtLbs) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ExtLbs) GetPoi() string {
	if m != nil {
		return m.Poi
	}
	return ""
}

func (m *ExtLbs) GetLocation() *LbsLoc {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *ExtLbs) GetShowTitle() string {
	if m != nil {
		return m.ShowTitle
	}
	return ""
}

func (m *ExtLbs) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ExtLbs) GetShowDistance() string {
	if m != nil {
		return m.ShowDistance
	}
	return ""
}

type ExtHighLight struct {
	Location             int64    `protobuf:"varint,1,opt,name=location,proto3" json:"location,omitempty"`
	Length               int64    `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	Data                 string   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Type                 int64    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	TypeId               string   `protobuf:"bytes,5,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	PrefixIcon           string   `protobuf:"bytes,6,opt,name=prefix_icon,json=prefixIcon,proto3" json:"prefix_icon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtHighLight) Reset()         { *m = ExtHighLight{} }
func (m *ExtHighLight) String() string { return proto.CompactTextString(m) }
func (*ExtHighLight) ProtoMessage()    {}
func (*ExtHighLight) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *ExtHighLight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtHighLight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtHighLight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtHighLight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtHighLight.Merge(m, src)
}
func (m *ExtHighLight) XXX_Size() int {
	return m.Size()
}
func (m *ExtHighLight) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtHighLight.DiscardUnknown(m)
}

var xxx_messageInfo_ExtHighLight proto.InternalMessageInfo

func (m *ExtHighLight) GetLocation() int64 {
	if m != nil {
		return m.Location
	}
	return 0
}

func (m *ExtHighLight) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ExtHighLight) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ExtHighLight) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ExtHighLight) GetTypeId() string {
	if m != nil {
		return m.TypeId
	}
	return ""
}

func (m *ExtHighLight) GetPrefixIcon() string {
	if m != nil {
		return m.PrefixIcon
	}
	return ""
}

type ExtOpenGoods struct {
	ItemsId              string   `protobuf:"bytes,1,opt,name=itemsId,proto3" json:"itemsId,omitempty"`
	ShopId               int64    `protobuf:"varint,2,opt,name=shopId,proto3" json:"shopId,omitempty"`
	Type                 int64    `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	LinkItemId           string   `protobuf:"bytes,4,opt,name=linkItemId,proto3" json:"linkItemId,omitempty"`
	Version              string   `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtOpenGoods) Reset()         { *m = ExtOpenGoods{} }
func (m *ExtOpenGoods) String() string { return proto.CompactTextString(m) }
func (*ExtOpenGoods) ProtoMessage()    {}
func (*ExtOpenGoods) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *ExtOpenGoods) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtOpenGoods) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtOpenGoods.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtOpenGoods) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtOpenGoods.Merge(m, src)
}
func (m *ExtOpenGoods) XXX_Size() int {
	return m.Size()
}
func (m *ExtOpenGoods) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtOpenGoods.DiscardUnknown(m)
}

var xxx_messageInfo_ExtOpenGoods proto.InternalMessageInfo

func (m *ExtOpenGoods) GetItemsId() string {
	if m != nil {
		return m.ItemsId
	}
	return ""
}

func (m *ExtOpenGoods) GetShopId() int64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *ExtOpenGoods) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ExtOpenGoods) GetLinkItemId() string {
	if m != nil {
		return m.LinkItemId
	}
	return ""
}

func (m *ExtOpenGoods) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type DynDispute struct {
	Content              string   `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	JumpUrl              string   `protobuf:"bytes,2,opt,name=jump_url,json=jumpUrl,proto3" json:"jump_url,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DynDispute) Reset()         { *m = DynDispute{} }
func (m *DynDispute) String() string { return proto.CompactTextString(m) }
func (*DynDispute) ProtoMessage()    {}
func (*DynDispute) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *DynDispute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynDispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynDispute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynDispute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynDispute.Merge(m, src)
}
func (m *DynDispute) XXX_Size() int {
	return m.Size()
}
func (m *DynDispute) XXX_DiscardUnknown() {
	xxx_messageInfo_DynDispute.DiscardUnknown(m)
}

var xxx_messageInfo_DynDispute proto.InternalMessageInfo

func (m *DynDispute) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *DynDispute) GetJumpUrl() string {
	if m != nil {
		return m.JumpUrl
	}
	return ""
}

func (m *DynDispute) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type LbsLoc struct {
	Lat                  float64  `protobuf:"fixed64,1,opt,name=lat,proto3" json:"lat,omitempty"`
	Lng                  float64  `protobuf:"fixed64,2,opt,name=lng,proto3" json:"lng,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LbsLoc) Reset()         { *m = LbsLoc{} }
func (m *LbsLoc) String() string { return proto.CompactTextString(m) }
func (*LbsLoc) ProtoMessage()    {}
func (*LbsLoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *LbsLoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LbsLoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LbsLoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LbsLoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LbsLoc.Merge(m, src)
}
func (m *LbsLoc) XXX_Size() int {
	return m.Size()
}
func (m *LbsLoc) XXX_DiscardUnknown() {
	xxx_messageInfo_LbsLoc.DiscardUnknown(m)
}

var xxx_messageInfo_LbsLoc proto.InternalMessageInfo

func (m *LbsLoc) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *LbsLoc) GetLng() float64 {
	if m != nil {
		return m.Lng
	}
	return 0
}

type ExtFlagCfg struct {
	IsPgc                bool     `protobuf:"varint,1,opt,name=is_pgc,json=isPgc,proto3" json:"is_pgc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtFlagCfg) Reset()         { *m = ExtFlagCfg{} }
func (m *ExtFlagCfg) String() string { return proto.CompactTextString(m) }
func (*ExtFlagCfg) ProtoMessage()    {}
func (*ExtFlagCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *ExtFlagCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtFlagCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtFlagCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtFlagCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtFlagCfg.Merge(m, src)
}
func (m *ExtFlagCfg) XXX_Size() int {
	return m.Size()
}
func (m *ExtFlagCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtFlagCfg.DiscardUnknown(m)
}

var xxx_messageInfo_ExtFlagCfg proto.InternalMessageInfo

func (m *ExtFlagCfg) GetIsPgc() bool {
	if m != nil {
		return m.IsPgc
	}
	return false
}

type FoldStatement struct {
	Statement            string   `protobuf:"bytes,1,opt,name=statement,proto3" json:"statement,omitempty"`
	JumpUri              string   `protobuf:"bytes,2,opt,name=jump_uri,json=jumpUri,proto3" json:"jump_uri,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FoldStatement) Reset()         { *m = FoldStatement{} }
func (m *FoldStatement) String() string { return proto.CompactTextString(m) }
func (*FoldStatement) ProtoMessage()    {}
func (*FoldStatement) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *FoldStatement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FoldStatement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FoldStatement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FoldStatement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FoldStatement.Merge(m, src)
}
func (m *FoldStatement) XXX_Size() int {
	return m.Size()
}
func (m *FoldStatement) XXX_DiscardUnknown() {
	xxx_messageInfo_FoldStatement.DiscardUnknown(m)
}

var xxx_messageInfo_FoldStatement proto.InternalMessageInfo

func (m *FoldStatement) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *FoldStatement) GetJumpUri() string {
	if m != nil {
		return m.JumpUri
	}
	return ""
}

func (m *FoldStatement) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type DynBrief struct {
	DynId                int64     `protobuf:"varint,1,opt,name=dyn_id,json=dynId,proto3" json:"dyn_id,omitempty"`
	Type                 int64     `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Rid                  int64     `protobuf:"varint,3,opt,name=rid,proto3" json:"rid,omitempty"`
	Uid                  int64     `protobuf:"varint,4,opt,name=uid,proto3" json:"uid,omitempty"`
	UidType              int64     `protobuf:"varint,5,opt,name=uid_type,json=uidType,proto3" json:"uid_type,omitempty"`
	RepostNum            int64     `protobuf:"varint,6,opt,name=repost_num,json=repostNum,proto3" json:"repost_num,omitempty"`
	Tips                 string    `protobuf:"bytes,7,opt,name=tips,proto3" json:"tips,omitempty"`
	Visible              bool      `protobuf:"varint,8,opt,name=visible,proto3" json:"visible,omitempty"`
	Ctime                int64     `protobuf:"varint,9,opt,name=ctime,proto3" json:"ctime,omitempty"`
	Ext                  *DynExt   `protobuf:"bytes,10,opt,name=ext,proto3" json:"ext,omitempty"`
	Origin               *DynBrief `protobuf:"bytes,11,opt,name=origin,proto3" json:"origin,omitempty"`
	Acl                  *DynAcl   `protobuf:"bytes,12,opt,name=acl,proto3" json:"acl,omitempty"`
	RType                int32     `protobuf:"varint,13,opt,name=r_type,json=rType,proto3" json:"r_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DynBrief) Reset()         { *m = DynBrief{} }
func (m *DynBrief) String() string { return proto.CompactTextString(m) }
func (*DynBrief) ProtoMessage()    {}
func (*DynBrief) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *DynBrief) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynBrief) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynBrief.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynBrief) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynBrief.Merge(m, src)
}
func (m *DynBrief) XXX_Size() int {
	return m.Size()
}
func (m *DynBrief) XXX_DiscardUnknown() {
	xxx_messageInfo_DynBrief.DiscardUnknown(m)
}

var xxx_messageInfo_DynBrief proto.InternalMessageInfo

func (m *DynBrief) GetDynId() int64 {
	if m != nil {
		return m.DynId
	}
	return 0
}

func (m *DynBrief) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DynBrief) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *DynBrief) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DynBrief) GetUidType() int64 {
	if m != nil {
		return m.UidType
	}
	return 0
}

func (m *DynBrief) GetRepostNum() int64 {
	if m != nil {
		return m.RepostNum
	}
	return 0
}

func (m *DynBrief) GetTips() string {
	if m != nil {
		return m.Tips
	}
	return ""
}

func (m *DynBrief) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

func (m *DynBrief) GetCtime() int64 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *DynBrief) GetExt() *DynExt {
	if m != nil {
		return m.Ext
	}
	return nil
}

func (m *DynBrief) GetOrigin() *DynBrief {
	if m != nil {
		return m.Origin
	}
	return nil
}

func (m *DynBrief) GetAcl() *DynAcl {
	if m != nil {
		return m.Acl
	}
	return nil
}

func (m *DynBrief) GetRType() int32 {
	if m != nil {
		return m.RType
	}
	return 0
}

type DynAcl struct {
	RepostBanned         bool     `protobuf:"varint,1,opt,name=repost_banned,json=repostBanned,proto3" json:"repost_banned,omitempty"`
	CommentBanned        bool     `protobuf:"varint,2,opt,name=comment_banned,json=commentBanned,proto3" json:"comment_banned,omitempty"`
	LimitDisplay         bool     `protobuf:"varint,3,opt,name=limit_display,json=limitDisplay,proto3" json:"limit_display,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DynAcl) Reset()         { *m = DynAcl{} }
func (m *DynAcl) String() string { return proto.CompactTextString(m) }
func (*DynAcl) ProtoMessage()    {}
func (*DynAcl) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *DynAcl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynAcl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynAcl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynAcl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynAcl.Merge(m, src)
}
func (m *DynAcl) XXX_Size() int {
	return m.Size()
}
func (m *DynAcl) XXX_DiscardUnknown() {
	xxx_messageInfo_DynAcl.DiscardUnknown(m)
}

var xxx_messageInfo_DynAcl proto.InternalMessageInfo

func (m *DynAcl) GetRepostBanned() bool {
	if m != nil {
		return m.RepostBanned
	}
	return false
}

func (m *DynAcl) GetCommentBanned() bool {
	if m != nil {
		return m.CommentBanned
	}
	return false
}

func (m *DynAcl) GetLimitDisplay() bool {
	if m != nil {
		return m.LimitDisplay
	}
	return false
}

type Attention struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	UidType              int32    `protobuf:"varint,2,opt,name=uid_type,json=uidType,proto3" json:"uid_type,omitempty"`
	IsSpecial            bool     `protobuf:"varint,3,opt,name=is_special,json=isSpecial,proto3" json:"is_special,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Attention) Reset()         { *m = Attention{} }
func (m *Attention) String() string { return proto.CompactTextString(m) }
func (*Attention) ProtoMessage()    {}
func (*Attention) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *Attention) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attention) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attention.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attention) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attention.Merge(m, src)
}
func (m *Attention) XXX_Size() int {
	return m.Size()
}
func (m *Attention) XXX_DiscardUnknown() {
	xxx_messageInfo_Attention.DiscardUnknown(m)
}

var xxx_messageInfo_Attention proto.InternalMessageInfo

func (m *Attention) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Attention) GetUidType() int32 {
	if m != nil {
		return m.UidType
	}
	return 0
}

func (m *Attention) GetIsSpecial() bool {
	if m != nil {
		return m.IsSpecial
	}
	return false
}

type AttentionInfo struct {
	AttentionList        []*Attention `protobuf:"bytes,1,rep,name=attention_list,json=attentionList,proto3" json:"attention_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AttentionInfo) Reset()         { *m = AttentionInfo{} }
func (m *AttentionInfo) String() string { return proto.CompactTextString(m) }
func (*AttentionInfo) ProtoMessage()    {}
func (*AttentionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *AttentionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttentionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttentionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttentionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttentionInfo.Merge(m, src)
}
func (m *AttentionInfo) XXX_Size() int {
	return m.Size()
}
func (m *AttentionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AttentionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AttentionInfo proto.InternalMessageInfo

func (m *AttentionInfo) GetAttentionList() []*Attention {
	if m != nil {
		return m.AttentionList
	}
	return nil
}

type Fold struct {
	DynIds               []int64  `protobuf:"varint,1,rep,packed,name=dyn_ids,json=dynIds,proto3" json:"dyn_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Fold) Reset()         { *m = Fold{} }
func (m *Fold) String() string { return proto.CompactTextString(m) }
func (*Fold) ProtoMessage()    {}
func (*Fold) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *Fold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fold.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fold.Merge(m, src)
}
func (m *Fold) XXX_Size() int {
	return m.Size()
}
func (m *Fold) XXX_DiscardUnknown() {
	xxx_messageInfo_Fold.DiscardUnknown(m)
}

var xxx_messageInfo_Fold proto.InternalMessageInfo

func (m *Fold) GetDynIds() []int64 {
	if m != nil {
		return m.DynIds
	}
	return nil
}

type FoldExt struct {
	FoldType             int64    `protobuf:"varint,1,opt,name=fold_type,json=foldType,proto3" json:"fold_type,omitempty"`
	Folds                []*Fold  `protobuf:"bytes,2,rep,name=folds,proto3" json:"folds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FoldExt) Reset()         { *m = FoldExt{} }
func (m *FoldExt) String() string { return proto.CompactTextString(m) }
func (*FoldExt) ProtoMessage()    {}
func (*FoldExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *FoldExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FoldExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FoldExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FoldExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FoldExt.Merge(m, src)
}
func (m *FoldExt) XXX_Size() int {
	return m.Size()
}
func (m *FoldExt) XXX_DiscardUnknown() {
	xxx_messageInfo_FoldExt.DiscardUnknown(m)
}

var xxx_messageInfo_FoldExt proto.InternalMessageInfo

func (m *FoldExt) GetFoldType() int64 {
	if m != nil {
		return m.FoldType
	}
	return 0
}

func (m *FoldExt) GetFolds() []*Fold {
	if m != nil {
		return m.Folds
	}
	return nil
}

type FoldDetail struct {
	Statement            string   `protobuf:"bytes,1,opt,name=statement,proto3" json:"statement,omitempty"`
	DynIds               []int64  `protobuf:"varint,2,rep,packed,name=dyn_ids,json=dynIds,proto3" json:"dyn_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FoldDetail) Reset()         { *m = FoldDetail{} }
func (m *FoldDetail) String() string { return proto.CompactTextString(m) }
func (*FoldDetail) ProtoMessage()    {}
func (*FoldDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *FoldDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FoldDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FoldDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FoldDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FoldDetail.Merge(m, src)
}
func (m *FoldDetail) XXX_Size() int {
	return m.Size()
}
func (m *FoldDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_FoldDetail.DiscardUnknown(m)
}

var xxx_messageInfo_FoldDetail proto.InternalMessageInfo

func (m *FoldDetail) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *FoldDetail) GetDynIds() []int64 {
	if m != nil {
		return m.DynIds
	}
	return nil
}

type FoldInfo struct {
	FoldMgr              []*FoldExt    `protobuf:"bytes,1,rep,name=fold_mgr,json=foldMgr,proto3" json:"fold_mgr,omitempty"`
	InplaceFold          []*FoldDetail `protobuf:"bytes,2,rep,name=inplace_fold,json=inplaceFold,proto3" json:"inplace_fold,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FoldInfo) Reset()         { *m = FoldInfo{} }
func (m *FoldInfo) String() string { return proto.CompactTextString(m) }
func (*FoldInfo) ProtoMessage()    {}
func (*FoldInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *FoldInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FoldInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FoldInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FoldInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FoldInfo.Merge(m, src)
}
func (m *FoldInfo) XXX_Size() int {
	return m.Size()
}
func (m *FoldInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FoldInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FoldInfo proto.InternalMessageInfo

func (m *FoldInfo) GetFoldMgr() []*FoldExt {
	if m != nil {
		return m.FoldMgr
	}
	return nil
}

func (m *FoldInfo) GetInplaceFold() []*FoldDetail {
	if m != nil {
		return m.InplaceFold
	}
	return nil
}

type VersionCtrlMeta struct {
	Build                string   `protobuf:"bytes,1,opt,name=build,proto3" json:"build,omitempty"`
	Platform             string   `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
	MobiApp              string   `protobuf:"bytes,3,opt,name=mobi_app,json=mobiApp,proto3" json:"mobi_app,omitempty"`
	Buvid                string   `protobuf:"bytes,4,opt,name=buvid,proto3" json:"buvid,omitempty"`
	Device               string   `protobuf:"bytes,5,opt,name=device,proto3" json:"device,omitempty"`
	Ip                   string   `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	From                 string   `protobuf:"bytes,7,opt,name=from,proto3" json:"from,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionCtrlMeta) Reset()         { *m = VersionCtrlMeta{} }
func (m *VersionCtrlMeta) String() string { return proto.CompactTextString(m) }
func (*VersionCtrlMeta) ProtoMessage()    {}
func (*VersionCtrlMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *VersionCtrlMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionCtrlMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionCtrlMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionCtrlMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionCtrlMeta.Merge(m, src)
}
func (m *VersionCtrlMeta) XXX_Size() int {
	return m.Size()
}
func (m *VersionCtrlMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionCtrlMeta.DiscardUnknown(m)
}

var xxx_messageInfo_VersionCtrlMeta proto.InternalMessageInfo

func (m *VersionCtrlMeta) GetBuild() string {
	if m != nil {
		return m.Build
	}
	return ""
}

func (m *VersionCtrlMeta) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *VersionCtrlMeta) GetMobiApp() string {
	if m != nil {
		return m.MobiApp
	}
	return ""
}

func (m *VersionCtrlMeta) GetBuvid() string {
	if m != nil {
		return m.Buvid
	}
	return ""
}

func (m *VersionCtrlMeta) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *VersionCtrlMeta) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *VersionCtrlMeta) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

type DynPostItem struct {
	DynId                int64    `protobuf:"varint,1,opt,name=dyn_id,json=dynId,proto3" json:"dyn_id,omitempty"`
	TopicNames           []string `protobuf:"bytes,2,rep,name=topic_names,json=topicNames,proto3" json:"topic_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DynPostItem) Reset()         { *m = DynPostItem{} }
func (m *DynPostItem) String() string { return proto.CompactTextString(m) }
func (*DynPostItem) ProtoMessage()    {}
func (*DynPostItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *DynPostItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynPostItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynPostItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynPostItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynPostItem.Merge(m, src)
}
func (m *DynPostItem) XXX_Size() int {
	return m.Size()
}
func (m *DynPostItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DynPostItem.DiscardUnknown(m)
}

var xxx_messageInfo_DynPostItem proto.InternalMessageInfo

func (m *DynPostItem) GetDynId() int64 {
	if m != nil {
		return m.DynId
	}
	return 0
}

func (m *DynPostItem) GetTopicNames() []string {
	if m != nil {
		return m.TopicNames
	}
	return nil
}

type LikeIcon struct {
	NewIconId            int64    `protobuf:"varint,1,opt,name=new_icon_id,json=newIconId,proto3" json:"new_icon_id,omitempty"`
	StartUrl             string   `protobuf:"bytes,2,opt,name=start_url,json=startUrl,proto3" json:"start_url,omitempty"`
	ActionUrl            string   `protobuf:"bytes,3,opt,name=action_url,json=actionUrl,proto3" json:"action_url,omitempty"`
	EndUrl               string   `protobuf:"bytes,4,opt,name=end_url,json=endUrl,proto3" json:"end_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LikeIcon) Reset()         { *m = LikeIcon{} }
func (m *LikeIcon) String() string { return proto.CompactTextString(m) }
func (*LikeIcon) ProtoMessage()    {}
func (*LikeIcon) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *LikeIcon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LikeIcon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LikeIcon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LikeIcon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LikeIcon.Merge(m, src)
}
func (m *LikeIcon) XXX_Size() int {
	return m.Size()
}
func (m *LikeIcon) XXX_DiscardUnknown() {
	xxx_messageInfo_LikeIcon.DiscardUnknown(m)
}

var xxx_messageInfo_LikeIcon proto.InternalMessageInfo

func (m *LikeIcon) GetNewIconId() int64 {
	if m != nil {
		return m.NewIconId
	}
	return 0
}

func (m *LikeIcon) GetStartUrl() string {
	if m != nil {
		return m.StartUrl
	}
	return ""
}

func (m *LikeIcon) GetActionUrl() string {
	if m != nil {
		return m.ActionUrl
	}
	return ""
}

func (m *LikeIcon) GetEndUrl() string {
	if m != nil {
		return m.EndUrl
	}
	return ""
}

type DynPostInfo struct {
	DynId                int64     `protobuf:"varint,1,opt,name=dyn_id,json=dynId,proto3" json:"dyn_id,omitempty"`
	LikeShowIcon         *LikeIcon `protobuf:"bytes,2,opt,name=like_show_icon,json=likeShowIcon,proto3" json:"like_show_icon,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DynPostInfo) Reset()         { *m = DynPostInfo{} }
func (m *DynPostInfo) String() string { return proto.CompactTextString(m) }
func (*DynPostInfo) ProtoMessage()    {}
func (*DynPostInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *DynPostInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynPostInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynPostInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynPostInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynPostInfo.Merge(m, src)
}
func (m *DynPostInfo) XXX_Size() int {
	return m.Size()
}
func (m *DynPostInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DynPostInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DynPostInfo proto.InternalMessageInfo

func (m *DynPostInfo) GetDynId() int64 {
	if m != nil {
		return m.DynId
	}
	return 0
}

func (m *DynPostInfo) GetLikeShowIcon() *LikeIcon {
	if m != nil {
		return m.LikeShowIcon
	}
	return nil
}

type FeedInfoCtrl struct {
	NeedLikeUsers          bool     `protobuf:"varint,1,opt,name=need_like_users,json=needLikeUsers,proto3" json:"need_like_users,omitempty"`
	NeedLimitFoldStatement bool     `protobuf:"varint,2,opt,name=need_limit_fold_statement,json=needLimitFoldStatement,proto3" json:"need_limit_fold_statement,omitempty"`
	NeedBottom             bool     `protobuf:"varint,3,opt,name=need_bottom,json=needBottom,proto3" json:"need_bottom,omitempty"`
	NeedTopicInfo          bool     `protobuf:"varint,4,opt,name=need_topic_info,json=needTopicInfo,proto3" json:"need_topic_info,omitempty"`
	NeedLikeIcon           bool     `protobuf:"varint,5,opt,name=need_like_icon,json=needLikeIcon,proto3" json:"need_like_icon,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *FeedInfoCtrl) Reset()         { *m = FeedInfoCtrl{} }
func (m *FeedInfoCtrl) String() string { return proto.CompactTextString(m) }
func (*FeedInfoCtrl) ProtoMessage()    {}
func (*FeedInfoCtrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *FeedInfoCtrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedInfoCtrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedInfoCtrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedInfoCtrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedInfoCtrl.Merge(m, src)
}
func (m *FeedInfoCtrl) XXX_Size() int {
	return m.Size()
}
func (m *FeedInfoCtrl) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedInfoCtrl.DiscardUnknown(m)
}

var xxx_messageInfo_FeedInfoCtrl proto.InternalMessageInfo

func (m *FeedInfoCtrl) GetNeedLikeUsers() bool {
	if m != nil {
		return m.NeedLikeUsers
	}
	return false
}

func (m *FeedInfoCtrl) GetNeedLimitFoldStatement() bool {
	if m != nil {
		return m.NeedLimitFoldStatement
	}
	return false
}

func (m *FeedInfoCtrl) GetNeedBottom() bool {
	if m != nil {
		return m.NeedBottom
	}
	return false
}

func (m *FeedInfoCtrl) GetNeedTopicInfo() bool {
	if m != nil {
		return m.NeedTopicInfo
	}
	return false
}

func (m *FeedInfoCtrl) GetNeedLikeIcon() bool {
	if m != nil {
		return m.NeedLikeIcon
	}
	return false
}

type PostInfoCtrl struct {
	NeedLikeIcon         bool     `protobuf:"varint,1,opt,name=need_like_icon,json=needLikeIcon,proto3" json:"need_like_icon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PostInfoCtrl) Reset()         { *m = PostInfoCtrl{} }
func (m *PostInfoCtrl) String() string { return proto.CompactTextString(m) }
func (*PostInfoCtrl) ProtoMessage()    {}
func (*PostInfoCtrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *PostInfoCtrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostInfoCtrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostInfoCtrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostInfoCtrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostInfoCtrl.Merge(m, src)
}
func (m *PostInfoCtrl) XXX_Size() int {
	return m.Size()
}
func (m *PostInfoCtrl) XXX_DiscardUnknown() {
	xxx_messageInfo_PostInfoCtrl.DiscardUnknown(m)
}

var xxx_messageInfo_PostInfoCtrl proto.InternalMessageInfo

func (m *PostInfoCtrl) GetNeedLikeIcon() bool {
	if m != nil {
		return m.NeedLikeIcon
	}
	return false
}

func init() {
	proto.RegisterEnum("dynamic.service.feed.svr.v1.TabType", TabType_name, TabType_value)
	proto.RegisterEnum("dynamic.service.feed.svr.v1.DynBottomTypes", DynBottomTypes_name, DynBottomTypes_value)
	proto.RegisterEnum("dynamic.service.feed.svr.v1.DynUidType", DynUidType_name, DynUidType_value)
	proto.RegisterType((*OffsetInfo)(nil), "dynamic.service.feed.svr.v1.OffsetInfo")
	proto.RegisterType((*UpdateNumReq)(nil), "dynamic.service.feed.svr.v1.UpdateNumReq")
	proto.RegisterType((*UpdateNumResp)(nil), "dynamic.service.feed.svr.v1.UpdateNumResp")
	proto.RegisterType((*VideoNewReq)(nil), "dynamic.service.feed.svr.v1.VideoNewReq")
	proto.RegisterType((*VideoNewRsp)(nil), "dynamic.service.feed.svr.v1.VideoNewRsp")
	proto.RegisterType((*VideoHistoryReq)(nil), "dynamic.service.feed.svr.v1.VideoHistoryReq")
	proto.RegisterType((*VideoHistoryRsp)(nil), "dynamic.service.feed.svr.v1.VideoHistoryRsp")
	proto.RegisterType((*DynBriefsReq)(nil), "dynamic.service.feed.svr.v1.DynBriefsReq")
	proto.RegisterType((*DynBriefsRsp)(nil), "dynamic.service.feed.svr.v1.DynBriefsRsp")
	proto.RegisterType((*VideoPersonalReq)(nil), "dynamic.service.feed.svr.v1.VideoPersonalReq")
	proto.RegisterType((*VideoPersonalRsp)(nil), "dynamic.service.feed.svr.v1.VideoPersonalRsp")
	proto.RegisterType((*DynPostInfoReq)(nil), "dynamic.service.feed.svr.v1.DynPostInfoReq")
	proto.RegisterType((*DynPostInfoRsp)(nil), "dynamic.service.feed.svr.v1.DynPostInfoRsp")
	proto.RegisterMapType((map[int64]*DynPostInfo)(nil), "dynamic.service.feed.svr.v1.DynPostInfoRsp.DynsEntry")
	proto.RegisterType((*TopicInfo)(nil), "dynamic.service.feed.svr.v1.TopicInfo")
	proto.RegisterType((*DynExt)(nil), "dynamic.service.feed.svr.v1.DynExt")
	proto.RegisterType((*BottomDetail)(nil), "dynamic.service.feed.svr.v1.BottomDetail")
	proto.RegisterType((*BottomBusiness)(nil), "dynamic.service.feed.svr.v1.BottomBusiness")
	proto.RegisterType((*ExtBottom)(nil), "dynamic.service.feed.svr.v1.ExtBottom")
	proto.RegisterType((*ExtTopic)(nil), "dynamic.service.feed.svr.v1.ExtTopic")
	proto.RegisterType((*ExtLottery)(nil), "dynamic.service.feed.svr.v1.ExtLottery")
	proto.RegisterType((*ExtVote)(nil), "dynamic.service.feed.svr.v1.ExtVote")
	proto.RegisterType((*ExtLbs)(nil), "dynamic.service.feed.svr.v1.ExtLbs")
	proto.RegisterType((*ExtHighLight)(nil), "dynamic.service.feed.svr.v1.ExtHighLight")
	proto.RegisterType((*ExtOpenGoods)(nil), "dynamic.service.feed.svr.v1.ExtOpenGoods")
	proto.RegisterType((*DynDispute)(nil), "dynamic.service.feed.svr.v1.DynDispute")
	proto.RegisterType((*LbsLoc)(nil), "dynamic.service.feed.svr.v1.LbsLoc")
	proto.RegisterType((*ExtFlagCfg)(nil), "dynamic.service.feed.svr.v1.ExtFlagCfg")
	proto.RegisterType((*FoldStatement)(nil), "dynamic.service.feed.svr.v1.FoldStatement")
	proto.RegisterType((*DynBrief)(nil), "dynamic.service.feed.svr.v1.DynBrief")
	proto.RegisterType((*DynAcl)(nil), "dynamic.service.feed.svr.v1.DynAcl")
	proto.RegisterType((*Attention)(nil), "dynamic.service.feed.svr.v1.Attention")
	proto.RegisterType((*AttentionInfo)(nil), "dynamic.service.feed.svr.v1.AttentionInfo")
	proto.RegisterType((*Fold)(nil), "dynamic.service.feed.svr.v1.Fold")
	proto.RegisterType((*FoldExt)(nil), "dynamic.service.feed.svr.v1.FoldExt")
	proto.RegisterType((*FoldDetail)(nil), "dynamic.service.feed.svr.v1.FoldDetail")
	proto.RegisterType((*FoldInfo)(nil), "dynamic.service.feed.svr.v1.FoldInfo")
	proto.RegisterType((*VersionCtrlMeta)(nil), "dynamic.service.feed.svr.v1.VersionCtrlMeta")
	proto.RegisterType((*DynPostItem)(nil), "dynamic.service.feed.svr.v1.DynPostItem")
	proto.RegisterType((*LikeIcon)(nil), "dynamic.service.feed.svr.v1.LikeIcon")
	proto.RegisterType((*DynPostInfo)(nil), "dynamic.service.feed.svr.v1.DynPostInfo")
	proto.RegisterType((*FeedInfoCtrl)(nil), "dynamic.service.feed.svr.v1.FeedInfoCtrl")
	proto.RegisterType((*PostInfoCtrl)(nil), "dynamic.service.feed.svr.v1.PostInfoCtrl")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 2670 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x39, 0x4b, 0x73, 0x1b, 0xc7,
	0xd1, 0x5e, 0x00, 0x04, 0xb0, 0x0d, 0x80, 0x82, 0xc7, 0xb6, 0x04, 0xd1, 0x9f, 0x25, 0x7a, 0xe5,
	0x07, 0x2d, 0xfb, 0x63, 0x55, 0x9c, 0xd8, 0xb1, 0xf3, 0x70, 0x0a, 0x24, 0x20, 0x09, 0x31, 0x45,
	0x32, 0x4b, 0x50, 0x29, 0xe7, 0xe0, 0xad, 0xc5, 0xee, 0x00, 0x18, 0x69, 0x5f, 0xde, 0x19, 0x50,
	0x44, 0x72, 0xc8, 0x3f, 0xc8, 0x2d, 0xc9, 0x21, 0xb7, 0x54, 0x2a, 0xe7, 0xfc, 0x82, 0x54, 0x8e,
	0x39, 0xa5, 0x52, 0x39, 0xe5, 0xe8, 0x72, 0x55, 0x7e, 0x40, 0x8e, 0xc9, 0x25, 0xa9, 0x9e, 0x99,
	0x5d, 0x2c, 0x68, 0x8a, 0x84, 0x64, 0x1f, 0x73, 0x9b, 0xee, 0xed, 0x9e, 0xe9, 0x77, 0xf7, 0xcc,
	0x82, 0xe9, 0x26, 0x6c, 0x3b, 0x49, 0x63, 0x11, 0x93, 0x97, 0xfd, 0x79, 0xe4, 0x86, 0xcc, 0xdb,
	0xe6, 0x34, 0x3d, 0x61, 0x1e, 0xdd, 0x1e, 0x53, 0xea, 0x6f, 0xf3, 0x93, 0x74, 0xfb, 0xe4, 0x1b,
	0xd6, 0x11, 0xc0, 0xc1, 0x78, 0xcc, 0xa9, 0x18, 0x44, 0xe3, 0x98, 0xb4, 0xa1, 0x2c, 0xdc, 0x51,
	0xc7, 0xd8, 0x34, 0xb6, 0x5a, 0x36, 0x2e, 0xc9, 0xcb, 0x60, 0x8a, 0x79, 0x42, 0x9d, 0x80, 0x71,
	0xd1, 0x29, 0x6d, 0x1a, 0x5b, 0xa6, 0x5d, 0x47, 0xc4, 0x1e, 0xe3, 0x82, 0x5c, 0x85, 0x6a, 0x2c,
	0x99, 0x3b, 0x65, 0xf9, 0x45, 0x43, 0x96, 0x07, 0xcd, 0xe3, 0xc4, 0x77, 0x05, 0xdd, 0x9f, 0x85,
	0x36, 0xfd, 0x0c, 0xb7, 0x9d, 0x31, 0x5f, 0x6e, 0x5b, 0xb1, 0x71, 0x49, 0xba, 0x50, 0x53, 0xb4,
	0xbc, 0x53, 0xda, 0x2c, 0x6f, 0x35, 0xde, 0x7d, 0x73, 0xfb, 0x02, 0x29, 0xb7, 0x17, 0x22, 0xda,
	0x19, 0x9f, 0xf5, 0x10, 0x5a, 0x85, 0x43, 0x78, 0x42, 0xae, 0x43, 0x3d, 0xa5, 0xbe, 0x83, 0xd2,
	0xc9, 0xa3, 0x4c, 0xbb, 0x96, 0x52, 0x7f, 0x38, 0x4f, 0x28, 0x79, 0x05, 0x60, 0x26, 0x69, 0x9d,
	0x68, 0x16, 0x4a, 0x35, 0x2a, 0xb6, 0x39, 0xcb, 0xb8, 0xc9, 0x4d, 0x68, 0xf8, 0x74, 0xec, 0xce,
	0x02, 0xe1, 0xa0, 0xfa, 0x4a, 0x19, 0xd0, 0xa8, 0xa1, 0x3b, 0xb2, 0xfe, 0x5d, 0x82, 0xc6, 0x03,
	0xe6, 0xd3, 0x78, 0x9f, 0x3e, 0x3e, 0xa3, 0x50, 0x59, 0x29, 0xf4, 0x26, 0x5c, 0xd1, 0x27, 0x8c,
	0x5c, 0x4e, 0x03, 0x16, 0x51, 0x6d, 0xad, 0x75, 0x85, 0xde, 0xd1, 0x58, 0x24, 0x74, 0x39, 0x67,
	0x5c, 0x2c, 0x08, 0xd5, 0x79, 0xeb, 0x0a, 0x9d, 0x13, 0x2e, 0x59, 0xbe, 0xb2, 0x59, 0x5e, 0xb2,
	0xfc, 0x01, 0x34, 0x4f, 0x68, 0xca, 0x59, 0x1c, 0x39, 0x9e, 0x48, 0x83, 0xce, 0xda, 0xa6, 0xb1,
	0xd5, 0x78, 0xf7, 0x9d, 0x0b, 0x8d, 0xf8, 0x40, 0x31, 0xec, 0x8a, 0x34, 0xb8, 0x4f, 0x85, 0x6b,
	0x37, 0x4e, 0x16, 0x08, 0x72, 0x07, 0x4c, 0x16, 0x8d, 0x63, 0xb5, 0x5b, 0x55, 0xee, 0xf6, 0xd6,
	0x85, 0xbb, 0xdd, 0xa1, 0xd4, 0x47, 0x87, 0x20, 0xb7, 0x5d, 0x67, 0x7a, 0x45, 0x7e, 0x04, 0xeb,
	0xae, 0x10, 0x34, 0x12, 0x28, 0x1a, 0x62, 0x3b, 0x35, 0xb9, 0xd9, 0xed, 0x0b, 0x37, 0xeb, 0x66,
	0x2c, 0xd2, 0xc5, 0x2d, 0xb7, 0x08, 0x5a, 0xbf, 0x2a, 0x1a, 0x9f, 0x27, 0x67, 0x9c, 0xa9, 0x7c,
	0x50, 0x70, 0xe6, 0xeb, 0xb0, 0x3e, 0x65, 0x5c, 0xc4, 0xe9, 0xdc, 0xd1, 0xc1, 0xa9, 0x1c, 0xd1,
	0xd2, 0x58, 0x15, 0x4b, 0xe7, 0x39, 0xac, 0x7c, 0xae, 0xc3, 0xae, 0x43, 0x7d, 0xea, 0x72, 0x27,
	0x8c, 0x53, 0xda, 0xa9, 0x6c, 0x1a, 0x5b, 0x75, 0xbb, 0x36, 0x75, 0xf9, 0xfd, 0x38, 0xa5, 0xe4,
	0x43, 0xa8, 0xf8, 0xf3, 0x88, 0x77, 0xd6, 0x64, 0x08, 0xbf, 0x7e, 0xa1, 0x8a, 0xbd, 0x79, 0xb4,
	0x93, 0x32, 0x3a, 0xb6, 0x25, 0x0b, 0xd9, 0x01, 0x73, 0x1c, 0x07, 0xbe, 0x32, 0x91, 0xb2, 0xf7,
	0xc5, 0xfc, 0x77, 0xe2, 0x40, 0xda, 0xdb, 0xae, 0x8f, 0xf5, 0xca, 0xfa, 0x7b, 0x09, 0xae, 0x48,
	0xc3, 0xdc, 0x53, 0x9a, 0x9d, 0x1f, 0x99, 0x8b, 0x24, 0x2d, 0x15, 0x93, 0x94, 0x10, 0xa8, 0x24,
	0xee, 0x44, 0x69, 0x5d, 0xb6, 0xe5, 0xfa, 0x7f, 0x31, 0x97, 0xc5, 0xdc, 0xdf, 0x8c, 0x33, 0xa6,
	0xe5, 0xc9, 0x39, 0x81, 0x65, 0x9c, 0x17, 0x58, 0xc5, 0x78, 0x29, 0x9d, 0x1f, 0x2f, 0xe5, 0xaf,
	0x18, 0x2f, 0x95, 0x67, 0x8b, 0x97, 0x3f, 0x19, 0xd0, 0xcc, 0xb6, 0xe5, 0x18, 0x2c, 0xd7, 0xa0,
	0xe6, 0xcf, 0x23, 0x87, 0xf9, 0xbc, 0x63, 0x6c, 0x96, 0xb7, 0xca, 0x76, 0xd5, 0x9f, 0x47, 0x03,
	0x9f, 0x7f, 0xc9, 0xd5, 0xa5, 0xaf, 0xd5, 0xd5, 0xe5, 0x67, 0x76, 0xb5, 0x35, 0x28, 0x6a, 0xc0,
	0x93, 0xdc, 0xa2, 0xc6, 0x53, 0x5b, 0xd4, 0x3a, 0x81, 0xb6, 0xf4, 0xf0, 0x21, 0x4d, 0x79, 0x1c,
	0xb9, 0xc1, 0xf9, 0xd9, 0x83, 0xde, 0x8c, 0xb9, 0x70, 0x10, 0x5d, 0x92, 0xe8, 0x1a, 0xc2, 0xc7,
	0xcc, 0xc7, 0x3a, 0xc4, 0xb8, 0x93, 0xa4, 0x34, 0x88, 0x5d, 0x5f, 0x2a, 0x55, 0xb7, 0x4d, 0xc6,
	0x0f, 0x15, 0xa2, 0x90, 0x77, 0x95, 0xa5, 0xe6, 0xf8, 0x0f, 0xe3, 0xec, 0xc1, 0xaa, 0x77, 0xe5,
	0x41, 0x63, 0x2c, 0x07, 0xcd, 0x93, 0xf2, 0xf7, 0x26, 0x34, 0x52, 0xea, 0xfa, 0xce, 0x52, 0x07,
	0x06, 0x44, 0xe9, 0x40, 0xcc, 0x6c, 0x53, 0xf9, 0x8a, 0xd1, 0xb6, 0xf6, 0x6c, 0xd1, 0xf6, 0x2f,
	0x03, 0xd6, 0x7b, 0xf3, 0xe8, 0x30, 0xe6, 0xaa, 0x71, 0x9f, 0x3b, 0x07, 0x7c, 0x4f, 0xcb, 0xa8,
	0x86, 0x80, 0xad, 0xcb, 0x64, 0x94, 0x9b, 0x09, 0x1a, 0x6a, 0x31, 0xcf, 0x86, 0x69, 0xf9, 0x6b,
	0x0d, 0xd3, 0xca, 0x0a, 0x61, 0x9a, 0x69, 0x77, 0x26, 0x4c, 0xff, 0x78, 0x46, 0x77, 0x9e, 0x90,
	0xc1, 0x52, 0xa4, 0xbe, 0xb7, 0x92, 0xa6, 0x8a, 0x15, 0x41, 0xde, 0x8f, 0x44, 0x3a, 0x57, 0x6a,
	0x6f, 0xb8, 0x60, 0xe6, 0x28, 0xb4, 0xe9, 0x23, 0x3a, 0xcf, 0x42, 0xf6, 0x11, 0x9d, 0x93, 0x8f,
	0x60, 0xed, 0xc4, 0x0d, 0x66, 0x54, 0x67, 0xed, 0xd6, 0xca, 0x47, 0x29, 0xb6, 0xef, 0x94, 0x3e,
	0x30, 0xac, 0xbf, 0x18, 0x60, 0x0e, 0xe3, 0x84, 0x79, 0x72, 0x2c, 0xbc, 0x0e, 0x75, 0x81, 0x80,
	0x93, 0xe7, 0x46, 0x4d, 0xc2, 0x03, 0x99, 0x04, 0xea, 0x53, 0xe4, 0x86, 0xd9, 0xc8, 0x63, 0x4a,
	0xcc, 0xbe, 0x1b, 0x52, 0x6c, 0x32, 0x5c, 0xb8, 0x2a, 0x3a, 0xd7, 0x6c, 0xb9, 0x26, 0x6f, 0xc0,
	0x95, 0x38, 0x65, 0x13, 0x16, 0x39, 0xf9, 0xa6, 0x15, 0xb9, 0x69, 0x4b, 0xa1, 0x87, 0x7a, 0xeb,
	0xdb, 0xf0, 0xfc, 0x12, 0x9d, 0x3c, 0x61, 0x4d, 0x9e, 0x70, 0xa5, 0x40, 0x29, 0xcf, 0xb9, 0x09,
	0x8d, 0x8c, 0x16, 0xc7, 0xbf, 0xaa, 0x3c, 0x0e, 0x34, 0xd5, 0x3c, 0xa1, 0xd6, 0x2f, 0xd7, 0xa0,
	0xda, 0x9b, 0x47, 0xfd, 0x53, 0x41, 0xbe, 0x0b, 0x95, 0x20, 0x16, 0xaa, 0x7a, 0x5f, 0x36, 0x78,
	0xf6, 0x4f, 0xc5, 0x5e, 0x2c, 0x04, 0x45, 0xdb, 0x23, 0x13, 0xf9, 0x00, 0x2a, 0x27, 0xb1, 0xc8,
	0x6c, 0xfb, 0xda, 0x65, 0xcc, 0x0f, 0x62, 0x41, 0x6d, 0xc9, 0x41, 0xde, 0x83, 0x72, 0x30, 0xe2,
	0x3a, 0x46, 0x6f, 0x5d, 0x7a, 0xea, 0x88, 0xdb, 0x48, 0x4f, 0xee, 0x01, 0x4c, 0xd9, 0x64, 0xea,
	0x04, 0x6c, 0x32, 0x15, 0x3a, 0x97, 0xdf, 0xba, 0x8c, 0xfb, 0x1e, 0x9b, 0x4c, 0xf7, 0x90, 0xc1,
	0x36, 0xa7, 0xd9, 0x92, 0xf4, 0x32, 0x57, 0xad, 0x9c, 0xd5, 0xfd, 0x53, 0x21, 0x4d, 0xac, 0x3d,
	0x2a, 0x63, 0xe1, 0x1e, 0x40, 0x9c, 0xd0, 0xc8, 0x99, 0xc4, 0xb1, 0xcf, 0x57, 0xea, 0xda, 0xfd,
	0x53, 0x71, 0x90, 0xd0, 0xe8, 0x2e, 0x32, 0xd8, 0x66, 0x9c, 0x2d, 0x31, 0x74, 0x68, 0x18, 0x3f,
	0x64, 0xca, 0x65, 0x35, 0xe9, 0x32, 0x53, 0x62, 0xe4, 0xcc, 0xde, 0x85, 0x9a, 0xcf, 0x78, 0x32,
	0x13, 0xb4, 0x53, 0x5f, 0xc1, 0x53, 0xbd, 0x79, 0xd4, 0x53, 0xe4, 0x76, 0xc6, 0x47, 0x3e, 0x82,
	0xea, 0x28, 0x16, 0x22, 0x0e, 0x3b, 0xa6, 0xdc, 0xe1, 0x8d, 0xcb, 0xe4, 0xdc, 0x91, 0xd4, 0xb6,
	0xe6, 0x22, 0x3b, 0x50, 0x1f, 0x07, 0xee, 0xc4, 0xf1, 0xc6, 0x93, 0x0e, 0xac, 0x16, 0x2d, 0x77,
	0x02, 0x77, 0xb2, 0x3b, 0x9e, 0xd8, 0xb5, 0xb1, 0x5a, 0xa0, 0x96, 0x01, 0x7b, 0x44, 0x9d, 0x19,
	0xa7, 0x29, 0xef, 0x34, 0x64, 0x9b, 0x35, 0x11, 0x73, 0x8c, 0x08, 0xeb, 0xb7, 0x06, 0x34, 0xd5,
	0xa9, 0x3d, 0x2a, 0x5c, 0x16, 0x60, 0xc6, 0xe4, 0x37, 0x98, 0xb2, 0x2d, 0xd7, 0x98, 0xe3, 0x69,
	0xde, 0x7f, 0x70, 0x49, 0x3a, 0x50, 0xf3, 0xe2, 0x08, 0x27, 0x16, 0x5d, 0xf8, 0x33, 0x10, 0x73,
	0xf5, 0xe1, 0x2c, 0x4c, 0x9c, 0x99, 0xae, 0x60, 0xa6, 0x5d, 0x43, 0xf8, 0x38, 0x0d, 0xb0, 0x93,
	0x60, 0x02, 0xce, 0xb8, 0x74, 0x7e, 0xd9, 0xd6, 0x10, 0x26, 0x8f, 0x52, 0x78, 0x29, 0x79, 0x14,
	0x4a, 0x26, 0xcf, 0xfb, 0xb0, 0xae, 0x64, 0xdc, 0x99, 0x71, 0x16, 0x51, 0xce, 0x33, 0x89, 0x8c,
	0x85, 0x44, 0x99, 0xdc, 0xa5, 0x85, 0xdc, 0xd6, 0xef, 0x0d, 0x30, 0x73, 0xab, 0x92, 0xbb, 0x50,
	0x1f, 0x69, 0x7e, 0x5d, 0x05, 0xdf, 0xbe, 0xd0, 0x9a, 0xcb, 0x47, 0xda, 0x39, 0x33, 0x39, 0x84,
	0x75, 0x2d, 0xaf, 0x2f, 0x6d, 0x96, 0xb5, 0x8f, 0xb7, 0x56, 0xd8, 0x4e, 0x59, 0xd9, 0x6e, 0x8d,
	0x0a, 0x10, 0xb7, 0x7e, 0x06, 0xf5, 0x2c, 0xd6, 0xb1, 0x3c, 0x31, 0xee, 0xb8, 0x42, 0xb8, 0xde,
	0x54, 0x55, 0x1e, 0xdd, 0x91, 0x5b, 0x8c, 0x77, 0x25, 0x56, 0xd1, 0xdd, 0x85, 0xc6, 0x22, 0x9d,
	0x32, 0x11, 0x2e, 0x8e, 0xb0, 0xbc, 0xa2, 0xda, 0x90, 0x27, 0x14, 0xb7, 0x7c, 0x80, 0x45, 0x99,
	0x91, 0xf1, 0xa2, 0x96, 0x8b, 0x6a, 0x6b, 0x6a, 0xcc, 0xc0, 0x27, 0x2f, 0xc2, 0x9a, 0x60, 0x22,
	0xc8, 0x4a, 0xad, 0x02, 0xc8, 0xab, 0xd0, 0xcc, 0x98, 0x04, 0x0b, 0xb3, 0x99, 0xbe, 0xa1, 0x71,
	0x43, 0x16, 0x52, 0xeb, 0x03, 0xa8, 0xe9, 0x7a, 0x84, 0x63, 0x1f, 0x56, 0xa4, 0xc5, 0xfe, 0x55,
	0x04, 0x9f, 0xb4, 0xb9, 0xf5, 0x1f, 0x03, 0xaa, 0xaa, 0x22, 0x61, 0xd8, 0xb9, 0xbe, 0x9f, 0x2a,
	0x0f, 0xca, 0xd8, 0xd2, 0x20, 0xd9, 0x80, 0xba, 0xcf, 0xb8, 0x70, 0x23, 0x2f, 0x0b, 0x81, 0x1c,
	0xce, 0x43, 0xa3, 0xbc, 0x1c, 0xd2, 0x49, 0xcc, 0x74, 0x84, 0xe2, 0x92, 0xfc, 0x00, 0xea, 0x41,
	0xec, 0xb9, 0x38, 0x82, 0xeb, 0xe2, 0x74, 0x71, 0x91, 0xdc, 0x1b, 0xf1, 0xbd, 0xd8, 0xb3, 0x73,
	0x26, 0xb4, 0x1c, 0x9f, 0xc6, 0x8f, 0x1d, 0xa5, 0x42, 0x55, 0xb5, 0x22, 0xc4, 0x0c, 0xa5, 0x8d,
	0x72, 0xe5, 0x6a, 0x45, 0xcb, 0xdd, 0x82, 0x96, 0x64, 0xca, 0x85, 0xaf, 0xcb, 0xaf, 0x4d, 0x44,
	0xf6, 0x34, 0xce, 0xfa, 0x9d, 0x01, 0xcd, 0x62, 0x55, 0x45, 0x6d, 0x73, 0x59, 0x95, 0x09, 0x17,
	0x62, 0x5c, 0x85, 0x6a, 0x40, 0xa3, 0x89, 0x98, 0x6a, 0x3b, 0x68, 0x08, 0xad, 0xe0, 0xbb, 0xc2,
	0xd5, 0xf9, 0x2a, 0xd7, 0xb9, 0x65, 0x2a, 0x05, 0xcb, 0x5c, 0x83, 0x9a, 0xbc, 0x83, 0x31, 0x5f,
	0x37, 0xbb, 0x2a, 0x82, 0x03, 0x1f, 0xd3, 0x34, 0x49, 0xe9, 0x98, 0x9d, 0x3a, 0xcc, 0x8b, 0x23,
	0xad, 0x20, 0x28, 0xd4, 0xc0, 0x8b, 0x23, 0xeb, 0x17, 0x4a, 0xcc, 0xbc, 0xd8, 0xa2, 0xbb, 0x98,
	0xa0, 0x21, 0x1f, 0xf8, 0x99, 0xbb, 0x34, 0x28, 0x4b, 0xc1, 0x34, 0x4e, 0x06, 0x59, 0x51, 0xd1,
	0xd0, 0xb9, 0xae, 0xba, 0x81, 0x15, 0x2c, 0x7a, 0x84, 0x73, 0xd7, 0xc0, 0xd7, 0x1e, 0x2b, 0x60,
	0xf0, 0x14, 0x3d, 0x43, 0x69, 0x81, 0x33, 0xd0, 0xf2, 0x00, 0x16, 0x65, 0xb9, 0x58, 0xb3, 0x8c,
	0x27, 0xd7, 0xac, 0xd2, 0x72, 0xcd, 0xda, 0x84, 0x86, 0x4f, 0xb9, 0x97, 0xb2, 0x44, 0x1a, 0x5b,
	0x19, 0xaf, 0x88, 0xb2, 0xde, 0x81, 0xaa, 0x0a, 0x05, 0x8c, 0xa9, 0xc0, 0x55, 0x9b, 0x1b, 0x36,
	0x2e, 0x25, 0x26, 0x9a, 0xc8, 0x3d, 0x11, 0x13, 0x4d, 0xac, 0x5b, 0x32, 0xd9, 0x74, 0x95, 0x26,
	0x2f, 0x41, 0x15, 0x47, 0xf8, 0x49, 0x96, 0xe2, 0x6b, 0x8c, 0x1f, 0x4e, 0x3c, 0xeb, 0x21, 0xb4,
	0x70, 0xa0, 0x3d, 0x12, 0xae, 0xa0, 0x21, 0x0a, 0xf8, 0x7f, 0x60, 0xf2, 0x0c, 0xd0, 0xc2, 0x2f,
	0x10, 0x05, 0xf1, 0xd9, 0xb2, 0xf8, 0x6c, 0x05, 0xf1, 0x7f, 0x53, 0x86, 0x7a, 0x36, 0x7d, 0xa3,
	0x3c, 0xea, 0x42, 0xa6, 0xa3, 0x6a, 0x4d, 0xde, 0xc7, 0xce, 0xab, 0xad, 0x59, 0x05, 0x2e, 0x2f,
	0x2a, 0xb0, 0x9e, 0xae, 0x2b, 0x4b, 0x97, 0x97, 0x19, 0xd3, 0x2f, 0x62, 0xaa, 0xe4, 0xd7, 0x66,
	0x2c, 0x7f, 0x11, 0x4b, 0x69, 0x82, 0x37, 0x9b, 0x68, 0x16, 0xca, 0x58, 0x2a, 0xdb, 0xa6, 0xc2,
	0xec, 0xcf, 0x42, 0x79, 0x22, 0x4b, 0xb8, 0xce, 0x15, 0xb9, 0x96, 0x7e, 0x66, 0x9c, 0x8d, 0x02,
	0x95, 0x24, 0x75, 0x3b, 0x03, 0x31, 0xb5, 0x3c, 0x59, 0x77, 0x4c, 0x25, 0xb5, 0x04, 0x70, 0xe0,
	0xa1, 0xa7, 0x42, 0x37, 0xce, 0x5b, 0x97, 0x35, 0xef, 0xfe, 0xa9, 0xb0, 0x91, 0x9e, 0x7c, 0x1f,
	0xaa, 0x6a, 0x6e, 0xeb, 0x34, 0x56, 0x18, 0x51, 0xf2, 0x8b, 0x8b, 0x66, 0xc2, 0x53, 0x5d, 0x2f,
	0xe8, 0x34, 0x57, 0x3b, 0xb5, 0xeb, 0x05, 0x36, 0xd2, 0xa3, 0xe5, 0x53, 0x65, 0xa8, 0x96, 0x6c,
	0x7f, 0x6b, 0xa9, 0xec, 0x7c, 0x73, 0x39, 0x35, 0x76, 0xbd, 0x00, 0x0b, 0x85, 0x36, 0xd8, 0xc8,
	0x8d, 0x22, 0xea, 0xeb, 0x88, 0x69, 0x2a, 0xe4, 0x8e, 0xc4, 0x91, 0xd7, 0x61, 0xdd, 0x8b, 0x43,
	0x0c, 0x8a, 0x8c, 0x4a, 0xbd, 0x00, 0xb4, 0x34, 0x56, 0x93, 0xdd, 0x82, 0x56, 0xc0, 0x42, 0x26,
	0xb0, 0xea, 0x24, 0x81, 0x3b, 0xd7, 0x97, 0xc7, 0xa6, 0x44, 0xf6, 0x14, 0xce, 0xfa, 0x31, 0x98,
	0xf9, 0x13, 0xc5, 0xf9, 0x17, 0xd3, 0xdc, 0xb7, 0x25, 0x29, 0x72, 0xd1, 0xb7, 0x8c, 0x3b, 0x3c,
	0xa1, 0x1e, 0x73, 0x83, 0xc5, 0xc5, 0xf4, 0x48, 0x21, 0xac, 0x4f, 0xa1, 0xb5, 0xf4, 0xf6, 0x41,
	0xee, 0x17, 0xdf, 0x4f, 0xe4, 0xd3, 0x8f, 0xb1, 0x42, 0x33, 0xcb, 0xf7, 0x28, 0xbc, 0x9d, 0xec,
	0x31, 0x2e, 0xac, 0x9b, 0x50, 0xc1, 0xec, 0x79, 0xe2, 0xeb, 0x82, 0xe5, 0x40, 0x0d, 0x09, 0x70,
	0x16, 0x7f, 0x59, 0x5f, 0x34, 0x0b, 0x23, 0x8f, 0xbc, 0x41, 0x4a, 0x3d, 0xbe, 0x0d, 0x6b, 0xb8,
	0xce, 0x7a, 0xeb, 0xab, 0x97, 0xde, 0x40, 0x6d, 0x45, 0x6f, 0xed, 0x02, 0x20, 0xa8, 0x27, 0xaa,
	0x8b, 0x93, 0xb7, 0x20, 0x65, 0x69, 0x49, 0xca, 0x5f, 0x1b, 0x50, 0xcf, 0xae, 0xb5, 0xd8, 0x9c,
	0xa4, 0x9c, 0xe1, 0x24, 0xd5, 0xc6, 0x79, 0xed, 0x52, 0x69, 0x30, 0xa2, 0x6b, 0xc8, 0x75, 0x7f,
	0x92, 0x92, 0x1f, 0x42, 0x93, 0x45, 0x49, 0xe0, 0x7a, 0xd4, 0x41, 0xd4, 0x4a, 0xaf, 0xde, 0x0b,
	0x1d, 0xec, 0x86, 0x66, 0x46, 0x94, 0xf5, 0x07, 0x03, 0xae, 0x9c, 0xb9, 0xc6, 0x62, 0x0a, 0x8e,
	0x66, 0x2c, 0xc8, 0x0a, 0xbd, 0x02, 0xb0, 0x4f, 0x25, 0x81, 0x2b, 0xc6, 0x71, 0x1a, 0x66, 0x8f,
	0xf7, 0x19, 0x8c, 0x01, 0x14, 0xc6, 0x23, 0xe6, 0xb8, 0x49, 0x92, 0xcd, 0x90, 0x08, 0x77, 0x93,
	0x44, 0x6d, 0x76, 0xc2, 0xb2, 0x62, 0xaf, 0x00, 0xec, 0x19, 0x3e, 0x45, 0x21, 0xb3, 0xbe, 0xa4,
	0x20, 0xb2, 0x0e, 0x25, 0x96, 0xe8, 0x76, 0x54, 0x62, 0x09, 0xd6, 0x8e, 0x71, 0x1a, 0x87, 0x59,
	0xed, 0xc0, 0xb5, 0xd5, 0x87, 0x46, 0xe1, 0xfa, 0xfe, 0xa4, 0x3a, 0x77, 0x33, 0x1b, 0xa9, 0xf0,
	0xaa, 0xa7, 0xfc, 0x61, 0xea, 0x51, 0x09, 0x6f, 0x79, 0xdc, 0xfa, 0x39, 0xd4, 0xf7, 0xd8, 0x23,
	0x8a, 0xdd, 0x8e, 0xdc, 0x80, 0x46, 0x44, 0x1f, 0xcb, 0x5e, 0x58, 0x98, 0x94, 0x22, 0xfa, 0x18,
	0xbf, 0x0e, 0x7c, 0x0c, 0x2d, 0x2e, 0xdc, 0x54, 0x14, 0xba, 0x4a, 0x5d, 0x22, 0xb0, 0xad, 0xbc,
	0x02, 0xe0, 0x7a, 0x32, 0xde, 0x67, 0xfa, 0xdd, 0xc0, 0xb4, 0x4d, 0x85, 0xc1, 0xcf, 0xd7, 0xa0,
	0x46, 0x23, 0xbf, 0x30, 0x43, 0x57, 0x69, 0xe4, 0x1f, 0xa7, 0x81, 0xf5, 0xd9, 0x42, 0x0f, 0x0c,
	0x8b, 0x27, 0xe8, 0xf1, 0x31, 0xac, 0xcb, 0x99, 0x5f, 0x4e, 0x16, 0xb2, 0x59, 0x97, 0x56, 0x28,
	0x65, 0x99, 0x66, 0x58, 0x07, 0x1e, 0xd1, 0xa3, 0x69, 0x2c, 0x35, 0xb1, 0x3e, 0x37, 0xa0, 0x59,
	0x7c, 0x0d, 0xc3, 0x01, 0x35, 0xa2, 0xd4, 0x77, 0x0a, 0xd7, 0x0a, 0x3d, 0xa0, 0x22, 0x7a, 0x2f,
	0xbb, 0x5a, 0x90, 0x0f, 0xe1, 0xba, 0xa6, 0xc3, 0x52, 0x23, 0xc3, 0x77, 0x91, 0x07, 0xaa, 0x2e,
	0x5d, 0x55, 0x1c, 0x21, 0x13, 0xcb, 0xfd, 0xee, 0x26, 0xda, 0x96, 0xfa, 0x8e, 0xbe, 0x3d, 0xa9,
	0x12, 0x02, 0x88, 0xd2, 0xb3, 0x7c, 0x26, 0x43, 0xe1, 0x42, 0x59, 0x59, 0xc8, 0xb0, 0x78, 0x39,
	0x78, 0x0d, 0xd6, 0x17, 0xb2, 0x4a, 0x4b, 0xac, 0xa9, 0x52, 0x97, 0x89, 0x2a, 0x55, 0xfc, 0x16,
	0x34, 0x8b, 0x0f, 0x29, 0xe7, 0x70, 0x19, 0x5f, 0xe6, 0xba, 0x3d, 0x80, 0xda, 0xd0, 0x1d, 0xc9,
	0x4a, 0xf1, 0x22, 0xb4, 0x07, 0xfb, 0x0f, 0xba, 0x7b, 0x83, 0x9e, 0x33, 0xec, 0xee, 0x38, 0xc3,
	0x4f, 0x0e, 0xfb, 0xed, 0xe7, 0x10, 0x9b, 0x41, 0xce, 0xdd, 0xfe, 0x7e, 0xdf, 0xee, 0xee, 0xb5,
	0x0d, 0x42, 0x60, 0x3d, 0xc7, 0x3e, 0x18, 0xf4, 0xfa, 0x07, 0xed, 0xd2, 0xed, 0xa1, 0x7c, 0xae,
	0xd9, 0xc9, 0x6f, 0x3c, 0x1c, 0x79, 0x77, 0x0e, 0x86, 0xc3, 0x83, 0xfb, 0x8a, 0x70, 0xff, 0x60,
	0x1f, 0x77, 0x7c, 0x09, 0x9e, 0xd7, 0xd8, 0xa3, 0xde, 0xc7, 0xce, 0xd1, 0xc1, 0xb1, 0xbd, 0xdb,
	0x6f, 0x1b, 0x05, 0xf4, 0xf0, 0xe0, 0x70, 0xb0, 0xeb, 0xec, 0x0d, 0xf6, 0x3f, 0x6e, 0x97, 0x6e,
	0xff, 0x54, 0x8e, 0x3f, 0xc7, 0xba, 0x2a, 0x5f, 0x83, 0x17, 0x7a, 0x9f, 0xec, 0x77, 0xef, 0x0f,
	0x76, 0x9d, 0xe3, 0x41, 0xcf, 0xe9, 0xf5, 0xef, 0x74, 0x8f, 0xf7, 0x86, 0xed, 0xe7, 0x50, 0xa0,
	0xe2, 0x87, 0xe3, 0xc3, 0xb6, 0x41, 0x5e, 0x80, 0x2b, 0x45, 0xdc, 0xe1, 0xdd, 0xdd, 0x76, 0xe9,
	0x2c, 0x61, 0xb7, 0xd7, 0x2e, 0x93, 0xab, 0x40, 0x8a, 0xb8, 0xdd, 0x7b, 0xfd, 0xfe, 0x51, 0xbf,
	0x5d, 0x79, 0xf7, 0x9f, 0x15, 0xa8, 0x60, 0xd4, 0x90, 0x11, 0x98, 0xf9, 0x6f, 0x32, 0x72, 0xf1,
	0x0d, 0xa9, 0xf8, 0xcf, 0x6e, 0xe3, 0xf6, 0xaa, 0xa4, 0x3c, 0x21, 0x9f, 0x42, 0x3d, 0xfb, 0x41,
	0x43, 0x2e, 0x7e, 0x6e, 0x2a, 0xfc, 0x44, 0xdb, 0x58, 0x91, 0x92, 0x27, 0xe4, 0x21, 0x34, 0x8b,
	0x8f, 0xf1, 0xe4, 0x9d, 0xcb, 0x39, 0x17, 0xbf, 0x44, 0x36, 0x9e, 0x82, 0x9a, 0x27, 0x44, 0x3d,
	0xae, 0xa9, 0x17, 0xe6, 0x4b, 0xec, 0x55, 0x7c, 0x4b, 0xdf, 0x58, 0x95, 0x94, 0x27, 0x24, 0x84,
	0xd6, 0xd2, 0x03, 0x30, 0xf9, 0xff, 0xcb, 0x25, 0x2c, 0xbc, 0x52, 0x6f, 0x3c, 0x0d, 0x39, 0x4f,
	0xc8, 0x64, 0xb9, 0x66, 0xbd, 0xbd, 0xf2, 0x7b, 0x20, 0xfd, 0x6c, 0xe3, 0xed, 0xa7, 0x78, 0xa7,
	0xdc, 0x79, 0xff, 0xcf, 0x5f, 0xdc, 0x30, 0xfe, 0xfa, 0xc5, 0x0d, 0xe3, 0xf3, 0x2f, 0x6e, 0x18,
	0xf0, 0xaa, 0x17, 0x87, 0xdb, 0x23, 0x37, 0x61, 0x3c, 0xdf, 0x83, 0x45, 0x82, 0xa6, 0x63, 0xd7,
	0xa3, 0x5c, 0x6e, 0x73, 0x68, 0xfc, 0xa4, 0xec, 0xcf, 0xa3, 0x51, 0x55, 0xfe, 0xa7, 0xfe, 0xe6,
	0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf2, 0xcd, 0x86, 0x2c, 0xb4, 0x1e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FeedClient is the client API for Feed service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FeedClient interface {
	// 网关调用 - 获取动态更新数量（客户端）
	UpdateNum(ctx context.Context, in *UpdateNumReq, opts ...grpc.CallOption) (*UpdateNumResp, error)
	// 网关调用 - 视频页刷新
	VideoNew(ctx context.Context, in *VideoNewReq, opts ...grpc.CallOption) (*VideoNewRsp, error)
	// 网关调用 - 视频页历史
	VideoHistory(ctx context.Context, in *VideoHistoryReq, opts ...grpc.CallOption) (*VideoHistoryRsp, error)
	// 网关调用 - 动态基本信息
	DynBriefs(ctx context.Context, in *DynBriefsReq, opts ...grpc.CallOption) (*DynBriefsRsp, error)
	// 网关调用 - 视频页最常访问个人feed流
	VideoPersonal(ctx context.Context, in *VideoPersonalReq, opts ...grpc.CallOption) (*VideoPersonalRsp, error)
	// 网关调用 - 动态后置信息
	DynPostInfo(ctx context.Context, in *DynPostInfoReq, opts ...grpc.CallOption) (*DynPostInfoRsp, error)
}

type feedClient struct {
	cc *grpc.ClientConn
}

func NewFeedClient(cc *grpc.ClientConn) FeedClient {
	return &feedClient{cc}
}

func (c *feedClient) UpdateNum(ctx context.Context, in *UpdateNumReq, opts ...grpc.CallOption) (*UpdateNumResp, error) {
	out := new(UpdateNumResp)
	err := c.cc.Invoke(ctx, "/dynamic.service.feed.svr.v1.Feed/UpdateNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedClient) VideoNew(ctx context.Context, in *VideoNewReq, opts ...grpc.CallOption) (*VideoNewRsp, error) {
	out := new(VideoNewRsp)
	err := c.cc.Invoke(ctx, "/dynamic.service.feed.svr.v1.Feed/VideoNew", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedClient) VideoHistory(ctx context.Context, in *VideoHistoryReq, opts ...grpc.CallOption) (*VideoHistoryRsp, error) {
	out := new(VideoHistoryRsp)
	err := c.cc.Invoke(ctx, "/dynamic.service.feed.svr.v1.Feed/VideoHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedClient) DynBriefs(ctx context.Context, in *DynBriefsReq, opts ...grpc.CallOption) (*DynBriefsRsp, error) {
	out := new(DynBriefsRsp)
	err := c.cc.Invoke(ctx, "/dynamic.service.feed.svr.v1.Feed/DynBriefs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedClient) VideoPersonal(ctx context.Context, in *VideoPersonalReq, opts ...grpc.CallOption) (*VideoPersonalRsp, error) {
	out := new(VideoPersonalRsp)
	err := c.cc.Invoke(ctx, "/dynamic.service.feed.svr.v1.Feed/VideoPersonal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedClient) DynPostInfo(ctx context.Context, in *DynPostInfoReq, opts ...grpc.CallOption) (*DynPostInfoRsp, error) {
	out := new(DynPostInfoRsp)
	err := c.cc.Invoke(ctx, "/dynamic.service.feed.svr.v1.Feed/DynPostInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeedServer is the server API for Feed service.
type FeedServer interface {
	// 网关调用 - 获取动态更新数量（客户端）
	UpdateNum(context.Context, *UpdateNumReq) (*UpdateNumResp, error)
	// 网关调用 - 视频页刷新
	VideoNew(context.Context, *VideoNewReq) (*VideoNewRsp, error)
	// 网关调用 - 视频页历史
	VideoHistory(context.Context, *VideoHistoryReq) (*VideoHistoryRsp, error)
	// 网关调用 - 动态基本信息
	DynBriefs(context.Context, *DynBriefsReq) (*DynBriefsRsp, error)
	// 网关调用 - 视频页最常访问个人feed流
	VideoPersonal(context.Context, *VideoPersonalReq) (*VideoPersonalRsp, error)
	// 网关调用 - 动态后置信息
	DynPostInfo(context.Context, *DynPostInfoReq) (*DynPostInfoRsp, error)
}

// UnimplementedFeedServer can be embedded to have forward compatible implementations.
type UnimplementedFeedServer struct {
}

func (*UnimplementedFeedServer) UpdateNum(ctx context.Context, req *UpdateNumReq) (*UpdateNumResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNum not implemented")
}
func (*UnimplementedFeedServer) VideoNew(ctx context.Context, req *VideoNewReq) (*VideoNewRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VideoNew not implemented")
}
func (*UnimplementedFeedServer) VideoHistory(ctx context.Context, req *VideoHistoryReq) (*VideoHistoryRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VideoHistory not implemented")
}
func (*UnimplementedFeedServer) DynBriefs(ctx context.Context, req *DynBriefsReq) (*DynBriefsRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DynBriefs not implemented")
}
func (*UnimplementedFeedServer) VideoPersonal(ctx context.Context, req *VideoPersonalReq) (*VideoPersonalRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VideoPersonal not implemented")
}
func (*UnimplementedFeedServer) DynPostInfo(ctx context.Context, req *DynPostInfoReq) (*DynPostInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DynPostInfo not implemented")
}

func RegisterFeedServer(s *grpc.Server, srv FeedServer) {
	s.RegisterService(&_Feed_serviceDesc, srv)
}

func _Feed_UpdateNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedServer).UpdateNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dynamic.service.feed.svr.v1.Feed/UpdateNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedServer).UpdateNum(ctx, req.(*UpdateNumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feed_VideoNew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoNewReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedServer).VideoNew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dynamic.service.feed.svr.v1.Feed/VideoNew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedServer).VideoNew(ctx, req.(*VideoNewReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feed_VideoHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedServer).VideoHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dynamic.service.feed.svr.v1.Feed/VideoHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedServer).VideoHistory(ctx, req.(*VideoHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feed_DynBriefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynBriefsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedServer).DynBriefs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dynamic.service.feed.svr.v1.Feed/DynBriefs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedServer).DynBriefs(ctx, req.(*DynBriefsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feed_VideoPersonal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoPersonalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedServer).VideoPersonal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dynamic.service.feed.svr.v1.Feed/VideoPersonal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedServer).VideoPersonal(ctx, req.(*VideoPersonalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feed_DynPostInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynPostInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedServer).DynPostInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dynamic.service.feed.svr.v1.Feed/DynPostInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedServer).DynPostInfo(ctx, req.(*DynPostInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Feed_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dynamic.service.feed.svr.v1.Feed",
	HandlerType: (*FeedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateNum",
			Handler:    _Feed_UpdateNum_Handler,
		},
		{
			MethodName: "VideoNew",
			Handler:    _Feed_VideoNew_Handler,
		},
		{
			MethodName: "VideoHistory",
			Handler:    _Feed_VideoHistory_Handler,
		},
		{
			MethodName: "DynBriefs",
			Handler:    _Feed_DynBriefs_Handler,
		},
		{
			MethodName: "VideoPersonal",
			Handler:    _Feed_VideoPersonal_Handler,
		},
		{
			MethodName: "DynPostInfo",
			Handler:    _Feed_DynPostInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *OffsetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OffsetInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tab != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Tab))
	}
	if len(m.TypeList) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeList)))
		i += copy(dAtA[i:], m.TypeList)
	}
	if len(m.Offset) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Offset)))
		i += copy(dAtA[i:], m.Offset)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if len(m.Offsets) > 0 {
		for _, msg := range m.Offsets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateNumResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNumResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RedType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RedType)))
		i += copy(dAtA[i:], m.RedType)
	}
	if m.UpdateNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UpdateNum))
	}
	if len(m.DefaultTab) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DefaultTab)))
		i += copy(dAtA[i:], m.DefaultTab)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoNewReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoNewReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if len(m.UpdateBaseline) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UpdateBaseline)))
		i += copy(dAtA[i:], m.UpdateBaseline)
	}
	if len(m.AssistBaseline) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.AssistBaseline)))
		i += copy(dAtA[i:], m.AssistBaseline)
	}
	if len(m.TypeList) > 0 {
		for _, s := range m.TypeList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.VersionCtrl != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VersionCtrl.Size()))
		n1, err1 := m.VersionCtrl.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.InfoCtrl != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.InfoCtrl.Size()))
		n2, err2 := m.InfoCtrl.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.AttentionInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttentionInfo.Size()))
		n3, err3 := m.AttentionInfo.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoNewRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoNewRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdateNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UpdateNum))
	}
	if len(m.HistoryOffset) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HistoryOffset)))
		i += copy(dAtA[i:], m.HistoryOffset)
	}
	if len(m.UpdateBaseline) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UpdateBaseline)))
		i += copy(dAtA[i:], m.UpdateBaseline)
	}
	if m.HasMore {
		dAtA[i] = 0x20
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Dyns) > 0 {
		for _, msg := range m.Dyns {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FoldInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FoldInfo.Size()))
		n4, err4 := m.FoldInfo.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if len(m.Offset) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Offset)))
		i += copy(dAtA[i:], m.Offset)
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page))
	}
	if len(m.TypeList) > 0 {
		for _, s := range m.TypeList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.VersionCtrl != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VersionCtrl.Size()))
		n5, err5 := m.VersionCtrl.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.InfoCtrl != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.InfoCtrl.Size()))
		n6, err6 := m.InfoCtrl.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.AttentionInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttentionInfo.Size()))
		n7, err7 := m.AttentionInfo.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoHistoryRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoHistoryRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HistoryOffset) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HistoryOffset)))
		i += copy(dAtA[i:], m.HistoryOffset)
	}
	if m.HasMore {
		dAtA[i] = 0x10
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Dyns) > 0 {
		for _, msg := range m.Dyns {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FoldInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FoldInfo.Size()))
		n8, err8 := m.FoldInfo.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynBriefsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynBriefsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DynIds) > 0 {
		dAtA10 := make([]byte, len(m.DynIds)*10)
		var j9 int
		for _, num1 := range m.DynIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.VersionCtrl != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VersionCtrl.Size()))
		n11, err11 := m.VersionCtrl.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	if m.InfoCtrl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.InfoCtrl.Size()))
		n12, err12 := m.InfoCtrl.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynBriefsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynBriefsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dyns) > 0 {
		for _, msg := range m.Dyns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoPersonalReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoPersonalReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.HostUid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HostUid))
	}
	if m.IsPreload {
		dAtA[i] = 0x18
		i++
		if m.IsPreload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Offset) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Offset)))
		i += copy(dAtA[i:], m.Offset)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoPersonalRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoPersonalRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasMore {
		dAtA[i] = 0x8
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Offset) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Offset)))
		i += copy(dAtA[i:], m.Offset)
	}
	if len(m.ReadOffset) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReadOffset)))
		i += copy(dAtA[i:], m.ReadOffset)
	}
	if len(m.Dyns) > 0 {
		for _, msg := range m.Dyns {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FoldInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FoldInfo.Size()))
		n13, err13 := m.FoldInfo.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynPostInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynPostInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if len(m.Dyns) > 0 {
		for _, msg := range m.Dyns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VersionCtrl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VersionCtrl.Size()))
		n14, err14 := m.VersionCtrl.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if m.InfoCtrl != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.InfoCtrl.Size()))
		n15, err15 := m.InfoCtrl.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynPostInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynPostInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dyns) > 0 {
		for k := range m.Dyns {
			dAtA[i] = 0xa
			i++
			v := m.Dyns[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n16, err16 := v.MarshalTo(dAtA[i:])
				if err16 != nil {
					return 0, err16
				}
				i += n16
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if len(m.TopicName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TopicName)))
		i += copy(dAtA[i:], m.TopicName)
	}
	if m.Stat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Stat))
	}
	if m.OriginTopicId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OriginTopicId))
	}
	if len(m.OriginTopicName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.OriginTopicName)))
		i += copy(dAtA[i:], m.OriginTopicName)
	}
	if m.OriginType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OriginType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynExt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynExt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lott != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Lott.Size()))
		n17, err17 := m.Lott.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	if m.Vote != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Vote.Size()))
		n18, err18 := m.Vote.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	if m.Lbs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Lbs.Size()))
		n19, err19 := m.Lbs.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	if len(m.HighLight) > 0 {
		for _, msg := range m.HighLight {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TopicInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicInfo.Size()))
		n20, err20 := m.TopicInfo.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.OpenGoods != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OpenGoods.Size()))
		n21, err21 := m.OpenGoods.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.EmojiType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.EmojiType))
	}
	if m.Dispute != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Dispute.Size()))
		n22, err22 := m.Dispute.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	if m.Bottom != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Bottom.Size()))
		n23, err23 := m.Bottom.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	if m.FlagCfg != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FlagCfg.Size()))
		n24, err24 := m.FlagCfg.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	if len(m.LikeUsers) > 0 {
		dAtA26 := make([]byte, len(m.LikeUsers)*10)
		var j25 int
		for _, num1 := range m.LikeUsers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BottomDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BottomDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Rid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rid))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.JumpUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.JumpUrl)))
		i += copy(dAtA[i:], m.JumpUrl)
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.BottomType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BottomType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BottomBusiness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BottomBusiness) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtBottom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtBottom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Business) > 0 {
		for _, msg := range m.Business {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BottomDetails) > 0 {
		for _, msg := range m.BottomDetails {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsAttachTopic {
		dAtA[i] = 0x8
		i++
		if m.IsAttachTopic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TopicInfos) > 0 {
		for _, msg := range m.TopicInfos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtLottery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtLottery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LotteryId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LotteryId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.LotteryTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LotteryTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtVote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VoteId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VoteId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtLbs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtLbs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Distance != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Distance))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.Poi) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Poi)))
		i += copy(dAtA[i:], m.Poi)
	}
	if m.Location != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Location.Size()))
		n27, err27 := m.Location.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	if len(m.ShowTitle) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ShowTitle)))
		i += copy(dAtA[i:], m.ShowTitle)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.ShowDistance) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ShowDistance)))
		i += copy(dAtA[i:], m.ShowDistance)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtHighLight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtHighLight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Location))
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Length))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeId)))
		i += copy(dAtA[i:], m.TypeId)
	}
	if len(m.PrefixIcon) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PrefixIcon)))
		i += copy(dAtA[i:], m.PrefixIcon)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtOpenGoods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtOpenGoods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ItemsId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ItemsId)))
		i += copy(dAtA[i:], m.ItemsId)
	}
	if m.ShopId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShopId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.LinkItemId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.LinkItemId)))
		i += copy(dAtA[i:], m.LinkItemId)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynDispute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynDispute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.JumpUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.JumpUrl)))
		i += copy(dAtA[i:], m.JumpUrl)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LbsLoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LbsLoc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lat != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i += 8
	}
	if m.Lng != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lng))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtFlagCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtFlagCfg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsPgc {
		dAtA[i] = 0x8
		i++
		if m.IsPgc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FoldStatement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FoldStatement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Statement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if len(m.JumpUri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.JumpUri)))
		i += copy(dAtA[i:], m.JumpUri)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynBrief) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynBrief) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DynId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DynId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Rid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rid))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.UidType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UidType))
	}
	if m.RepostNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RepostNum))
	}
	if len(m.Tips) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tips)))
		i += copy(dAtA[i:], m.Tips)
	}
	if m.Visible {
		dAtA[i] = 0x40
		i++
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ctime))
	}
	if m.Ext != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ext.Size()))
		n28, err28 := m.Ext.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	if m.Origin != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Origin.Size()))
		n29, err29 := m.Origin.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.Acl != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Acl.Size()))
		n30, err30 := m.Acl.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	if m.RType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynAcl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynAcl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RepostBanned {
		dAtA[i] = 0x8
		i++
		if m.RepostBanned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CommentBanned {
		dAtA[i] = 0x10
		i++
		if m.CommentBanned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LimitDisplay {
		dAtA[i] = 0x18
		i++
		if m.LimitDisplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Attention) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attention) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.UidType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UidType))
	}
	if m.IsSpecial {
		dAtA[i] = 0x18
		i++
		if m.IsSpecial {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttentionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttentionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AttentionList) > 0 {
		for _, msg := range m.AttentionList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Fold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fold) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DynIds) > 0 {
		dAtA32 := make([]byte, len(m.DynIds)*10)
		var j31 int
		for _, num1 := range m.DynIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j31))
		i += copy(dAtA[i:], dAtA32[:j31])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FoldExt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FoldExt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FoldType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FoldType))
	}
	if len(m.Folds) > 0 {
		for _, msg := range m.Folds {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FoldDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FoldDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Statement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if len(m.DynIds) > 0 {
		dAtA34 := make([]byte, len(m.DynIds)*10)
		var j33 int
		for _, num1 := range m.DynIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA34[:j33])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FoldInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FoldInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FoldMgr) > 0 {
		for _, msg := range m.FoldMgr {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InplaceFold) > 0 {
		for _, msg := range m.InplaceFold {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VersionCtrlMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionCtrlMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Build) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Build)))
		i += copy(dAtA[i:], m.Build)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.MobiApp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MobiApp)))
		i += copy(dAtA[i:], m.MobiApp)
	}
	if len(m.Buvid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Buvid)))
		i += copy(dAtA[i:], m.Buvid)
	}
	if len(m.Device) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Device)))
		i += copy(dAtA[i:], m.Device)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynPostItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynPostItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DynId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DynId))
	}
	if len(m.TopicNames) > 0 {
		for _, s := range m.TopicNames {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LikeIcon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LikeIcon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewIconId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NewIconId))
	}
	if len(m.StartUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartUrl)))
		i += copy(dAtA[i:], m.StartUrl)
	}
	if len(m.ActionUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ActionUrl)))
		i += copy(dAtA[i:], m.ActionUrl)
	}
	if len(m.EndUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndUrl)))
		i += copy(dAtA[i:], m.EndUrl)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynPostInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynPostInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DynId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DynId))
	}
	if m.LikeShowIcon != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LikeShowIcon.Size()))
		n35, err35 := m.LikeShowIcon.MarshalTo(dAtA[i:])
		if err35 != nil {
			return 0, err35
		}
		i += n35
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FeedInfoCtrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedInfoCtrl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NeedLikeUsers {
		dAtA[i] = 0x8
		i++
		if m.NeedLikeUsers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NeedLimitFoldStatement {
		dAtA[i] = 0x10
		i++
		if m.NeedLimitFoldStatement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NeedBottom {
		dAtA[i] = 0x18
		i++
		if m.NeedBottom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NeedTopicInfo {
		dAtA[i] = 0x20
		i++
		if m.NeedTopicInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NeedLikeIcon {
		dAtA[i] = 0x28
		i++
		if m.NeedLikeIcon {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PostInfoCtrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostInfoCtrl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NeedLikeIcon {
		dAtA[i] = 0x8
		i++
		if m.NeedLikeIcon {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *OffsetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tab != 0 {
		n += 1 + sovApi(uint64(m.Tab))
	}
	l = len(m.TypeList)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Offset)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateNumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if len(m.Offsets) > 0 {
		for _, e := range m.Offsets {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateNumResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RedType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpdateNum != 0 {
		n += 1 + sovApi(uint64(m.UpdateNum))
	}
	l = len(m.DefaultTab)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoNewReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	l = len(m.UpdateBaseline)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AssistBaseline)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.TypeList) > 0 {
		for _, s := range m.TypeList {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.VersionCtrl != nil {
		l = m.VersionCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.InfoCtrl != nil {
		l = m.InfoCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AttentionInfo != nil {
		l = m.AttentionInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoNewRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateNum != 0 {
		n += 1 + sovApi(uint64(m.UpdateNum))
	}
	l = len(m.HistoryOffset)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.UpdateBaseline)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HasMore {
		n += 2
	}
	if len(m.Dyns) > 0 {
		for _, e := range m.Dyns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.FoldInfo != nil {
		l = m.FoldInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoHistoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	l = len(m.Offset)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovApi(uint64(m.Page))
	}
	if len(m.TypeList) > 0 {
		for _, s := range m.TypeList {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.VersionCtrl != nil {
		l = m.VersionCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.InfoCtrl != nil {
		l = m.InfoCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AttentionInfo != nil {
		l = m.AttentionInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoHistoryRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HistoryOffset)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HasMore {
		n += 2
	}
	if len(m.Dyns) > 0 {
		for _, e := range m.Dyns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.FoldInfo != nil {
		l = m.FoldInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynBriefsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DynIds) > 0 {
		l = 0
		for _, e := range m.DynIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.VersionCtrl != nil {
		l = m.VersionCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.InfoCtrl != nil {
		l = m.InfoCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynBriefsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dyns) > 0 {
		for _, e := range m.Dyns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoPersonalReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.HostUid != 0 {
		n += 1 + sovApi(uint64(m.HostUid))
	}
	if m.IsPreload {
		n += 2
	}
	l = len(m.Offset)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoPersonalRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasMore {
		n += 2
	}
	l = len(m.Offset)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ReadOffset)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Dyns) > 0 {
		for _, e := range m.Dyns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.FoldInfo != nil {
		l = m.FoldInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynPostInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if len(m.Dyns) > 0 {
		for _, e := range m.Dyns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.VersionCtrl != nil {
		l = m.VersionCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.InfoCtrl != nil {
		l = m.InfoCtrl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynPostInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dyns) > 0 {
		for k, v := range m.Dyns {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	l = len(m.TopicName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Stat != 0 {
		n += 1 + sovApi(uint64(m.Stat))
	}
	if m.OriginTopicId != 0 {
		n += 1 + sovApi(uint64(m.OriginTopicId))
	}
	l = len(m.OriginTopicName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.OriginType != 0 {
		n += 1 + sovApi(uint64(m.OriginType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynExt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lott != nil {
		l = m.Lott.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Lbs != nil {
		l = m.Lbs.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.HighLight) > 0 {
		for _, e := range m.HighLight {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.TopicInfo != nil {
		l = m.TopicInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.OpenGoods != nil {
		l = m.OpenGoods.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EmojiType != 0 {
		n += 1 + sovApi(uint64(m.EmojiType))
	}
	if m.Dispute != nil {
		l = m.Dispute.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Bottom != nil {
		l = m.Bottom.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FlagCfg != nil {
		l = m.FlagCfg.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.LikeUsers) > 0 {
		l = 0
		for _, e := range m.LikeUsers {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BottomDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Rid != 0 {
		n += 1 + sovApi(uint64(m.Rid))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.JumpUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.BottomType != 0 {
		n += 1 + sovApi(uint64(m.BottomType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BottomBusiness) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rid != 0 {
		n += 1 + sovApi(uint64(m.Rid))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtBottom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Business) > 0 {
		for _, e := range m.Business {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BottomDetails) > 0 {
		for _, e := range m.BottomDetails {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtTopic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsAttachTopic {
		n += 2
	}
	if len(m.TopicInfos) > 0 {
		for _, e := range m.TopicInfos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtLottery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LotteryId != 0 {
		n += 1 + sovApi(uint64(m.LotteryId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LotteryTime != 0 {
		n += 1 + sovApi(uint64(m.LotteryTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteId != 0 {
		n += 1 + sovApi(uint64(m.VoteId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtLbs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Distance != 0 {
		n += 1 + sovApi(uint64(m.Distance))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.Poi)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ShowTitle)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ShowDistance)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtHighLight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != 0 {
		n += 1 + sovApi(uint64(m.Location))
	}
	if m.Length != 0 {
		n += 1 + sovApi(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PrefixIcon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtOpenGoods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ItemsId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ShopId != 0 {
		n += 1 + sovApi(uint64(m.ShopId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.LinkItemId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynDispute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.JumpUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LbsLoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lat != 0 {
		n += 9
	}
	if m.Lng != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtFlagCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsPgc {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FoldStatement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.JumpUri)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynBrief) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DynId != 0 {
		n += 1 + sovApi(uint64(m.DynId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Rid != 0 {
		n += 1 + sovApi(uint64(m.Rid))
	}
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.UidType != 0 {
		n += 1 + sovApi(uint64(m.UidType))
	}
	if m.RepostNum != 0 {
		n += 1 + sovApi(uint64(m.RepostNum))
	}
	l = len(m.Tips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Visible {
		n += 2
	}
	if m.Ctime != 0 {
		n += 1 + sovApi(uint64(m.Ctime))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Acl != nil {
		l = m.Acl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RType != 0 {
		n += 1 + sovApi(uint64(m.RType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynAcl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RepostBanned {
		n += 2
	}
	if m.CommentBanned {
		n += 2
	}
	if m.LimitDisplay {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Attention) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.UidType != 0 {
		n += 1 + sovApi(uint64(m.UidType))
	}
	if m.IsSpecial {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttentionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AttentionList) > 0 {
		for _, e := range m.AttentionList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Fold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DynIds) > 0 {
		l = 0
		for _, e := range m.DynIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FoldExt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FoldType != 0 {
		n += 1 + sovApi(uint64(m.FoldType))
	}
	if len(m.Folds) > 0 {
		for _, e := range m.Folds {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FoldDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.DynIds) > 0 {
		l = 0
		for _, e := range m.DynIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FoldInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FoldMgr) > 0 {
		for _, e := range m.FoldMgr {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.InplaceFold) > 0 {
		for _, e := range m.InplaceFold {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionCtrlMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Build)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.MobiApp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Buvid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynPostItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DynId != 0 {
		n += 1 + sovApi(uint64(m.DynId))
	}
	if len(m.TopicNames) > 0 {
		for _, s := range m.TopicNames {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LikeIcon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewIconId != 0 {
		n += 1 + sovApi(uint64(m.NewIconId))
	}
	l = len(m.StartUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ActionUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynPostInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DynId != 0 {
		n += 1 + sovApi(uint64(m.DynId))
	}
	if m.LikeShowIcon != nil {
		l = m.LikeShowIcon.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FeedInfoCtrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedLikeUsers {
		n += 2
	}
	if m.NeedLimitFoldStatement {
		n += 2
	}
	if m.NeedBottom {
		n += 2
	}
	if m.NeedTopicInfo {
		n += 2
	}
	if m.NeedLikeIcon {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PostInfoCtrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedLikeIcon {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OffsetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OffsetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OffsetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tab", wireType)
			}
			m.Tab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tab |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offsets = append(m.Offsets, &OffsetInfo{})
			if err := m.Offsets[len(m.Offsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNumResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNumResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNumResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateNum", wireType)
			}
			m.UpdateNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTab", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultTab = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoNewReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoNewReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoNewReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBaseline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateBaseline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistBaseline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssistBaseline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeList = append(m.TypeList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionCtrl == nil {
				m.VersionCtrl = &VersionCtrlMeta{}
			}
			if err := m.VersionCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoCtrl == nil {
				m.InfoCtrl = &FeedInfoCtrl{}
			}
			if err := m.InfoCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttentionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttentionInfo == nil {
				m.AttentionInfo = &AttentionInfo{}
			}
			if err := m.AttentionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoNewRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoNewRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoNewRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateNum", wireType)
			}
			m.UpdateNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryOffset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryOffset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBaseline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateBaseline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dyns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dyns = append(m.Dyns, &DynBrief{})
			if err := m.Dyns[len(m.Dyns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoldInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FoldInfo == nil {
				m.FoldInfo = &FoldInfo{}
			}
			if err := m.FoldInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeList = append(m.TypeList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionCtrl == nil {
				m.VersionCtrl = &VersionCtrlMeta{}
			}
			if err := m.VersionCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoCtrl == nil {
				m.InfoCtrl = &FeedInfoCtrl{}
			}
			if err := m.InfoCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttentionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttentionInfo == nil {
				m.AttentionInfo = &AttentionInfo{}
			}
			if err := m.AttentionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoHistoryRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoHistoryRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoHistoryRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryOffset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryOffset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dyns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dyns = append(m.Dyns, &DynBrief{})
			if err := m.Dyns[len(m.Dyns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoldInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FoldInfo == nil {
				m.FoldInfo = &FoldInfo{}
			}
			if err := m.FoldInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynBriefsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynBriefsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynBriefsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DynIds = append(m.DynIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DynIds) == 0 {
					m.DynIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DynIds = append(m.DynIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DynIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionCtrl == nil {
				m.VersionCtrl = &VersionCtrlMeta{}
			}
			if err := m.VersionCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoCtrl == nil {
				m.InfoCtrl = &FeedInfoCtrl{}
			}
			if err := m.InfoCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynBriefsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynBriefsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynBriefsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dyns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dyns = append(m.Dyns, &DynBrief{})
			if err := m.Dyns[len(m.Dyns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoPersonalReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPersonalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPersonalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostUid", wireType)
			}
			m.HostUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPreload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPreload = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoPersonalRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPersonalRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPersonalRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOffset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadOffset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dyns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dyns = append(m.Dyns, &DynBrief{})
			if err := m.Dyns[len(m.Dyns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoldInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FoldInfo == nil {
				m.FoldInfo = &FoldInfo{}
			}
			if err := m.FoldInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynPostInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynPostInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynPostInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dyns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dyns = append(m.Dyns, &DynPostItem{})
			if err := m.Dyns[len(m.Dyns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionCtrl == nil {
				m.VersionCtrl = &VersionCtrlMeta{}
			}
			if err := m.VersionCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoCtrl == nil {
				m.InfoCtrl = &PostInfoCtrl{}
			}
			if err := m.InfoCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynPostInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynPostInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynPostInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dyns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dyns == nil {
				m.Dyns = make(map[int64]*DynPostInfo)
			}
			var mapkey int64
			var mapvalue *DynPostInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DynPostInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Dyns[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			m.Stat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTopicId", wireType)
			}
			m.OriginTopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginTopicId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTopicName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginType", wireType)
			}
			m.OriginType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lott", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lott == nil {
				m.Lott = &ExtLottery{}
			}
			if err := m.Lott.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &ExtVote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lbs == nil {
				m.Lbs = &ExtLbs{}
			}
			if err := m.Lbs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighLight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighLight = append(m.HighLight, &ExtHighLight{})
			if err := m.HighLight[len(m.HighLight)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicInfo == nil {
				m.TopicInfo = &ExtTopic{}
			}
			if err := m.TopicInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenGoods == nil {
				m.OpenGoods = &ExtOpenGoods{}
			}
			if err := m.OpenGoods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiType", wireType)
			}
			m.EmojiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmojiType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dispute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dispute == nil {
				m.Dispute = &DynDispute{}
			}
			if err := m.Dispute.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bottom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bottom == nil {
				m.Bottom = &ExtBottom{}
			}
			if err := m.Bottom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagCfg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlagCfg == nil {
				m.FlagCfg = &ExtFlagCfg{}
			}
			if err := m.FlagCfg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LikeUsers = append(m.LikeUsers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LikeUsers) == 0 {
					m.LikeUsers = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LikeUsers = append(m.LikeUsers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeUsers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BottomDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BottomDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BottomDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BottomType", wireType)
			}
			m.BottomType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BottomType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BottomBusiness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BottomBusiness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BottomBusiness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtBottom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtBottom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtBottom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = append(m.Business, &BottomBusiness{})
			if err := m.Business[len(m.Business)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BottomDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BottomDetails = append(m.BottomDetails, &BottomDetail{})
			if err := m.BottomDetails[len(m.BottomDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAttachTopic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAttachTopic = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicInfos = append(m.TopicInfos, &TopicInfo{})
			if err := m.TopicInfos[len(m.TopicInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtLottery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtLottery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtLottery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LotteryId", wireType)
			}
			m.LotteryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LotteryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LotteryTime", wireType)
			}
			m.LotteryTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LotteryTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteId", wireType)
			}
			m.VoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtLbs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtLbs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtLbs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			m.Distance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Distance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LbsLoc{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShowTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowDistance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShowDistance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtHighLight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtHighLight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtHighLight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			m.Location = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Location |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtOpenGoods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtOpenGoods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtOpenGoods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkItemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkItemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynDispute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynDispute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynDispute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LbsLoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbsLoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbsLoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lng = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtFlagCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtFlagCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtFlagCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPgc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPgc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FoldStatement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FoldStatement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FoldStatement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynBrief) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynBrief: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynBrief: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynId", wireType)
			}
			m.DynId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DynId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidType", wireType)
			}
			m.UidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepostNum", wireType)
			}
			m.RepostNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepostNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &DynExt{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &DynBrief{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acl == nil {
				m.Acl = &DynAcl{}
			}
			if err := m.Acl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RType", wireType)
			}
			m.RType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynAcl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynAcl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynAcl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepostBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RepostBanned = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommentBanned = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitDisplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LimitDisplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attention) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attention: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attention: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidType", wireType)
			}
			m.UidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UidType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpecial", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSpecial = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttentionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttentionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttentionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttentionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttentionList = append(m.AttentionList, &Attention{})
			if err := m.AttentionList[len(m.AttentionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DynIds = append(m.DynIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DynIds) == 0 {
					m.DynIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DynIds = append(m.DynIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DynIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FoldExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FoldExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FoldExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoldType", wireType)
			}
			m.FoldType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FoldType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Folds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Folds = append(m.Folds, &Fold{})
			if err := m.Folds[len(m.Folds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FoldDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FoldDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FoldDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DynIds = append(m.DynIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DynIds) == 0 {
					m.DynIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DynIds = append(m.DynIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DynIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FoldInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FoldInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FoldInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoldMgr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoldMgr = append(m.FoldMgr, &FoldExt{})
			if err := m.FoldMgr[len(m.FoldMgr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InplaceFold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InplaceFold = append(m.InplaceFold, &FoldDetail{})
			if err := m.InplaceFold[len(m.InplaceFold)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionCtrlMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionCtrlMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionCtrlMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Build = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobiApp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MobiApp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buvid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buvid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynPostItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynPostItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynPostItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynId", wireType)
			}
			m.DynId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DynId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicNames = append(m.TopicNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LikeIcon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LikeIcon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LikeIcon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIconId", wireType)
			}
			m.NewIconId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewIconId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynPostInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynPostInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynPostInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynId", wireType)
			}
			m.DynId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DynId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeShowIcon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LikeShowIcon == nil {
				m.LikeShowIcon = &LikeIcon{}
			}
			if err := m.LikeShowIcon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedInfoCtrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedInfoCtrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedInfoCtrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLikeUsers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedLikeUsers = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLimitFoldStatement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedLimitFoldStatement = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedBottom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedBottom = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedTopicInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedTopicInfo = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLikeIcon", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedLikeIcon = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostInfoCtrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostInfoCtrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostInfoCtrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLikeIcon", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedLikeIcon = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthApi
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)
