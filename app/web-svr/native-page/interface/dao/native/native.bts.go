// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package native is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// bts: -struct_name=Dao
		NativePages(c context.Context, ids []int64) (map[int64]*v1.NativePage, error)
		// bts: -nullcache=&v1.NativePageDyn{Id:-1} -check_null_code=$!=nil&&$.Id==-1 -struct_name=Dao
		NativePagesExt(c context.Context, ids []int64) (map[int64]*v1.NativePageDyn, error)
		// bts: -struct_name=Dao
		NtTsPages(c context.Context, ids []int64) (map[int64]*v1.NativeTsPage, error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&dynmdl.ModuleRankReply{IDs:[]*dynmdl.RankInfo{{ID:-1,Score:3786883200}}} -check_null_code=$!=nil&&len($.IDs)==1&&$.IDs[0]!=nil&&$.IDs[0].ID==-1 -struct_name=Dao
		NtTsUIDs(c context.Context, uid int64, start int64, end int64) (res *dynmdl.ModuleRankReply, err error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&dynmdl.ModuleRankReply{IDs:[]*dynmdl.RankInfo{{ID:-1,Score:3786883200}}} -check_null_code=$!=nil&&len($.IDs)==1&&$.IDs[0]!=nil&&$.IDs[0].ID==-1 -struct_name=Dao
		NtTsOnlineIDs(c context.Context, uid int64, start int64, end int64) (res *dynmdl.ModuleRankReply, err error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&dynmdl.ModuleIDsReply{IDs:[]int64{-1}} -check_null_code=$!=nil&&len($.IDs)==1&&$.IDs[0]==-1 -struct_name=Dao
		NtTsModuleIDs(c context.Context, tsID int64, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error)
		// bts: -struct_name=Dao
		NtTsModulesExt(c context.Context, ids []int64) (map[int64]*dynmdl.NativeTsModuleExt, error)
		// bts: -singleflight=true -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		NtPidToTsID(c context.Context, pid int64) (int64, error)
		// bts: -struct_name=Dao -nullcache=-1 -check_null_code=$==-1
		NtPidToTsIDs(c context.Context, pids []int64) (map[int64]int64, error)
		// bts: -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		NativeForeigns(c context.Context, ids []int64, pageType int64) (map[int64]int64, error)
		// bts: -singleflight=true -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		NatTagIDExist(c context.Context, id int64) (int64, error)
		// bts: -struct_name=Dao
		NativeModules(c context.Context, ids []int64) (map[int64]*v1.NativeModule, error)
		// bts: -struct_name=Dao
		NativeClicks(c context.Context, ids []int64) (map[int64]*v1.NativeClick, error)
		// bts: -struct_name=Dao
		NativeDynamics(c context.Context, ids []int64) (map[int64]*v1.NativeDynamicExt, error)
		// bts: -struct_name=Dao
		NativeVideos(c context.Context, ids []int64) (map[int64]*v1.NativeVideoExt, error)
		// bts: -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		NativeUkey(c context.Context, pid int64, ukey string) (int64, error)
		// bts: -struct_name=Dao
		NativeMixtures(c context.Context, ids []int64) (map[int64]*v1.NativeMixtureExt, error)
		// bts: -nullcache=&v1.NativeActTab{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		NativeTabs(c context.Context, ids []int64) (res map[int64]*v1.NativeActTab, err error)
		// bts: -nullcache=&v1.NativeTabModule{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		NativeTabModules(c context.Context, ids []int64) (res map[int64]*v1.NativeTabModule, err error)
		// bts: -singleflight=true -nullcache=[]int64{-1} -check_null_code=len($)==1&&$[0]==-1 -struct_name=Dao
		NativeTabSort(c context.Context, id int64) (res []int64, err error)
		// bts: -singleflight=true -nullcache=[]int64{-1} -check_null_code=len($)==1&&$[0]==-1 -struct_name=Dao
		NativeClickIDs(c context.Context, id int64) (res []int64, err error)
		// bts: -singleflight=true -nullcache=[]int64{-1} -check_null_code=len($)==1&&$[0]==-1 -struct_name=Dao
		NativeDynamicIDs(c context.Context, id int64) (res []int64, err error)
		// bts: -singleflight=true -nullcache=[]int64{-1} -check_null_code=len($)==1&&$[0]==-1 -struct_name=Dao
		NativeActIDs(c context.Context, id int64) (res []int64, err error)
		// bts: -singleflight=true -nullcache=[]int64{-1} -check_null_code=len($)==1&&$[0]==-1 -struct_name=Dao
		NativeVideoIDs(c context.Context, id int64) (res []int64, err error)
		// bts: -nullcache=&v1.NativeParticipationExt{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		NativePart(c context.Context, ids []int64) (res map[int64]*v1.NativeParticipationExt, err error)
		// bts: -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		NativeTabBind(c context.Context, ids []int64, category int32) (map[int64]int64, error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&dynmdl.ModuleIDsReply{IDs:[]int64{-1}} -check_null_code=$!=nil&&len($.IDs)==1&&$.IDs[0]==-1 -struct_name=Dao
		ModuleIDs(c context.Context, nid int64, pType int32, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&dynmdl.ModuleIDsReply{IDs:[]int64{-1}} -check_null_code=$!=nil&&len($.IDs)==1&&$.IDs[0]==-1 -struct_name=Dao
		NatMixIDs(c context.Context, moduleID int64, pType int32, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&dynmdl.ModuleIDsReply{IDs:[]int64{-1}} -check_null_code=$!=nil&&len($.IDs)==1&&$.IDs[0]==-1 -struct_name=Dao
		NatAllMixIDs(c context.Context, moduleID int64, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&dynmdl.ModuleIDsReply{IDs:[]int64{-1}} -check_null_code=$!=nil&&len($.IDs)==1&&$.IDs[0]==-1 -struct_name=Dao
		PartPids(c context.Context, pid int64, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error)
		// bts: -struct_name=Dao
		NatIDsByActType(c context.Context, actType int64) ([]int64, error)
		// bts: -struct_name=Dao -singleflight=true -check_null_code=$!=nil&&$.ID==-1 -nullcache=&white_list.WhiteList{ID:-1}
		WhiteListByMid(c context.Context, mid int64) (*white_list.WhiteList, error)
		// bts: -struct_name=Dao -nullcache=&v1.NativeUserSpace{Id:-1} -check_null_code=$!=nil&&$.Id==-1
		UserSpaceByMid(c context.Context, mid int64) (*v1.NativeUserSpace, error)
		// bts: -singleflight=true -nullcache=&v1.NativePageExtend{Id:-1} -check_null_code=$!=nil&&$.Id==-1 -struct_name=Dao
		NativeExtend(c context.Context, pid int64) (res *v1.NativePageExtend, err error)
	}
*/

package native

import (
	"context"

	"go-common/library/cache"
	v1 "go-gateway/app/web-svr/native-page/interface/api"
	dynmdl "go-gateway/app/web-svr/native-page/interface/model/dynamic"
	"go-gateway/app/web-svr/native-page/interface/model/white_list"

	"golang.org/x/sync/singleflight"
)

var _ _bts
var cacheSingleFlights = [16]*singleflight.Group{{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}}

// NativePages get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativePages(c context.Context, ids []int64) (res map[int64]*v1.NativePage, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativePages(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativePages")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativePage
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativePages")
	missData, err = d.RawNativePages(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativePage, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativePages(c, missData)
	})
	return
}

// NativePagesExt get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativePagesExt(c context.Context, ids []int64) (res map[int64]*v1.NativePageDyn, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativePagesExt(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativePagesExt")
	for k, v := range res {
		if v != nil && v.Id == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativePageDyn
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativePagesExt")
	missData, err = d.RawNativePagesExt(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativePageDyn, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == nil {
			missData[key] = &v1.NativePageDyn{Id: -1}
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativePagesExt(c, missData)
	})
	return
}

// NtTsPages get data from cache if miss will call source method, then add to cache.
func (d *Dao) NtTsPages(c context.Context, ids []int64) (res map[int64]*v1.NativeTsPage, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNtTsPages(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NtTsPages")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeTsPage
	cache.MetricMisses.Add(float64(len(miss)), "bts:NtTsPages")
	missData, err = d.RawNtTsPages(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeTsPage, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNtTsPages(c, missData)
	})
	return
}

// NtTsUIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NtTsUIDs(c context.Context, uid int64, start int64, end int64) (res *dynmdl.ModuleRankReply, err error) {
	addCache := true
	res, err = d.CacheNtTsUIDs(c, uid, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && len(res.IDs) == 1 && res.IDs[0] != nil && res.IDs[0].ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:NtTsUIDs")
		return
	}
	var miss *dynmdl.ModuleRankReply
	var rr interface{}
	sf := d.cacheSFNtTsUIDs(uid, start, end)
	rr, err, _ = cacheSingleFlights[0].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NtTsUIDs")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawNtTsUIDs(c, uid, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*dynmdl.ModuleRankReply)
	miss = rr.([2]interface{})[1].(*dynmdl.ModuleRankReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &dynmdl.ModuleRankReply{IDs: []*dynmdl.RankInfo{{ID: -1, Score: 3786883200}}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNtTsUIDs(c, uid, miss)
	})
	return
}

// NtTsOnlineIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NtTsOnlineIDs(c context.Context, uid int64, start int64, end int64) (res *dynmdl.ModuleRankReply, err error) {
	addCache := true
	res, err = d.CacheNtTsOnlineIDs(c, uid, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && len(res.IDs) == 1 && res.IDs[0] != nil && res.IDs[0].ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:NtTsOnlineIDs")
		return
	}
	var miss *dynmdl.ModuleRankReply
	var rr interface{}
	sf := d.cacheSFNtTsOnlineIDs(uid, start, end)
	rr, err, _ = cacheSingleFlights[1].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NtTsOnlineIDs")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawNtTsOnlineIDs(c, uid, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*dynmdl.ModuleRankReply)
	miss = rr.([2]interface{})[1].(*dynmdl.ModuleRankReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &dynmdl.ModuleRankReply{IDs: []*dynmdl.RankInfo{{ID: -1, Score: 3786883200}}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNtTsOnlineIDs(c, uid, miss)
	})
	return
}

// NtTsModuleIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NtTsModuleIDs(c context.Context, tsID int64, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error) {
	addCache := true
	res, err = d.CacheNtTsModuleIDs(c, tsID, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && len(res.IDs) == 1 && res.IDs[0] == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:NtTsModuleIDs")
		return
	}
	var miss *dynmdl.ModuleIDsReply
	var rr interface{}
	sf := d.cacheSFNtTsModuleIDs(tsID, start, end)
	rr, err, _ = cacheSingleFlights[2].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NtTsModuleIDs")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawNtTsModuleIDs(c, tsID, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*dynmdl.ModuleIDsReply)
	miss = rr.([2]interface{})[1].(*dynmdl.ModuleIDsReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &dynmdl.ModuleIDsReply{IDs: []int64{-1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNtTsModuleIDs(c, tsID, miss)
	})
	return
}

// NtTsModulesExt get data from cache if miss will call source method, then add to cache.
func (d *Dao) NtTsModulesExt(c context.Context, ids []int64) (res map[int64]*dynmdl.NativeTsModuleExt, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNtTsModulesExt(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NtTsModulesExt")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*dynmdl.NativeTsModuleExt
	cache.MetricMisses.Add(float64(len(miss)), "bts:NtTsModulesExt")
	missData, err = d.RawNtTsModulesExt(c, miss)
	if res == nil {
		res = make(map[int64]*dynmdl.NativeTsModuleExt, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNtTsModulesExt(c, missData)
	})
	return
}

// NtPidToTsID get data from cache if miss will call source method, then add to cache.
func (d *Dao) NtPidToTsID(c context.Context, pid int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheNtPidToTsID(c, pid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:NtPidToTsID")
		return
	}
	var rr interface{}
	sf := d.cacheSFNtPidToTsID(pid)
	rr, err, _ = cacheSingleFlights[3].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NtPidToTsID")
		r, e = d.RawNtPidToTsID(c, pid)
		return
	})
	res = rr.(int64)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNtPidToTsID(c, pid, miss)
	})
	return
}

// NtPidToTsIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NtPidToTsIDs(c context.Context, pids []int64) (res map[int64]int64, err error) {
	if len(pids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNtPidToTsIDs(c, pids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range pids {
		if _, ok := res[key]; !ok {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(pids)-len(miss)), "bts:NtPidToTsIDs")
	for k, v := range res {
		if v == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]int64
	cache.MetricMisses.Add(float64(len(miss)), "bts:NtPidToTsIDs")
	missData, err = d.RawNtPidToTsIDs(c, miss)
	if res == nil {
		res = make(map[int64]int64, len(pids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == 0 {
			missData[key] = -1
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNtPidToTsIDs(c, missData)
	})
	return
}

// NativeForeigns get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeForeigns(c context.Context, ids []int64, pageType int64) (res map[int64]int64, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeForeigns(c, ids, pageType); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if _, ok := res[key]; !ok {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeForeigns")
	for k, v := range res {
		if v == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]int64
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeForeigns")
	missData, err = d.RawNativeForeigns(c, miss, pageType)
	if res == nil {
		res = make(map[int64]int64, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == 0 {
			missData[key] = -1
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeForeigns(c, missData, pageType)
	})
	return
}

// NatTagIDExist get data from cache if miss will call source method, then add to cache.
func (d *Dao) NatTagIDExist(c context.Context, id int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheNatTagIDExist(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:NatTagIDExist")
		return
	}
	var rr interface{}
	sf := d.cacheSFNatTagIDExist(id)
	rr, err, _ = cacheSingleFlights[4].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NatTagIDExist")
		r, e = d.RawNatTagIDExist(c, id)
		return
	})
	res = rr.(int64)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNatTagIDExist(c, id, miss)
	})
	return
}

// NativeModules get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeModules(c context.Context, ids []int64) (res map[int64]*v1.NativeModule, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeModules(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeModules")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeModule
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeModules")
	missData, err = d.RawNativeModules(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeModule, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeModules(c, missData)
	})
	return
}

// NativeClicks get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeClicks(c context.Context, ids []int64) (res map[int64]*v1.NativeClick, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeClicks(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeClicks")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeClick
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeClicks")
	missData, err = d.RawNativeClicks(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeClick, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeClicks(c, missData)
	})
	return
}

// NativeDynamics get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeDynamics(c context.Context, ids []int64) (res map[int64]*v1.NativeDynamicExt, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeDynamics(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeDynamics")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeDynamicExt
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeDynamics")
	missData, err = d.RawNativeDynamics(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeDynamicExt, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeDynamics(c, missData)
	})
	return
}

// NativeVideos get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeVideos(c context.Context, ids []int64) (res map[int64]*v1.NativeVideoExt, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeVideos(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeVideos")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeVideoExt
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeVideos")
	missData, err = d.RawNativeVideos(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeVideoExt, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeVideos(c, missData)
	})
	return
}

// NativeUkey get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeUkey(c context.Context, pid int64, ukey string) (res int64, err error) {
	addCache := true
	res, err = d.CacheNativeUkey(c, pid, ukey)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:NativeUkey")
		return
	}
	cache.MetricMisses.Inc("bts:NativeUkey")
	res, err = d.RawNativeUkey(c, pid, ukey)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeUkey(c, pid, miss, ukey)
	})
	return
}

// NativeMixtures get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeMixtures(c context.Context, ids []int64) (res map[int64]*v1.NativeMixtureExt, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeMixtures(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeMixtures")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeMixtureExt
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeMixtures")
	missData, err = d.RawNativeMixtures(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeMixtureExt, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeMixtures(c, missData)
	})
	return
}

// NativeTabs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeTabs(c context.Context, ids []int64) (res map[int64]*v1.NativeActTab, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeTabs(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeTabs")
	for k, v := range res {
		if v != nil && v.ID == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeActTab
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeTabs")
	missData, err = d.RawNativeTabs(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeActTab, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == nil {
			missData[key] = &v1.NativeActTab{ID: -1}
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeTabs(c, missData)
	})
	return
}

// NativeTabModules get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeTabModules(c context.Context, ids []int64) (res map[int64]*v1.NativeTabModule, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeTabModules(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeTabModules")
	for k, v := range res {
		if v != nil && v.ID == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeTabModule
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeTabModules")
	missData, err = d.RawNativeTabModules(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeTabModule, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == nil {
			missData[key] = &v1.NativeTabModule{ID: -1}
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeTabModules(c, missData)
	})
	return
}

// NativeTabSort get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeTabSort(c context.Context, id int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheNativeTabSort(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:NativeTabSort")
		return
	}
	var rr interface{}
	sf := d.cacheSFNativeTabSort(id)
	rr, err, _ = cacheSingleFlights[5].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NativeTabSort")
		r, e = d.RawNativeTabSort(c, id)
		return
	})
	res = rr.([]int64)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []int64{-1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeTabSort(c, id, miss)
	})
	return
}

// NativeClickIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeClickIDs(c context.Context, id int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheNativeClickIDs(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:NativeClickIDs")
		return
	}
	var rr interface{}
	sf := d.cacheSFNativeClickIDs(id)
	rr, err, _ = cacheSingleFlights[6].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NativeClickIDs")
		r, e = d.RawNativeClickIDs(c, id)
		return
	})
	res = rr.([]int64)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []int64{-1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeClickIDs(c, id, miss)
	})
	return
}

// NativeDynamicIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeDynamicIDs(c context.Context, id int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheNativeDynamicIDs(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:NativeDynamicIDs")
		return
	}
	var rr interface{}
	sf := d.cacheSFNativeDynamicIDs(id)
	rr, err, _ = cacheSingleFlights[7].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NativeDynamicIDs")
		r, e = d.RawNativeDynamicIDs(c, id)
		return
	})
	res = rr.([]int64)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []int64{-1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeDynamicIDs(c, id, miss)
	})
	return
}

// NativeActIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeActIDs(c context.Context, id int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheNativeActIDs(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:NativeActIDs")
		return
	}
	var rr interface{}
	sf := d.cacheSFNativeActIDs(id)
	rr, err, _ = cacheSingleFlights[8].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NativeActIDs")
		r, e = d.RawNativeActIDs(c, id)
		return
	})
	res = rr.([]int64)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []int64{-1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeActIDs(c, id, miss)
	})
	return
}

// NativeVideoIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeVideoIDs(c context.Context, id int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheNativeVideoIDs(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:NativeVideoIDs")
		return
	}
	var rr interface{}
	sf := d.cacheSFNativeVideoIDs(id)
	rr, err, _ = cacheSingleFlights[9].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NativeVideoIDs")
		r, e = d.RawNativeVideoIDs(c, id)
		return
	})
	res = rr.([]int64)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []int64{-1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeVideoIDs(c, id, miss)
	})
	return
}

// NativePart get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativePart(c context.Context, ids []int64) (res map[int64]*v1.NativeParticipationExt, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativePart(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativePart")
	for k, v := range res {
		if v != nil && v.ID == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*v1.NativeParticipationExt
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativePart")
	missData, err = d.RawNativePart(c, miss)
	if res == nil {
		res = make(map[int64]*v1.NativeParticipationExt, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == nil {
			missData[key] = &v1.NativeParticipationExt{ID: -1}
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativePart(c, missData)
	})
	return
}

// NativeTabBind get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeTabBind(c context.Context, ids []int64, category int32) (res map[int64]int64, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheNativeTabBind(c, ids, category); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if _, ok := res[key]; !ok {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:NativeTabBind")
	for k, v := range res {
		if v == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]int64
	cache.MetricMisses.Add(float64(len(miss)), "bts:NativeTabBind")
	missData, err = d.RawNativeTabBind(c, miss, category)
	if res == nil {
		res = make(map[int64]int64, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == 0 {
			missData[key] = -1
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeTabBind(c, missData, category)
	})
	return
}

// ModuleIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) ModuleIDs(c context.Context, nid int64, pType int32, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error) {
	addCache := true
	res, err = d.CacheModuleIDs(c, nid, pType, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && len(res.IDs) == 1 && res.IDs[0] == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:ModuleIDs")
		return
	}
	var miss *dynmdl.ModuleIDsReply
	var rr interface{}
	sf := d.cacheSFModuleIDs(nid, pType, start, end)
	rr, err, _ = cacheSingleFlights[10].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:ModuleIDs")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawModuleIDs(c, nid, pType, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*dynmdl.ModuleIDsReply)
	miss = rr.([2]interface{})[1].(*dynmdl.ModuleIDsReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &dynmdl.ModuleIDsReply{IDs: []int64{-1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheModuleIDs(c, nid, miss, pType)
	})
	return
}

// NatMixIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NatMixIDs(c context.Context, moduleID int64, pType int32, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error) {
	addCache := true
	res, err = d.CacheNatMixIDs(c, moduleID, pType, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && len(res.IDs) == 1 && res.IDs[0] == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:NatMixIDs")
		return
	}
	var miss *dynmdl.ModuleIDsReply
	var rr interface{}
	sf := d.cacheSFNatMixIDs(moduleID, pType, start, end)
	rr, err, _ = cacheSingleFlights[11].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NatMixIDs")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawNatMixIDs(c, moduleID, pType, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*dynmdl.ModuleIDsReply)
	miss = rr.([2]interface{})[1].(*dynmdl.ModuleIDsReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &dynmdl.ModuleIDsReply{IDs: []int64{-1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNatMixIDs(c, moduleID, miss, pType)
	})
	return
}

// NatAllMixIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) NatAllMixIDs(c context.Context, moduleID int64, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error) {
	addCache := true
	res, err = d.CacheNatAllMixIDs(c, moduleID, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && len(res.IDs) == 1 && res.IDs[0] == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:NatAllMixIDs")
		return
	}
	var miss *dynmdl.ModuleIDsReply
	var rr interface{}
	sf := d.cacheSFNatAllMixIDs(moduleID, start, end)
	rr, err, _ = cacheSingleFlights[12].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NatAllMixIDs")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawNatAllMixIDs(c, moduleID, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*dynmdl.ModuleIDsReply)
	miss = rr.([2]interface{})[1].(*dynmdl.ModuleIDsReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &dynmdl.ModuleIDsReply{IDs: []int64{-1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNatAllMixIDs(c, moduleID, miss)
	})
	return
}

// PartPids get data from cache if miss will call source method, then add to cache.
func (d *Dao) PartPids(c context.Context, pid int64, start int64, end int64) (res *dynmdl.ModuleIDsReply, err error) {
	addCache := true
	res, err = d.CachePartPids(c, pid, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && len(res.IDs) == 1 && res.IDs[0] == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:PartPids")
		return
	}
	var miss *dynmdl.ModuleIDsReply
	var rr interface{}
	sf := d.cacheSFPartPids(pid, start, end)
	rr, err, _ = cacheSingleFlights[13].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:PartPids")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawPartPids(c, pid, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*dynmdl.ModuleIDsReply)
	miss = rr.([2]interface{})[1].(*dynmdl.ModuleIDsReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &dynmdl.ModuleIDsReply{IDs: []int64{-1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCachePartPids(c, pid, miss)
	})
	return
}

// NatIDsByActType get data from cache if miss will call source method, then add to cache.
func (d *Dao) NatIDsByActType(c context.Context, actType int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheNatIDsByActType(c, actType)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:NatIDsByActType")
		return
	}
	cache.MetricMisses.Inc("bts:NatIDsByActType")
	res, err = d.RawNatIDsByActType(c, actType)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNatIDsByActType(c, actType, miss)
	})
	return
}

// WhiteListByMid get data from cache if miss will call source method, then add to cache.
func (d *Dao) WhiteListByMid(c context.Context, mid int64) (res *white_list.WhiteList, err error) {
	addCache := true
	res, err = d.CacheWhiteListByMid(c, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:WhiteListByMid")
		return
	}
	var rr interface{}
	sf := d.cacheSFWhiteListByMid(mid)
	rr, err, _ = cacheSingleFlights[14].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:WhiteListByMid")
		r, e = d.RawWhiteListByMid(c, mid)
		return
	})
	res = rr.(*white_list.WhiteList)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &white_list.WhiteList{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheWhiteListByMid(c, mid, miss)
	})
	return
}

// UserSpaceByMid get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserSpaceByMid(c context.Context, mid int64) (res *v1.NativeUserSpace, err error) {
	addCache := true
	res, err = d.CacheUserSpaceByMid(c, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.Id == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:UserSpaceByMid")
		return
	}
	cache.MetricMisses.Inc("bts:UserSpaceByMid")
	res, err = d.RawUserSpaceByMid(c, mid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &v1.NativeUserSpace{Id: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserSpaceByMid(c, mid, miss)
	})
	return
}

// NativeExtend get data from cache if miss will call source method, then add to cache.
func (d *Dao) NativeExtend(c context.Context, pid int64) (res *v1.NativePageExtend, err error) {
	addCache := true
	res, err = d.CacheNativeExtend(c, pid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.Id == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:NativeExtend")
		return
	}
	var rr interface{}
	sf := d.cacheSFNativeExtend(pid)
	rr, err, _ = cacheSingleFlights[15].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:NativeExtend")
		r, e = d.RawNativeExtend(c, pid)
		return
	})
	res = rr.(*v1.NativePageExtend)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &v1.NativePageExtend{Id: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheNativeExtend(c, pid, miss)
	})
	return
}
