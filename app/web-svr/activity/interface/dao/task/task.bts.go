// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package task is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// get a foreign business task id data.
		// bts:-struct_name=Dao
		TaskIDs(c context.Context, businessID int64, foreignID int64) ([]int64, error)
		// get task data by id.
		// bts:-struct_name=Dao
		Task(c context.Context, id int64) (*task.Task, error)
		// get tasks data by ids.
		// bts:-struct_name=Dao
		Tasks(c context.Context, ids []int64) (map[int64]*task.Task, error)
		// bts:-struct_name=Dao
		TaskStats(ctx context.Context, taskIDs []int64, sid int64, businessID int64) (map[int64]int64, error)
	}
*/

package task

import (
	"context"

	"go-common/library/cache"
	"go-gateway/app/web-svr/activity/interface/model/task"
)

var _ _bts

// TaskIDs get a foreign business task id data.
func (d *Dao) TaskIDs(c context.Context, businessID int64, foreignID int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheTaskIDs(c, businessID, foreignID)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:TaskIDs")
		return
	}
	cache.MetricMisses.Inc("bts:TaskIDs")
	res, err = d.RawTaskIDs(c, businessID, foreignID)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheTaskIDs(c, businessID, miss, foreignID)
	})
	return
}

// Task get task data by id.
func (d *Dao) Task(c context.Context, id int64) (res *task.Task, err error) {
	addCache := true
	res, err = d.CacheTask(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:Task")
		return
	}
	cache.MetricMisses.Inc("bts:Task")
	res, err = d.RawTask(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheTask(c, id, miss)
	})
	return
}

// Tasks get tasks data by ids.
func (d *Dao) Tasks(c context.Context, ids []int64) (res map[int64]*task.Task, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheTasks(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:Tasks")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*task.Task
	cache.MetricMisses.Add(float64(len(miss)), "bts:Tasks")
	missData, err = d.RawTasks(c, miss)
	if res == nil {
		res = make(map[int64]*task.Task, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheTasks(c, missData)
	})
	return
}

// TaskStats get data from cache if miss will call source method, then add to cache.
func (d *Dao) TaskStats(c context.Context, taskIDs []int64, sid int64, businessID int64) (res map[int64]int64, err error) {
	if len(taskIDs) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheTaskStats(c, taskIDs, sid, businessID); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range taskIDs {
		if _, ok := res[key]; !ok {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(taskIDs)-len(miss)), "bts:TaskStats")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]int64
	cache.MetricMisses.Add(float64(len(miss)), "bts:TaskStats")
	missData, err = d.RawTaskStats(c, miss, sid, businessID)
	if res == nil {
		res = make(map[int64]int64, len(taskIDs))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheTaskStats(c, missData, sid, businessID)
	})
	return
}
