// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package dao is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// bts: -struct_name=Dao
		EpContests(c context.Context, ids []int64) (map[int64]*model.Contest, error)
		// bts: -struct_name=Dao
		EpSeasons(c context.Context, ids []int64) (map[int64]*model.Season, error)
		// bts: -struct_name=Dao
		EpTeams(c context.Context, ids []int64) (map[int64]*model.Team, error)
		// bts: -struct_name=Dao
		SearchMainIDs(c context.Context) ([]int64, error)
		// bts: -struct_name=Dao
		SearchMD(c context.Context, mainIDs []int64) (res map[int64]*model.SearchRes, err error)
		// bts: -struct_name=Dao
		EpGames(c context.Context, ids []int64) (map[int64]*mdlEp.Game, error)
		// bts: -struct_name=Dao
		EpGameMap(c context.Context, oids []int64, tp int64) (map[int64]int64, error)
		// bts: -struct_name=Dao
		LolGames(c context.Context, matchID int64) ([]*model.LolGame, error)
		// bts: -struct_name=Dao
		DotaGames(c context.Context, matchID int64) ([]*model.LolGame, error)
		// bts: -struct_name=Dao
		OwGames(c context.Context, matchID int64) ([]*model.OwGame, error)
		// bts: -struct_name=Dao
		SeasonGames(c context.Context) ([]int64, error)
		//bts: -nullcache=[]*model.MatchSeason{{SeasonID:-1}} -check_null_code=len($)==1&&$[0].SeasonID==-1 -struct_name=Dao
		FetchSeasonsByMatchId(c context.Context, matchID int64) ([]*model.MatchSeason, error)
		// bts: -nullcache=&model.MatchSeason{SeasonID:-1} -check_null_code=$.SeasonID==-1 -struct_name=Dao
		FetchSeasonsInfoMap(c context.Context, sids []int64) (map[int64]*model.MatchSeason, error)
		// bts: -nullcache=&model.VideoListInfo{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		VideoList(c context.Context, id int64) (*model.VideoListInfo, error)
	}
*/

package dao

import (
	"context"

	"go-common/library/cache"

	mdlEp "go-gateway/app/web-svr/esports/interface/api/v1"
	"go-gateway/app/web-svr/esports/interface/model"
)

var _ _bts

func (d *Dao) FetchEffectiveTeamList(ctx context.Context) (m map[int64]*model.Team, err error) {
	m = make(map[int64]*model.Team, 0)

	startID := int64(0)
	for {
		if d, err := d.EffectiveTeamList(ctx, startID); err == nil {
			for _, v := range d {
				m[v.ID] = v
			}

			if len(d) < 1000 {
				break
			}

			startID = d[len(d)-1].ID
		} else {
			break
		}
	}

	return
}

func (d *Dao) FetchEffectiveSeasonList(ctx context.Context) (m map[int64]*model.Season, err error) {
	m = make(map[int64]*model.Season, 0)

	startID := int64(0)
	for {
		if d, err := d.EffectiveSeasonList(ctx, startID); err == nil {
			for _, v := range d {
				m[v.ID] = v
			}

			if len(d) < 1000 {
				break
			}

			startID = d[len(d)-1].ID
		} else {
			break
		}
	}

	return
}

// EpContests get data from cache if miss will call source method, then add to cache.
func (d *Dao) EpContests(c context.Context, ids []int64) (res map[int64]*model.Contest, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheEpContests(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:EpContests")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*model.Contest
	cache.MetricMisses.Add(float64(len(miss)), "bts:EpContests")
	missData, err = d.RawEpContests(c, miss)
	if res == nil {
		res = make(map[int64]*model.Contest, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheEpContests(c, missData)
	})
	return
}

// EpSeasons get data from cache if miss will call source method, then add to cache.
func (d *Dao) EpSeasons(c context.Context, ids []int64) (res map[int64]*model.Season, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheEpSeasons(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:EpSeasons")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*model.Season
	cache.MetricMisses.Add(float64(len(miss)), "bts:EpSeasons")
	missData, err = d.RawEpSeasons(c, miss)
	if res == nil {
		res = make(map[int64]*model.Season, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheEpSeasons(c, missData)
	})
	return
}

// EpTeams get data from cache if miss will call source method, then add to cache.
func (d *Dao) EpTeams(c context.Context, ids []int64) (res map[int64]*model.Team, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheEpTeams(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:EpTeams")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*model.Team
	cache.MetricMisses.Add(float64(len(miss)), "bts:EpTeams")
	missData, err = d.RawEpTeams(c, miss)
	if res == nil {
		res = make(map[int64]*model.Team, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheEpTeams(c, missData)
	})
	return
}

// SearchMainIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) SearchMainIDs(c context.Context) (res []int64, err error) {
	addCache := true
	res, err = d.CacheSearchMainIDs(c)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:SearchMainIDs")
		return
	}
	cache.MetricMisses.Inc("bts:SearchMainIDs")
	res, err = d.RawSearchMainIDs(c)
	if err != nil {
		return
	}
	var miss = res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheSearchMainIDs(c, miss)
	})
	return
}

// SearchMD get data from cache if miss will call source method, then add to cache.
func (d *Dao) SearchMD(c context.Context, mainIDs []int64) (res map[int64]*model.SearchRes, err error) {
	if len(mainIDs) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheSearchMD(c, mainIDs); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range mainIDs {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(mainIDs)-len(miss)), "bts:SearchMD")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*model.SearchRes
	cache.MetricMisses.Add(float64(len(miss)), "bts:SearchMD")
	missData, err = d.RawSearchMD(c, miss)
	if res == nil {
		res = make(map[int64]*model.SearchRes, len(mainIDs))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheSearchMD(c, missData)
	})
	return
}

// EpGames get data from cache if miss will call source method, then add to cache.
func (d *Dao) EpGames(c context.Context, ids []int64) (res map[int64]*mdlEp.Game, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheEpGames(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:EpGames")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*mdlEp.Game
	cache.MetricMisses.Add(float64(len(miss)), "bts:EpGames")
	missData, err = d.RawEpGames(c, miss)
	if res == nil {
		res = make(map[int64]*mdlEp.Game, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheEpGames(c, missData)
	})
	return
}

// EpGameMap get data from cache if miss will call source method, then add to cache.
func (d *Dao) EpGameMap(c context.Context, oids []int64, tp int64) (res map[int64]int64, err error) {
	if len(oids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheEpGameMap(c, oids, tp); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range oids {
		if _, ok := res[key]; !ok {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(oids)-len(miss)), "bts:EpGameMap")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]int64
	cache.MetricMisses.Add(float64(len(miss)), "bts:EpGameMap")
	missData, err = d.RawEpGameMap(c, miss, tp)
	if res == nil {
		res = make(map[int64]int64, len(oids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheEpGameMap(c, missData, tp)
	})
	return
}

// LolGames get data from cache if miss will call source method, then add to cache.
func (d *Dao) LolGames(c context.Context, matchID int64) (res []*model.LolGame, err error) {
	addCache := true
	res, err = d.CacheLolGames(c, matchID)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:LolGames")
		return
	}
	cache.MetricMisses.Inc("bts:LolGames")
	res, err = d.RawLolGames(c, matchID)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheLolGames(c, matchID, miss)
	})
	return
}

// DotaGames get data from cache if miss will call source method, then add to cache.
func (d *Dao) DotaGames(c context.Context, matchID int64) (res []*model.LolGame, err error) {
	addCache := true
	res, err = d.CacheDotaGames(c, matchID)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:DotaGames")
		return
	}
	cache.MetricMisses.Inc("bts:DotaGames")
	res, err = d.RawDotaGames(c, matchID)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheDotaGames(c, matchID, miss)
	})
	return
}

// OwGames get data from cache if miss will call source method, then add to cache.
func (d *Dao) OwGames(c context.Context, matchID int64) (res []*model.OwGame, err error) {
	addCache := true
	res, err = d.CacheOwGames(c, matchID)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:OwGames")
		return
	}
	cache.MetricMisses.Inc("bts:OwGames")
	res, err = d.RawOwGames(c, matchID)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheOwGames(c, matchID, miss)
	})
	return
}

// SeasonGames get data from cache if miss will call source method, then add to cache.
func (d *Dao) SeasonGames(c context.Context) (res []int64, err error) {
	addCache := true
	res, err = d.CacheSeasonGames(c)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:SeasonGames")
		return
	}
	cache.MetricMisses.Inc("bts:SeasonGames")
	res, err = d.RawSeasonGames(c)
	if err != nil {
		return
	}
	var miss = res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheSeasonGames(c, miss)
	})
	return
}

// FetchSeasonsByMatchId get data from cache if miss will call source method, then add to cache.
func (d *Dao) FetchSeasonsByMatchId(c context.Context, matchID int64) (res []*model.MatchSeason, err error) {
	addCache := true
	res, err = d.CacheFetchSeasonsByMatchId(c, matchID)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0].SeasonID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:FetchSeasonsByMatchId")
		return
	}
	cache.MetricMisses.Inc("bts:FetchSeasonsByMatchId")
	res, err = d.RawFetchSeasonsByMatchId(c, matchID)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*model.MatchSeason{{SeasonID: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheFetchSeasonsByMatchId(c, matchID, miss)
	})
	return
}

// FetchSeasonsInfoMap get data from cache if miss will call source method, then add to cache.
func (d *Dao) FetchSeasonsInfoMap(c context.Context, sids []int64) (res map[int64]*model.MatchSeason, err error) {
	if len(sids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheFetchSeasonsInfoMap(c, sids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range sids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(sids)-len(miss)), "bts:FetchSeasonsInfoMap")
	for k, v := range res {
		if v.SeasonID == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*model.MatchSeason
	cache.MetricMisses.Add(float64(len(miss)), "bts:FetchSeasonsInfoMap")
	missData, err = d.RawFetchSeasonsInfoMap(c, miss)
	if res == nil {
		res = make(map[int64]*model.MatchSeason, len(sids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == nil {
			missData[key] = &model.MatchSeason{SeasonID: -1}
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheFetchSeasonsInfoMap(c, missData)
	})
	return
}

// VideoList get data from cache if miss will call source method, then add to cache.
func (d *Dao) VideoList(c context.Context, id int64) (res *model.VideoListInfo, err error) {
	addCache := true
	res, err = d.CacheVideoList(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:VideoList")
		return
	}
	cache.MetricMisses.Inc("bts:VideoList")
	res, err = d.RawVideoList(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &model.VideoListInfo{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheVideoList(c, id, miss)
	})
	return
}
