// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: show.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Head struct {
	// 模块头部 ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 模块头部 平台
	Plat int32 `protobuf:"varint,2,opt,name=plat,proto3" json:"plat,omitempty"`
	// 模块头部 参数
	Param string `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
	// 模块类型
	Type string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	// 模块显示类型
	Style string `protobuf:"bytes,5,opt,name=style,proto3" json:"style,omitempty"`
	// 模块数据名称
	Title string `protobuf:"bytes,6,opt,name=title,proto3" json:"title,omitempty"`
	// 排行榜
	Rank int32 `protobuf:"varint,7,opt,name=rank,proto3" json:"rank,omitempty"`
	// build号
	Build int32 `protobuf:"varint,8,opt,name=build,proto3" json:"build,omitempty"`
	// 状态字段
	Condition string `protobuf:"bytes,9,opt,name=condition,proto3" json:"condition,omitempty"`
	// 使用语言
	Language             string   `protobuf:"bytes,10,opt,name=language,proto3" json:"language,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Head) Reset()         { *m = Head{} }
func (m *Head) String() string { return proto.CompactTextString(m) }
func (*Head) ProtoMessage()    {}
func (*Head) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{0}
}
func (m *Head) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Head) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Head.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Head) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Head.Merge(m, src)
}
func (m *Head) XXX_Size() int {
	return m.Size()
}
func (m *Head) XXX_DiscardUnknown() {
	xxx_messageInfo_Head.DiscardUnknown(m)
}

var xxx_messageInfo_Head proto.InternalMessageInfo

func (m *Head) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Head) GetPlat() int32 {
	if m != nil {
		return m.Plat
	}
	return 0
}

func (m *Head) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

func (m *Head) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Head) GetStyle() string {
	if m != nil {
		return m.Style
	}
	return ""
}

func (m *Head) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Head) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *Head) GetBuild() int32 {
	if m != nil {
		return m.Build
	}
	return 0
}

func (m *Head) GetCondition() string {
	if m != nil {
		return m.Condition
	}
	return ""
}

func (m *Head) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

type Item struct {
	// sid
	Sid int32 `protobuf:"varint,1,opt,name=sid,proto3" json:"sid,omitempty"`
	// 类型名称
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// 封面
	Cover string `protobuf:"bytes,3,opt,name=cover,proto3" json:"cover,omitempty"`
	// 参数
	Param string `protobuf:"bytes,4,opt,name=param,proto3" json:"param,omitempty"`
	// 随机数
	Random               int32    `protobuf:"varint,5,opt,name=random,proto3" json:"random,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{1}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetSid() int32 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *Item) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Item) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *Item) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

func (m *Item) GetRandom() int32 {
	if m != nil {
		return m.Random
	}
	return 0
}

type ShowHdMap struct {
	Key                  int32    `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Heads                []*Head  `protobuf:"bytes,2,rep,name=heads,proto3" json:"heads,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowHdMap) Reset()         { *m = ShowHdMap{} }
func (m *ShowHdMap) String() string { return proto.CompactTextString(m) }
func (*ShowHdMap) ProtoMessage()    {}
func (*ShowHdMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{2}
}
func (m *ShowHdMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowHdMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowHdMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowHdMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowHdMap.Merge(m, src)
}
func (m *ShowHdMap) XXX_Size() int {
	return m.Size()
}
func (m *ShowHdMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowHdMap.DiscardUnknown(m)
}

var xxx_messageInfo_ShowHdMap proto.InternalMessageInfo

func (m *ShowHdMap) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *ShowHdMap) GetHeads() []*Head {
	if m != nil {
		return m.Heads
	}
	return nil
}

type ShowHdmReply struct {
	Hdm                  []*ShowHdMap `protobuf:"bytes,1,rep,name=hdm,proto3" json:"hdm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ShowHdmReply) Reset()         { *m = ShowHdmReply{} }
func (m *ShowHdmReply) String() string { return proto.CompactTextString(m) }
func (*ShowHdmReply) ProtoMessage()    {}
func (*ShowHdmReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{3}
}
func (m *ShowHdmReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowHdmReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowHdmReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowHdmReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowHdmReply.Merge(m, src)
}
func (m *ShowHdmReply) XXX_Size() int {
	return m.Size()
}
func (m *ShowHdmReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowHdmReply.DiscardUnknown(m)
}

var xxx_messageInfo_ShowHdmReply proto.InternalMessageInfo

func (m *ShowHdmReply) GetHdm() []*ShowHdMap {
	if m != nil {
		return m.Hdm
	}
	return nil
}

type ShowItMap struct {
	Key                  int32    `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Items                []*Item  `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowItMap) Reset()         { *m = ShowItMap{} }
func (m *ShowItMap) String() string { return proto.CompactTextString(m) }
func (*ShowItMap) ProtoMessage()    {}
func (*ShowItMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{4}
}
func (m *ShowItMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowItMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowItMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowItMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowItMap.Merge(m, src)
}
func (m *ShowItMap) XXX_Size() int {
	return m.Size()
}
func (m *ShowItMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowItMap.DiscardUnknown(m)
}

var xxx_messageInfo_ShowItMap proto.InternalMessageInfo

func (m *ShowItMap) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *ShowItMap) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type ShowItmReply struct {
	Itm                  []*ShowItMap `protobuf:"bytes,1,rep,name=itm,proto3" json:"itm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ShowItmReply) Reset()         { *m = ShowItmReply{} }
func (m *ShowItmReply) String() string { return proto.CompactTextString(m) }
func (*ShowItmReply) ProtoMessage()    {}
func (*ShowItmReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{5}
}
func (m *ShowItmReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowItmReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowItmReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowItmReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowItmReply.Merge(m, src)
}
func (m *ShowItmReply) XXX_Size() int {
	return m.Size()
}
func (m *ShowItmReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowItmReply.DiscardUnknown(m)
}

var xxx_messageInfo_ShowItmReply proto.InternalMessageInfo

func (m *ShowItmReply) GetItm() []*ShowItMap {
	if m != nil {
		return m.Itm
	}
	return nil
}

type ArticleCard struct {
	// 卡id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 文章id
	ArticleId int64 `protobuf:"varint,2,opt,name=article_id,json=articleId,proto3" json:"article_id,omitempty"`
	// 封面
	Cover                string   `protobuf:"bytes,3,opt,name=cover,proto3" json:"cover,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArticleCard) Reset()         { *m = ArticleCard{} }
func (m *ArticleCard) String() string { return proto.CompactTextString(m) }
func (*ArticleCard) ProtoMessage()    {}
func (*ArticleCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{6}
}
func (m *ArticleCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArticleCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArticleCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArticleCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArticleCard.Merge(m, src)
}
func (m *ArticleCard) XXX_Size() int {
	return m.Size()
}
func (m *ArticleCard) XXX_DiscardUnknown() {
	xxx_messageInfo_ArticleCard.DiscardUnknown(m)
}

var xxx_messageInfo_ArticleCard proto.InternalMessageInfo

func (m *ArticleCard) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ArticleCard) GetArticleId() int64 {
	if m != nil {
		return m.ArticleId
	}
	return 0
}

func (m *ArticleCard) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

type ArticleCardMap struct {
	Key                  int64        `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Card                 *ArticleCard `protobuf:"bytes,2,opt,name=card,proto3" json:"card,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ArticleCardMap) Reset()         { *m = ArticleCardMap{} }
func (m *ArticleCardMap) String() string { return proto.CompactTextString(m) }
func (*ArticleCardMap) ProtoMessage()    {}
func (*ArticleCardMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{7}
}
func (m *ArticleCardMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArticleCardMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArticleCardMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArticleCardMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArticleCardMap.Merge(m, src)
}
func (m *ArticleCardMap) XXX_Size() int {
	return m.Size()
}
func (m *ArticleCardMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ArticleCardMap.DiscardUnknown(m)
}

var xxx_messageInfo_ArticleCardMap proto.InternalMessageInfo

func (m *ArticleCardMap) GetKey() int64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *ArticleCardMap) GetCard() *ArticleCard {
	if m != nil {
		return m.Card
	}
	return nil
}

type ArticleCardMapReply struct {
	Cardm                []*ArticleCardMap `protobuf:"bytes,1,rep,name=cardm,proto3" json:"cardm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ArticleCardMapReply) Reset()         { *m = ArticleCardMapReply{} }
func (m *ArticleCardMapReply) String() string { return proto.CompactTextString(m) }
func (*ArticleCardMapReply) ProtoMessage()    {}
func (*ArticleCardMapReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_40dadfe47b432028, []int{8}
}
func (m *ArticleCardMapReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArticleCardMapReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArticleCardMapReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArticleCardMapReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArticleCardMapReply.Merge(m, src)
}
func (m *ArticleCardMapReply) XXX_Size() int {
	return m.Size()
}
func (m *ArticleCardMapReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArticleCardMapReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArticleCardMapReply proto.InternalMessageInfo

func (m *ArticleCardMapReply) GetCardm() []*ArticleCardMap {
	if m != nil {
		return m.Cardm
	}
	return nil
}

func init() {
	proto.RegisterType((*Head)(nil), "app.job.v1.Head")
	proto.RegisterType((*Item)(nil), "app.job.v1.Item")
	proto.RegisterType((*ShowHdMap)(nil), "app.job.v1.ShowHdMap")
	proto.RegisterType((*ShowHdmReply)(nil), "app.job.v1.ShowHdmReply")
	proto.RegisterType((*ShowItMap)(nil), "app.job.v1.ShowItMap")
	proto.RegisterType((*ShowItmReply)(nil), "app.job.v1.ShowItmReply")
	proto.RegisterType((*ArticleCard)(nil), "app.job.v1.ArticleCard")
	proto.RegisterType((*ArticleCardMap)(nil), "app.job.v1.ArticleCardMap")
	proto.RegisterType((*ArticleCardMapReply)(nil), "app.job.v1.ArticleCardMapReply")
}

func init() { proto.RegisterFile("show.proto", fileDescriptor_40dadfe47b432028) }

var fileDescriptor_40dadfe47b432028 = []byte{
	// 459 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0x4d, 0x8f, 0xd3, 0x30,
	0x10, 0x25, 0x5f, 0x65, 0x33, 0x45, 0xab, 0x95, 0x29, 0x60, 0xad, 0xa0, 0xaa, 0x72, 0x80, 0x4a,
	0x48, 0x11, 0xbb, 0x1c, 0x38, 0x03, 0x42, 0x6c, 0x0f, 0x08, 0xc9, 0xdc, 0xb8, 0x20, 0xb7, 0xb6,
	0xb6, 0xa6, 0x49, 0x1c, 0x39, 0xde, 0xae, 0xf2, 0x4f, 0xf8, 0x49, 0x1c, 0xf9, 0x09, 0xa8, 0xf0,
	0x43, 0x90, 0xc7, 0x9b, 0x26, 0xac, 0xb6, 0xb7, 0x79, 0x6f, 0xde, 0xcc, 0xf3, 0x8b, 0x1d, 0x80,
	0x66, 0xad, 0xaf, 0xf3, 0xda, 0x68, 0xab, 0x09, 0xf0, 0xba, 0xce, 0xbf, 0xeb, 0x65, 0xbe, 0x3d,
	0xcb, 0xfe, 0x06, 0x10, 0x5f, 0x48, 0x2e, 0xc8, 0x31, 0x84, 0x4a, 0xd0, 0x60, 0x16, 0xcc, 0x13,
	0x16, 0x2a, 0x41, 0x08, 0xc4, 0x75, 0xc1, 0x2d, 0x0d, 0x91, 0xc1, 0x9a, 0x4c, 0x20, 0xa9, 0xb9,
	0xe1, 0x25, 0x8d, 0x66, 0xc1, 0x3c, 0x65, 0x1e, 0x38, 0xa5, 0x6d, 0x6b, 0x49, 0x63, 0x24, 0xb1,
	0x76, 0xca, 0xc6, 0xb6, 0x85, 0xa4, 0x89, 0x57, 0x22, 0x70, 0xac, 0x55, 0xb6, 0x90, 0x74, 0xe4,
	0x59, 0x04, 0x6e, 0xde, 0xf0, 0x6a, 0x43, 0xef, 0x7b, 0x27, 0x57, 0x3b, 0xe5, 0xf2, 0x4a, 0x15,
	0x82, 0x1e, 0x21, 0xe9, 0x01, 0x79, 0x0a, 0xe9, 0x4a, 0x57, 0x42, 0x59, 0xa5, 0x2b, 0x9a, 0xe2,
	0x8e, 0x9e, 0x20, 0xa7, 0x70, 0x54, 0xf0, 0xea, 0xf2, 0x8a, 0x5f, 0x4a, 0x0a, 0xd8, 0xdc, 0xe3,
	0xcc, 0x40, 0xbc, 0xb0, 0xb2, 0x24, 0x27, 0x10, 0x35, 0xfb, 0x98, 0xae, 0xec, 0xcf, 0x14, 0x0e,
	0xcf, 0x34, 0x81, 0x64, 0xa5, 0xb7, 0xd2, 0x74, 0x49, 0x11, 0xf4, 0xf9, 0xe3, 0x61, 0xfe, 0xc7,
	0x30, 0x32, 0xbc, 0x12, 0xba, 0xc4, 0xb0, 0x09, 0xbb, 0x41, 0xd9, 0x07, 0x48, 0xbf, 0xac, 0xf5,
	0xf5, 0x85, 0xf8, 0xc4, 0x6b, 0x67, 0xbc, 0x91, 0x6d, 0x67, 0xbc, 0x91, 0x2d, 0x79, 0x0e, 0xc9,
	0x5a, 0x72, 0xd1, 0xd0, 0x70, 0x16, 0xcd, 0xc7, 0xe7, 0x27, 0x79, 0x7f, 0x2b, 0xb9, 0xbb, 0x11,
	0xe6, 0xdb, 0xd9, 0x1b, 0x78, 0xe0, 0xd7, 0x94, 0x4c, 0xd6, 0x45, 0x4b, 0x5e, 0x40, 0xb4, 0x16,
	0x25, 0x0d, 0x70, 0xea, 0xd1, 0x70, 0x6a, 0xef, 0xc6, 0x9c, 0xa2, 0xf3, 0x5f, 0xd8, 0x83, 0xfe,
	0xca, 0xca, 0xf2, 0x4e, 0x7f, 0xf7, 0xad, 0x98, 0x6f, 0x77, 0xfe, 0x0b, 0xdb, 0xfb, 0x2b, 0x7b,
	0xd0, 0x1f, 0xdd, 0x98, 0x53, 0x64, 0x0c, 0xc6, 0x6f, 0x8d, 0x55, 0xab, 0x42, 0xbe, 0xe7, 0x66,
	0xf8, 0xc0, 0x22, 0x7c, 0x60, 0xcf, 0x00, 0xb8, 0x6f, 0x7f, 0x53, 0x02, 0xbf, 0x7e, 0xc4, 0xd2,
	0x1b, 0x66, 0x21, 0xee, 0xbe, 0x81, 0xec, 0x33, 0x1c, 0x0f, 0x76, 0xde, 0x0a, 0x16, 0xf9, 0x60,
	0x2f, 0x21, 0x5e, 0x71, 0xe3, 0x57, 0x8e, 0xcf, 0x9f, 0x0c, 0x4f, 0x38, 0x98, 0x65, 0x28, 0xca,
	0x3e, 0xc2, 0xc3, 0xff, 0x17, 0xfa, 0x90, 0xaf, 0x20, 0x71, 0xed, 0x2e, 0xe6, 0xe9, 0x81, 0x25,
	0x4e, 0xef, 0x85, 0xef, 0x26, 0x3f, 0x77, 0xd3, 0xe0, 0xd7, 0x6e, 0x1a, 0xfc, 0xde, 0x4d, 0x83,
	0x1f, 0x7f, 0xa6, 0xf7, 0xbe, 0x86, 0xdb, 0xb3, 0xe5, 0x08, 0xff, 0xb8, 0xd7, 0xff, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x6d, 0x8f, 0x2c, 0x70, 0x7f, 0x03, 0x00, 0x00,
}

func (m *Head) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Head) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Head) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Condition) > 0 {
		i -= len(m.Condition)
		copy(dAtA[i:], m.Condition)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Condition)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Build != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x40
	}
	if m.Rank != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Style) > 0 {
		i -= len(m.Style)
		copy(dAtA[i:], m.Style)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Style)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Plat != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Random != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Random))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cover) > 0 {
		i -= len(m.Cover)
		copy(dAtA[i:], m.Cover)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Cover)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Sid != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowHdMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowHdMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowHdMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Heads) > 0 {
		for iNdEx := len(m.Heads) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Heads[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Key != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowHdmReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowHdmReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowHdmReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hdm) > 0 {
		for iNdEx := len(m.Hdm) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hdm[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShowItMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowItMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowItMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Key != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowItmReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowItmReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowItmReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Itm) > 0 {
		for iNdEx := len(m.Itm) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Itm[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArticleCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArticleCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArticleCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cover) > 0 {
		i -= len(m.Cover)
		copy(dAtA[i:], m.Cover)
		i = encodeVarintShow(dAtA, i, uint64(len(m.Cover)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ArticleId != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.ArticleId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArticleCardMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArticleCardMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArticleCardMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Card != nil {
		{
			size, err := m.Card.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintShow(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArticleCardMapReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArticleCardMapReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArticleCardMapReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cardm) > 0 {
		for iNdEx := len(m.Cardm) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cardm[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintShow(dAtA []byte, offset int, v uint64) int {
	offset -= sovShow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Head) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShow(uint64(m.Id))
	}
	if m.Plat != 0 {
		n += 1 + sovShow(uint64(m.Plat))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	l = len(m.Style)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovShow(uint64(m.Rank))
	}
	if m.Build != 0 {
		n += 1 + sovShow(uint64(m.Build))
	}
	l = len(m.Condition)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovShow(uint64(m.Sid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	if m.Random != 0 {
		n += 1 + sovShow(uint64(m.Random))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowHdMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovShow(uint64(m.Key))
	}
	if len(m.Heads) > 0 {
		for _, e := range m.Heads {
			l = e.Size()
			n += 1 + l + sovShow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowHdmReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hdm) > 0 {
		for _, e := range m.Hdm {
			l = e.Size()
			n += 1 + l + sovShow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowItMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovShow(uint64(m.Key))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovShow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowItmReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Itm) > 0 {
		for _, e := range m.Itm {
			l = e.Size()
			n += 1 + l + sovShow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArticleCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShow(uint64(m.Id))
	}
	if m.ArticleId != 0 {
		n += 1 + sovShow(uint64(m.ArticleId))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovShow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArticleCardMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovShow(uint64(m.Key))
	}
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovShow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArticleCardMapReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cardm) > 0 {
		for _, e := range m.Cardm {
			l = e.Size()
			n += 1 + l + sovShow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShow(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShow(x uint64) (n int) {
	return sovShow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Head) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Head: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Head: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Style = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			m.Random = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Random |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowHdMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowHdMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowHdMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heads = append(m.Heads, &Head{})
			if err := m.Heads[len(m.Heads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowHdmReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowHdmReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowHdmReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hdm = append(m.Hdm, &ShowHdMap{})
			if err := m.Hdm[len(m.Hdm)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowItMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowItMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowItMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowItmReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowItmReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowItmReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Itm = append(m.Itm, &ShowItMap{})
			if err := m.Itm[len(m.Itm)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArticleCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArticleCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArticleCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArticleId", wireType)
			}
			m.ArticleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArticleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArticleCardMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArticleCardMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArticleCardMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &ArticleCard{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArticleCardMapReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArticleCardMapReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArticleCardMapReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cardm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cardm = append(m.Cardm, &ArticleCardMap{})
			if err := m.Cardm[len(m.Cardm)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShow = fmt.Errorf("proto: unexpected end of group")
)
