// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package like is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// bts: -sync=true -struct_name=Dao
		Like(c context.Context, id int64) (*likemdl.Item, error)
		// bts: -sync=true -struct_name=Dao
		Likes(c context.Context, ids []int64) (map[int64]*likemdl.Item, error)
		// bts: -sync=true -struct_name=Dao
		ActSubject(c context.Context, id int64) (*likemdl.SubjectItem, error)
		// bts: -struct_name=Dao
		ActSubjects(c context.Context, ids []int64) (map[int64]*likemdl.SubjectItem, error)
		// bts: -sync=true -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		LikeMissionBuff(ctx context.Context, sid int64, mid int64) (res int64, err error)
		// bts: -sync=true -struct_name=Dao
		MissionGroupItems(ctx context.Context, lids []int64) (map[int64]*likemdl.MissionGroup, error)
		// bts: -sync=true -nullcache=-1 -check_null_code=$!=nil&&$==-1 -struct_name=Dao
		ActMission(ctx context.Context, sid int64, lid int64, mid int64) (res int64, err error)
		// bts:-sync=true -struct_name=Dao
		ActLikeAchieves(ctx context.Context, sid int64) (res *likemdl.Achievements, err error)
		// bts:-sync=true -struct_name=Dao
		ActMissionFriends(ctx context.Context, sid int64, lid int64) (res *likemdl.ActMissionGroups, err error)
		// bts:-sync=true -struct_name=Dao
		ActUserAchieve(ctx context.Context, id int64) (res *likemdl.ActLikeUserAchievement, err error)
		// bts:-struct_name=Dao
		MatchSubjects(c context.Context, ids []int64) (map[int64]*likemdl.Object, error)
		// bts:-sync=true -struct_name=Dao
		LikeContent(c context.Context, ids []int64) (map[int64]*likemdl.LikeContent, error)
		// bts:-struct_name=Dao
		SourceItemData(c context.Context, sid int64) ([]int64, error)
		// bts:-sync=true -struct_name=Dao
		ActSubjectProtocol(c context.Context, sid int64) (res *likemdl.ActSubjectProtocol, err error)
		// bts: -struct_name=Dao
		ActSubjectProtocols(c context.Context, sid []int64) (map[int64]*likemdl.ActSubjectProtocol, error)
		// bts: -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		LikeTotal(c context.Context, sid int64) (int64, error)
		// bts: -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		LikeMidTotal(c context.Context, mid int64, sids []int64) (int64, error)
		// bts: -nullcache=&likemdl.Item{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		LikeCheck(c context.Context, mid int64, sid int64) (*likemdl.Item, error)
		// bts: -nullcache=[]*likemdl.LidItem{{Lid:-1}} -check_null_code=len($)==1&&$[0].Lid==-1 -struct_name=Dao
		LikeActLids(c context.Context, sid int64, mid int64) ([]*likemdl.LidItem, error)
		// bts: -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		TextOnly(c context.Context, sid int64, mid int64) (int, error)
		// bts: -nullcache=-1 -check_null_code=$==-1 -struct_name=Dao
		ActUserAward(c context.Context, id int64) (int64, error)
		// bts: -nullcache=&likemdl.HasReserve{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao -sync=true
		ReserveOnly(c context.Context, sid int64, mid int64) (*likemdl.HasReserve, error)
		// bts: -struct_name=Dao
		ReservesTotal(c context.Context, sid []int64) (map[int64]int64, error)
		// bts: -singleflight=true -nullcache=[]int64{-1} -check_null_code=len($)==1&&$[0]==-1 -struct_name=Dao
		ActStochastic(c context.Context, sid int64, ltype int64) (res []int64, err error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=&likemdl.EsLikesReply{Lids:[]int64{-1}} -check_null_code=len($.Lids)==1&&$.Lids[0]==-1 -struct_name=Dao
		ActEsLikesIDs(c context.Context, sid int64, ltype int64, start int64, end int64) (res *likemdl.EsLikesReply, err error)
		// bts: -singleflight=true -paging=true -ignores=||start,end -nullcache=[]int64{-1} -check_null_code=len($)==1&&$[0]==-1 -struct_name=Dao
		ActRandom(c context.Context, sid int64, ltype int64, start int64, end int64) (res []int64, err error)
		// bts:-sync=true -struct_name=Dao
		LikeExtendToken(ctx context.Context, sid int64, mid int64) (res *likemdl.ExtendTokenDetail, err error)
		// bts:-sync=true -struct_name=Dao
		LikeExtendInfo(ctx context.Context, sid int64, token string) (res *likemdl.ExtendTokenDetail, err error)
		// bts:-sync=true -struct_name=Dao -nullcache=&likemdl.AwardSubject{ID:-1} -check_null_code=$!=nil&&$.ID==-1
		AwardSubject(ctx context.Context, sid int64) (res *likemdl.AwardSubject, err error)
		// bts:-sync=true -struct_name=Dao -nullcache=&likemdl.AwardSubject{ID:-1} -check_null_code=$!=nil&&$.ID==-1
		AwardSubjectByID(ctx context.Context, id int64) (res *likemdl.AwardSubject, err error)
		// bts: -nullcache=&likemdl.ActUp{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		ActUp(c context.Context, mid int64) (res *likemdl.ActUp, err error)
		// bts: -nullcache=&likemdl.ActUp{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		ActUpBySid(c context.Context, sid int64) (res *likemdl.ActUp, err error)
		// bts: -nullcache=&likemdl.ActUp{ID:-1} -check_null_code=$!=nil&&$.ID==-1 -struct_name=Dao
		ActUpByAid(c context.Context, aid int64) (res *likemdl.ActUp, err error)
		// bts: -nullcache=[]*likemdl.SubjectRule{{ID:-1}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].ID==-1 -struct_name=Dao
		SubjectRulesBySid(c context.Context, sid int64) ([]*likemdl.SubjectRule, error)
		// bts: -nullcache=[]*likemdl.SubjectRule{{ID:-1}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].ID==-1 -struct_name=Dao
		SubjectRulesBySids(c context.Context, sids []int64) (map[int64][]*likemdl.SubjectRule, error)
		// bts: -nullcache=[]*likemdl.Item{{ID:-1}} -check_null_code=len($)==1&&$[0].ID==-1 -struct_name=Dao
		ActivityArchives(ctx context.Context, sid int64, mid int64) ([]*likemdl.Item, error)
		// bts:-sync=true -struct_name=Dao -nullcache=&likemdl.ActRelationInfo{ID:-1} -check_null_code=$!=nil&&$.ID==-1
		GetActRelationInfo(ctx context.Context, id int64) (res *likemdl.ActRelationInfo, err error)
		// bts: -sync=true -struct_name=Dao
		ActSubjectWithState(c context.Context, id int64) (*likemdl.SubjectItem, error)
		// bts: -sync=true -struct_name=Dao
		ActSubjectsWithState(c context.Context, ids []int64) (map[int64]*likemdl.SubjectItem, error)
		// bts:-sync=true -struct_name=Dao
		GetUpActReserveRelationInfoBySid(ctx context.Context, sids []int64) (res map[int64]*likemdl.UpActReserveRelationInfo, err error)
		// bts:-sync=true -struct_name=Dao
		GetReserveCounterGroupIDBySid(ctx context.Context, sid int64) (res []int64, err error)
		// bts:-sync=true -struct_name=Dao
		GetReserveCounterGroupInfoByGid(ctx context.Context, gid []int64) (res map[int64]*likemdl.ReserveCounterGroupItem, err error)
		// bts:-sync=true -struct_name=Dao
		GetReserveCounterNodeByGid(ctx context.Context, gid []int64) (res map[int64][]*likemdl.ReserveCounterNodeItem, err error)
		// bts:-sync=true -struct_name=Dao
		GetUpActReserveRelationInfo4SpaceCardIDs(ctx context.Context, mid int64, ) (res []int64, err error)
		// bts:-sync=true -struct_name=Dao -nullcache=-1 -check_null_code=$==-1
		GetUpActReserveRelationInfo4Live(ctx context.Context, upMid int64) (res int64, err error)
		// bts:-sync=true -struct_name=Dao -nullcache=[]*likemdl.WebDataItem{{ID:-1}} -check_null_code=len($)==1&&$[0].ID==-1
		GetWebViewDataByVid(ctx context.Context, vid int64) ([]*likemdl.WebDataItem, error)
		// bts:-sync=true -struct_name=Dao -nullcache=[]*likemdl.WebDataItem{{ID:-1}} -check_null_code=len($)==1&&$[0].ID==-1
		GetOnlineWebViewDataByVid(ctx context.Context, vid int64) ([]*likemdl.WebDataItem, error)
	}
*/

package like

import (
	"context"

	"go-common/library/cache"
	likemdl "go-gateway/app/web-svr/activity/interface/model/like"

	"golang.org/x/sync/singleflight"
)

var _ _bts
var cacheSingleFlights = [3]*singleflight.Group{{}, {}, {}}

// Like get data from cache if miss will call source method, then add to cache.
func (d *Dao) Like(c context.Context, id int64) (res *likemdl.Item, err error) {
	addCache := true
	res, err = d.CacheLike(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:Like")
		return
	}
	cache.MetricMisses.Inc("bts:Like")
	res, err = d.RawLike(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheLike(c, id, miss)
	return
}

// Likes get data from cache if miss will call source method, then add to cache.
func (d *Dao) Likes(c context.Context, ids []int64) (res map[int64]*likemdl.Item, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheLikes(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:Likes")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.Item
	cache.MetricMisses.Add(float64(len(miss)), "bts:Likes")
	missData, err = d.RawLikes(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.Item, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheLikes(c, missData)
	return
}

// ActSubject get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActSubject(c context.Context, id int64) (res *likemdl.SubjectItem, err error) {
	addCache := true
	res, err = d.CacheActSubject(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:ActSubject")
		return
	}
	cache.MetricMisses.Inc("bts:ActSubject")
	res, err = d.RawActSubject(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheActSubject(c, id, miss)
	return
}

// ActSubjects get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActSubjects(c context.Context, ids []int64) (res map[int64]*likemdl.SubjectItem, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheActSubjects(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:ActSubjects")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.SubjectItem
	cache.MetricMisses.Add(float64(len(miss)), "bts:ActSubjects")
	missData, err = d.RawActSubjects(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.SubjectItem, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActSubjects(c, missData)
	})
	return
}

// LikeMissionBuff get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeMissionBuff(c context.Context, sid int64, mid int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheLikeMissionBuff(c, sid, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:LikeMissionBuff")
		return
	}
	cache.MetricMisses.Inc("bts:LikeMissionBuff")
	res, err = d.RawLikeMissionBuff(c, sid, mid)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.AddCacheLikeMissionBuff(c, sid, miss, mid)
	return
}

// MissionGroupItems get data from cache if miss will call source method, then add to cache.
func (d *Dao) MissionGroupItems(c context.Context, lids []int64) (res map[int64]*likemdl.MissionGroup, err error) {
	if len(lids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheMissionGroupItems(c, lids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range lids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(lids)-len(miss)), "bts:MissionGroupItems")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.MissionGroup
	cache.MetricMisses.Add(float64(len(miss)), "bts:MissionGroupItems")
	missData, err = d.RawMissionGroupItems(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.MissionGroup, len(lids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheMissionGroupItems(c, missData)
	return
}

// ActMission get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActMission(c context.Context, sid int64, lid int64, mid int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheActMission(c, sid, lid, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:ActMission")
		return
	}
	cache.MetricMisses.Inc("bts:ActMission")
	res, err = d.RawActMission(c, sid, lid, mid)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.AddCacheActMission(c, sid, miss, lid, mid)
	return
}

// ActLikeAchieves get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActLikeAchieves(c context.Context, sid int64) (res *likemdl.Achievements, err error) {
	addCache := true
	res, err = d.CacheActLikeAchieves(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:ActLikeAchieves")
		return
	}
	cache.MetricMisses.Inc("bts:ActLikeAchieves")
	res, err = d.RawActLikeAchieves(c, sid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheActLikeAchieves(c, sid, miss)
	return
}

// ActMissionFriends get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActMissionFriends(c context.Context, sid int64, lid int64) (res *likemdl.ActMissionGroups, err error) {
	addCache := true
	res, err = d.CacheActMissionFriends(c, sid, lid)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:ActMissionFriends")
		return
	}
	cache.MetricMisses.Inc("bts:ActMissionFriends")
	res, err = d.RawActMissionFriends(c, sid, lid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheActMissionFriends(c, sid, miss, lid)
	return
}

// ActUserAchieve get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActUserAchieve(c context.Context, id int64) (res *likemdl.ActLikeUserAchievement, err error) {
	addCache := true
	res, err = d.CacheActUserAchieve(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:ActUserAchieve")
		return
	}
	cache.MetricMisses.Inc("bts:ActUserAchieve")
	res, err = d.RawActUserAchieve(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheActUserAchieve(c, id, miss)
	return
}

// MatchSubjects get data from cache if miss will call source method, then add to cache.
func (d *Dao) MatchSubjects(c context.Context, ids []int64) (res map[int64]*likemdl.Object, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheMatchSubjects(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:MatchSubjects")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.Object
	cache.MetricMisses.Add(float64(len(miss)), "bts:MatchSubjects")
	missData, err = d.RawMatchSubjects(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.Object, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheMatchSubjects(c, missData)
	})
	return
}

// LikeContent get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeContent(c context.Context, ids []int64) (res map[int64]*likemdl.LikeContent, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheLikeContent(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:LikeContent")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.LikeContent
	cache.MetricMisses.Add(float64(len(miss)), "bts:LikeContent")
	missData, err = d.RawLikeContent(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.LikeContent, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheLikeContent(c, missData)
	return
}

// SourceItemData get data from cache if miss will call source method, then add to cache.
func (d *Dao) SourceItemData(c context.Context, sid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheSourceItemData(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:SourceItemData")
		return
	}
	cache.MetricMisses.Inc("bts:SourceItemData")
	res, err = d.RawSourceItemData(c, sid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheSourceItemData(c, sid, miss)
	})
	return
}

// ActSubjectProtocol get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActSubjectProtocol(c context.Context, sid int64) (res *likemdl.ActSubjectProtocol, err error) {
	addCache := true
	res, err = d.CacheActSubjectProtocol(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:ActSubjectProtocol")
		return
	}
	cache.MetricMisses.Inc("bts:ActSubjectProtocol")
	res, err = d.RawActSubjectProtocol(c, sid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheActSubjectProtocol(c, sid, miss)
	return
}

// ActSubjectProtocols get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActSubjectProtocols(c context.Context, sid []int64) (res map[int64]*likemdl.ActSubjectProtocol, err error) {
	if len(sid) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheActSubjectProtocols(c, sid); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range sid {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(sid)-len(miss)), "bts:ActSubjectProtocols")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.ActSubjectProtocol
	cache.MetricMisses.Add(float64(len(miss)), "bts:ActSubjectProtocols")
	missData, err = d.RawActSubjectProtocols(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.ActSubjectProtocol, len(sid))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActSubjectProtocols(c, missData)
	})
	return
}

// LikeTotal get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeTotal(c context.Context, sid int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheLikeTotal(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:LikeTotal")
		return
	}
	cache.MetricMisses.Inc("bts:LikeTotal")
	res, err = d.RawLikeTotal(c, sid)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheLikeTotal(c, sid, miss)
	})
	return
}

// LikeMidTotal get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeMidTotal(c context.Context, mid int64, sids []int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheLikeMidTotal(c, mid, sids)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:LikeMidTotal")
		return
	}
	cache.MetricMisses.Inc("bts:LikeMidTotal")
	res, err = d.RawLikeMidTotal(c, mid, sids)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheLikeMidTotal(c, mid, miss, sids)
	})
	return
}

// LikeCheck get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeCheck(c context.Context, mid int64, sid int64) (res *likemdl.Item, err error) {
	addCache := true
	res, err = d.CacheLikeCheck(c, mid, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:LikeCheck")
		return
	}
	cache.MetricMisses.Inc("bts:LikeCheck")
	res, err = d.RawLikeCheck(c, mid, sid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.Item{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheLikeCheck(c, mid, miss, sid)
	})
	return
}

// LikeActLids get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeActLids(c context.Context, sid int64, mid int64) (res []*likemdl.LidItem, err error) {
	addCache := true
	res, err = d.CacheLikeActLids(c, sid, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0].Lid == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:LikeActLids")
		return
	}
	cache.MetricMisses.Inc("bts:LikeActLids")
	res, err = d.RawLikeActLids(c, sid, mid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*likemdl.LidItem{{Lid: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheLikeActLids(c, sid, miss, mid)
	})
	return
}

// TextOnly get data from cache if miss will call source method, then add to cache.
func (d *Dao) TextOnly(c context.Context, sid int64, mid int64) (res int, err error) {
	addCache := true
	res, err = d.CacheTextOnly(c, sid, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:TextOnly")
		return
	}
	cache.MetricMisses.Inc("bts:TextOnly")
	res, err = d.RawTextOnly(c, sid, mid)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheTextOnly(c, sid, miss, mid)
	})
	return
}

// ActUserAward get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActUserAward(c context.Context, id int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheActUserAward(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:ActUserAward")
		return
	}
	cache.MetricMisses.Inc("bts:ActUserAward")
	res, err = d.RawActUserAward(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActUserAward(c, id, miss)
	})
	return
}

// ReserveOnly get data from cache if miss will call source method, then add to cache.
func (d *Dao) ReserveOnly(c context.Context, sid int64, mid int64) (res *likemdl.HasReserve, err error) {
	addCache := true
	res, err = d.CacheReserveOnly(c, sid, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:ReserveOnly")
		return
	}
	cache.MetricMisses.Inc("bts:ReserveOnly")
	res, err = d.RawReserveOnly(c, sid, mid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.HasReserve{ID: -1}
	}
	if !addCache {
		return
	}
	d.AddCacheReserveOnly(c, sid, miss, mid)
	return
}

// ReservesTotal get data from cache if miss will call source method, then add to cache.
func (d *Dao) ReservesTotal(c context.Context, sid []int64) (res map[int64]int64, err error) {
	if len(sid) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheReservesTotal(c, sid); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range sid {
		if _, ok := res[key]; !ok {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(sid)-len(miss)), "bts:ReservesTotal")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]int64
	cache.MetricMisses.Add(float64(len(miss)), "bts:ReservesTotal")
	missData, err = d.RawReservesTotal(c, miss)
	if res == nil {
		res = make(map[int64]int64, len(sid))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheReservesTotal(c, missData)
	})
	return
}

// ActStochastic get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActStochastic(c context.Context, sid int64, ltype int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheActStochastic(c, sid, ltype)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:ActStochastic")
		return
	}
	var rr interface{}
	sf := d.cacheSFActStochastic(sid, ltype)
	rr, err, _ = cacheSingleFlights[0].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:ActStochastic")
		r, e = d.RawActStochastic(c, sid, ltype)
		return
	})
	res = rr.([]int64)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []int64{-1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActStochastic(c, sid, miss, ltype)
	})
	return
}

// ActEsLikesIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActEsLikesIDs(c context.Context, sid int64, ltype int64, start int64, end int64) (res *likemdl.EsLikesReply, err error) {
	addCache := true
	res, err = d.CacheActEsLikesIDs(c, sid, ltype, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res.Lids) == 1 && res.Lids[0] == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:ActEsLikesIDs")
		return
	}
	var miss *likemdl.EsLikesReply
	var rr interface{}
	sf := d.cacheSFActEsLikesIDs(sid, ltype, start, end)
	rr, err, _ = cacheSingleFlights[1].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:ActEsLikesIDs")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawActEsLikesIDs(c, sid, ltype, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].(*likemdl.EsLikesReply)
	miss = rr.([2]interface{})[1].(*likemdl.EsLikesReply)
	if err != nil {
		return
	}
	if miss == nil {
		miss = &likemdl.EsLikesReply{Lids: []int64{-1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActEsLikesIDs(c, sid, miss, ltype)
	})
	return
}

// ActRandom get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActRandom(c context.Context, sid int64, ltype int64, start int64, end int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheActRandom(c, sid, ltype, start, end)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:ActRandom")
		return
	}
	var miss []int64
	var rr interface{}
	sf := d.cacheSFActRandom(sid, ltype, start, end)
	rr, err, _ = cacheSingleFlights[2].Do(sf, func() (r interface{}, e error) {
		cache.MetricMisses.Inc("bts:ActRandom")
		var rrs [2]interface{}
		rrs[0], rrs[1], e = d.RawActRandom(c, sid, ltype, start, end)
		r = rrs
		return
	})
	res = rr.([2]interface{})[0].([]int64)
	miss = rr.([2]interface{})[1].([]int64)
	if err != nil {
		return
	}
	if len(miss) == 0 {
		miss = []int64{-1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActRandom(c, sid, miss, ltype)
	})
	return
}

// LikeExtendToken get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeExtendToken(c context.Context, sid int64, mid int64) (res *likemdl.ExtendTokenDetail, err error) {
	addCache := true
	res, err = d.CacheLikeExtendToken(c, sid, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:LikeExtendToken")
		return
	}
	cache.MetricMisses.Inc("bts:LikeExtendToken")
	res, err = d.RawLikeExtendToken(c, sid, mid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheLikeExtendToken(c, sid, miss, mid)
	return
}

// LikeExtendInfo get data from cache if miss will call source method, then add to cache.
func (d *Dao) LikeExtendInfo(c context.Context, sid int64, token string) (res *likemdl.ExtendTokenDetail, err error) {
	addCache := true
	res, err = d.CacheLikeExtendInfo(c, sid, token)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:LikeExtendInfo")
		return
	}
	cache.MetricMisses.Inc("bts:LikeExtendInfo")
	res, err = d.RawLikeExtendInfo(c, sid, token)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheLikeExtendInfo(c, sid, miss, token)
	return
}

// AwardSubject get data from cache if miss will call source method, then add to cache.
func (d *Dao) AwardSubject(c context.Context, sid int64) (res *likemdl.AwardSubject, err error) {
	addCache := true
	res, err = d.CacheAwardSubject(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:AwardSubject")
		return
	}
	cache.MetricMisses.Inc("bts:AwardSubject")
	res, err = d.RawAwardSubject(c, sid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.AwardSubject{ID: -1}
	}
	if !addCache {
		return
	}
	d.AddCacheAwardSubject(c, sid, miss)
	return
}

// AwardSubjectByID get data from cache if miss will call source method, then add to cache.
func (d *Dao) AwardSubjectByID(c context.Context, id int64) (res *likemdl.AwardSubject, err error) {
	addCache := true
	res, err = d.CacheAwardSubjectByID(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:AwardSubjectByID")
		return
	}
	cache.MetricMisses.Inc("bts:AwardSubjectByID")
	res, err = d.RawAwardSubjectByID(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.AwardSubject{ID: -1}
	}
	if !addCache {
		return
	}
	d.AddCacheAwardSubjectByID(c, id, miss)
	return
}

// ActUp get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActUp(c context.Context, mid int64) (res *likemdl.ActUp, err error) {
	addCache := true
	res, err = d.CacheActUp(c, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:ActUp")
		return
	}
	cache.MetricMisses.Inc("bts:ActUp")
	res, err = d.RawActUp(c, mid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.ActUp{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActUp(c, mid, miss)
	})
	return
}

// ActUpBySid get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActUpBySid(c context.Context, sid int64) (res *likemdl.ActUp, err error) {
	addCache := true
	res, err = d.CacheActUpBySid(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:ActUpBySid")
		return
	}
	cache.MetricMisses.Inc("bts:ActUpBySid")
	res, err = d.RawActUpBySid(c, sid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.ActUp{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActUpBySid(c, sid, miss)
	})
	return
}

// ActUpByAid get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActUpByAid(c context.Context, aid int64) (res *likemdl.ActUp, err error) {
	addCache := true
	res, err = d.CacheActUpByAid(c, aid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:ActUpByAid")
		return
	}
	cache.MetricMisses.Inc("bts:ActUpByAid")
	res, err = d.RawActUpByAid(c, aid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.ActUp{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActUpByAid(c, aid, miss)
	})
	return
}

// SubjectRulesBySid get data from cache if miss will call source method, then add to cache.
func (d *Dao) SubjectRulesBySid(c context.Context, sid int64) (res []*likemdl.SubjectRule, err error) {
	addCache := true
	res, err = d.CacheSubjectRulesBySid(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] != nil && res[0].ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:SubjectRulesBySid")
		return
	}
	cache.MetricMisses.Inc("bts:SubjectRulesBySid")
	res, err = d.RawSubjectRulesBySid(c, sid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*likemdl.SubjectRule{{ID: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheSubjectRulesBySid(c, sid, miss)
	})
	return
}

// SubjectRulesBySids get data from cache if miss will call source method, then add to cache.
func (d *Dao) SubjectRulesBySids(c context.Context, sids []int64) (res map[int64][]*likemdl.SubjectRule, err error) {
	if len(sids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheSubjectRulesBySids(c, sids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range sids {
		if (res == nil) || (len(res[key]) == 0) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(sids)-len(miss)), "bts:SubjectRulesBySids")
	for k, v := range res {
		if len(v) == 1 && v[0] != nil && v[0].ID == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64][]*likemdl.SubjectRule
	cache.MetricMisses.Add(float64(len(miss)), "bts:SubjectRulesBySids")
	missData, err = d.RawSubjectRulesBySids(c, miss)
	if res == nil {
		res = make(map[int64][]*likemdl.SubjectRule, len(sids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if len(res[key]) == 0 {
			missData[key] = []*likemdl.SubjectRule{{ID: -1}}
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheSubjectRulesBySids(c, missData)
	})
	return
}

// ActivityArchives get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActivityArchives(c context.Context, sid int64, mid int64) (res []*likemdl.Item, err error) {
	addCache := true
	res, err = d.CacheActivityArchives(c, sid, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0].ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:ActivityArchives")
		return
	}
	cache.MetricMisses.Inc("bts:ActivityArchives")
	res, err = d.RawActivityArchives(c, sid, mid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*likemdl.Item{{ID: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheActivityArchives(c, sid, miss, mid)
	})
	return
}

// GetActRelationInfo get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetActRelationInfo(c context.Context, id int64) (res *likemdl.ActRelationInfo, err error) {
	addCache := true
	res, err = d.CacheGetActRelationInfo(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:GetActRelationInfo")
		return
	}
	cache.MetricMisses.Inc("bts:GetActRelationInfo")
	res, err = d.RawGetActRelationInfo(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &likemdl.ActRelationInfo{ID: -1}
	}
	if !addCache {
		return
	}
	d.AddCacheGetActRelationInfo(c, id, miss)
	return
}

// ActSubjectWithState get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActSubjectWithState(c context.Context, id int64) (res *likemdl.SubjectItem, err error) {
	addCache := true
	res, err = d.CacheActSubjectWithState(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:ActSubjectWithState")
		return
	}
	cache.MetricMisses.Inc("bts:ActSubjectWithState")
	res, err = d.RawActSubjectWithState(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheActSubjectWithState(c, id, miss)
	return
}

// ActSubjectsWithState get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActSubjectsWithState(c context.Context, ids []int64) (res map[int64]*likemdl.SubjectItem, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheActSubjectsWithState(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:ActSubjectsWithState")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.SubjectItem
	cache.MetricMisses.Add(float64(len(miss)), "bts:ActSubjectsWithState")
	missData, err = d.RawActSubjectsWithState(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.SubjectItem, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheActSubjectsWithState(c, missData)
	return
}

// GetUpActReserveRelationInfoBySid get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetUpActReserveRelationInfoBySid(c context.Context, sids []int64) (res map[int64]*likemdl.UpActReserveRelationInfo, err error) {
	if len(sids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheGetUpActReserveRelationInfoBySid(c, sids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range sids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(sids)-len(miss)), "bts:GetUpActReserveRelationInfoBySid")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.UpActReserveRelationInfo
	cache.MetricMisses.Add(float64(len(miss)), "bts:GetUpActReserveRelationInfoBySid")
	missData, err = d.RawGetUpActReserveRelationInfoBySid(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.UpActReserveRelationInfo, len(sids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheGetUpActReserveRelationInfoBySid(c, missData)
	return
}

// GetReserveCounterGroupIDBySid get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetReserveCounterGroupIDBySid(c context.Context, sid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheGetReserveCounterGroupIDBySid(c, sid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:GetReserveCounterGroupIDBySid")
		return
	}
	cache.MetricMisses.Inc("bts:GetReserveCounterGroupIDBySid")
	res, err = d.RawGetReserveCounterGroupIDBySid(c, sid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheGetReserveCounterGroupIDBySid(c, sid, miss)
	return
}

// GetReserveCounterGroupInfoByGid get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetReserveCounterGroupInfoByGid(c context.Context, gid []int64) (res map[int64]*likemdl.ReserveCounterGroupItem, err error) {
	if len(gid) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheGetReserveCounterGroupInfoByGid(c, gid); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range gid {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(gid)-len(miss)), "bts:GetReserveCounterGroupInfoByGid")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*likemdl.ReserveCounterGroupItem
	cache.MetricMisses.Add(float64(len(miss)), "bts:GetReserveCounterGroupInfoByGid")
	missData, err = d.RawGetReserveCounterGroupInfoByGid(c, miss)
	if res == nil {
		res = make(map[int64]*likemdl.ReserveCounterGroupItem, len(gid))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheGetReserveCounterGroupInfoByGid(c, missData)
	return
}

// GetReserveCounterNodeByGid get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetReserveCounterNodeByGid(c context.Context, gid []int64) (res map[int64][]*likemdl.ReserveCounterNodeItem, err error) {
	if len(gid) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheGetReserveCounterNodeByGid(c, gid); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range gid {
		if (res == nil) || (len(res[key]) == 0) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(gid)-len(miss)), "bts:GetReserveCounterNodeByGid")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64][]*likemdl.ReserveCounterNodeItem
	cache.MetricMisses.Add(float64(len(miss)), "bts:GetReserveCounterNodeByGid")
	missData, err = d.RawGetReserveCounterNodeByGid(c, miss)
	if res == nil {
		res = make(map[int64][]*likemdl.ReserveCounterNodeItem, len(gid))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheGetReserveCounterNodeByGid(c, missData)
	return
}

// GetUpActReserveRelationInfo4SpaceCardIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetUpActReserveRelationInfo4SpaceCardIDs(c context.Context, mid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheGetUpActReserveRelationInfo4SpaceCardIDs(c, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:GetUpActReserveRelationInfo4SpaceCardIDs")
		return
	}
	cache.MetricMisses.Inc("bts:GetUpActReserveRelationInfo4SpaceCardIDs")
	res, err = d.RawGetUpActReserveRelationInfo4SpaceCardIDs(c, mid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheGetUpActReserveRelationInfo4SpaceCardIDs(c, mid, miss)
	return
}

// GetUpActReserveRelationInfo4Live get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetUpActReserveRelationInfo4Live(c context.Context, upMid int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheGetUpActReserveRelationInfo4Live(c, upMid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:GetUpActReserveRelationInfo4Live")
		return
	}
	cache.MetricMisses.Inc("bts:GetUpActReserveRelationInfo4Live")
	res, err = d.RawGetUpActReserveRelationInfo4Live(c, upMid)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.AddCacheGetUpActReserveRelationInfo4Live(c, upMid, miss)
	return
}

// GetWebViewDataByVid get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetWebViewDataByVid(c context.Context, vid int64) (res []*likemdl.WebDataItem, err error) {
	addCache := true
	res, err = d.CacheGetWebViewDataByVid(c, vid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0].ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:GetWebViewDataByVid")
		return
	}
	cache.MetricMisses.Inc("bts:GetWebViewDataByVid")
	res, err = d.RawGetWebViewDataByVid(c, vid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*likemdl.WebDataItem{{ID: -1}}
	}
	if !addCache {
		return
	}
	d.AddCacheGetWebViewDataByVid(c, vid, miss)
	return
}

// GetOnlineWebViewDataByVid get data from cache if miss will call source method, then add to cache.
func (d *Dao) GetOnlineWebViewDataByVid(c context.Context, vid int64) (res []*likemdl.WebDataItem, err error) {
	addCache := true
	res, err = d.CacheGetOnlineWebViewDataByVid(c, vid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0].ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:GetOnlineWebViewDataByVid")
		return
	}
	cache.MetricMisses.Inc("bts:GetOnlineWebViewDataByVid")
	res, err = d.RawGetOnlineWebViewDataByVid(c, vid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*likemdl.WebDataItem{{ID: -1}}
	}
	if !addCache {
		return
	}
	d.AddCacheGetOnlineWebViewDataByVid(c, vid, miss)
	return
}
