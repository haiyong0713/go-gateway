// Code generated by kratos tool mcgen. DO NOT EDIT.

/*
  Package aggregation is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=aggKey
		CacheAggregation(c context.Context, hotID int64) (*agg.Aggregation, error)
		// mc: -key=aggKey
		CacheAggregations(c context.Context, hotIDs []int64) (map[int64]*agg.Aggregation, error)
		// mc: -key=aggKey -expire=d.aggExpire -encode=json
		AddCacheAggregation(c context.Context, hotID int64, values *agg.Aggregation) error
		// mc: -key=aggKey -expire=d.aggExpire -encode=json
		AddCacheAggregations(c context.Context, hotID map[int64]*agg.Aggregation) error
	}
*/

package show

import (
	"context"
	"fmt"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
	agg "go-gateway/app/app-svr/app-show/interface/model/aggregation"
)

func aggKey(hotID int64) string {
	return fmt.Sprintf(_aggKey, hotID)
}

// CacheAggregation get data from mc
func (d *Dao) CacheAggregation(c context.Context, id int64) (res *agg.Aggregation, err error) {
	key := aggKey(id)
	res = &agg.Aggregation{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheAggregation")
		log.Errorv(c, log.KV("CacheAggregation", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheAggregations get data from mc
func (d *Dao) CacheAggregations(c context.Context, ids []int64) (res map[int64]*agg.Aggregation, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := aggKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheAggregations")
		log.Errorv(c, log.KV("CacheAggregations", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &agg.Aggregation{}
		err = replies.Scan(key, v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheAggregations")
			log.Errorv(c, log.KV("CacheAggregations", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*agg.Aggregation, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheAggregation Set data to mc
func (d *Dao) AddCacheAggregation(c context.Context, id int64, val *agg.Aggregation) (err error) {
	if val == nil {
		return
	}
	key := aggKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.aggExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheAggregation")
		log.Errorv(c, log.KV("AddCacheAggregation", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheAggregations Set data to mc
func (d *Dao) AddCacheAggregations(c context.Context, values map[int64]*agg.Aggregation) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := aggKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.aggExpire, Flags: memcache.FlagJSON}
		if err = d.mc.Set(c, item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheAggregations")
			log.Errorv(c, log.KV("AddCacheAggregations", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}
