// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package dao is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		Close()
		Ping(ctx context.Context) (err error)
		// bts:-struct_name=Dao -nullcache=&model.Goods{Id:-1} -check_null_code=$!=nil&&$.Id==-1
		Goods(c context.Context, id int64) (*model.Goods, error)
		// bts:-struct_name=Dao -nullcache=[]*model.Goods{{Id:-1}} -check_null_code=len($)!=0&&$[0].Id==-1
		GoodsList(c context.Context) ([]*model.Goods, error)
		// bts:-struct_name=Dao -nullcache=&model.Task{Id:-1} -check_null_code=$!=nil&&$.Id==-1
		Task(c context.Context, uid int64) (*model.Task, error)
		// bts:-struct_name=Dao -nullcache=[]*model.Invite{{Uid:-1}} -check_null_code=len($)!=0&&$[0].Uid==-1
		InviteList(c context.Context, uid int64, id int64) ([]*model.Invite, error)
		// bts:-struct_name=Dao -nullcache=[]*model.Task{{Id:-1}} -check_null_code=len($)!=0&&$[0].Id==-1
		PrizeList(c context.Context) ([]*model.Task, error)
		// bts:-struct_name=Dao -nullcache="NULL" -check_null_code="NULL"
		Config(c context.Context, key string) (string, error)
	}
*/

package dao

import (
	"context"

	"go-common/library/cache"
	model "go-gateway/app/web-svr/activity/interface/model/vogue"
)

var _ _bts

// Goods get data from cache if miss will call source method, then add to cache.
func (d *Dao) Goods(c context.Context, id int64) (res *model.Goods, err error) {
	addCache := true
	res, err = d.CacheGoods(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.Id == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:Goods")
		return
	}
	cache.MetricMisses.Inc("bts:Goods")
	res, err = d.RawGoods(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &model.Goods{Id: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheGoods(c, id, miss)
	})
	return
}

// GoodsList get data from cache if miss will call source method, then add to cache.
func (d *Dao) GoodsList(c context.Context) (res []*model.Goods, err error) {
	addCache := true
	res, err = d.CacheGoodsList(c)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) != 0 && res[0].Id == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:GoodsList")
		return
	}
	cache.MetricMisses.Inc("bts:GoodsList")
	res, err = d.RawGoodsList(c)
	if err != nil {
		return
	}
	var miss = res
	if len(miss) == 0 {
		miss = []*model.Goods{{Id: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheGoodsList(c, miss)
	})
	return
}

// Task get data from cache if miss will call source method, then add to cache.
func (d *Dao) Task(c context.Context, uid int64) (res *model.Task, err error) {
	addCache := true
	res, err = d.CacheTask(c, uid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.Id == -1 {
			res = nil
		}
	}()
	if res != nil {
		cache.MetricHits.Inc("bts:Task")
		return
	}
	cache.MetricMisses.Inc("bts:Task")
	res, err = d.RawTask(c, uid)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &model.Task{Id: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheTask(c, uid, miss)
	})
	return
}

// InviteList get data from cache if miss will call source method, then add to cache.
func (d *Dao) InviteList(c context.Context, uid int64, id int64) (res []*model.Invite, err error) {
	addCache := true
	res, err = d.CacheInviteList(c, uid, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) != 0 && res[0].Uid == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:InviteList")
		return
	}
	cache.MetricMisses.Inc("bts:InviteList")
	res, err = d.RawInviteList(c, uid, id)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*model.Invite{{Uid: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheInviteList(c, uid, miss, id)
	})
	return
}

// PrizeList get data from cache if miss will call source method, then add to cache.
func (d *Dao) PrizeList(c context.Context) (res []*model.Task, err error) {
	addCache := true
	res, err = d.CachePrizeList(c)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) != 0 && res[0].Id == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:PrizeList")
		return
	}
	cache.MetricMisses.Inc("bts:PrizeList")
	res, err = d.RawPrizeList(c)
	if err != nil {
		return
	}
	var miss = res
	if len(miss) == 0 {
		miss = []*model.Task{{Id: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCachePrizeList(c, miss)
	})
	return
}

// Config get data from cache if miss will call source method, then add to cache.
func (d *Dao) Config(c context.Context, key string) (res string, err error) {
	addCache := true
	res, err = d.CacheConfig(c, key)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == "NULL" {
			res = ""
		}
	}()
	if res != "" {
		cache.MetricHits.Inc("bts:Config")
		return
	}
	cache.MetricMisses.Inc("bts:Config")
	res, err = d.RawConfig(c, key)
	if err != nil {
		return
	}
	miss := res
	if miss == "" {
		miss = "NULL"
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheConfig(c, key, miss)
	})
	return
}
