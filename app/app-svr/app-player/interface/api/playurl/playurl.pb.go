// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-gateway/app/app-svr/app-player/interface/api/playurl/playurl.proto

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PlayLimitCode int32

const (
	// Unknown
	PlayLimitCode_PLCUnkown PlayLimitCode = 0
	// 合集中稿件未付费
	PlayLimitCode_PLCUgcNotPayed PlayLimitCode = 1
)

var PlayLimitCode_name = map[int32]string{
	0: "PLCUnkown",
	1: "PLCUgcNotPayed",
}

var PlayLimitCode_value = map[string]int32{
	"PLCUnkown":      0,
	"PLCUgcNotPayed": 1,
}

func (x PlayLimitCode) String() string {
	return proto.EnumName(PlayLimitCode_name, int32(x))
}

func (PlayLimitCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{0}
}

type Business int32

const (
	// 未知类型
	Business_UNKNOWN Business = 0
	// story业务
	Business_STORY Business = 1
)

var Business_name = map[int32]string{
	0: "UNKNOWN",
	1: "STORY",
}

var Business_value = map[string]int32{
	"UNKNOWN": 0,
	"STORY":   1,
}

func (x Business) String() string {
	return proto.EnumName(Business_name, int32(x))
}

func (Business) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{1}
}

type CodeType int32

const (
	//default
	CodeType_NOCODE CodeType = 0
	//编码格式 264
	CodeType_CODE264 CodeType = 1
	//编码格式 265
	CodeType_CODE265 CodeType = 2
	//编码格式 av1
	CodeType_CODEAV1 CodeType = 3
)

var CodeType_name = map[int32]string{
	0: "NOCODE",
	1: "CODE264",
	2: "CODE265",
	3: "CODEAV1",
}

var CodeType_value = map[string]int32{
	"NOCODE":  0,
	"CODE264": 1,
	"CODE265": 2,
	"CODEAV1": 3,
}

func (x CodeType) String() string {
	return proto.EnumName(CodeType_name, int32(x))
}

func (CodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{2}
}

type Group int32

const (
	Group_UnknownGroup Group = 0
	Group_A            Group = 1
	Group_B            Group = 2
	Group_C            Group = 3
)

var Group_name = map[int32]string{
	0: "UnknownGroup",
	1: "A",
	2: "B",
	3: "C",
}

var Group_value = map[string]int32{
	"UnknownGroup": 0,
	"A":            1,
	"B":            2,
	"C":            3,
}

func (x Group) String() string {
	return proto.EnumName(Group_name, int32(x))
}

func (Group) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{3}
}

type ConfType int32

const (
	// default
	ConfType_NoType ConfType = 0
	//镜像反转
	ConfType_FLIPCONF ConfType = 1
	//视频投屏
	ConfType_CASTCONF ConfType = 2
	//反馈
	ConfType_FEEDBACK ConfType = 3
	//字幕
	ConfType_SUBTITLE ConfType = 4
	//播放速度
	ConfType_PLAYBACKRATE ConfType = 5
	//定时停止播放
	ConfType_TIMEUP ConfType = 6
	//播放方式
	ConfType_PLAYBACKMODE ConfType = 7
	//画面尺寸
	ConfType_SCALEMODE ConfType = 8
	//后台播放
	ConfType_BACKGROUNDPLAY ConfType = 9
	//顶
	ConfType_LIKE ConfType = 10
	//踩
	ConfType_DISLIKE ConfType = 11
	//投币
	ConfType_COIN ConfType = 12
	//充电
	ConfType_ELEC ConfType = 13
	//分享
	ConfType_SHARE ConfType = 14
	//截图/gif
	ConfType_SCREENSHOT ConfType = 15
	//锁屏
	ConfType_LOCKSCREEN ConfType = 16
	//相关推荐
	ConfType_RECOMMEND ConfType = 17
	//倍速
	ConfType_PLAYBACKSPEED ConfType = 18
	//清晰度
	ConfType_DEFINITION ConfType = 19
	//选集
	ConfType_SELECTIONS ConfType = 20
	//下一集
	ConfType_NEXT ConfType = 21
	//编辑弹幕
	ConfType_EDITDM ConfType = 22
	//小窗
	ConfType_SMALLWINDOW ConfType = 23
	//播放震动
	ConfType_SHAKE ConfType = 24
	//外层面板弹幕设置（实验组1）
	ConfType_OUTERDM ConfType = 25
	//三点内弹幕设置（实验组2）
	ConfType_INNERDM ConfType = 26
	//全景
	ConfType_PANORAMA ConfType = 27
	//杜比
	ConfType_DOLBY ConfType = 28
	//滤镜
	ConfType_COLORFILTER ConfType = 29
	//无损音频
	ConfType_LOSSLESS ConfType = 30
)

var ConfType_name = map[int32]string{
	0:  "NoType",
	1:  "FLIPCONF",
	2:  "CASTCONF",
	3:  "FEEDBACK",
	4:  "SUBTITLE",
	5:  "PLAYBACKRATE",
	6:  "TIMEUP",
	7:  "PLAYBACKMODE",
	8:  "SCALEMODE",
	9:  "BACKGROUNDPLAY",
	10: "LIKE",
	11: "DISLIKE",
	12: "COIN",
	13: "ELEC",
	14: "SHARE",
	15: "SCREENSHOT",
	16: "LOCKSCREEN",
	17: "RECOMMEND",
	18: "PLAYBACKSPEED",
	19: "DEFINITION",
	20: "SELECTIONS",
	21: "NEXT",
	22: "EDITDM",
	23: "SMALLWINDOW",
	24: "SHAKE",
	25: "OUTERDM",
	26: "INNERDM",
	27: "PANORAMA",
	28: "DOLBY",
	29: "COLORFILTER",
	30: "LOSSLESS",
}

var ConfType_value = map[string]int32{
	"NoType":         0,
	"FLIPCONF":       1,
	"CASTCONF":       2,
	"FEEDBACK":       3,
	"SUBTITLE":       4,
	"PLAYBACKRATE":   5,
	"TIMEUP":         6,
	"PLAYBACKMODE":   7,
	"SCALEMODE":      8,
	"BACKGROUNDPLAY": 9,
	"LIKE":           10,
	"DISLIKE":        11,
	"COIN":           12,
	"ELEC":           13,
	"SHARE":          14,
	"SCREENSHOT":     15,
	"LOCKSCREEN":     16,
	"RECOMMEND":      17,
	"PLAYBACKSPEED":  18,
	"DEFINITION":     19,
	"SELECTIONS":     20,
	"NEXT":           21,
	"EDITDM":         22,
	"SMALLWINDOW":    23,
	"SHAKE":          24,
	"OUTERDM":        25,
	"INNERDM":        26,
	"PANORAMA":       27,
	"DOLBY":          28,
	"COLORFILTER":    29,
	"LOSSLESS":       30,
}

func (x ConfType) String() string {
	return proto.EnumName(ConfType_name, int32(x))
}

func (ConfType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{4}
}

type PlayErr int32

const (
	PlayErr_NoErr                   PlayErr = 0
	PlayErr_WithMultiDeviceLoginErr PlayErr = 1
)

var PlayErr_name = map[int32]string{
	0: "NoErr",
	1: "WithMultiDeviceLoginErr",
}

var PlayErr_value = map[string]int32{
	"NoErr":                   0,
	"WithMultiDeviceLoginErr": 1,
}

func (x PlayErr) String() string {
	return proto.EnumName(PlayErr_name, int32(x))
}

func (PlayErr) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{5}
}

type VideoType int32

const (
	VideoType_Unknown VideoType = 0
	VideoType_FLV     VideoType = 1
	VideoType_DASH    VideoType = 2
	VideoType_MP4     VideoType = 3
)

var VideoType_name = map[int32]string{
	0: "Unknown",
	1: "FLV",
	2: "DASH",
	3: "MP4",
}

var VideoType_value = map[string]int32{
	"Unknown": 0,
	"FLV":     1,
	"DASH":    2,
	"MP4":     3,
}

func (x VideoType) String() string {
	return proto.EnumName(VideoType_name, int32(x))
}

func (VideoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{6}
}

type DolbyItem_Type int32

const (
	// NONE
	DolbyItem_NONE DolbyItem_Type = 0
	// 普通杜比音效
	DolbyItem_COMMON DolbyItem_Type = 1
	// 全景杜比音效
	DolbyItem_ATMOS DolbyItem_Type = 2
)

var DolbyItem_Type_name = map[int32]string{
	0: "NONE",
	1: "COMMON",
	2: "ATMOS",
}

var DolbyItem_Type_value = map[string]int32{
	"NONE":   0,
	"COMMON": 1,
	"ATMOS":  2,
}

func (x DolbyItem_Type) String() string {
	return proto.EnumName(DolbyItem_Type_name, int32(x))
}

func (DolbyItem_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{30, 0}
}

// PlayURLReq 播放地址请求参数
type PlayURLReq struct {
	// aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty" validate:"gt=0,required"`
	// cid
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty" validate:"gt=0,required"`
	// qn清晰度
	Qn int64 `protobuf:"varint,3,opt,name=qn,proto3" json:"qn,omitempty"`
	// fnver和fnval标识视频格式
	Fnver int32 `protobuf:"varint,4,opt,name=fnver,proto3" json:"fnver,omitempty"`
	// fnver和fnval标识视频格式
	Fnval int32 `protobuf:"varint,5,opt,name=fnval,proto3" json:"fnval,omitempty"`
	// 下载参数 0-非下载 1-下载flv 2-下载dash
	Download uint32 `protobuf:"varint,6,opt,name=download,proto3" json:"download,omitempty"`
	// 返回url是否强制使用域名(非ip地址), 1-http域名 2-https域名
	ForceHost int32 `protobuf:"varint,7,opt,name=force_host,json=forceHost,proto3" json:"force_host,omitempty"`
	// 是否需要4k清晰度
	Fourk bool `protobuf:"varint,8,opt,name=fourk,proto3" json:"fourk,omitempty"`
	// spmid 当前页面
	Spmid string `protobuf:"bytes,9,opt,name=spmid,proto3" json:"spmid,omitempty"`
	// from_spmid 上级页面
	FromSpmid string `protobuf:"bytes,10,opt,name=from_spmid,json=fromSpmid,proto3" json:"from_spmid,omitempty"`
	//是否开启音量均衡，1开启
	VoiceBalance         int64    `protobuf:"varint,11,opt,name=voice_balance,json=voiceBalance,proto3" json:"voice_balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayURLReq) Reset()         { *m = PlayURLReq{} }
func (m *PlayURLReq) String() string { return proto.CompactTextString(m) }
func (*PlayURLReq) ProtoMessage()    {}
func (*PlayURLReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{0}
}
func (m *PlayURLReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayURLReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayURLReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayURLReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayURLReq.Merge(m, src)
}
func (m *PlayURLReq) XXX_Size() int {
	return m.Size()
}
func (m *PlayURLReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayURLReq.DiscardUnknown(m)
}

var xxx_messageInfo_PlayURLReq proto.InternalMessageInfo

func (m *PlayURLReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *PlayURLReq) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *PlayURLReq) GetQn() int64 {
	if m != nil {
		return m.Qn
	}
	return 0
}

func (m *PlayURLReq) GetFnver() int32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *PlayURLReq) GetFnval() int32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *PlayURLReq) GetDownload() uint32 {
	if m != nil {
		return m.Download
	}
	return 0
}

func (m *PlayURLReq) GetForceHost() int32 {
	if m != nil {
		return m.ForceHost
	}
	return 0
}

func (m *PlayURLReq) GetFourk() bool {
	if m != nil {
		return m.Fourk
	}
	return false
}

func (m *PlayURLReq) GetSpmid() string {
	if m != nil {
		return m.Spmid
	}
	return ""
}

func (m *PlayURLReq) GetFromSpmid() string {
	if m != nil {
		return m.FromSpmid
	}
	return ""
}

func (m *PlayURLReq) GetVoiceBalance() int64 {
	if m != nil {
		return m.VoiceBalance
	}
	return 0
}

// PlayURLReply 播放地址返回结果
type PlayURLReply struct {
	//返回视频的清晰度
	Quality uint32 `protobuf:"varint,1,opt,name=quality,proto3" json:"quality,omitempty"`
	//返回视频的格式
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	//返回视频的总时长, 单位为ms
	Timelength uint64 `protobuf:"varint,3,opt,name=timelength,proto3" json:"timelength,omitempty"`
	//返回视频的编码号
	VideoCodecid uint32 `protobuf:"varint,4,opt,name=video_codecid,json=videoCodecid,proto3" json:"video_codecid,omitempty"`
	//透传返回请求的fnver
	Fnver uint32 `protobuf:"varint,5,opt,name=fnver,proto3" json:"fnver,omitempty"`
	//透传返回请求的fnval
	Fnval uint32 `protobuf:"varint,6,opt,name=fnval,proto3" json:"fnval,omitempty"`
	//返回视频的是否支持投影
	VideoProject bool `protobuf:"varint,7,opt,name=video_project,json=videoProject,proto3" json:"video_project,omitempty"`
	//返回视频播放url的列表，有durl则没dash字段
	Durl []*ResponseUrl `protobuf:"bytes,8,rep,name=durl,proto3" json:"durl,omitempty"`
	//返回DASH视频的MPD格式文件,有dash则没durl字段
	Dash *ResponseDash `protobuf:"bytes,9,opt,name=dash,proto3" json:"dash,omitempty"`
	//表示cid是否非全二压，1表示非全二压
	NoRexcode int32 `protobuf:"varint,10,opt,name=no_rexcode,json=noRexcode,proto3" json:"no_rexcode,omitempty"`
	//互动视频升级提示
	UpgradeLimit *UpgradeLimit `protobuf:"bytes,11,opt,name=upgrade_limit,json=upgradeLimit,proto3" json:"upgrade_limit,omitempty"`
	//返回视频的拥有的清晰度描述的列表
	SupportFormats []*FormatDescription `protobuf:"bytes,12,rep,name=support_formats,json=supportFormats,proto3" json:"support_formats,omitempty"`
	//视频类型 1-flv 2-dash 3-mp4（只标识一个清晰度的格式）
	Type VideoType `protobuf:"varint,13,opt,name=type,proto3,enum=bilibili.app.playurl.v1.VideoType" json:"type,omitempty"`
	//音量均衡信息
	Volume               *VolumeInfo `protobuf:"bytes,14,opt,name=volume,proto3" json:"volume,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PlayURLReply) Reset()         { *m = PlayURLReply{} }
func (m *PlayURLReply) String() string { return proto.CompactTextString(m) }
func (*PlayURLReply) ProtoMessage()    {}
func (*PlayURLReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{1}
}
func (m *PlayURLReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayURLReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayURLReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayURLReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayURLReply.Merge(m, src)
}
func (m *PlayURLReply) XXX_Size() int {
	return m.Size()
}
func (m *PlayURLReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayURLReply.DiscardUnknown(m)
}

var xxx_messageInfo_PlayURLReply proto.InternalMessageInfo

func (m *PlayURLReply) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *PlayURLReply) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *PlayURLReply) GetTimelength() uint64 {
	if m != nil {
		return m.Timelength
	}
	return 0
}

func (m *PlayURLReply) GetVideoCodecid() uint32 {
	if m != nil {
		return m.VideoCodecid
	}
	return 0
}

func (m *PlayURLReply) GetFnver() uint32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *PlayURLReply) GetFnval() uint32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *PlayURLReply) GetVideoProject() bool {
	if m != nil {
		return m.VideoProject
	}
	return false
}

func (m *PlayURLReply) GetDurl() []*ResponseUrl {
	if m != nil {
		return m.Durl
	}
	return nil
}

func (m *PlayURLReply) GetDash() *ResponseDash {
	if m != nil {
		return m.Dash
	}
	return nil
}

func (m *PlayURLReply) GetNoRexcode() int32 {
	if m != nil {
		return m.NoRexcode
	}
	return 0
}

func (m *PlayURLReply) GetUpgradeLimit() *UpgradeLimit {
	if m != nil {
		return m.UpgradeLimit
	}
	return nil
}

func (m *PlayURLReply) GetSupportFormats() []*FormatDescription {
	if m != nil {
		return m.SupportFormats
	}
	return nil
}

func (m *PlayURLReply) GetType() VideoType {
	if m != nil {
		return m.Type
	}
	return VideoType_Unknown
}

func (m *PlayURLReply) GetVolume() *VolumeInfo {
	if m != nil {
		return m.Volume
	}
	return nil
}

// ResponseUrl flv url信息
type ResponseUrl struct {
	//视频的分片序列号
	Order uint32 `protobuf:"varint,1,opt,name=order,proto3" json:"order,omitempty"`
	//视频分片的时长, 单位ms
	Length uint64 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	//视频分片的大小, 单位Byte
	Size_ uint64 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	//视频分片的url地址
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	//视频分片的备用url地址列表
	BackupUrl []string `protobuf:"bytes,5,rep,name=backup_url,json=backupUrl,proto3" json:"backup_url,omitempty"`
	//视频分片的md5,只有离线下载才有值
	Md5                  string   `protobuf:"bytes,6,opt,name=md5,proto3" json:"md5,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseUrl) Reset()         { *m = ResponseUrl{} }
func (m *ResponseUrl) String() string { return proto.CompactTextString(m) }
func (*ResponseUrl) ProtoMessage()    {}
func (*ResponseUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{2}
}
func (m *ResponseUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseUrl.Merge(m, src)
}
func (m *ResponseUrl) XXX_Size() int {
	return m.Size()
}
func (m *ResponseUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseUrl.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseUrl proto.InternalMessageInfo

func (m *ResponseUrl) GetOrder() uint32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *ResponseUrl) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ResponseUrl) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ResponseUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ResponseUrl) GetBackupUrl() []string {
	if m != nil {
		return m.BackupUrl
	}
	return nil
}

func (m *ResponseUrl) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

// ResponseDash dash信息
type ResponseDash struct {
	//dash视频信息
	Video []*DashItem `protobuf:"bytes,1,rep,name=video,proto3" json:"video,omitempty"`
	//dash视频信息
	Audio                []*DashItem `protobuf:"bytes,2,rep,name=audio,proto3" json:"audio,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ResponseDash) Reset()         { *m = ResponseDash{} }
func (m *ResponseDash) String() string { return proto.CompactTextString(m) }
func (*ResponseDash) ProtoMessage()    {}
func (*ResponseDash) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{3}
}
func (m *ResponseDash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseDash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseDash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseDash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseDash.Merge(m, src)
}
func (m *ResponseDash) XXX_Size() int {
	return m.Size()
}
func (m *ResponseDash) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseDash.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseDash proto.InternalMessageInfo

func (m *ResponseDash) GetVideo() []*DashItem {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *ResponseDash) GetAudio() []*DashItem {
	if m != nil {
		return m.Audio
	}
	return nil
}

// DashItem dash具体信息
type DashItem struct {
	//dash的清晰度
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	//dash的url地址
	BaseUrl string `protobuf:"bytes,2,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	//dash的backup url地址
	BackupUrl []string `protobuf:"bytes,3,rep,name=backup_url,json=backupUrl,proto3" json:"backup_url,omitempty"`
	//dash的信息
	Bandwidth uint32 `protobuf:"varint,4,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	//dash的信息
	Codecid uint32 `protobuf:"varint,5,opt,name=codecid,proto3" json:"codecid,omitempty"`
	//视频分片的md5,只有dash离线下载才有值
	Md5 string `protobuf:"bytes,6,opt,name=md5,proto3" json:"md5,omitempty"`
	//视频分片的大小, 单位Byte,只有dash离线下载才有值
	Size_ uint64 `protobuf:"varint,7,opt,name=size,proto3" json:"size,omitempty"`
	//dash的信息
	FrameRate            string   `protobuf:"bytes,8,opt,name=frame_rate,json=frameRate,proto3" json:"frame_rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DashItem) Reset()         { *m = DashItem{} }
func (m *DashItem) String() string { return proto.CompactTextString(m) }
func (*DashItem) ProtoMessage()    {}
func (*DashItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{4}
}
func (m *DashItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DashItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DashItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DashItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DashItem.Merge(m, src)
}
func (m *DashItem) XXX_Size() int {
	return m.Size()
}
func (m *DashItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DashItem.DiscardUnknown(m)
}

var xxx_messageInfo_DashItem proto.InternalMessageInfo

func (m *DashItem) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DashItem) GetBaseUrl() string {
	if m != nil {
		return m.BaseUrl
	}
	return ""
}

func (m *DashItem) GetBackupUrl() []string {
	if m != nil {
		return m.BackupUrl
	}
	return nil
}

func (m *DashItem) GetBandwidth() uint32 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *DashItem) GetCodecid() uint32 {
	if m != nil {
		return m.Codecid
	}
	return 0
}

func (m *DashItem) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *DashItem) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *DashItem) GetFrameRate() string {
	if m != nil {
		return m.FrameRate
	}
	return ""
}

// PlayLimit 播放限制信息
type PlayLimit struct {
	//错误码
	Code PlayLimitCode `protobuf:"varint,1,opt,name=code,proto3,enum=bilibili.app.playurl.v1.PlayLimitCode" json:"code,omitempty"`
	//错误信息
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	//副文案
	SubMessage string `protobuf:"bytes,3,opt,name=sub_message,json=subMessage,proto3" json:"sub_message,omitempty"`
	//按钮信息
	Button               *ButtonStyle `protobuf:"bytes,4,opt,name=button,proto3" json:"button,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PlayLimit) Reset()         { *m = PlayLimit{} }
func (m *PlayLimit) String() string { return proto.CompactTextString(m) }
func (*PlayLimit) ProtoMessage()    {}
func (*PlayLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{5}
}
func (m *PlayLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayLimit.Merge(m, src)
}
func (m *PlayLimit) XXX_Size() int {
	return m.Size()
}
func (m *PlayLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayLimit.DiscardUnknown(m)
}

var xxx_messageInfo_PlayLimit proto.InternalMessageInfo

func (m *PlayLimit) GetCode() PlayLimitCode {
	if m != nil {
		return m.Code
	}
	return PlayLimitCode_PLCUnkown
}

func (m *PlayLimit) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PlayLimit) GetSubMessage() string {
	if m != nil {
		return m.SubMessage
	}
	return ""
}

func (m *PlayLimit) GetButton() *ButtonStyle {
	if m != nil {
		return m.Button
	}
	return nil
}

type ButtonStyle struct {
	//按钮文案
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	//按钮字体色值
	TextColor string `protobuf:"bytes,2,opt,name=text_color,json=textColor,proto3" json:"text_color,omitempty"`
	//按钮背景色
	BgColor string `protobuf:"bytes,3,opt,name=bg_color,json=bgColor,proto3" json:"bg_color,omitempty"`
	//链接 为空表示不下发 不为空表示下发
	JumpLink             string   `protobuf:"bytes,4,opt,name=jump_link,json=jumpLink,proto3" json:"jump_link,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ButtonStyle) Reset()         { *m = ButtonStyle{} }
func (m *ButtonStyle) String() string { return proto.CompactTextString(m) }
func (*ButtonStyle) ProtoMessage()    {}
func (*ButtonStyle) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{6}
}
func (m *ButtonStyle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonStyle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonStyle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ButtonStyle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonStyle.Merge(m, src)
}
func (m *ButtonStyle) XXX_Size() int {
	return m.Size()
}
func (m *ButtonStyle) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonStyle.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonStyle proto.InternalMessageInfo

func (m *ButtonStyle) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ButtonStyle) GetTextColor() string {
	if m != nil {
		return m.TextColor
	}
	return ""
}

func (m *ButtonStyle) GetBgColor() string {
	if m != nil {
		return m.BgColor
	}
	return ""
}

func (m *ButtonStyle) GetJumpLink() string {
	if m != nil {
		return m.JumpLink
	}
	return ""
}

// UpgradeLimit 互动视频升级信息
type UpgradeLimit struct {
	//错误码
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	//错误信息
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	//图片
	Image string `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	//升级按钮信息
	Button               *UpgradeButton `protobuf:"bytes,4,opt,name=button,proto3" json:"button,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpgradeLimit) Reset()         { *m = UpgradeLimit{} }
func (m *UpgradeLimit) String() string { return proto.CompactTextString(m) }
func (*UpgradeLimit) ProtoMessage()    {}
func (*UpgradeLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{7}
}
func (m *UpgradeLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeLimit.Merge(m, src)
}
func (m *UpgradeLimit) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeLimit.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeLimit proto.InternalMessageInfo

func (m *UpgradeLimit) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UpgradeLimit) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *UpgradeLimit) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *UpgradeLimit) GetButton() *UpgradeButton {
	if m != nil {
		return m.Button
	}
	return nil
}

// UpgradeButton 互动视频升级按钮信息
type UpgradeButton struct {
	//标题
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	//链接
	Link                 string   `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpgradeButton) Reset()         { *m = UpgradeButton{} }
func (m *UpgradeButton) String() string { return proto.CompactTextString(m) }
func (*UpgradeButton) ProtoMessage()    {}
func (*UpgradeButton) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{8}
}
func (m *UpgradeButton) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeButton) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeButton.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeButton) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeButton.Merge(m, src)
}
func (m *UpgradeButton) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeButton) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeButton.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeButton proto.InternalMessageInfo

func (m *UpgradeButton) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *UpgradeButton) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

type FormatDescription struct {
	//清晰度qn
	Quality uint32 `protobuf:"varint,1,opt,name=quality,proto3" json:"quality,omitempty"`
	//清晰度格式
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	//清晰度描述
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	//6.9版本开始新描述
	NewDescription string `protobuf:"bytes,4,opt,name=new_description,json=newDescription,proto3" json:"new_description,omitempty"`
	//选中态的清晰度描述
	DisplayDesc string `protobuf:"bytes,5,opt,name=display_desc,json=displayDesc,proto3" json:"display_desc,omitempty"`
	//选中态的清晰度描述的角标
	Superscript          string   `protobuf:"bytes,6,opt,name=superscript,proto3" json:"superscript,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FormatDescription) Reset()         { *m = FormatDescription{} }
func (m *FormatDescription) String() string { return proto.CompactTextString(m) }
func (*FormatDescription) ProtoMessage()    {}
func (*FormatDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{9}
}
func (m *FormatDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FormatDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FormatDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FormatDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FormatDescription.Merge(m, src)
}
func (m *FormatDescription) XXX_Size() int {
	return m.Size()
}
func (m *FormatDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_FormatDescription.DiscardUnknown(m)
}

var xxx_messageInfo_FormatDescription proto.InternalMessageInfo

func (m *FormatDescription) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *FormatDescription) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FormatDescription) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FormatDescription) GetNewDescription() string {
	if m != nil {
		return m.NewDescription
	}
	return ""
}

func (m *FormatDescription) GetDisplayDesc() string {
	if m != nil {
		return m.DisplayDesc
	}
	return ""
}

func (m *FormatDescription) GetSuperscript() string {
	if m != nil {
		return m.Superscript
	}
	return ""
}

// ProjectReq 投屏地址请求参数
type ProjectReq struct {
	// aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty" validate:"gt=0,required"`
	// cid
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty" validate:"gt=0,required"`
	// qn清晰度
	Qn int64 `protobuf:"varint,3,opt,name=qn,proto3" json:"qn,omitempty"`
	// fnver和fnval标识视频格式
	Fnver int32 `protobuf:"varint,4,opt,name=fnver,proto3" json:"fnver,omitempty"`
	// fnver和fnval标识视频格式
	Fnval int32 `protobuf:"varint,5,opt,name=fnval,proto3" json:"fnval,omitempty"`
	// 下载参数 0-非下载 1-下载flv 2-下载dash
	Download uint32 `protobuf:"varint,6,opt,name=download,proto3" json:"download,omitempty"`
	// 返回url是否强制使用域名(非ip地址), 1-http域名 2-https域名
	ForceHost int32 `protobuf:"varint,7,opt,name=force_host,json=forceHost,proto3" json:"force_host,omitempty"`
	// 是否需要4k清晰度
	Fourk bool `protobuf:"varint,8,opt,name=fourk,proto3" json:"fourk,omitempty"`
	// spmid 当前页面
	Spmid string `protobuf:"bytes,9,opt,name=spmid,proto3" json:"spmid,omitempty"`
	// from_spmid 上级页面
	FromSpmid string `protobuf:"bytes,10,opt,name=from_spmid,json=fromSpmid,proto3" json:"from_spmid,omitempty"`
	// 使用协议 默认乐播=0，自建协议=1，云投屏=2，3=airplay
	Protocol int32 `protobuf:"varint,11,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// 投屏设备 默认其他=0，OTT设备=1
	DeviceType           int32    `protobuf:"varint,12,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProjectReq) Reset()         { *m = ProjectReq{} }
func (m *ProjectReq) String() string { return proto.CompactTextString(m) }
func (*ProjectReq) ProtoMessage()    {}
func (*ProjectReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{10}
}
func (m *ProjectReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectReq.Merge(m, src)
}
func (m *ProjectReq) XXX_Size() int {
	return m.Size()
}
func (m *ProjectReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectReq.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectReq proto.InternalMessageInfo

func (m *ProjectReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ProjectReq) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *ProjectReq) GetQn() int64 {
	if m != nil {
		return m.Qn
	}
	return 0
}

func (m *ProjectReq) GetFnver() int32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *ProjectReq) GetFnval() int32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *ProjectReq) GetDownload() uint32 {
	if m != nil {
		return m.Download
	}
	return 0
}

func (m *ProjectReq) GetForceHost() int32 {
	if m != nil {
		return m.ForceHost
	}
	return 0
}

func (m *ProjectReq) GetFourk() bool {
	if m != nil {
		return m.Fourk
	}
	return false
}

func (m *ProjectReq) GetSpmid() string {
	if m != nil {
		return m.Spmid
	}
	return ""
}

func (m *ProjectReq) GetFromSpmid() string {
	if m != nil {
		return m.FromSpmid
	}
	return ""
}

func (m *ProjectReq) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *ProjectReq) GetDeviceType() int32 {
	if m != nil {
		return m.DeviceType
	}
	return 0
}

// ProjectReply 投屏地址返回结果
type ProjectReply struct {
	//投屏播放地址
	Project              *PlayURLReply `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ProjectReply) Reset()         { *m = ProjectReply{} }
func (m *ProjectReply) String() string { return proto.CompactTextString(m) }
func (*ProjectReply) ProtoMessage()    {}
func (*ProjectReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{11}
}
func (m *ProjectReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectReply.Merge(m, src)
}
func (m *ProjectReply) XXX_Size() int {
	return m.Size()
}
func (m *ProjectReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectReply.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectReply proto.InternalMessageInfo

func (m *ProjectReply) GetProject() *PlayURLReply {
	if m != nil {
		return m.Project
	}
	return nil
}

// PlayViewReq 播放view请求参数
type PlayViewReq struct {
	// aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty" validate:"gt=0,required"`
	// cid
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty" validate:"gt=0,required"`
	// qn清晰度
	Qn int64 `protobuf:"varint,3,opt,name=qn,proto3" json:"qn,omitempty"`
	// fnver和fnval标识视频格式
	Fnver int32 `protobuf:"varint,4,opt,name=fnver,proto3" json:"fnver,omitempty"`
	// fnver和fnval标识视频格式
	Fnval int32 `protobuf:"varint,5,opt,name=fnval,proto3" json:"fnval,omitempty"`
	// 下载参数 0-非下载 1-下载flv 2-下载dash
	Download uint32 `protobuf:"varint,6,opt,name=download,proto3" json:"download,omitempty"`
	// 返回url是否强制使用域名(非ip地址), 1-http域名 2-https域名
	ForceHost int32 `protobuf:"varint,7,opt,name=force_host,json=forceHost,proto3" json:"force_host,omitempty"`
	// 是否需要4k清晰度
	Fourk bool `protobuf:"varint,8,opt,name=fourk,proto3" json:"fourk,omitempty"`
	// spmid 当前页面
	Spmid string `protobuf:"bytes,9,opt,name=spmid,proto3" json:"spmid,omitempty"`
	// from_spmid 上级页面
	FromSpmid string `protobuf:"bytes,10,opt,name=from_spmid,json=fromSpmid,proto3" json:"from_spmid,omitempty"`
	// 青少年模式
	TeenagersMode int32 `protobuf:"varint,11,opt,name=teenagers_mode,json=teenagersMode,proto3" json:"teenagers_mode,omitempty"`
	// 优先返回视频格式(h264 ,h265)
	PreferCodecType CodeType `protobuf:"varint,12,opt,name=prefer_codec_type,json=preferCodecType,proto3,enum=bilibili.app.playurl.v1.CodeType" json:"prefer_codec_type,omitempty"`
	// 业务类型
	Business Business `protobuf:"varint,13,opt,name=business,proto3,enum=bilibili.app.playurl.v1.Business" json:"business,omitempty"`
	//是否开启音量均衡，1开启
	VoiceBalance         int64    `protobuf:"varint,14,opt,name=voice_balance,json=voiceBalance,proto3" json:"voice_balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayViewReq) Reset()         { *m = PlayViewReq{} }
func (m *PlayViewReq) String() string { return proto.CompactTextString(m) }
func (*PlayViewReq) ProtoMessage()    {}
func (*PlayViewReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{12}
}
func (m *PlayViewReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayViewReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayViewReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayViewReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayViewReq.Merge(m, src)
}
func (m *PlayViewReq) XXX_Size() int {
	return m.Size()
}
func (m *PlayViewReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayViewReq.DiscardUnknown(m)
}

var xxx_messageInfo_PlayViewReq proto.InternalMessageInfo

func (m *PlayViewReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *PlayViewReq) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *PlayViewReq) GetQn() int64 {
	if m != nil {
		return m.Qn
	}
	return 0
}

func (m *PlayViewReq) GetFnver() int32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *PlayViewReq) GetFnval() int32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *PlayViewReq) GetDownload() uint32 {
	if m != nil {
		return m.Download
	}
	return 0
}

func (m *PlayViewReq) GetForceHost() int32 {
	if m != nil {
		return m.ForceHost
	}
	return 0
}

func (m *PlayViewReq) GetFourk() bool {
	if m != nil {
		return m.Fourk
	}
	return false
}

func (m *PlayViewReq) GetSpmid() string {
	if m != nil {
		return m.Spmid
	}
	return ""
}

func (m *PlayViewReq) GetFromSpmid() string {
	if m != nil {
		return m.FromSpmid
	}
	return ""
}

func (m *PlayViewReq) GetTeenagersMode() int32 {
	if m != nil {
		return m.TeenagersMode
	}
	return 0
}

func (m *PlayViewReq) GetPreferCodecType() CodeType {
	if m != nil {
		return m.PreferCodecType
	}
	return CodeType_NOCODE
}

func (m *PlayViewReq) GetBusiness() Business {
	if m != nil {
		return m.Business
	}
	return Business_UNKNOWN
}

func (m *PlayViewReq) GetVoiceBalance() int64 {
	if m != nil {
		return m.VoiceBalance
	}
	return 0
}

// PlayViewReply 播放页返回结果
type PlayViewReply struct {
	// play基础信息
	VideoInfo *VideoInfo `protobuf:"bytes,1,opt,name=video_info,json=videoInfo,proto3" json:"video_info,omitempty"`
	//云控配置信息-用户维度
	PlayConf *PlayAbilityConf `protobuf:"bytes,2,opt,name=play_conf,json=playConf,proto3" json:"play_conf,omitempty"`
	//互动视频升级提示
	UpgradeLimit *UpgradeLimit `protobuf:"bytes,3,opt,name=upgrade_limit,json=upgradeLimit,proto3" json:"upgrade_limit,omitempty"`
	// Chronos灰度管理（6.6版本开始不返回，已迁移到ViewProgress接口）
	Chronos *Chronos `protobuf:"bytes,4,opt,name=chronos,proto3" json:"chronos,omitempty"`
	//云控是否可用配置-稿件维度
	PlayArc *PlayArcConf `protobuf:"bytes,5,opt,name=play_arc,json=playArc,proto3" json:"play_arc,omitempty"`
	//播放事件
	Event *Event `protobuf:"bytes,6,opt,name=event,proto3" json:"event,omitempty"`
	//ab实验相关的逻辑
	Ab *AB `protobuf:"bytes,7,opt,name=ab,proto3" json:"ab,omitempty"`
	//播放限制提示
	PlayLimit            *PlayLimit `protobuf:"bytes,8,opt,name=play_limit,json=playLimit,proto3" json:"play_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PlayViewReply) Reset()         { *m = PlayViewReply{} }
func (m *PlayViewReply) String() string { return proto.CompactTextString(m) }
func (*PlayViewReply) ProtoMessage()    {}
func (*PlayViewReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{13}
}
func (m *PlayViewReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayViewReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayViewReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayViewReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayViewReply.Merge(m, src)
}
func (m *PlayViewReply) XXX_Size() int {
	return m.Size()
}
func (m *PlayViewReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayViewReply.DiscardUnknown(m)
}

var xxx_messageInfo_PlayViewReply proto.InternalMessageInfo

func (m *PlayViewReply) GetVideoInfo() *VideoInfo {
	if m != nil {
		return m.VideoInfo
	}
	return nil
}

func (m *PlayViewReply) GetPlayConf() *PlayAbilityConf {
	if m != nil {
		return m.PlayConf
	}
	return nil
}

func (m *PlayViewReply) GetUpgradeLimit() *UpgradeLimit {
	if m != nil {
		return m.UpgradeLimit
	}
	return nil
}

func (m *PlayViewReply) GetChronos() *Chronos {
	if m != nil {
		return m.Chronos
	}
	return nil
}

func (m *PlayViewReply) GetPlayArc() *PlayArcConf {
	if m != nil {
		return m.PlayArc
	}
	return nil
}

func (m *PlayViewReply) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *PlayViewReply) GetAb() *AB {
	if m != nil {
		return m.Ab
	}
	return nil
}

func (m *PlayViewReply) GetPlayLimit() *PlayLimit {
	if m != nil {
		return m.PlayLimit
	}
	return nil
}

// 音量均衡信息
type VolumeInfo struct {
	MeasuredI            float64  `protobuf:"fixed64,1,opt,name=measured_i,json=measuredI,proto3" json:"measured_i,omitempty"`
	MeasuredLra          float64  `protobuf:"fixed64,2,opt,name=measured_lra,json=measuredLra,proto3" json:"measured_lra,omitempty"`
	MeasuredTp           float64  `protobuf:"fixed64,3,opt,name=measured_tp,json=measuredTp,proto3" json:"measured_tp,omitempty"`
	MeasuredThreshold    float64  `protobuf:"fixed64,4,opt,name=measured_threshold,json=measuredThreshold,proto3" json:"measured_threshold,omitempty"`
	TargetOffset         float64  `protobuf:"fixed64,5,opt,name=target_offset,json=targetOffset,proto3" json:"target_offset,omitempty"`
	TargetI              float64  `protobuf:"fixed64,6,opt,name=target_i,json=targetI,proto3" json:"target_i,omitempty"`
	TargetTp             float64  `protobuf:"fixed64,7,opt,name=target_tp,json=targetTp,proto3" json:"target_tp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeInfo) Reset()         { *m = VolumeInfo{} }
func (m *VolumeInfo) String() string { return proto.CompactTextString(m) }
func (*VolumeInfo) ProtoMessage()    {}
func (*VolumeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{14}
}
func (m *VolumeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeInfo.Merge(m, src)
}
func (m *VolumeInfo) XXX_Size() int {
	return m.Size()
}
func (m *VolumeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeInfo proto.InternalMessageInfo

func (m *VolumeInfo) GetMeasuredI() float64 {
	if m != nil {
		return m.MeasuredI
	}
	return 0
}

func (m *VolumeInfo) GetMeasuredLra() float64 {
	if m != nil {
		return m.MeasuredLra
	}
	return 0
}

func (m *VolumeInfo) GetMeasuredTp() float64 {
	if m != nil {
		return m.MeasuredTp
	}
	return 0
}

func (m *VolumeInfo) GetMeasuredThreshold() float64 {
	if m != nil {
		return m.MeasuredThreshold
	}
	return 0
}

func (m *VolumeInfo) GetTargetOffset() float64 {
	if m != nil {
		return m.TargetOffset
	}
	return 0
}

func (m *VolumeInfo) GetTargetI() float64 {
	if m != nil {
		return m.TargetI
	}
	return 0
}

func (m *VolumeInfo) GetTargetTp() float64 {
	if m != nil {
		return m.TargetTp
	}
	return 0
}

type AB struct {
	Glance               *Glance  `protobuf:"bytes,1,opt,name=glance,proto3" json:"glance,omitempty"`
	Group                Group    `protobuf:"varint,2,opt,name=group,proto3,enum=bilibili.app.playurl.v1.Group" json:"group,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AB) Reset()         { *m = AB{} }
func (m *AB) String() string { return proto.CompactTextString(m) }
func (*AB) ProtoMessage()    {}
func (*AB) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{15}
}
func (m *AB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AB.Merge(m, src)
}
func (m *AB) XXX_Size() int {
	return m.Size()
}
func (m *AB) XXX_DiscardUnknown() {
	xxx_messageInfo_AB.DiscardUnknown(m)
}

var xxx_messageInfo_AB proto.InternalMessageInfo

func (m *AB) GetGlance() *Glance {
	if m != nil {
		return m.Glance
	}
	return nil
}

func (m *AB) GetGroup() Group {
	if m != nil {
		return m.Group
	}
	return Group_UnknownGroup
}

type Glance struct {
	//能否试看(包括:视频有除杜比外大会员清晰度且时长大于2min,登录用户且非大会员，命中ab实验B，C组)
	CanWatch bool `protobuf:"varint,1,opt,name=can_watch,json=canWatch,proto3" json:"can_watch,omitempty"`
	//试看次数
	Times int64 `protobuf:"varint,2,opt,name=times,proto3" json:"times,omitempty"`
	//试看时长
	Duration             int64    `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Glance) Reset()         { *m = Glance{} }
func (m *Glance) String() string { return proto.CompactTextString(m) }
func (*Glance) ProtoMessage()    {}
func (*Glance) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{16}
}
func (m *Glance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Glance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Glance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Glance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Glance.Merge(m, src)
}
func (m *Glance) XXX_Size() int {
	return m.Size()
}
func (m *Glance) XXX_DiscardUnknown() {
	xxx_messageInfo_Glance.DiscardUnknown(m)
}

var xxx_messageInfo_Glance proto.InternalMessageInfo

func (m *Glance) GetCanWatch() bool {
	if m != nil {
		return m.CanWatch
	}
	return false
}

func (m *Glance) GetTimes() int64 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *Glance) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// Event is
type Event struct {
	// 震动事件
	Shake                *Shake   `protobuf:"bytes,1,opt,name=shake,proto3" json:"shake,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{17}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetShake() *Shake {
	if m != nil {
		return m.Shake
	}
	return nil
}

// Shake Event
type Shake struct {
	//文件地址
	File                 string   `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Shake) Reset()         { *m = Shake{} }
func (m *Shake) String() string { return proto.CompactTextString(m) }
func (*Shake) ProtoMessage()    {}
func (*Shake) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{18}
}
func (m *Shake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shake.Merge(m, src)
}
func (m *Shake) XXX_Size() int {
	return m.Size()
}
func (m *Shake) XXX_DiscardUnknown() {
	xxx_messageInfo_Shake.DiscardUnknown(m)
}

var xxx_messageInfo_Shake proto.InternalMessageInfo

func (m *Shake) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

// PlayConfReq 控制面板信息req
type PlayConfReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayConfReq) Reset()         { *m = PlayConfReq{} }
func (m *PlayConfReq) String() string { return proto.CompactTextString(m) }
func (*PlayConfReq) ProtoMessage()    {}
func (*PlayConfReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{19}
}
func (m *PlayConfReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayConfReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayConfReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayConfReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayConfReq.Merge(m, src)
}
func (m *PlayConfReq) XXX_Size() int {
	return m.Size()
}
func (m *PlayConfReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayConfReq.DiscardUnknown(m)
}

var xxx_messageInfo_PlayConfReq proto.InternalMessageInfo

// PlayConfReply 控制面板信息reply
type PlayConfReply struct {
	//云控配置信息
	PlayConf             *PlayAbilityConf `protobuf:"bytes,1,opt,name=play_conf,json=playConf,proto3" json:"play_conf,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PlayConfReply) Reset()         { *m = PlayConfReply{} }
func (m *PlayConfReply) String() string { return proto.CompactTextString(m) }
func (*PlayConfReply) ProtoMessage()    {}
func (*PlayConfReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{20}
}
func (m *PlayConfReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayConfReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayConfReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayConfReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayConfReply.Merge(m, src)
}
func (m *PlayConfReply) XXX_Size() int {
	return m.Size()
}
func (m *PlayConfReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayConfReply.DiscardUnknown(m)
}

var xxx_messageInfo_PlayConfReply proto.InternalMessageInfo

func (m *PlayConfReply) GetPlayConf() *PlayAbilityConf {
	if m != nil {
		return m.PlayConf
	}
	return nil
}

// Chronos灰度管理
type Chronos struct {
	//唯一标志
	Md5 string `protobuf:"bytes,1,opt,name=md5,proto3" json:"md5,omitempty"`
	//文件地址
	File                 string   `protobuf:"bytes,2,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Chronos) Reset()         { *m = Chronos{} }
func (m *Chronos) String() string { return proto.CompactTextString(m) }
func (*Chronos) ProtoMessage()    {}
func (*Chronos) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{21}
}
func (m *Chronos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chronos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chronos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chronos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chronos.Merge(m, src)
}
func (m *Chronos) XXX_Size() int {
	return m.Size()
}
func (m *Chronos) XXX_DiscardUnknown() {
	xxx_messageInfo_Chronos.DiscardUnknown(m)
}

var xxx_messageInfo_Chronos proto.InternalMessageInfo

func (m *Chronos) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *Chronos) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

// PlayConf 播放三点配置信息
type PlayAbilityConf struct {
	//后台播放
	BackgroundPlayConf *CloudConf `protobuf:"bytes,1,opt,name=background_play_conf,json=backgroundPlayConf,proto3" json:"background_play_conf,omitempty"`
	//镜像反转
	FlipConf *CloudConf `protobuf:"bytes,2,opt,name=flip_conf,json=flipConf,proto3" json:"flip_conf,omitempty"`
	//返回视频的是否支持投屏
	CastConf *CloudConf `protobuf:"bytes,3,opt,name=cast_conf,json=castConf,proto3" json:"cast_conf,omitempty"`
	//反馈
	FeedbackConf *CloudConf `protobuf:"bytes,4,opt,name=feedback_conf,json=feedbackConf,proto3" json:"feedback_conf,omitempty"`
	//字幕
	SubtitleConf *CloudConf `protobuf:"bytes,5,opt,name=subtitle_conf,json=subtitleConf,proto3" json:"subtitle_conf,omitempty"`
	//播放速度
	PlaybackRateConf *CloudConf `protobuf:"bytes,6,opt,name=playback_rate_conf,json=playbackRateConf,proto3" json:"playback_rate_conf,omitempty"`
	//定时停止播放
	TimeUpConf *CloudConf `protobuf:"bytes,7,opt,name=time_up_conf,json=timeUpConf,proto3" json:"time_up_conf,omitempty"`
	//播放方式
	PlaybackModeConf *CloudConf `protobuf:"bytes,8,opt,name=playback_mode_conf,json=playbackModeConf,proto3" json:"playback_mode_conf,omitempty"`
	//画面尺寸
	ScaleModeConf *CloudConf `protobuf:"bytes,9,opt,name=scale_mode_conf,json=scaleModeConf,proto3" json:"scale_mode_conf,omitempty"`
	//顶
	LikeConf *CloudConf `protobuf:"bytes,10,opt,name=like_conf,json=likeConf,proto3" json:"like_conf,omitempty"`
	//踩
	DislikeConf *CloudConf `protobuf:"bytes,11,opt,name=dislike_conf,json=dislikeConf,proto3" json:"dislike_conf,omitempty"`
	//投币
	CoinConf *CloudConf `protobuf:"bytes,12,opt,name=coin_conf,json=coinConf,proto3" json:"coin_conf,omitempty"`
	//充电
	ElecConf *CloudConf `protobuf:"bytes,13,opt,name=elec_conf,json=elecConf,proto3" json:"elec_conf,omitempty"`
	//分享
	ShareConf *CloudConf `protobuf:"bytes,14,opt,name=share_conf,json=shareConf,proto3" json:"share_conf,omitempty"`
	//截图/gif
	ScreenShotConf *CloudConf `protobuf:"bytes,15,opt,name=screen_shot_conf,json=screenShotConf,proto3" json:"screen_shot_conf,omitempty"`
	//锁屏
	LockScreenConf *CloudConf `protobuf:"bytes,16,opt,name=lock_screen_conf,json=lockScreenConf,proto3" json:"lock_screen_conf,omitempty"`
	//相关推荐
	RecommendConf *CloudConf `protobuf:"bytes,17,opt,name=recommend_conf,json=recommendConf,proto3" json:"recommend_conf,omitempty"`
	//倍速
	PlaybackSpeedConf *CloudConf `protobuf:"bytes,18,opt,name=playback_speed_conf,json=playbackSpeedConf,proto3" json:"playback_speed_conf,omitempty"`
	//清晰度
	DefinitionConf *CloudConf `protobuf:"bytes,19,opt,name=definition_conf,json=definitionConf,proto3" json:"definition_conf,omitempty"`
	//选集
	SelectionsConf *CloudConf `protobuf:"bytes,20,opt,name=selections_conf,json=selectionsConf,proto3" json:"selections_conf,omitempty"`
	//下一集
	NextConf *CloudConf `protobuf:"bytes,21,opt,name=next_conf,json=nextConf,proto3" json:"next_conf,omitempty"`
	//编辑弹幕
	EditDmConf *CloudConf `protobuf:"bytes,22,opt,name=edit_dm_conf,json=editDmConf,proto3" json:"edit_dm_conf,omitempty"`
	//小窗
	SmallWindowConf *CloudConf `protobuf:"bytes,23,opt,name=small_window_conf,json=smallWindowConf,proto3" json:"small_window_conf,omitempty"`
	//播放震动
	ShakeConf *CloudConf `protobuf:"bytes,24,opt,name=shake_conf,json=shakeConf,proto3" json:"shake_conf,omitempty"`
	//外层面板弹幕设置（实验组1）
	OuterDmConf *CloudConf `protobuf:"bytes,25,opt,name=outer_dm_conf,json=outerDmConf,proto3" json:"outer_dm_conf,omitempty"`
	//三点内弹幕设置（实验组2）
	InnerDmConf *CloudConf `protobuf:"bytes,26,opt,name=inner_dm_conf,json=innerDmConf,proto3" json:"inner_dm_conf,omitempty"`
	//全景
	PanoramaConf *CloudConf `protobuf:"bytes,27,opt,name=panorama_conf,json=panoramaConf,proto3" json:"panorama_conf,omitempty"`
	//杜比
	DolbyConf *CloudConf `protobuf:"bytes,28,opt,name=dolby_conf,json=dolbyConf,proto3" json:"dolby_conf,omitempty"`
	//滤镜
	ColorFilterConf *CloudConf `protobuf:"bytes,29,opt,name=color_filter_conf,json=colorFilterConf,proto3" json:"color_filter_conf,omitempty"`
	//无损
	LossLessConf         *CloudConf `protobuf:"bytes,30,opt,name=loss_less_conf,json=lossLessConf,proto3" json:"loss_less_conf,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PlayAbilityConf) Reset()         { *m = PlayAbilityConf{} }
func (m *PlayAbilityConf) String() string { return proto.CompactTextString(m) }
func (*PlayAbilityConf) ProtoMessage()    {}
func (*PlayAbilityConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{22}
}
func (m *PlayAbilityConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayAbilityConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayAbilityConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayAbilityConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayAbilityConf.Merge(m, src)
}
func (m *PlayAbilityConf) XXX_Size() int {
	return m.Size()
}
func (m *PlayAbilityConf) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayAbilityConf.DiscardUnknown(m)
}

var xxx_messageInfo_PlayAbilityConf proto.InternalMessageInfo

func (m *PlayAbilityConf) GetBackgroundPlayConf() *CloudConf {
	if m != nil {
		return m.BackgroundPlayConf
	}
	return nil
}

func (m *PlayAbilityConf) GetFlipConf() *CloudConf {
	if m != nil {
		return m.FlipConf
	}
	return nil
}

func (m *PlayAbilityConf) GetCastConf() *CloudConf {
	if m != nil {
		return m.CastConf
	}
	return nil
}

func (m *PlayAbilityConf) GetFeedbackConf() *CloudConf {
	if m != nil {
		return m.FeedbackConf
	}
	return nil
}

func (m *PlayAbilityConf) GetSubtitleConf() *CloudConf {
	if m != nil {
		return m.SubtitleConf
	}
	return nil
}

func (m *PlayAbilityConf) GetPlaybackRateConf() *CloudConf {
	if m != nil {
		return m.PlaybackRateConf
	}
	return nil
}

func (m *PlayAbilityConf) GetTimeUpConf() *CloudConf {
	if m != nil {
		return m.TimeUpConf
	}
	return nil
}

func (m *PlayAbilityConf) GetPlaybackModeConf() *CloudConf {
	if m != nil {
		return m.PlaybackModeConf
	}
	return nil
}

func (m *PlayAbilityConf) GetScaleModeConf() *CloudConf {
	if m != nil {
		return m.ScaleModeConf
	}
	return nil
}

func (m *PlayAbilityConf) GetLikeConf() *CloudConf {
	if m != nil {
		return m.LikeConf
	}
	return nil
}

func (m *PlayAbilityConf) GetDislikeConf() *CloudConf {
	if m != nil {
		return m.DislikeConf
	}
	return nil
}

func (m *PlayAbilityConf) GetCoinConf() *CloudConf {
	if m != nil {
		return m.CoinConf
	}
	return nil
}

func (m *PlayAbilityConf) GetElecConf() *CloudConf {
	if m != nil {
		return m.ElecConf
	}
	return nil
}

func (m *PlayAbilityConf) GetShareConf() *CloudConf {
	if m != nil {
		return m.ShareConf
	}
	return nil
}

func (m *PlayAbilityConf) GetScreenShotConf() *CloudConf {
	if m != nil {
		return m.ScreenShotConf
	}
	return nil
}

func (m *PlayAbilityConf) GetLockScreenConf() *CloudConf {
	if m != nil {
		return m.LockScreenConf
	}
	return nil
}

func (m *PlayAbilityConf) GetRecommendConf() *CloudConf {
	if m != nil {
		return m.RecommendConf
	}
	return nil
}

func (m *PlayAbilityConf) GetPlaybackSpeedConf() *CloudConf {
	if m != nil {
		return m.PlaybackSpeedConf
	}
	return nil
}

func (m *PlayAbilityConf) GetDefinitionConf() *CloudConf {
	if m != nil {
		return m.DefinitionConf
	}
	return nil
}

func (m *PlayAbilityConf) GetSelectionsConf() *CloudConf {
	if m != nil {
		return m.SelectionsConf
	}
	return nil
}

func (m *PlayAbilityConf) GetNextConf() *CloudConf {
	if m != nil {
		return m.NextConf
	}
	return nil
}

func (m *PlayAbilityConf) GetEditDmConf() *CloudConf {
	if m != nil {
		return m.EditDmConf
	}
	return nil
}

func (m *PlayAbilityConf) GetSmallWindowConf() *CloudConf {
	if m != nil {
		return m.SmallWindowConf
	}
	return nil
}

func (m *PlayAbilityConf) GetShakeConf() *CloudConf {
	if m != nil {
		return m.ShakeConf
	}
	return nil
}

func (m *PlayAbilityConf) GetOuterDmConf() *CloudConf {
	if m != nil {
		return m.OuterDmConf
	}
	return nil
}

func (m *PlayAbilityConf) GetInnerDmConf() *CloudConf {
	if m != nil {
		return m.InnerDmConf
	}
	return nil
}

func (m *PlayAbilityConf) GetPanoramaConf() *CloudConf {
	if m != nil {
		return m.PanoramaConf
	}
	return nil
}

func (m *PlayAbilityConf) GetDolbyConf() *CloudConf {
	if m != nil {
		return m.DolbyConf
	}
	return nil
}

func (m *PlayAbilityConf) GetColorFilterConf() *CloudConf {
	if m != nil {
		return m.ColorFilterConf
	}
	return nil
}

func (m *PlayAbilityConf) GetLossLessConf() *CloudConf {
	if m != nil {
		return m.LossLessConf
	}
	return nil
}

// PlayArcConf 播放三点配置信息-稿件维度
type PlayArcConf struct {
	//后台播放
	BackgroundPlayConf *ArcConf `protobuf:"bytes,1,opt,name=background_play_conf,json=backgroundPlayConf,proto3" json:"background_play_conf,omitempty"`
	//镜像反转
	FlipConf *ArcConf `protobuf:"bytes,2,opt,name=flip_conf,json=flipConf,proto3" json:"flip_conf,omitempty"`
	//返回视频的是否支持投屏
	CastConf *ArcConf `protobuf:"bytes,3,opt,name=cast_conf,json=castConf,proto3" json:"cast_conf,omitempty"`
	//反馈
	FeedbackConf *ArcConf `protobuf:"bytes,4,opt,name=feedback_conf,json=feedbackConf,proto3" json:"feedback_conf,omitempty"`
	//字幕
	SubtitleConf *ArcConf `protobuf:"bytes,5,opt,name=subtitle_conf,json=subtitleConf,proto3" json:"subtitle_conf,omitempty"`
	//播放速度
	PlaybackRateConf *ArcConf `protobuf:"bytes,6,opt,name=playback_rate_conf,json=playbackRateConf,proto3" json:"playback_rate_conf,omitempty"`
	//定时停止播放
	TimeUpConf *ArcConf `protobuf:"bytes,7,opt,name=time_up_conf,json=timeUpConf,proto3" json:"time_up_conf,omitempty"`
	//播放方式
	PlaybackModeConf *ArcConf `protobuf:"bytes,8,opt,name=playback_mode_conf,json=playbackModeConf,proto3" json:"playback_mode_conf,omitempty"`
	//画面尺寸
	ScaleModeConf *ArcConf `protobuf:"bytes,9,opt,name=scale_mode_conf,json=scaleModeConf,proto3" json:"scale_mode_conf,omitempty"`
	//顶
	LikeConf *ArcConf `protobuf:"bytes,10,opt,name=like_conf,json=likeConf,proto3" json:"like_conf,omitempty"`
	//踩
	DislikeConf *ArcConf `protobuf:"bytes,11,opt,name=dislike_conf,json=dislikeConf,proto3" json:"dislike_conf,omitempty"`
	//投币
	CoinConf *ArcConf `protobuf:"bytes,12,opt,name=coin_conf,json=coinConf,proto3" json:"coin_conf,omitempty"`
	//充电
	ElecConf *ArcConf `protobuf:"bytes,13,opt,name=elec_conf,json=elecConf,proto3" json:"elec_conf,omitempty"`
	//分享
	ShareConf *ArcConf `protobuf:"bytes,14,opt,name=share_conf,json=shareConf,proto3" json:"share_conf,omitempty"`
	//截图/gif
	ScreenShotConf *ArcConf `protobuf:"bytes,15,opt,name=screen_shot_conf,json=screenShotConf,proto3" json:"screen_shot_conf,omitempty"`
	//锁屏
	LockScreenConf *ArcConf `protobuf:"bytes,16,opt,name=lock_screen_conf,json=lockScreenConf,proto3" json:"lock_screen_conf,omitempty"`
	//相关推荐
	RecommendConf *ArcConf `protobuf:"bytes,17,opt,name=recommend_conf,json=recommendConf,proto3" json:"recommend_conf,omitempty"`
	//倍速
	PlaybackSpeedConf *ArcConf `protobuf:"bytes,18,opt,name=playback_speed_conf,json=playbackSpeedConf,proto3" json:"playback_speed_conf,omitempty"`
	//清晰度
	DefinitionConf *ArcConf `protobuf:"bytes,19,opt,name=definition_conf,json=definitionConf,proto3" json:"definition_conf,omitempty"`
	//选集
	SelectionsConf *ArcConf `protobuf:"bytes,20,opt,name=selections_conf,json=selectionsConf,proto3" json:"selections_conf,omitempty"`
	//下一集
	NextConf *ArcConf `protobuf:"bytes,21,opt,name=next_conf,json=nextConf,proto3" json:"next_conf,omitempty"`
	//编辑弹幕
	EditDmConf *ArcConf `protobuf:"bytes,22,opt,name=edit_dm_conf,json=editDmConf,proto3" json:"edit_dm_conf,omitempty"`
	//小窗
	SmallWindowConf *ArcConf `protobuf:"bytes,23,opt,name=small_window_conf,json=smallWindowConf,proto3" json:"small_window_conf,omitempty"`
	//播放震动
	ShakeConf *ArcConf `protobuf:"bytes,24,opt,name=shake_conf,json=shakeConf,proto3" json:"shake_conf,omitempty"`
	//外层面板弹幕设置（实验组1）
	OuterDmConf *ArcConf `protobuf:"bytes,25,opt,name=outer_dm_conf,json=outerDmConf,proto3" json:"outer_dm_conf,omitempty"`
	//三点内弹幕设置（实验组2）
	InnerDmConf *ArcConf `protobuf:"bytes,26,opt,name=inner_dm_conf,json=innerDmConf,proto3" json:"inner_dm_conf,omitempty"`
	//全景
	PanoramaConf *ArcConf `protobuf:"bytes,27,opt,name=panorama_conf,json=panoramaConf,proto3" json:"panorama_conf,omitempty"`
	//杜比
	DolbyConf *ArcConf `protobuf:"bytes,28,opt,name=dolby_conf,json=dolbyConf,proto3" json:"dolby_conf,omitempty"`
	//屏幕录制
	ScreenRecordingConf *ArcConf `protobuf:"bytes,29,opt,name=screen_recording_conf,json=screenRecordingConf,proto3" json:"screen_recording_conf,omitempty"`
	//播放滤镜
	ColorFilterConf *ArcConf `protobuf:"bytes,30,opt,name=color_filter_conf,json=colorFilterConf,proto3" json:"color_filter_conf,omitempty"`
	//无损
	LossLessConf         *ArcConf `protobuf:"bytes,31,opt,name=loss_less_conf,json=lossLessConf,proto3" json:"loss_less_conf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayArcConf) Reset()         { *m = PlayArcConf{} }
func (m *PlayArcConf) String() string { return proto.CompactTextString(m) }
func (*PlayArcConf) ProtoMessage()    {}
func (*PlayArcConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{23}
}
func (m *PlayArcConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayArcConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayArcConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayArcConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayArcConf.Merge(m, src)
}
func (m *PlayArcConf) XXX_Size() int {
	return m.Size()
}
func (m *PlayArcConf) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayArcConf.DiscardUnknown(m)
}

var xxx_messageInfo_PlayArcConf proto.InternalMessageInfo

func (m *PlayArcConf) GetBackgroundPlayConf() *ArcConf {
	if m != nil {
		return m.BackgroundPlayConf
	}
	return nil
}

func (m *PlayArcConf) GetFlipConf() *ArcConf {
	if m != nil {
		return m.FlipConf
	}
	return nil
}

func (m *PlayArcConf) GetCastConf() *ArcConf {
	if m != nil {
		return m.CastConf
	}
	return nil
}

func (m *PlayArcConf) GetFeedbackConf() *ArcConf {
	if m != nil {
		return m.FeedbackConf
	}
	return nil
}

func (m *PlayArcConf) GetSubtitleConf() *ArcConf {
	if m != nil {
		return m.SubtitleConf
	}
	return nil
}

func (m *PlayArcConf) GetPlaybackRateConf() *ArcConf {
	if m != nil {
		return m.PlaybackRateConf
	}
	return nil
}

func (m *PlayArcConf) GetTimeUpConf() *ArcConf {
	if m != nil {
		return m.TimeUpConf
	}
	return nil
}

func (m *PlayArcConf) GetPlaybackModeConf() *ArcConf {
	if m != nil {
		return m.PlaybackModeConf
	}
	return nil
}

func (m *PlayArcConf) GetScaleModeConf() *ArcConf {
	if m != nil {
		return m.ScaleModeConf
	}
	return nil
}

func (m *PlayArcConf) GetLikeConf() *ArcConf {
	if m != nil {
		return m.LikeConf
	}
	return nil
}

func (m *PlayArcConf) GetDislikeConf() *ArcConf {
	if m != nil {
		return m.DislikeConf
	}
	return nil
}

func (m *PlayArcConf) GetCoinConf() *ArcConf {
	if m != nil {
		return m.CoinConf
	}
	return nil
}

func (m *PlayArcConf) GetElecConf() *ArcConf {
	if m != nil {
		return m.ElecConf
	}
	return nil
}

func (m *PlayArcConf) GetShareConf() *ArcConf {
	if m != nil {
		return m.ShareConf
	}
	return nil
}

func (m *PlayArcConf) GetScreenShotConf() *ArcConf {
	if m != nil {
		return m.ScreenShotConf
	}
	return nil
}

func (m *PlayArcConf) GetLockScreenConf() *ArcConf {
	if m != nil {
		return m.LockScreenConf
	}
	return nil
}

func (m *PlayArcConf) GetRecommendConf() *ArcConf {
	if m != nil {
		return m.RecommendConf
	}
	return nil
}

func (m *PlayArcConf) GetPlaybackSpeedConf() *ArcConf {
	if m != nil {
		return m.PlaybackSpeedConf
	}
	return nil
}

func (m *PlayArcConf) GetDefinitionConf() *ArcConf {
	if m != nil {
		return m.DefinitionConf
	}
	return nil
}

func (m *PlayArcConf) GetSelectionsConf() *ArcConf {
	if m != nil {
		return m.SelectionsConf
	}
	return nil
}

func (m *PlayArcConf) GetNextConf() *ArcConf {
	if m != nil {
		return m.NextConf
	}
	return nil
}

func (m *PlayArcConf) GetEditDmConf() *ArcConf {
	if m != nil {
		return m.EditDmConf
	}
	return nil
}

func (m *PlayArcConf) GetSmallWindowConf() *ArcConf {
	if m != nil {
		return m.SmallWindowConf
	}
	return nil
}

func (m *PlayArcConf) GetShakeConf() *ArcConf {
	if m != nil {
		return m.ShakeConf
	}
	return nil
}

func (m *PlayArcConf) GetOuterDmConf() *ArcConf {
	if m != nil {
		return m.OuterDmConf
	}
	return nil
}

func (m *PlayArcConf) GetInnerDmConf() *ArcConf {
	if m != nil {
		return m.InnerDmConf
	}
	return nil
}

func (m *PlayArcConf) GetPanoramaConf() *ArcConf {
	if m != nil {
		return m.PanoramaConf
	}
	return nil
}

func (m *PlayArcConf) GetDolbyConf() *ArcConf {
	if m != nil {
		return m.DolbyConf
	}
	return nil
}

func (m *PlayArcConf) GetScreenRecordingConf() *ArcConf {
	if m != nil {
		return m.ScreenRecordingConf
	}
	return nil
}

func (m *PlayArcConf) GetColorFilterConf() *ArcConf {
	if m != nil {
		return m.ColorFilterConf
	}
	return nil
}

func (m *PlayArcConf) GetLossLessConf() *ArcConf {
	if m != nil {
		return m.LossLessConf
	}
	return nil
}

type ConfValue struct {
	// Types that are valid to be assigned to Value:
	//	*ConfValue_SwitchVal
	//	*ConfValue_SelectedVal
	Value                isConfValue_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ConfValue) Reset()         { *m = ConfValue{} }
func (m *ConfValue) String() string { return proto.CompactTextString(m) }
func (*ConfValue) ProtoMessage()    {}
func (*ConfValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{24}
}
func (m *ConfValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfValue.Merge(m, src)
}
func (m *ConfValue) XXX_Size() int {
	return m.Size()
}
func (m *ConfValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfValue.DiscardUnknown(m)
}

var xxx_messageInfo_ConfValue proto.InternalMessageInfo

type isConfValue_Value interface {
	isConfValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConfValue_SwitchVal struct {
	SwitchVal bool `protobuf:"varint,1,opt,name=switch_val,json=switchVal,proto3,oneof" json:"switch_val,omitempty"`
}
type ConfValue_SelectedVal struct {
	SelectedVal int64 `protobuf:"varint,2,opt,name=selected_val,json=selectedVal,proto3,oneof" json:"selected_val,omitempty"`
}

func (*ConfValue_SwitchVal) isConfValue_Value()   {}
func (*ConfValue_SelectedVal) isConfValue_Value() {}

func (m *ConfValue) GetValue() isConfValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ConfValue) GetSwitchVal() bool {
	if x, ok := m.GetValue().(*ConfValue_SwitchVal); ok {
		return x.SwitchVal
	}
	return false
}

func (m *ConfValue) GetSelectedVal() int64 {
	if x, ok := m.GetValue().(*ConfValue_SelectedVal); ok {
		return x.SelectedVal
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConfValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConfValue_SwitchVal)(nil),
		(*ConfValue_SelectedVal)(nil),
	}
}

// CloudConf .
type CloudConf struct {
	//是否展示功能
	Show bool `protobuf:"varint,1,opt,name=show,proto3" json:"show,omitempty"`
	// 标记类型
	ConfType ConfType `protobuf:"varint,2,opt,name=conf_type,json=confType,proto3,enum=bilibili.app.playurl.v1.ConfType" json:"conf_type,omitempty"`
	//云控开关信息
	FieldValue *FieldValue `protobuf:"bytes,3,opt,name=field_value,json=fieldValue,proto3" json:"field_value,omitempty"`
	// 播放配置的值
	ConfValue            *ConfValue `protobuf:"bytes,4,opt,name=conf_value,json=confValue,proto3" json:"conf_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CloudConf) Reset()         { *m = CloudConf{} }
func (m *CloudConf) String() string { return proto.CompactTextString(m) }
func (*CloudConf) ProtoMessage()    {}
func (*CloudConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{25}
}
func (m *CloudConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudConf.Merge(m, src)
}
func (m *CloudConf) XXX_Size() int {
	return m.Size()
}
func (m *CloudConf) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudConf.DiscardUnknown(m)
}

var xxx_messageInfo_CloudConf proto.InternalMessageInfo

func (m *CloudConf) GetShow() bool {
	if m != nil {
		return m.Show
	}
	return false
}

func (m *CloudConf) GetConfType() ConfType {
	if m != nil {
		return m.ConfType
	}
	return ConfType_NoType
}

func (m *CloudConf) GetFieldValue() *FieldValue {
	if m != nil {
		return m.FieldValue
	}
	return nil
}

func (m *CloudConf) GetConfValue() *ConfValue {
	if m != nil {
		return m.ConfValue
	}
	return nil
}

// ArcConf 稿件维度
type ArcConf struct {
	//是否可用（可见）
	IsSupport bool `protobuf:"varint,1,opt,name=is_support,json=isSupport,proto3" json:"is_support,omitempty"`
	//是否禁用
	Disabled bool `protobuf:"varint,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
	//提示信息
	ExtraContent *ExtraContent `protobuf:"bytes,3,opt,name=extra_content,json=extraContent,proto3" json:"extra_content,omitempty"`
	//不支持的场景：1:首映
	UnsupportScene       []int64  `protobuf:"varint,4,rep,packed,name=unsupport_scene,json=unsupportScene,proto3" json:"unsupport_scene,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcConf) Reset()         { *m = ArcConf{} }
func (m *ArcConf) String() string { return proto.CompactTextString(m) }
func (*ArcConf) ProtoMessage()    {}
func (*ArcConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{26}
}
func (m *ArcConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcConf.Merge(m, src)
}
func (m *ArcConf) XXX_Size() int {
	return m.Size()
}
func (m *ArcConf) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcConf.DiscardUnknown(m)
}

var xxx_messageInfo_ArcConf proto.InternalMessageInfo

func (m *ArcConf) GetIsSupport() bool {
	if m != nil {
		return m.IsSupport
	}
	return false
}

func (m *ArcConf) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *ArcConf) GetExtraContent() *ExtraContent {
	if m != nil {
		return m.ExtraContent
	}
	return nil
}

func (m *ArcConf) GetUnsupportScene() []int64 {
	if m != nil {
		return m.UnsupportScene
	}
	return nil
}

type ExtraContent struct {
	//禁用的原因
	DisabledReason string `protobuf:"bytes,1,opt,name=disabled_reason,json=disabledReason,proto3" json:"disabled_reason,omitempty"`
	//禁用的错误码
	DisabledCode         int64    `protobuf:"varint,2,opt,name=disabled_code,json=disabledCode,proto3" json:"disabled_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtraContent) Reset()         { *m = ExtraContent{} }
func (m *ExtraContent) String() string { return proto.CompactTextString(m) }
func (*ExtraContent) ProtoMessage()    {}
func (*ExtraContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{27}
}
func (m *ExtraContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtraContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtraContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtraContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtraContent.Merge(m, src)
}
func (m *ExtraContent) XXX_Size() int {
	return m.Size()
}
func (m *ExtraContent) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtraContent.DiscardUnknown(m)
}

var xxx_messageInfo_ExtraContent proto.InternalMessageInfo

func (m *ExtraContent) GetDisabledReason() string {
	if m != nil {
		return m.DisabledReason
	}
	return ""
}

func (m *ExtraContent) GetDisabledCode() int64 {
	if m != nil {
		return m.DisabledCode
	}
	return 0
}

// VideoInfo 播放地址返回结果
type VideoInfo struct {
	//返回视频的清晰度
	Quality uint32 `protobuf:"varint,1,opt,name=quality,proto3" json:"quality,omitempty"`
	//返回视频的格式
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	//返回视频的总时长, 单位为ms
	Timelength uint64 `protobuf:"varint,3,opt,name=timelength,proto3" json:"timelength,omitempty"`
	//返回视频的编码号
	VideoCodecid uint32 `protobuf:"varint,4,opt,name=video_codecid,json=videoCodecid,proto3" json:"video_codecid,omitempty"`
	//流信息
	StreamList []*Stream `protobuf:"bytes,5,rep,name=stream_list,json=streamList,proto3" json:"stream_list,omitempty"`
	// aduio info
	DashAudio []*DashItem `protobuf:"bytes,6,rep,name=dash_audio,json=dashAudio,proto3" json:"dash_audio,omitempty"`
	// dolby
	Dolby *DolbyItem `protobuf:"bytes,7,opt,name=dolby,proto3" json:"dolby,omitempty"`
	//音量均衡信息
	Volume *VolumeInfo `protobuf:"bytes,8,opt,name=volume,proto3" json:"volume,omitempty"`
	//无损音频
	LossLessItem         *LossLessItem `protobuf:"bytes,9,opt,name=loss_less_item,json=lossLessItem,proto3" json:"loss_less_item,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *VideoInfo) Reset()         { *m = VideoInfo{} }
func (m *VideoInfo) String() string { return proto.CompactTextString(m) }
func (*VideoInfo) ProtoMessage()    {}
func (*VideoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{28}
}
func (m *VideoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoInfo.Merge(m, src)
}
func (m *VideoInfo) XXX_Size() int {
	return m.Size()
}
func (m *VideoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VideoInfo proto.InternalMessageInfo

func (m *VideoInfo) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *VideoInfo) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *VideoInfo) GetTimelength() uint64 {
	if m != nil {
		return m.Timelength
	}
	return 0
}

func (m *VideoInfo) GetVideoCodecid() uint32 {
	if m != nil {
		return m.VideoCodecid
	}
	return 0
}

func (m *VideoInfo) GetStreamList() []*Stream {
	if m != nil {
		return m.StreamList
	}
	return nil
}

func (m *VideoInfo) GetDashAudio() []*DashItem {
	if m != nil {
		return m.DashAudio
	}
	return nil
}

func (m *VideoInfo) GetDolby() *DolbyItem {
	if m != nil {
		return m.Dolby
	}
	return nil
}

func (m *VideoInfo) GetVolume() *VolumeInfo {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *VideoInfo) GetLossLessItem() *LossLessItem {
	if m != nil {
		return m.LossLessItem
	}
	return nil
}

type LossLessItem struct {
	IsLosslessAudio bool `protobuf:"varint,1,opt,name=is_lossless_audio,json=isLosslessAudio,proto3" json:"is_lossless_audio,omitempty"`
	//无损音频信息
	Audio *DashItem `protobuf:"bytes,2,opt,name=audio,proto3" json:"audio,omitempty"`
	//需要vip
	NeedVip              bool     `protobuf:"varint,3,opt,name=need_vip,json=needVip,proto3" json:"need_vip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LossLessItem) Reset()         { *m = LossLessItem{} }
func (m *LossLessItem) String() string { return proto.CompactTextString(m) }
func (*LossLessItem) ProtoMessage()    {}
func (*LossLessItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{29}
}
func (m *LossLessItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LossLessItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LossLessItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LossLessItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LossLessItem.Merge(m, src)
}
func (m *LossLessItem) XXX_Size() int {
	return m.Size()
}
func (m *LossLessItem) XXX_DiscardUnknown() {
	xxx_messageInfo_LossLessItem.DiscardUnknown(m)
}

var xxx_messageInfo_LossLessItem proto.InternalMessageInfo

func (m *LossLessItem) GetIsLosslessAudio() bool {
	if m != nil {
		return m.IsLosslessAudio
	}
	return false
}

func (m *LossLessItem) GetAudio() *DashItem {
	if m != nil {
		return m.Audio
	}
	return nil
}

func (m *LossLessItem) GetNeedVip() bool {
	if m != nil {
		return m.NeedVip
	}
	return false
}

// DolbyItem .
type DolbyItem struct {
	//杜比类型
	Type DolbyItem_Type `protobuf:"varint,1,opt,name=type,proto3,enum=bilibili.app.playurl.v1.DolbyItem_Type" json:"type,omitempty"`
	// 杜比音频信息
	Audio                []*DashItem `protobuf:"bytes,2,rep,name=audio,proto3" json:"audio,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DolbyItem) Reset()         { *m = DolbyItem{} }
func (m *DolbyItem) String() string { return proto.CompactTextString(m) }
func (*DolbyItem) ProtoMessage()    {}
func (*DolbyItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{30}
}
func (m *DolbyItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DolbyItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DolbyItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DolbyItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DolbyItem.Merge(m, src)
}
func (m *DolbyItem) XXX_Size() int {
	return m.Size()
}
func (m *DolbyItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DolbyItem.DiscardUnknown(m)
}

var xxx_messageInfo_DolbyItem proto.InternalMessageInfo

func (m *DolbyItem) GetType() DolbyItem_Type {
	if m != nil {
		return m.Type
	}
	return DolbyItem_NONE
}

func (m *DolbyItem) GetAudio() []*DashItem {
	if m != nil {
		return m.Audio
	}
	return nil
}

// 返回视频的拥有的清晰度描述的列表
type Stream struct {
	StreamInfo *StreamInfo `protobuf:"bytes,1,opt,name=stream_info,json=streamInfo,proto3" json:"stream_info,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*Stream_DashVideo
	//	*Stream_SegmentVideo
	Content              isStream_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Stream) Reset()         { *m = Stream{} }
func (m *Stream) String() string { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()    {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{31}
}
func (m *Stream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(m, src)
}
func (m *Stream) XXX_Size() int {
	return m.Size()
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

type isStream_Content interface {
	isStream_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Stream_DashVideo struct {
	DashVideo *DashVideo `protobuf:"bytes,2,opt,name=dash_video,json=dashVideo,proto3,oneof" json:"dash_video,omitempty"`
}
type Stream_SegmentVideo struct {
	SegmentVideo *SegmentVideo `protobuf:"bytes,3,opt,name=segment_video,json=segmentVideo,proto3,oneof" json:"segment_video,omitempty"`
}

func (*Stream_DashVideo) isStream_Content()    {}
func (*Stream_SegmentVideo) isStream_Content() {}

func (m *Stream) GetContent() isStream_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Stream) GetStreamInfo() *StreamInfo {
	if m != nil {
		return m.StreamInfo
	}
	return nil
}

func (m *Stream) GetDashVideo() *DashVideo {
	if x, ok := m.GetContent().(*Stream_DashVideo); ok {
		return x.DashVideo
	}
	return nil
}

func (m *Stream) GetSegmentVideo() *SegmentVideo {
	if x, ok := m.GetContent().(*Stream_SegmentVideo); ok {
		return x.SegmentVideo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Stream) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Stream_DashVideo)(nil),
		(*Stream_SegmentVideo)(nil),
	}
}

// 返回DASH视频的MPD格式文件,有dash则没durl字段
type SegmentVideo struct {
	Segment              []*ResponseUrl `protobuf:"bytes,1,rep,name=segment,proto3" json:"segment,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SegmentVideo) Reset()         { *m = SegmentVideo{} }
func (m *SegmentVideo) String() string { return proto.CompactTextString(m) }
func (*SegmentVideo) ProtoMessage()    {}
func (*SegmentVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{32}
}
func (m *SegmentVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegmentVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegmentVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegmentVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentVideo.Merge(m, src)
}
func (m *SegmentVideo) XXX_Size() int {
	return m.Size()
}
func (m *SegmentVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentVideo.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentVideo proto.InternalMessageInfo

func (m *SegmentVideo) GetSegment() []*ResponseUrl {
	if m != nil {
		return m.Segment
	}
	return nil
}

type StreamInfo struct {
	//清晰度qn
	Quality uint32 `protobuf:"varint,1,opt,name=quality,proto3" json:"quality,omitempty"`
	//清晰度格式
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	//清晰度描述
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	//错误码
	ErrCode PlayErr `protobuf:"varint,4,opt,name=err_code,json=errCode,proto3,enum=bilibili.app.playurl.v1.PlayErr" json:"err_code,omitempty"`
	//不满足播放条件时的提示文案
	Limit *StreamLimit `protobuf:"bytes,5,opt,name=limit,proto3" json:"limit,omitempty"`
	//需要vip
	NeedVip bool `protobuf:"varint,6,opt,name=need_vip,json=needVip,proto3" json:"need_vip,omitempty"`
	//需要登录
	NeedLogin bool `protobuf:"varint,7,opt,name=need_login,json=needLogin,proto3" json:"need_login,omitempty"`
	//是否是完整的
	Intact bool `protobuf:"varint,8,opt,name=intact,proto3" json:"intact,omitempty"`
	//表示cid是否非全二压，true表示非全二压
	NoRexcode bool `protobuf:"varint,9,opt,name=no_rexcode,json=noRexcode,proto3" json:"no_rexcode,omitempty"`
	//清晰度属性位（每位为1表示不同属性）
	//第0位为1->是HDR
	//第1位为1->是dolbyHDR
	Attribute int64 `protobuf:"varint,10,opt,name=attribute,proto3" json:"attribute,omitempty"`
	//6.9版本开始新描述
	NewDescription string `protobuf:"bytes,11,opt,name=new_description,json=newDescription,proto3" json:"new_description,omitempty"`
	//选中态的清晰度描述
	DisplayDesc string `protobuf:"bytes,12,opt,name=display_desc,json=displayDesc,proto3" json:"display_desc,omitempty"`
	//选中态的清晰度描述的角标
	Superscript string `protobuf:"bytes,13,opt,name=superscript,proto3" json:"superscript,omitempty"`
	//是否是限免
	VipFree bool `protobuf:"varint,14,opt,name=vip_free,json=vipFree,proto3" json:"vip_free,omitempty"`
	//副标题
	Subtitle             string   `protobuf:"bytes,15,opt,name=subtitle,proto3" json:"subtitle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamInfo) Reset()         { *m = StreamInfo{} }
func (m *StreamInfo) String() string { return proto.CompactTextString(m) }
func (*StreamInfo) ProtoMessage()    {}
func (*StreamInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{33}
}
func (m *StreamInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamInfo.Merge(m, src)
}
func (m *StreamInfo) XXX_Size() int {
	return m.Size()
}
func (m *StreamInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StreamInfo proto.InternalMessageInfo

func (m *StreamInfo) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *StreamInfo) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *StreamInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *StreamInfo) GetErrCode() PlayErr {
	if m != nil {
		return m.ErrCode
	}
	return PlayErr_NoErr
}

func (m *StreamInfo) GetLimit() *StreamLimit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *StreamInfo) GetNeedVip() bool {
	if m != nil {
		return m.NeedVip
	}
	return false
}

func (m *StreamInfo) GetNeedLogin() bool {
	if m != nil {
		return m.NeedLogin
	}
	return false
}

func (m *StreamInfo) GetIntact() bool {
	if m != nil {
		return m.Intact
	}
	return false
}

func (m *StreamInfo) GetNoRexcode() bool {
	if m != nil {
		return m.NoRexcode
	}
	return false
}

func (m *StreamInfo) GetAttribute() int64 {
	if m != nil {
		return m.Attribute
	}
	return 0
}

func (m *StreamInfo) GetNewDescription() string {
	if m != nil {
		return m.NewDescription
	}
	return ""
}

func (m *StreamInfo) GetDisplayDesc() string {
	if m != nil {
		return m.DisplayDesc
	}
	return ""
}

func (m *StreamInfo) GetSuperscript() string {
	if m != nil {
		return m.Superscript
	}
	return ""
}

func (m *StreamInfo) GetVipFree() bool {
	if m != nil {
		return m.VipFree
	}
	return false
}

func (m *StreamInfo) GetSubtitle() string {
	if m != nil {
		return m.Subtitle
	}
	return ""
}

// 清晰度不满足条件时，提示文案
type StreamLimit struct {
	//提示文案
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	//跳转地址
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	//提示文案
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamLimit) Reset()         { *m = StreamLimit{} }
func (m *StreamLimit) String() string { return proto.CompactTextString(m) }
func (*StreamLimit) ProtoMessage()    {}
func (*StreamLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{34}
}
func (m *StreamLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamLimit.Merge(m, src)
}
func (m *StreamLimit) XXX_Size() int {
	return m.Size()
}
func (m *StreamLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamLimit.DiscardUnknown(m)
}

var xxx_messageInfo_StreamLimit proto.InternalMessageInfo

func (m *StreamLimit) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *StreamLimit) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *StreamLimit) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type PlayConfEditReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayConfEditReply) Reset()         { *m = PlayConfEditReply{} }
func (m *PlayConfEditReply) String() string { return proto.CompactTextString(m) }
func (*PlayConfEditReply) ProtoMessage()    {}
func (*PlayConfEditReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{35}
}
func (m *PlayConfEditReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayConfEditReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayConfEditReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayConfEditReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayConfEditReply.Merge(m, src)
}
func (m *PlayConfEditReply) XXX_Size() int {
	return m.Size()
}
func (m *PlayConfEditReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayConfEditReply.DiscardUnknown(m)
}

var xxx_messageInfo_PlayConfEditReply proto.InternalMessageInfo

// 编辑控制面板
type PlayConfEditReq struct {
	PlayConf             []*PlayConfState `protobuf:"bytes,1,rep,name=play_conf,json=playConf,proto3" json:"play_conf,omitempty" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PlayConfEditReq) Reset()         { *m = PlayConfEditReq{} }
func (m *PlayConfEditReq) String() string { return proto.CompactTextString(m) }
func (*PlayConfEditReq) ProtoMessage()    {}
func (*PlayConfEditReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{36}
}
func (m *PlayConfEditReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayConfEditReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayConfEditReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayConfEditReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayConfEditReq.Merge(m, src)
}
func (m *PlayConfEditReq) XXX_Size() int {
	return m.Size()
}
func (m *PlayConfEditReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayConfEditReq.DiscardUnknown(m)
}

var xxx_messageInfo_PlayConfEditReq proto.InternalMessageInfo

func (m *PlayConfEditReq) GetPlayConf() []*PlayConfState {
	if m != nil {
		return m.PlayConf
	}
	return nil
}

type PlayConfState struct {
	//云控类型
	ConfType ConfType `protobuf:"varint,1,opt,name=conf_type,json=confType,proto3,enum=bilibili.app.playurl.v1.ConfType" json:"conf_type,omitempty"`
	//true: false:隐藏
	Show bool `protobuf:"varint,2,opt,name=show,proto3" json:"show,omitempty"`
	//云控开关信息
	FieldValue *FieldValue `protobuf:"bytes,3,opt,name=field_value,json=fieldValue,proto3" json:"field_value,omitempty"`
	// 播放配置的值
	ConfValue            *ConfValue `protobuf:"bytes,4,opt,name=conf_value,json=confValue,proto3" json:"conf_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PlayConfState) Reset()         { *m = PlayConfState{} }
func (m *PlayConfState) String() string { return proto.CompactTextString(m) }
func (*PlayConfState) ProtoMessage()    {}
func (*PlayConfState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{37}
}
func (m *PlayConfState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayConfState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayConfState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayConfState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayConfState.Merge(m, src)
}
func (m *PlayConfState) XXX_Size() int {
	return m.Size()
}
func (m *PlayConfState) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayConfState.DiscardUnknown(m)
}

var xxx_messageInfo_PlayConfState proto.InternalMessageInfo

func (m *PlayConfState) GetConfType() ConfType {
	if m != nil {
		return m.ConfType
	}
	return ConfType_NoType
}

func (m *PlayConfState) GetShow() bool {
	if m != nil {
		return m.Show
	}
	return false
}

func (m *PlayConfState) GetFieldValue() *FieldValue {
	if m != nil {
		return m.FieldValue
	}
	return nil
}

func (m *PlayConfState) GetConfValue() *ConfValue {
	if m != nil {
		return m.ConfValue
	}
	return nil
}

type FieldValue struct {
	// Types that are valid to be assigned to Value:
	//	*FieldValue_Switch
	Value                isFieldValue_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *FieldValue) Reset()         { *m = FieldValue{} }
func (m *FieldValue) String() string { return proto.CompactTextString(m) }
func (*FieldValue) ProtoMessage()    {}
func (*FieldValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{38}
}
func (m *FieldValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldValue.Merge(m, src)
}
func (m *FieldValue) XXX_Size() int {
	return m.Size()
}
func (m *FieldValue) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldValue.DiscardUnknown(m)
}

var xxx_messageInfo_FieldValue proto.InternalMessageInfo

type isFieldValue_Value interface {
	isFieldValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FieldValue_Switch struct {
	Switch bool `protobuf:"varint,1,opt,name=switch,proto3,oneof" json:"switch,omitempty"`
}

func (*FieldValue_Switch) isFieldValue_Value() {}

func (m *FieldValue) GetValue() isFieldValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *FieldValue) GetSwitch() bool {
	if x, ok := m.GetValue().(*FieldValue_Switch); ok {
		return x.Switch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FieldValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FieldValue_Switch)(nil),
	}
}

// DashVideo dash信息
type DashVideo struct {
	//dash的url地址
	BaseUrl string `protobuf:"bytes,1,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	//dash的backup url地址
	BackupUrl []string `protobuf:"bytes,2,rep,name=backup_url,json=backupUrl,proto3" json:"backup_url,omitempty"`
	//dash的信息
	Bandwidth uint32 `protobuf:"varint,3,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	//dash的信息
	Codecid uint32 `protobuf:"varint,4,opt,name=codecid,proto3" json:"codecid,omitempty"`
	//视频分片的md5,只有dash离线下载才有值
	Md5 string `protobuf:"bytes,5,opt,name=md5,proto3" json:"md5,omitempty"`
	//视频分片的大小, 单位Byte,只有dash离线下载才有值
	Size_ uint64 `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	//dash视频信息id,default_id
	AudioId uint32 `protobuf:"varint,7,opt,name=audio_id,json=audioId,proto3" json:"audio_id,omitempty"`
	//表示cid是否非全二压，true表示非全二压
	NoRexcode bool `protobuf:"varint,8,opt,name=no_rexcode,json=noRexcode,proto3" json:"no_rexcode,omitempty"`
	//帧率
	FrameRate string `protobuf:"bytes,9,opt,name=frame_rate,json=frameRate,proto3" json:"frame_rate,omitempty"`
	//宽
	Width uint32 `protobuf:"varint,10,opt,name=width,proto3" json:"width,omitempty"`
	//高
	Height               uint32   `protobuf:"varint,11,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DashVideo) Reset()         { *m = DashVideo{} }
func (m *DashVideo) String() string { return proto.CompactTextString(m) }
func (*DashVideo) ProtoMessage()    {}
func (*DashVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a3d491d087f669a, []int{39}
}
func (m *DashVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DashVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DashVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DashVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DashVideo.Merge(m, src)
}
func (m *DashVideo) XXX_Size() int {
	return m.Size()
}
func (m *DashVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_DashVideo.DiscardUnknown(m)
}

var xxx_messageInfo_DashVideo proto.InternalMessageInfo

func (m *DashVideo) GetBaseUrl() string {
	if m != nil {
		return m.BaseUrl
	}
	return ""
}

func (m *DashVideo) GetBackupUrl() []string {
	if m != nil {
		return m.BackupUrl
	}
	return nil
}

func (m *DashVideo) GetBandwidth() uint32 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *DashVideo) GetCodecid() uint32 {
	if m != nil {
		return m.Codecid
	}
	return 0
}

func (m *DashVideo) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *DashVideo) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *DashVideo) GetAudioId() uint32 {
	if m != nil {
		return m.AudioId
	}
	return 0
}

func (m *DashVideo) GetNoRexcode() bool {
	if m != nil {
		return m.NoRexcode
	}
	return false
}

func (m *DashVideo) GetFrameRate() string {
	if m != nil {
		return m.FrameRate
	}
	return ""
}

func (m *DashVideo) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *DashVideo) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func init() {
	proto.RegisterEnum("bilibili.app.playurl.v1.PlayLimitCode", PlayLimitCode_name, PlayLimitCode_value)
	proto.RegisterEnum("bilibili.app.playurl.v1.Business", Business_name, Business_value)
	proto.RegisterEnum("bilibili.app.playurl.v1.CodeType", CodeType_name, CodeType_value)
	proto.RegisterEnum("bilibili.app.playurl.v1.Group", Group_name, Group_value)
	proto.RegisterEnum("bilibili.app.playurl.v1.ConfType", ConfType_name, ConfType_value)
	proto.RegisterEnum("bilibili.app.playurl.v1.PlayErr", PlayErr_name, PlayErr_value)
	proto.RegisterEnum("bilibili.app.playurl.v1.VideoType", VideoType_name, VideoType_value)
	proto.RegisterEnum("bilibili.app.playurl.v1.DolbyItem_Type", DolbyItem_Type_name, DolbyItem_Type_value)
	proto.RegisterType((*PlayURLReq)(nil), "bilibili.app.playurl.v1.PlayURLReq")
	proto.RegisterType((*PlayURLReply)(nil), "bilibili.app.playurl.v1.PlayURLReply")
	proto.RegisterType((*ResponseUrl)(nil), "bilibili.app.playurl.v1.ResponseUrl")
	proto.RegisterType((*ResponseDash)(nil), "bilibili.app.playurl.v1.ResponseDash")
	proto.RegisterType((*DashItem)(nil), "bilibili.app.playurl.v1.DashItem")
	proto.RegisterType((*PlayLimit)(nil), "bilibili.app.playurl.v1.PlayLimit")
	proto.RegisterType((*ButtonStyle)(nil), "bilibili.app.playurl.v1.ButtonStyle")
	proto.RegisterType((*UpgradeLimit)(nil), "bilibili.app.playurl.v1.UpgradeLimit")
	proto.RegisterType((*UpgradeButton)(nil), "bilibili.app.playurl.v1.UpgradeButton")
	proto.RegisterType((*FormatDescription)(nil), "bilibili.app.playurl.v1.FormatDescription")
	proto.RegisterType((*ProjectReq)(nil), "bilibili.app.playurl.v1.ProjectReq")
	proto.RegisterType((*ProjectReply)(nil), "bilibili.app.playurl.v1.ProjectReply")
	proto.RegisterType((*PlayViewReq)(nil), "bilibili.app.playurl.v1.PlayViewReq")
	proto.RegisterType((*PlayViewReply)(nil), "bilibili.app.playurl.v1.PlayViewReply")
	proto.RegisterType((*VolumeInfo)(nil), "bilibili.app.playurl.v1.VolumeInfo")
	proto.RegisterType((*AB)(nil), "bilibili.app.playurl.v1.AB")
	proto.RegisterType((*Glance)(nil), "bilibili.app.playurl.v1.Glance")
	proto.RegisterType((*Event)(nil), "bilibili.app.playurl.v1.Event")
	proto.RegisterType((*Shake)(nil), "bilibili.app.playurl.v1.Shake")
	proto.RegisterType((*PlayConfReq)(nil), "bilibili.app.playurl.v1.PlayConfReq")
	proto.RegisterType((*PlayConfReply)(nil), "bilibili.app.playurl.v1.PlayConfReply")
	proto.RegisterType((*Chronos)(nil), "bilibili.app.playurl.v1.Chronos")
	proto.RegisterType((*PlayAbilityConf)(nil), "bilibili.app.playurl.v1.PlayAbilityConf")
	proto.RegisterType((*PlayArcConf)(nil), "bilibili.app.playurl.v1.PlayArcConf")
	proto.RegisterType((*ConfValue)(nil), "bilibili.app.playurl.v1.ConfValue")
	proto.RegisterType((*CloudConf)(nil), "bilibili.app.playurl.v1.CloudConf")
	proto.RegisterType((*ArcConf)(nil), "bilibili.app.playurl.v1.ArcConf")
	proto.RegisterType((*ExtraContent)(nil), "bilibili.app.playurl.v1.ExtraContent")
	proto.RegisterType((*VideoInfo)(nil), "bilibili.app.playurl.v1.VideoInfo")
	proto.RegisterType((*LossLessItem)(nil), "bilibili.app.playurl.v1.LossLessItem")
	proto.RegisterType((*DolbyItem)(nil), "bilibili.app.playurl.v1.DolbyItem")
	proto.RegisterType((*Stream)(nil), "bilibili.app.playurl.v1.Stream")
	proto.RegisterType((*SegmentVideo)(nil), "bilibili.app.playurl.v1.SegmentVideo")
	proto.RegisterType((*StreamInfo)(nil), "bilibili.app.playurl.v1.StreamInfo")
	proto.RegisterType((*StreamLimit)(nil), "bilibili.app.playurl.v1.StreamLimit")
	proto.RegisterType((*PlayConfEditReply)(nil), "bilibili.app.playurl.v1.PlayConfEditReply")
	proto.RegisterType((*PlayConfEditReq)(nil), "bilibili.app.playurl.v1.PlayConfEditReq")
	proto.RegisterType((*PlayConfState)(nil), "bilibili.app.playurl.v1.PlayConfState")
	proto.RegisterType((*FieldValue)(nil), "bilibili.app.playurl.v1.FieldValue")
	proto.RegisterType((*DashVideo)(nil), "bilibili.app.playurl.v1.DashVideo")
}

func init() {
	proto.RegisterFile("go-gateway/app/app-svr/app-player/interface/api/playurl/playurl.proto", fileDescriptor_5a3d491d087f669a)
}

var fileDescriptor_5a3d491d087f669a = []byte{
	// 3970 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcd, 0x73, 0xe3, 0x46,
	0x76, 0x17, 0x48, 0x51, 0x24, 0x1f, 0x3f, 0x04, 0xc1, 0x63, 0x9b, 0xf3, 0xe1, 0x19, 0x99, 0xb3,
	0x6b, 0xab, 0x94, 0x58, 0x13, 0x2b, 0xde, 0x2f, 0x3b, 0xf2, 0x2c, 0x45, 0x52, 0x33, 0xf4, 0x50,
	0xa4, 0xd2, 0x94, 0x34, 0xeb, 0xad, 0x54, 0xb1, 0x40, 0xa2, 0x49, 0x62, 0x05, 0x02, 0x1c, 0x00,
	0x94, 0xac, 0x9c, 0xf6, 0x98, 0x1c, 0x92, 0x43, 0x4e, 0x39, 0x27, 0xb7, 0xfd, 0x0f, 0xf6, 0x90,
	0xaa, 0x1c, 0x53, 0x39, 0x65, 0x2b, 0x95, 0x6b, 0x2a, 0xe5, 0x5c, 0x52, 0x95, 0x3d, 0xe5, 0x9a,
	0x4b, 0xea, 0xbd, 0x6e, 0x80, 0x90, 0x28, 0x92, 0x18, 0x57, 0xa5, 0x92, 0xc3, 0x1e, 0x54, 0xc4,
	0x7b, 0xfd, 0xde, 0x0f, 0xdd, 0xaf, 0x5f, 0x77, 0xff, 0x00, 0x3c, 0x41, 0x7d, 0xe8, 0x7c, 0x32,
	0xd4, 0x7d, 0x7e, 0xa5, 0x5f, 0x3f, 0xd3, 0x27, 0x13, 0xfc, 0xfb, 0xc4, 0xbb, 0x74, 0xe9, 0x77,
	0x62, 0xe9, 0xd7, 0xdc, 0x7d, 0x66, 0xda, 0x3e, 0x77, 0x07, 0x7a, 0x9f, 0x3f, 0xd3, 0x27, 0xe6,
	0x33, 0x54, 0x4e, 0x5d, 0x2b, 0xf8, 0xdd, 0x9b, 0xb8, 0x8e, 0xef, 0x68, 0xef, 0xf7, 0x4c, 0xcb,
	0xc4, 0xbf, 0x3d, 0x7d, 0x32, 0xd9, 0x0b, 0xda, 0x2e, 0x3f, 0x7d, 0xf0, 0xc9, 0xd0, 0xf4, 0x47,
	0xd3, 0xde, 0x5e, 0xdf, 0x19, 0x3f, 0x1b, 0x3a, 0x43, 0xe7, 0x19, 0xd9, 0xf7, 0xa6, 0x03, 0x92,
	0x48, 0xa0, 0x2b, 0x81, 0x53, 0xfe, 0xe7, 0x04, 0xc0, 0x89, 0xa5, 0x5f, 0x9f, 0xb1, 0x26, 0xe3,
	0x6f, 0xb4, 0x3d, 0x48, 0xea, 0xa6, 0x51, 0x52, 0xb6, 0x95, 0x9d, 0xe4, 0xe1, 0xa3, 0xff, 0xfa,
	0xd7, 0x27, 0xa5, 0x4b, 0xdd, 0x32, 0x0d, 0xdd, 0xe7, 0x9f, 0x97, 0x87, 0xfe, 0xc1, 0x1f, 0xfc,
	0xbe, 0xcb, 0xdf, 0x4c, 0x4d, 0x97, 0x1b, 0x65, 0x86, 0x86, 0x68, 0xdf, 0x37, 0x8d, 0x52, 0x22,
	0x8e, 0x7d, 0xdf, 0x34, 0xb4, 0x22, 0x24, 0xde, 0xd8, 0xa5, 0x24, 0x9a, 0xb3, 0xc4, 0x1b, 0x5b,
	0xbb, 0x07, 0xa9, 0x81, 0x7d, 0xc9, 0xdd, 0xd2, 0xfa, 0xb6, 0xb2, 0x93, 0x62, 0x42, 0x90, 0x5a,
	0xdd, 0x2a, 0xa5, 0x42, 0xad, 0x6e, 0x69, 0x0f, 0x20, 0x63, 0x38, 0x57, 0xb6, 0xe5, 0xe8, 0x46,
	0x69, 0x63, 0x5b, 0xd9, 0x29, 0xb0, 0x50, 0xd6, 0x3e, 0x00, 0x18, 0x38, 0x6e, 0x9f, 0x77, 0x47,
	0x8e, 0xe7, 0x97, 0xd2, 0xe4, 0x96, 0x25, 0xcd, 0x4b, 0xc7, 0xf3, 0x09, 0xd0, 0x99, 0xba, 0x17,
	0xa5, 0xcc, 0xb6, 0xb2, 0x93, 0x61, 0x42, 0x40, 0xad, 0x37, 0x19, 0x9b, 0x46, 0x29, 0xbb, 0xad,
	0xec, 0x64, 0x99, 0x10, 0x08, 0xca, 0x75, 0xc6, 0x5d, 0xd1, 0x04, 0xd4, 0x94, 0x45, 0x4d, 0x87,
	0x9a, 0x9f, 0x42, 0xe1, 0xd2, 0x31, 0xfb, 0xbc, 0xdb, 0xd3, 0x2d, 0xdd, 0xee, 0xf3, 0x52, 0x8e,
	0x06, 0x93, 0x27, 0xe5, 0xa1, 0xd0, 0x95, 0x7f, 0x99, 0x82, 0x7c, 0x18, 0xd5, 0x89, 0x75, 0xad,
	0x95, 0x20, 0xfd, 0x66, 0xaa, 0x5b, 0xa6, 0x7f, 0x4d, 0xb1, 0x2d, 0xb0, 0x40, 0xd4, 0xde, 0x83,
	0x8d, 0x81, 0xe3, 0x8e, 0x75, 0x9f, 0x82, 0x98, 0x65, 0x52, 0xd2, 0x1e, 0x03, 0xf8, 0xe6, 0x98,
	0x5b, 0xdc, 0x1e, 0xfa, 0x23, 0x8a, 0xd8, 0x3a, 0x8b, 0x68, 0xa8, 0x1f, 0xa6, 0xc1, 0x9d, 0x6e,
	0xdf, 0x31, 0x38, 0xce, 0xc1, 0x3a, 0xe1, 0xe6, 0x49, 0x59, 0x15, 0xba, 0x59, 0x78, 0x53, 0xd4,
	0x78, 0x3b, 0xbc, 0x1b, 0xa1, 0x56, 0xb7, 0x66, 0x80, 0x13, 0xd7, 0xf9, 0x05, 0xef, 0x8b, 0x28,
	0x66, 0x24, 0xe0, 0x89, 0xd0, 0x69, 0x3f, 0x86, 0x75, 0x63, 0xea, 0x5a, 0xa5, 0xcc, 0x76, 0x72,
	0x27, 0xb7, 0xff, 0xbd, 0xbd, 0x05, 0x59, 0xb8, 0xc7, 0xb8, 0x37, 0x71, 0x6c, 0x8f, 0x9f, 0xb9,
	0x16, 0x23, 0x0f, 0xed, 0x27, 0xb0, 0x6e, 0xe8, 0xde, 0x88, 0x62, 0x9d, 0xdb, 0xff, 0xfe, 0x4a,
	0xcf, 0x9a, 0xee, 0x8d, 0x18, 0xb9, 0xe0, 0x8c, 0xd8, 0x4e, 0xd7, 0xe5, 0xdf, 0xe0, 0x50, 0x69,
	0x46, 0x52, 0x2c, 0x6b, 0x3b, 0x4c, 0x28, 0xb4, 0xaf, 0xa0, 0x30, 0x9d, 0x0c, 0x5d, 0xdd, 0xe0,
	0x5d, 0xcb, 0x1c, 0x9b, 0x3e, 0xcd, 0xc8, 0xb2, 0x5b, 0x9c, 0x09, 0xeb, 0x26, 0x1a, 0xb3, 0xfc,
	0x34, 0x22, 0x69, 0x1d, 0xd8, 0xf4, 0xa6, 0x93, 0x89, 0xe3, 0xfa, 0x5d, 0x31, 0x0f, 0x5e, 0x29,
	0x4f, 0x43, 0xdd, 0x5d, 0x88, 0x76, 0x44, 0x76, 0x35, 0xee, 0xf5, 0x5d, 0x73, 0xe2, 0x9b, 0x8e,
	0xcd, 0x8a, 0x12, 0x42, 0xb4, 0x78, 0xda, 0x0f, 0x61, 0xdd, 0xbf, 0x9e, 0xf0, 0x52, 0x61, 0x5b,
	0xd9, 0x29, 0xee, 0x97, 0x17, 0x22, 0x9d, 0x63, 0xa4, 0x4f, 0xaf, 0x27, 0x9c, 0x91, 0xbd, 0xf6,
	0x05, 0x6c, 0x5c, 0x3a, 0xd6, 0x74, 0xcc, 0x4b, 0x45, 0x1a, 0xd1, 0xd3, 0xc5, 0x9e, 0x64, 0xd6,
	0xb0, 0x07, 0x0e, 0x93, 0x2e, 0xe5, 0xbf, 0x52, 0x20, 0x17, 0x99, 0x05, 0x9c, 0x74, 0xc7, 0x35,
	0xb8, 0x2b, 0xf3, 0x4f, 0x08, 0x98, 0x7d, 0x32, 0xc3, 0x12, 0x94, 0x61, 0x52, 0xd2, 0x34, 0x58,
	0xf7, 0xcc, 0x3f, 0xe5, 0x32, 0xef, 0xe8, 0x5a, 0x53, 0x21, 0x89, 0x53, 0xbf, 0x4e, 0x69, 0x8a,
	0x97, 0x38, 0x31, 0x3d, 0xbd, 0x7f, 0x31, 0x9d, 0x74, 0xb1, 0x21, 0xb5, 0x9d, 0xc4, 0xa5, 0x22,
	0x34, 0x78, 0x4b, 0x15, 0x92, 0x63, 0xe3, 0x07, 0x94, 0x65, 0x59, 0x86, 0x97, 0xe5, 0x5f, 0x2a,
	0x90, 0x8f, 0x4e, 0xb0, 0xf6, 0x23, 0x48, 0x51, 0x7e, 0x95, 0x14, 0x8a, 0xf2, 0x87, 0x0b, 0x47,
	0x88, 0xd6, 0x0d, 0x9f, 0x8f, 0x99, 0xb0, 0x47, 0x47, 0x7d, 0x6a, 0x98, 0x4e, 0x29, 0x11, 0xdb,
	0x91, 0xec, 0xcb, 0xbf, 0x51, 0x20, 0x13, 0xe8, 0x70, 0x3b, 0x92, 0xbb, 0x5d, 0x81, 0x25, 0x4c,
	0x43, 0xbb, 0x0f, 0x99, 0x9e, 0xee, 0x71, 0x1a, 0x8e, 0x58, 0x8e, 0x69, 0x94, 0xcf, 0xe6, 0xc6,
	0x9a, 0xbc, 0x3d, 0xd6, 0x47, 0x90, 0xed, 0xe9, 0xb6, 0x71, 0x65, 0x1a, 0xfe, 0x48, 0x2e, 0xc5,
	0x99, 0x02, 0x97, 0x7f, 0xb0, 0x4c, 0xc5, 0x4a, 0x0c, 0xc4, 0xf9, 0x18, 0x85, 0xa1, 0x4f, 0x47,
	0x42, 0x4f, 0x7b, 0x92, 0x3e, 0xe6, 0x5d, 0x57, 0xf7, 0x39, 0x6d, 0x62, 0xb4, 0x27, 0xe9, 0x63,
	0xce, 0x74, 0x9f, 0x97, 0xff, 0x5e, 0x81, 0x2c, 0x6e, 0x37, 0x22, 0x87, 0x3f, 0x87, 0x75, 0x5a,
	0x28, 0x0a, 0xa5, 0xdb, 0x47, 0x0b, 0x23, 0x13, 0x7a, 0xe0, 0x6e, 0xc1, 0xc8, 0x07, 0x3b, 0x3a,
	0xe6, 0x9e, 0xa7, 0x0f, 0x79, 0x30, 0x7e, 0x29, 0x6a, 0x4f, 0x20, 0xe7, 0x4d, 0x7b, 0xdd, 0xa0,
	0x35, 0x49, 0xad, 0xe0, 0x4d, 0x7b, 0xc7, 0xd2, 0xe0, 0x8f, 0x60, 0xa3, 0x37, 0xf5, 0x7d, 0xc7,
	0xa6, 0xe1, 0x2f, 0xdb, 0x1c, 0x0e, 0xc9, 0xac, 0xe3, 0x5f, 0x5b, 0x9c, 0x49, 0x9f, 0xf2, 0x37,
	0x90, 0x8b, 0xa8, 0x31, 0x08, 0x3e, 0xff, 0xc6, 0xa7, 0x31, 0x64, 0x19, 0x5d, 0x63, 0x10, 0xf0,
	0xb7, 0xdb, 0x77, 0x2c, 0xc7, 0x95, 0xdd, 0xcb, 0xa2, 0xa6, 0x8a, 0x0a, 0x9a, 0xbb, 0xa1, 0x6c,
	0x4c, 0xca, 0xb9, 0x1b, 0x8a, 0xa6, 0x87, 0x90, 0xfd, 0xc5, 0x74, 0x3c, 0xe9, 0x5a, 0xa6, 0x7d,
	0x21, 0xf3, 0x37, 0x83, 0x8a, 0xa6, 0x69, 0x5f, 0xe0, 0x42, 0xc9, 0x47, 0x77, 0x04, 0xbc, 0x77,
	0x18, 0xbf, 0xd4, 0xca, 0xb8, 0xdc, 0x83, 0x94, 0x39, 0x9e, 0x45, 0x44, 0x08, 0xda, 0x97, 0xb7,
	0x82, 0xf1, 0xd1, 0xaa, 0xcd, 0x48, 0x0c, 0x3e, 0x0c, 0xc7, 0x4f, 0xa0, 0x70, 0xa3, 0x01, 0x6f,
	0xe3, 0x9b, 0xbe, 0xc5, 0x65, 0x44, 0x84, 0x80, 0x5d, 0xa5, 0x31, 0x89, 0x3e, 0xd1, 0x75, 0xf9,
	0x5f, 0x14, 0xd8, 0x9a, 0xdb, 0x93, 0xbe, 0xc3, 0x01, 0xb4, 0x0d, 0x39, 0x63, 0x06, 0x20, 0x87,
	0x17, 0x55, 0x69, 0x1f, 0xc3, 0xa6, 0xcd, 0xaf, 0xba, 0x51, 0x2b, 0x11, 0xdc, 0xa2, 0xcd, 0xaf,
	0xa2, 0x37, 0xff, 0x10, 0xf2, 0x86, 0xe9, 0xe1, 0xa0, 0xc9, 0x98, 0xd6, 0x00, 0x62, 0x09, 0x1d,
	0x5a, 0xe2, 0xdd, 0xbc, 0xe9, 0x84, 0xbb, 0xc2, 0x49, 0xae, 0x87, 0xa8, 0xaa, 0xfc, 0x9f, 0xc8,
	0x54, 0xc4, 0x31, 0xf4, 0x3b, 0xa6, 0x12, 0x87, 0xa9, 0x3c, 0x80, 0x0c, 0x71, 0xbc, 0xbe, 0x63,
	0xd1, 0x91, 0x98, 0x62, 0xa1, 0x8c, 0xab, 0xd9, 0xe0, 0x97, 0x48, 0x63, 0xe8, 0x64, 0xca, 0x53,
	0x33, 0x08, 0x15, 0x9e, 0x40, 0xe5, 0x36, 0xe4, 0xc3, 0x60, 0x23, 0x81, 0x79, 0x0e, 0xe9, 0x80,
	0x17, 0x28, 0x2b, 0x8e, 0xd7, 0x28, 0xf1, 0x61, 0x81, 0x57, 0xf9, 0xcf, 0xd7, 0x21, 0x87, 0x2d,
	0xe7, 0x26, 0xbf, 0xfa, 0xdd, 0xfc, 0xc5, 0x99, 0xbf, 0xef, 0x43, 0xd1, 0xe7, 0xdc, 0xd6, 0x87,
	0xdc, 0xf5, 0xba, 0x63, 0xdc, 0x91, 0xc4, 0x2c, 0x16, 0x42, 0xed, 0x31, 0x6e, 0x4d, 0xc7, 0xb0,
	0x35, 0x71, 0xf9, 0x80, 0xbb, 0x82, 0x09, 0xce, 0x26, 0xb4, 0xb8, 0xe4, 0x54, 0xc4, 0x2d, 0x9f,
	0x98, 0xc6, 0xa6, 0xf0, 0x25, 0xc2, 0x88, 0x0a, 0xed, 0x00, 0x32, 0xbd, 0xa9, 0x67, 0xda, 0xdc,
	0xf3, 0x24, 0x61, 0xf9, 0x70, 0xc9, 0x46, 0x2e, 0x0c, 0x59, 0xe8, 0x32, 0x4f, 0x8f, 0x8b, 0x77,
	0xd0, 0xe3, 0x3f, 0x5b, 0x87, 0xc2, 0x2c, 0x17, 0x30, 0xbd, 0x2a, 0x00, 0x82, 0x7c, 0x9a, 0xf6,
	0xc0, 0x91, 0x19, 0xb6, 0x82, 0x28, 0x11, 0xdb, 0xc9, 0x5e, 0x06, 0x97, 0x5a, 0x1d, 0xb2, 0xb4,
	0xc3, 0xf4, 0x1d, 0x7b, 0x40, 0x69, 0x92, 0xdb, 0xdf, 0x59, 0x9a, 0xa3, 0x15, 0x6c, 0xf0, 0xaf,
	0xab, 0x8e, 0x3d, 0x60, 0x19, 0x6c, 0xc3, 0xab, 0x79, 0x36, 0x99, 0xfc, 0xee, 0x6c, 0xf2, 0x73,
	0x48, 0xf7, 0x47, 0xae, 0x63, 0x3b, 0x9e, 0x3c, 0x06, 0xb6, 0x17, 0x4f, 0x88, 0xb0, 0x63, 0x81,
	0x83, 0xf6, 0x1c, 0xa8, 0x4f, 0x5d, 0xdd, 0x15, 0xfb, 0xe5, 0xb2, 0x03, 0x95, 0x46, 0xe3, 0xf6,
	0x69, 0x24, 0xe9, 0x89, 0x10, 0xb4, 0xcf, 0x20, 0xc5, 0x2f, 0xb9, 0x2d, 0xf6, 0xd2, 0xdc, 0xfe,
	0xe3, 0x85, 0xde, 0x75, 0xb4, 0x62, 0xc2, 0x58, 0xfb, 0x3d, 0x48, 0xe8, 0x3d, 0x4a, 0xeb, 0xdc,
	0xfe, 0xc3, 0x85, 0x2e, 0x95, 0x43, 0x96, 0xd0, 0x7b, 0x38, 0x6b, 0xd4, 0x47, 0x11, 0xa8, 0xcc,
	0x8a, 0x59, 0x0b, 0xf9, 0x06, 0xa3, 0x89, 0xa2, 0xcb, 0xf2, 0x7f, 0x2b, 0x00, 0x33, 0xf6, 0x8a,
	0x4b, 0x62, 0xcc, 0x75, 0x6f, 0xea, 0x72, 0xa3, 0x6b, 0x52, 0x1e, 0x28, 0x2c, 0x1b, 0x68, 0x1a,
	0x78, 0x90, 0x84, 0xcd, 0x96, 0xab, 0xd3, 0x34, 0x2b, 0x2c, 0x17, 0xe8, 0x9a, 0xae, 0x8e, 0x3b,
	0x5b, 0x68, 0xe2, 0x4f, 0x68, 0xf6, 0x14, 0x16, 0x82, 0x9e, 0x4e, 0xb4, 0x4f, 0x40, 0x9b, 0x19,
	0x8c, 0x5c, 0xee, 0x8d, 0x1c, 0x4b, 0x3c, 0x3d, 0x29, 0x6c, 0x2b, 0xb4, 0x0b, 0x1a, 0x30, 0xa1,
	0x7d, 0xdd, 0x1d, 0x72, 0xbf, 0xeb, 0x0c, 0x06, 0x1e, 0xf7, 0x69, 0x32, 0x14, 0x96, 0x17, 0xca,
	0x36, 0xe9, 0x90, 0x7b, 0x48, 0x23, 0x93, 0xc2, 0xad, 0xb0, 0xb4, 0x90, 0x1b, 0xc8, 0x3d, 0x64,
	0x93, 0x3f, 0xa1, 0xb8, 0x2a, 0x4c, 0xda, 0x9e, 0x4e, 0xca, 0x1e, 0x24, 0x2a, 0x87, 0xda, 0x8f,
	0x60, 0x63, 0x28, 0x16, 0x8b, 0x48, 0xfc, 0x27, 0x0b, 0x43, 0xf8, 0x82, 0xcc, 0x98, 0x34, 0xc7,
	0x29, 0x1e, 0xba, 0xce, 0x74, 0x42, 0x71, 0x28, 0x2e, 0x99, 0xe2, 0x17, 0x68, 0xc5, 0x84, 0x71,
	0xf9, 0x35, 0x6c, 0x08, 0x1c, 0xec, 0x5b, 0x5f, 0xb7, 0xbb, 0x57, 0xba, 0xdf, 0x1f, 0xd1, 0xbd,
	0x33, 0x2c, 0xd3, 0xd7, 0xed, 0xd7, 0x28, 0x0b, 0xc6, 0x31, 0xe6, 0x9e, 0xd8, 0x72, 0x99, 0x10,
	0x68, 0x6b, 0x9c, 0xba, 0x7a, 0x48, 0x09, 0x92, 0x2c, 0x94, 0xcb, 0x07, 0x90, 0xa2, 0x5c, 0xc2,
	0x7e, 0x79, 0x23, 0xfd, 0x22, 0x18, 0xcf, 0xe2, 0x7e, 0x75, 0xd0, 0x8a, 0x09, 0xe3, 0xf2, 0x43,
	0x48, 0x91, 0x8c, 0xac, 0x66, 0x60, 0x86, 0x54, 0x87, 0xae, 0xcb, 0x05, 0x71, 0x7a, 0x50, 0x8a,
	0xf3, 0x37, 0xe5, 0x73, 0xb1, 0x81, 0x08, 0x11, 0x37, 0x90, 0x1b, 0xab, 0x5f, 0xf9, 0xae, 0xab,
	0xbf, 0xfc, 0x0c, 0xd2, 0x72, 0x25, 0x06, 0xcc, 0x5c, 0xb9, 0xc1, 0xcc, 0xa9, 0x5f, 0x89, 0x48,
	0xbf, 0xfe, 0x76, 0x0b, 0x36, 0x6f, 0xc1, 0x69, 0xa7, 0x70, 0x0f, 0x1f, 0x0c, 0x30, 0xda, 0xb6,
	0xd1, 0xbd, 0xdd, 0xad, 0xc5, 0x0b, 0xa4, 0x6a, 0x39, 0x53, 0x83, 0x3a, 0xa4, 0xcd, 0xfc, 0x83,
	0x61, 0x6a, 0xcf, 0x21, 0x3b, 0xb0, 0xcc, 0x49, 0x74, 0x7f, 0x8b, 0x03, 0x95, 0x41, 0xa7, 0x00,
	0xa0, 0xaf, 0x7b, 0xbe, 0x00, 0x48, 0xc6, 0x07, 0x40, 0x27, 0x02, 0x78, 0x01, 0x85, 0x01, 0xe7,
	0x06, 0xf6, 0x4d, 0x80, 0xac, 0xc7, 0x06, 0xc9, 0x07, 0x8e, 0x01, 0x90, 0x37, 0xed, 0x11, 0x85,
	0x15, 0x40, 0xa9, 0xf8, 0x40, 0x81, 0x23, 0x01, 0x9d, 0x80, 0x86, 0x56, 0xd4, 0x23, 0x7c, 0x34,
	0x12, 0x68, 0x1b, 0xb1, 0xd1, 0xd4, 0xc0, 0x1b, 0x1f, 0xa3, 0x08, 0xb1, 0x06, 0x79, 0x4c, 0xf4,
	0xee, 0x54, 0x06, 0x3a, 0x1d, 0x1b, 0x8b, 0x5e, 0xce, 0x9c, 0x4d, 0xe6, 0xfa, 0x85, 0x27, 0xb7,
	0xc0, 0xca, 0xbc, 0x7d, 0xbf, 0xf0, 0x84, 0x97, 0xc7, 0xd2, 0xa6, 0xd7, 0xd7, 0x2d, 0x1e, 0x81,
	0xcb, 0xc6, 0x86, 0x2b, 0x90, 0x6b, 0x88, 0xf5, 0x1c, 0xb2, 0x96, 0x79, 0x21, 0x51, 0x20, 0x7e,
	0x22, 0xa0, 0x13, 0x01, 0xd4, 0x89, 0xcf, 0xcf, 0x30, 0x72, 0xb1, 0x31, 0x72, 0xd2, 0x2f, 0x4c,
	0x48, 0xc7, 0xb4, 0x05, 0x46, 0xfe, 0x2d, 0x12, 0xd2, 0x31, 0xed, 0x00, 0x80, 0x5b, 0xbc, 0x2f,
	0x00, 0x0a, 0xf1, 0x01, 0xd0, 0x89, 0x00, 0x2a, 0x00, 0xde, 0x48, 0x77, 0xe5, 0x30, 0x8a, 0xb1,
	0x11, 0xb2, 0xe4, 0x45, 0x10, 0x4d, 0x50, 0xbd, 0xbe, 0xcb, 0xb9, 0xdd, 0xf5, 0x46, 0x8e, 0x5c,
	0x5c, 0x9b, 0xb1, 0x81, 0x8a, 0xc2, 0xb7, 0x33, 0x72, 0xfc, 0x00, 0xcd, 0x72, 0xfa, 0x17, 0x5d,
	0x09, 0x49, 0x68, 0x6a, 0x7c, 0x34, 0xf4, 0xed, 0x90, 0x2b, 0xa1, 0x35, 0xa0, 0xe8, 0xf2, 0xbe,
	0x33, 0x1e, 0x73, 0xdb, 0x10, 0x58, 0x5b, 0xf1, 0x73, 0x26, 0xf4, 0x24, 0x28, 0x06, 0xef, 0x84,
	0x19, 0xed, 0x4d, 0x38, 0x97, 0x78, 0x5a, 0x6c, 0xbc, 0xad, 0xc0, 0xbd, 0x83, 0xde, 0x84, 0xf9,
	0x0a, 0x36, 0x0d, 0x3e, 0x30, 0x6d, 0x13, 0x4f, 0x0f, 0x81, 0xf7, 0x4e, 0xfc, 0xb1, 0xce, 0x5c,
	0x03, 0x30, 0x0f, 0xe7, 0x15, 0x15, 0x9e, 0x00, 0xbb, 0xf7, 0x16, 0xd3, 0x10, 0xba, 0x06, 0x89,
	0x65, 0x8b, 0x57, 0x0d, 0xf6, 0xa0, 0xf4, 0x6e, 0xfc, 0xc4, 0xb2, 0xe9, 0x6d, 0x84, 0xd8, 0x46,
	0xb8, 0x61, 0xfa, 0x5d, 0x63, 0x2c, 0x30, 0xde, 0x8b, 0xbf, 0x8d, 0xa0, 0x5f, 0x6d, 0x4c, 0x28,
	0x2d, 0xd8, 0xf2, 0xc6, 0xba, 0x65, 0x75, 0xaf, 0x4c, 0xdb, 0x70, 0xae, 0x04, 0xd4, 0xfb, 0xb1,
	0xa1, 0x36, 0xc9, 0xf9, 0x35, 0xf9, 0x46, 0xd2, 0x3d, 0x58, 0xb5, 0xa5, 0xb7, 0x4a, 0x77, 0xb9,
	0x66, 0x8f, 0xa0, 0xe0, 0x4c, 0x7d, 0xee, 0x86, 0x23, 0xbb, 0x1f, 0x7f, 0xed, 0x93, 0xa3, 0x1c,
	0xda, 0x11, 0x14, 0x4c, 0xdb, 0x8e, 0xe0, 0x3c, 0x88, 0x8f, 0x43, 0x8e, 0x12, 0xe7, 0x05, 0x14,
	0x26, 0xba, 0xed, 0xb8, 0xfa, 0x58, 0x17, 0x38, 0x0f, 0xe3, 0x1f, 0x25, 0x81, 0x63, 0x10, 0x1b,
	0xc3, 0xb1, 0x7a, 0xf2, 0xa8, 0x7e, 0x14, 0x3f, 0x36, 0xe4, 0x15, 0x4c, 0x17, 0xbd, 0x7e, 0xea,
	0x0e, 0x4c, 0xcb, 0xa7, 0xe7, 0x31, 0x7b, 0x50, 0xfa, 0x20, 0xfe, 0x74, 0x91, 0xf3, 0x11, 0xf9,
	0x12, 0xde, 0x4b, 0x28, 0x5a, 0x8e, 0xe7, 0x75, 0x2d, 0xee, 0xc9, 0x8c, 0x7e, 0x1c, 0x7f, 0x70,
	0xe8, 0xd9, 0xe4, 0x1e, 0xe5, 0x73, 0xf9, 0xd7, 0x5b, 0x82, 0x3e, 0xc9, 0x87, 0x04, 0x8d, 0x2d,
	0x65, 0x28, 0x8b, 0x9f, 0x52, 0x82, 0x87, 0x8c, 0xbb, 0xf8, 0xc9, 0xc1, 0x3c, 0x3f, 0x59, 0x0d,
	0x34, 0x63, 0x27, 0x07, 0xf3, 0xec, 0x24, 0x86, 0x7b, 0xc8, 0x4d, 0xea, 0x77, 0x73, 0x93, 0xd5,
	0x10, 0x37, 0x99, 0x49, 0xfd, 0x6e, 0x66, 0x12, 0x03, 0xe6, 0x06, 0x2f, 0x69, 0x2d, 0xe1, 0x25,
	0xab, 0xb1, 0xe6, 0x59, 0xc9, 0xe1, 0x9d, 0xac, 0x64, 0x35, 0x52, 0x94, 0x93, 0xb4, 0x96, 0x70,
	0x92, 0xb7, 0xe8, 0x53, 0xc8, 0x22, 0x5e, 0x2e, 0x62, 0x24, 0xab, 0xc1, 0x6e, 0xf1, 0x91, 0x83,
	0x79, 0x3e, 0x12, 0x63, 0xea, 0x43, 0x1a, 0x51, 0xbd, 0x93, 0x8d, 0xac, 0x46, 0xb8, 0xc1, 0x45,
	0x0e, 0xe6, 0xb9, 0x48, 0x9c, 0xf4, 0x0b, 0x98, 0xc8, 0xc1, 0x3c, 0x13, 0x89, 0xe1, 0x1e, 0xf2,
	0x90, 0xe7, 0x77, 0xf0, 0x90, 0xd5, 0xfe, 0x11, 0x16, 0xf2, 0xd5, 0x42, 0x16, 0xb2, 0x1a, 0xe6,
	0x36, 0x07, 0xf9, 0x6a, 0x21, 0x07, 0x89, 0x81, 0x75, 0x8b, 0x81, 0xbc, 0x58, 0xc0, 0x40, 0x62,
	0xe4, 0xc8, 0x4d, 0xfe, 0x71, 0xb2, 0x8c, 0x7f, 0xac, 0x46, 0xbb, 0x83, 0x7d, 0x34, 0x16, 0xb1,
	0x8f, 0x18, 0xa3, 0xbc, 0xc5, 0x3d, 0x1a, 0x8b, 0xb8, 0x47, 0x9c, 0xe0, 0xdf, 0x64, 0x1e, 0x07,
	0xf3, 0xcc, 0x23, 0x46, 0x22, 0x85, 0xbc, 0xe3, 0xf0, 0x4e, 0xde, 0x11, 0x63, 0xa3, 0x88, 0xb0,
	0x8e, 0xe6, 0x62, 0xd6, 0xb1, 0x1a, 0x68, 0x8e, 0x73, 0x3c, 0xbf, 0x83, 0x73, 0xc4, 0x4b, 0xed,
	0x8b, 0xe0, 0x89, 0xec, 0x4e, 0xc6, 0x11, 0x63, 0x7d, 0x47, 0xf9, 0x46, 0xed, 0x6e, 0xbe, 0x11,
	0x03, 0x25, 0xca, 0x36, 0xea, 0x77, 0xb3, 0x8d, 0x18, 0xc7, 0xc3, 0x0d, 0xae, 0xf1, 0xfc, 0x0e,
	0xae, 0x11, 0x23, 0x26, 0x33, 0xa6, 0x71, 0x0a, 0xef, 0xca, 0xd5, 0x89, 0xab, 0xc4, 0x35, 0x4c,
	0x7b, 0x18, 0x65, 0x1b, 0xab, 0xb1, 0xde, 0x11, 0xee, 0x2c, 0xf0, 0x0e, 0x26, 0x7e, 0x9e, 0xbf,
	0x3c, 0x8e, 0x3b, 0xf1, 0xb7, 0xd9, 0xcb, 0xd1, 0x1c, 0x7b, 0x79, 0x12, 0x37, 0x58, 0x37, 0xb8,
	0xcb, 0xcf, 0x21, 0x8b, 0xbf, 0xe7, 0xba, 0x35, 0xe5, 0xda, 0x13, 0x00, 0xef, 0xca, 0xf4, 0xfb,
	0xa3, 0xee, 0xa5, 0x6e, 0x89, 0x57, 0x56, 0x2f, 0xd7, 0x58, 0x56, 0xe8, 0xce, 0xa9, 0x8a, 0x21,
	0x2f, 0x56, 0x14, 0x37, 0xc8, 0x84, 0x5e, 0x5e, 0xbd, 0x5c, 0x63, 0xb9, 0x40, 0x7b, 0xae, 0x5b,
	0x87, 0x69, 0x48, 0x5d, 0x22, 0x5c, 0xf9, 0x3f, 0x14, 0xc8, 0x86, 0x9c, 0x89, 0xbe, 0xbc, 0x8e,
	0x9c, 0x2b, 0xf9, 0x26, 0x8c, 0xae, 0xb5, 0x2f, 0xf1, 0x5c, 0xb0, 0x07, 0xe2, 0xad, 0x7a, 0x62,
	0xe5, 0x5b, 0x75, 0x7b, 0x40, 0x6f, 0xd5, 0x33, 0x7d, 0x79, 0xa5, 0xd5, 0x20, 0x37, 0x30, 0xb9,
	0x45, 0x9d, 0x99, 0x72, 0x49, 0x6c, 0x16, 0x7f, 0xc8, 0x3f, 0x42, 0x5b, 0x1a, 0x2a, 0x83, 0x41,
	0x78, 0x8d, 0xe4, 0x94, 0x7a, 0x21, 0x40, 0x56, 0xbe, 0x76, 0x09, 0xc2, 0xc5, 0xa8, 0xef, 0x74,
	0x59, 0xfe, 0xb5, 0x02, 0xe9, 0x80, 0xfe, 0x7d, 0x00, 0x60, 0x7a, 0x5d, 0x59, 0xa5, 0x20, 0x87,
	0x9b, 0x35, 0xbd, 0x8e, 0x50, 0xd0, 0x3b, 0x3e, 0xd3, 0xd3, 0x7b, 0x16, 0x17, 0xdf, 0x5b, 0x32,
	0x2c, 0x94, 0xb5, 0xaf, 0xa0, 0xc0, 0xbf, 0xf1, 0x5d, 0x4a, 0x7f, 0x9f, 0xdb, 0xab, 0x5f, 0x8f,
	0xd7, 0xd1, 0xba, 0x2a, 0x8c, 0x59, 0x9e, 0x47, 0x24, 0xed, 0x63, 0xd8, 0x9c, 0xda, 0x41, 0xb9,
	0x85, 0xd7, 0xe7, 0x36, 0x0e, 0x2d, 0xb9, 0x93, 0x64, 0xc5, 0x50, 0xdd, 0x41, 0x6d, 0xf9, 0x4f,
	0x20, 0x5f, 0xbf, 0xe5, 0x18, 0x74, 0xa8, 0xeb, 0x72, 0xdd, 0x73, 0x6c, 0xf9, 0x9a, 0xae, 0x18,
	0xa8, 0x19, 0x69, 0xb5, 0xa7, 0x50, 0x08, 0x0d, 0xe9, 0x9b, 0xae, 0x78, 0x97, 0x99, 0x0f, 0x94,
	0x55, 0xc7, 0xe0, 0xe5, 0x7f, 0x4c, 0x42, 0x36, 0xfc, 0xa2, 0xf0, 0x7f, 0x55, 0xa9, 0xf3, 0x53,
	0xc8, 0x79, 0xbe, 0xcb, 0xf5, 0x71, 0xd7, 0x32, 0x3d, 0x9f, 0x6a, 0x29, 0x96, 0xbd, 0x08, 0xee,
	0x90, 0x2d, 0x03, 0xe1, 0xd3, 0x34, 0x3d, 0x5f, 0xfb, 0x29, 0x80, 0xa1, 0x7b, 0xa3, 0xae, 0x28,
	0x8b, 0xd8, 0x88, 0x5b, 0x16, 0x91, 0x45, 0xa7, 0x0a, 0xfa, 0x68, 0x3f, 0x86, 0x14, 0x6d, 0x31,
	0x2b, 0x5f, 0x7a, 0xd5, 0xd0, 0x4a, 0x14, 0x55, 0x90, 0x43, 0xa4, 0x52, 0x25, 0xf3, 0xd6, 0x95,
	0x2a, 0xda, 0xab, 0xe8, 0x46, 0x61, 0xfa, 0x7c, 0xbc, 0xb2, 0x46, 0xa8, 0x29, 0xf7, 0x07, 0xea,
	0x42, 0xb8, 0x5b, 0xa0, 0x54, 0xfe, 0x4b, 0x05, 0xf2, 0xd1, 0x66, 0x6d, 0x17, 0xb6, 0x4c, 0xaf,
	0x8b, 0x36, 0x84, 0x2f, 0xa2, 0x23, 0x52, 0x7e, 0xd3, 0xf4, 0x9a, 0x52, 0x2f, 0x02, 0x10, 0x29,
	0x2a, 0x51, 0xde, 0xa6, 0xa8, 0x44, 0xbb, 0x0f, 0x19, 0x1b, 0x39, 0xc9, 0xa5, 0x29, 0xbe, 0x38,
	0x64, 0x58, 0x1a, 0xe5, 0x73, 0x73, 0x52, 0xfe, 0x95, 0x02, 0xd9, 0x30, 0x5e, 0xda, 0x17, 0xb2,
	0x14, 0x48, 0xd4, 0x66, 0x7c, 0xbc, 0x3a, 0xc2, 0x7b, 0x91, 0x7a, 0xa0, 0xef, 0x5c, 0xf3, 0xf2,
	0x31, 0xac, 0xd3, 0x66, 0x94, 0x81, 0xf5, 0x56, 0xbb, 0x55, 0x57, 0xd7, 0x34, 0x80, 0x8d, 0x6a,
	0xfb, 0xf8, 0xb8, 0xdd, 0x52, 0x15, 0x2d, 0x0b, 0xa9, 0xca, 0xe9, 0x71, 0xbb, 0xa3, 0x26, 0xca,
	0xbf, 0x55, 0x60, 0x43, 0xa4, 0x16, 0x6e, 0x5c, 0x32, 0x21, 0x23, 0x9f, 0xe4, 0x9e, 0xae, 0x48,
	0x48, 0x9a, 0x57, 0x99, 0x94, 0xb4, 0x9a, 0xaa, 0x32, 0x29, 0x45, 0x91, 0xcf, 0xaa, 0xb7, 0xd6,
	0xd8, 0x6f, 0x5a, 0x89, 0xb8, 0xa7, 0x1b, 0x81, 0xa0, 0x35, 0xa1, 0xe0, 0xf1, 0xe1, 0x98, 0xdb,
	0xbe, 0xc4, 0x59, 0xb5, 0xe7, 0x74, 0x84, 0x75, 0x00, 0x95, 0xf7, 0x22, 0xf2, 0x61, 0x16, 0xd2,
	0x72, 0xef, 0x2a, 0xb7, 0x20, 0x1f, 0x35, 0xd5, 0xbe, 0x84, 0xb4, 0x34, 0x95, 0xf5, 0x48, 0xf1,
	0x0a, 0xdc, 0x02, 0xa7, 0xf2, 0x5f, 0xac, 0x03, 0xcc, 0x02, 0xf1, 0xbf, 0x52, 0x73, 0xf1, 0x05,
	0x64, 0xb8, 0x2b, 0x3e, 0xf5, 0xd2, 0x3e, 0x52, 0x5c, 0x72, 0x9e, 0xe2, 0xa3, 0x79, 0xdd, 0x75,
	0x59, 0x9a, 0xbb, 0xf4, 0x81, 0x57, 0xfb, 0x1c, 0x52, 0xe2, 0x53, 0xdd, 0xaa, 0x0f, 0x8a, 0x1d,
	0xb9, 0xad, 0x8c, 0x4d, 0x9f, 0x09, 0x97, 0x1b, 0x29, 0xbe, 0x71, 0x23, 0xc5, 0xa9, 0x3e, 0x0f,
	0x9b, 0x2c, 0x67, 0x68, 0xda, 0xb2, 0x6c, 0x30, 0x8b, 0x9a, 0x26, 0x2a, 0x70, 0xb0, 0xa6, 0xed,
	0xeb, 0x7d, 0x5f, 0x7e, 0x13, 0x97, 0xd2, 0xad, 0xb2, 0xbe, 0xac, 0x74, 0x0b, 0xcb, 0xfa, 0x1e,
	0x41, 0x56, 0xf7, 0x7d, 0xd7, 0xec, 0x4d, 0x7d, 0x51, 0xf4, 0x97, 0x64, 0x33, 0xc5, 0x5d, 0xb5,
	0x27, 0xb9, 0x58, 0xb5, 0x27, 0xf9, 0x95, 0xb5, 0x27, 0x85, 0xb9, 0xda, 0x13, 0x1c, 0xfc, 0xa5,
	0x39, 0xe9, 0x0e, 0x5c, 0x2e, 0x3e, 0x68, 0x67, 0x58, 0xfa, 0xd2, 0x9c, 0x1c, 0xb9, 0x9c, 0xe3,
	0x61, 0x19, 0x3c, 0xfa, 0xd3, 0x13, 0x57, 0x96, 0x85, 0x72, 0xf9, 0x05, 0xe4, 0x22, 0x91, 0x5c,
	0x50, 0xc3, 0x43, 0x65, 0x75, 0xa6, 0x4c, 0x04, 0xbc, 0xa4, 0x2f, 0x4f, 0xde, 0x50, 0xce, 0x3e,
	0x5e, 0x96, 0xdf, 0x81, 0xad, 0xe0, 0x3d, 0x4b, 0xdd, 0x30, 0x45, 0x49, 0x46, 0xd9, 0x17, 0x5f,
	0x9e, 0x66, 0xca, 0x37, 0x9a, 0x7e, 0xf3, 0x2b, 0x58, 0x72, 0x69, 0xe5, 0x51, 0xe0, 0xdc, 0xf1,
	0x75, 0x9f, 0xaf, 0x28, 0xa9, 0x98, 0x7d, 0x21, 0xfb, 0xad, 0x32, 0xfb, 0xf4, 0x46, 0x9e, 0x37,
	0x29, 0x92, 0xf2, 0xf6, 0x14, 0x29, 0xa0, 0x5d, 0x89, 0x08, 0xed, 0xfa, 0x7f, 0x43, 0x9b, 0x9e,
	0x01, 0xcc, 0xc0, 0xb5, 0x12, 0x6c, 0x08, 0xaa, 0x19, 0x52, 0x4f, 0x29, 0xcf, 0x28, 0xe5, 0xaf,
	0x12, 0x90, 0x0d, 0xf7, 0xb1, 0x1b, 0x05, 0x85, 0xca, 0xb2, 0x82, 0xc2, 0xc4, 0xd2, 0x82, 0xc2,
	0xe4, 0x92, 0x82, 0xc2, 0xf5, 0x3b, 0x0b, 0x0a, 0x53, 0xf3, 0x05, 0x85, 0x1b, 0x91, 0x82, 0xc2,
	0xfb, 0x90, 0xa1, 0xa3, 0xa1, 0x6b, 0x1a, 0xb4, 0x60, 0x0b, 0x2c, 0x4d, 0x72, 0xc3, 0xb8, 0xb5,
	0x2c, 0x33, 0xb7, 0x97, 0xe5, 0xcd, 0x52, 0xc4, 0xec, 0xad, 0x52, 0x44, 0xcc, 0x71, 0xd1, 0x65,
	0x10, 0x65, 0xa6, 0xa2, 0xbb, 0xef, 0xc1, 0xc6, 0x88, 0x9b, 0xc3, 0x91, 0xa8, 0xcd, 0x2d, 0x30,
	0x29, 0xed, 0xee, 0x8b, 0x5c, 0x0a, 0xab, 0x10, 0xb5, 0x02, 0x64, 0x4f, 0x9a, 0xd5, 0x33, 0xfb,
	0xc2, 0xb9, 0xb2, 0xd5, 0x35, 0x4d, 0x83, 0x22, 0x8a, 0xc3, 0x7e, 0xcb, 0xf1, 0x4f, 0xf4, 0x6b,
	0x6e, 0xa8, 0xca, 0x6e, 0x19, 0x32, 0x41, 0xdd, 0x89, 0x96, 0x83, 0xf4, 0x59, 0xeb, 0x55, 0xab,
	0xfd, 0xba, 0xa5, 0xae, 0xe1, 0x39, 0xd6, 0x39, 0x6d, 0xb3, 0xaf, 0x55, 0x65, 0xf7, 0x00, 0x32,
	0x41, 0x85, 0x0b, 0x1e, 0x75, 0xad, 0x76, 0xb5, 0x5d, 0xc3, 0x63, 0x2f, 0x07, 0x69, 0xbc, 0xda,
	0xff, 0xe1, 0x67, 0xaa, 0x32, 0x13, 0x7e, 0xa0, 0x26, 0x02, 0xa1, 0x72, 0xfe, 0xa9, 0x9a, 0xdc,
	0xdd, 0x83, 0x14, 0x7d, 0x31, 0xd7, 0x54, 0xc8, 0x9f, 0xd9, 0x17, 0xb6, 0x73, 0x65, 0x93, 0xac,
	0xae, 0x69, 0x29, 0x50, 0x2a, 0xaa, 0x82, 0x3f, 0x87, 0x6a, 0x02, 0x7f, 0xaa, 0x6a, 0x72, 0xf7,
	0xef, 0x92, 0x78, 0x3f, 0x99, 0xce, 0x78, 0x3f, 0xaa, 0xe2, 0x55, 0xd7, 0xb4, 0x3c, 0x64, 0x8e,
	0x9a, 0x8d, 0x93, 0x6a, 0xbb, 0x75, 0xa4, 0x2a, 0x28, 0x55, 0x2b, 0x9d, 0x53, 0x92, 0x12, 0xd4,
	0x56, 0xaf, 0xd7, 0x0e, 0x2b, 0xd5, 0x57, 0x6a, 0x12, 0xa5, 0xce, 0xd9, 0xe1, 0x69, 0xe3, 0xb4,
	0x59, 0x57, 0xd7, 0xf1, 0xbe, 0x27, 0xcd, 0xca, 0xd7, 0xd8, 0xc6, 0x2a, 0xa7, 0x75, 0x35, 0x85,
	0xa8, 0xa7, 0x8d, 0xe3, 0xfa, 0xd9, 0x89, 0xba, 0x11, 0x6d, 0x3d, 0xc6, 0x71, 0xa5, 0x31, 0x6c,
	0x9d, 0x6a, 0xa5, 0x59, 0x27, 0x31, 0x83, 0x61, 0xc3, 0xc6, 0x17, 0xac, 0x7d, 0xd6, 0xaa, 0xa1,
	0xa9, 0x9a, 0xc5, 0xb3, 0xbf, 0xd9, 0x78, 0x55, 0x57, 0x01, 0x87, 0x5a, 0x6b, 0x74, 0x48, 0xc8,
	0xa1, 0xba, 0xda, 0x6e, 0xb4, 0xd4, 0x3c, 0x5e, 0xd5, 0x9b, 0xf5, 0xaa, 0x5a, 0xa0, 0x40, 0xbe,
	0xac, 0xb0, 0xba, 0x5a, 0xd4, 0x8a, 0x00, 0x9d, 0x2a, 0xab, 0xd7, 0x5b, 0x9d, 0x97, 0xed, 0x53,
	0x75, 0x13, 0xe5, 0x66, 0xbb, 0xfa, 0x4a, 0xe8, 0x54, 0x15, 0x6f, 0xcc, 0xea, 0xc8, 0x24, 0xea,
	0xad, 0x9a, 0xba, 0xa5, 0x6d, 0x41, 0x21, 0xe8, 0x59, 0xe7, 0xa4, 0x5e, 0xaf, 0xa9, 0x1a, 0x7a,
	0xd4, 0xea, 0x47, 0x8d, 0x56, 0xe3, 0xb4, 0xd1, 0x6e, 0xa9, 0xef, 0x10, 0x22, 0xde, 0x07, 0xc5,
	0x8e, 0x7a, 0x8f, 0x38, 0x49, 0xfd, 0x67, 0xa7, 0xea, 0xbb, 0x38, 0xc4, 0x7a, 0xad, 0x71, 0x5a,
	0x3b, 0x56, 0xdf, 0xd3, 0x36, 0x21, 0xd7, 0x39, 0xae, 0x34, 0x9b, 0xaf, 0x1b, 0xad, 0x5a, 0xfb,
	0xb5, 0xfa, 0xbe, 0xec, 0xd3, 0xab, 0xba, 0x5a, 0xc2, 0xfe, 0xb7, 0xcf, 0x4e, 0xeb, 0xac, 0x76,
	0xac, 0xde, 0x47, 0xa1, 0xd1, 0x6a, 0x91, 0xf0, 0x00, 0x83, 0x78, 0x52, 0x69, 0xb5, 0x59, 0xe5,
	0xb8, 0xa2, 0x3e, 0x44, 0x97, 0x5a, 0xbb, 0x79, 0xf8, 0xb5, 0xfa, 0x08, 0xe1, 0xaa, 0xed, 0x66,
	0x9b, 0x1d, 0x35, 0x9a, 0xa7, 0x75, 0xa6, 0x7e, 0x80, 0x96, 0xcd, 0x76, 0xa7, 0xd3, 0xac, 0x77,
	0x3a, 0xea, 0xe3, 0xdd, 0x4f, 0x21, 0x2d, 0xcf, 0x4a, 0x74, 0x6a, 0x39, 0x75, 0xd7, 0x55, 0xd7,
	0xb4, 0x87, 0xf0, 0xfe, 0x6b, 0xd3, 0x1f, 0x1d, 0x4f, 0x2d, 0xdf, 0xac, 0x51, 0x65, 0x1c, 0x9d,
	0x67, 0xd8, 0xa8, 0xec, 0x7e, 0x26, 0x9f, 0x19, 0x68, 0xca, 0x31, 0x0d, 0x45, 0x9a, 0xa8, 0x6b,
	0x5a, 0x1a, 0x92, 0x47, 0xcd, 0x73, 0x55, 0xc1, 0x91, 0xd5, 0x2a, 0x9d, 0x97, 0x6a, 0x02, 0x55,
	0xc7, 0x27, 0x9f, 0xa9, 0xc9, 0xfd, 0xdf, 0x24, 0xc5, 0x9d, 0xce, 0x58, 0x53, 0x3b, 0x9b, 0x5d,
	0x3e, 0x5d, 0x5d, 0x4b, 0xf7, 0xe6, 0x41, 0xbc, 0x82, 0x3b, 0x82, 0x95, 0xc5, 0xfa, 0x4b, 0x60,
	0xc3, 0x3a, 0xca, 0x65, 0xb0, 0xd1, 0xfa, 0xbf, 0x9f, 0x41, 0x26, 0xa8, 0xd8, 0xd2, 0x96, 0x17,
	0x22, 0xc9, 0x02, 0xbf, 0x07, 0x1f, 0xc5, 0xb0, 0x42, 0x64, 0x43, 0xfc, 0xab, 0x44, 0x70, 0x8c,
	0x69, 0x3b, 0x2b, 0x0f, 0x2c, 0x79, 0xda, 0x3d, 0xd8, 0x8d, 0x69, 0x19, 0xe9, 0x3f, 0x3d, 0xfe,
	0x7e, 0x6f, 0xa5, 0xdf, 0xea, 0xfe, 0x87, 0x95, 0x27, 0x87, 0x7f, 0xfc, 0x0f, 0xdf, 0x3e, 0x56,
	0xfe, 0xe9, 0xdb, 0xc7, 0xca, 0xbf, 0x7d, 0xfb, 0x58, 0xf9, 0xeb, 0x7f, 0x7f, 0xbc, 0x06, 0x1f,
	0xf6, 0x9d, 0xf1, 0x5e, 0x4f, 0x9f, 0x98, 0xde, 0x22, 0x88, 0x13, 0xe5, 0xe7, 0x49, 0x7d, 0x62,
	0xfe, 0x4d, 0xe2, 0xde, 0x61, 0xe5, 0xa4, 0x71, 0x22, 0xf4, 0xe7, 0x9f, 0xca, 0x8b, 0xde, 0x06,
	0xd5, 0x69, 0xfe, 0xe1, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xac, 0x56, 0x30, 0x27, 0x2c, 0x34,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PlayURLClient is the client API for PlayURL service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PlayURLClient interface {
	// 获取播放地址
	PlayURL(ctx context.Context, in *PlayURLReq, opts ...grpc.CallOption) (*PlayURLReply, error)
	// 获取投屏地址（该接口不支持返回dash格式）
	Project(ctx context.Context, in *ProjectReq, opts ...grpc.CallOption) (*ProjectReply, error)
	// 获取播放地址和云控配置信息
	PlayView(ctx context.Context, in *PlayViewReq, opts ...grpc.CallOption) (*PlayViewReply, error)
	// 编辑云控的配置面板信息
	PlayConfEdit(ctx context.Context, in *PlayConfEditReq, opts ...grpc.CallOption) (*PlayConfEditReply, error)
	// 云控配置信息
	PlayConf(ctx context.Context, in *PlayConfReq, opts ...grpc.CallOption) (*PlayConfReply, error)
}

type playURLClient struct {
	cc *grpc.ClientConn
}

func NewPlayURLClient(cc *grpc.ClientConn) PlayURLClient {
	return &playURLClient{cc}
}

func (c *playURLClient) PlayURL(ctx context.Context, in *PlayURLReq, opts ...grpc.CallOption) (*PlayURLReply, error) {
	out := new(PlayURLReply)
	err := c.cc.Invoke(ctx, "/bilibili.app.playurl.v1.PlayURL/PlayURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playURLClient) Project(ctx context.Context, in *ProjectReq, opts ...grpc.CallOption) (*ProjectReply, error) {
	out := new(ProjectReply)
	err := c.cc.Invoke(ctx, "/bilibili.app.playurl.v1.PlayURL/Project", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playURLClient) PlayView(ctx context.Context, in *PlayViewReq, opts ...grpc.CallOption) (*PlayViewReply, error) {
	out := new(PlayViewReply)
	err := c.cc.Invoke(ctx, "/bilibili.app.playurl.v1.PlayURL/PlayView", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playURLClient) PlayConfEdit(ctx context.Context, in *PlayConfEditReq, opts ...grpc.CallOption) (*PlayConfEditReply, error) {
	out := new(PlayConfEditReply)
	err := c.cc.Invoke(ctx, "/bilibili.app.playurl.v1.PlayURL/PlayConfEdit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playURLClient) PlayConf(ctx context.Context, in *PlayConfReq, opts ...grpc.CallOption) (*PlayConfReply, error) {
	out := new(PlayConfReply)
	err := c.cc.Invoke(ctx, "/bilibili.app.playurl.v1.PlayURL/PlayConf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlayURLServer is the server API for PlayURL service.
type PlayURLServer interface {
	// 获取播放地址
	PlayURL(context.Context, *PlayURLReq) (*PlayURLReply, error)
	// 获取投屏地址（该接口不支持返回dash格式）
	Project(context.Context, *ProjectReq) (*ProjectReply, error)
	// 获取播放地址和云控配置信息
	PlayView(context.Context, *PlayViewReq) (*PlayViewReply, error)
	// 编辑云控的配置面板信息
	PlayConfEdit(context.Context, *PlayConfEditReq) (*PlayConfEditReply, error)
	// 云控配置信息
	PlayConf(context.Context, *PlayConfReq) (*PlayConfReply, error)
}

// UnimplementedPlayURLServer can be embedded to have forward compatible implementations.
type UnimplementedPlayURLServer struct {
}

func (*UnimplementedPlayURLServer) PlayURL(ctx context.Context, req *PlayURLReq) (*PlayURLReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayURL not implemented")
}
func (*UnimplementedPlayURLServer) Project(ctx context.Context, req *ProjectReq) (*ProjectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Project not implemented")
}
func (*UnimplementedPlayURLServer) PlayView(ctx context.Context, req *PlayViewReq) (*PlayViewReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayView not implemented")
}
func (*UnimplementedPlayURLServer) PlayConfEdit(ctx context.Context, req *PlayConfEditReq) (*PlayConfEditReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayConfEdit not implemented")
}
func (*UnimplementedPlayURLServer) PlayConf(ctx context.Context, req *PlayConfReq) (*PlayConfReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayConf not implemented")
}

func RegisterPlayURLServer(s *grpc.Server, srv PlayURLServer) {
	s.RegisterService(&_PlayURL_serviceDesc, srv)
}

func _PlayURL_PlayURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayURLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayURLServer).PlayURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bilibili.app.playurl.v1.PlayURL/PlayURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayURLServer).PlayURL(ctx, req.(*PlayURLReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlayURL_Project_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayURLServer).Project(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bilibili.app.playurl.v1.PlayURL/Project",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayURLServer).Project(ctx, req.(*ProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlayURL_PlayView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayViewReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayURLServer).PlayView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bilibili.app.playurl.v1.PlayURL/PlayView",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayURLServer).PlayView(ctx, req.(*PlayViewReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlayURL_PlayConfEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayConfEditReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayURLServer).PlayConfEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bilibili.app.playurl.v1.PlayURL/PlayConfEdit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayURLServer).PlayConfEdit(ctx, req.(*PlayConfEditReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlayURL_PlayConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayConfReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayURLServer).PlayConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bilibili.app.playurl.v1.PlayURL/PlayConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayURLServer).PlayConf(ctx, req.(*PlayConfReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _PlayURL_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bilibili.app.playurl.v1.PlayURL",
	HandlerType: (*PlayURLServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PlayURL",
			Handler:    _PlayURL_PlayURL_Handler,
		},
		{
			MethodName: "Project",
			Handler:    _PlayURL_Project_Handler,
		},
		{
			MethodName: "PlayView",
			Handler:    _PlayURL_PlayView_Handler,
		},
		{
			MethodName: "PlayConfEdit",
			Handler:    _PlayURL_PlayConfEdit_Handler,
		},
		{
			MethodName: "PlayConf",
			Handler:    _PlayURL_PlayConf_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go-gateway/app/app-svr/app-player/interface/api/playurl/playurl.proto",
}

func (m *PlayURLReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayURLReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayURLReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VoiceBalance != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.VoiceBalance))
		i--
		dAtA[i] = 0x58
	}
	if len(m.FromSpmid) > 0 {
		i -= len(m.FromSpmid)
		copy(dAtA[i:], m.FromSpmid)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.FromSpmid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Spmid) > 0 {
		i -= len(m.Spmid)
		copy(dAtA[i:], m.Spmid)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Spmid)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Fourk {
		i--
		if m.Fourk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ForceHost != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.ForceHost))
		i--
		dAtA[i] = 0x38
	}
	if m.Download != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Download))
		i--
		dAtA[i] = 0x30
	}
	if m.Fnval != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x28
	}
	if m.Fnver != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x20
	}
	if m.Qn != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Qn))
		i--
		dAtA[i] = 0x18
	}
	if m.Cid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayURLReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayURLReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayURLReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Volume != nil {
		{
			size, err := m.Volume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Type != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x68
	}
	if len(m.SupportFormats) > 0 {
		for iNdEx := len(m.SupportFormats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupportFormats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.UpgradeLimit != nil {
		{
			size, err := m.UpgradeLimit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.NoRexcode != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.NoRexcode))
		i--
		dAtA[i] = 0x50
	}
	if m.Dash != nil {
		{
			size, err := m.Dash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Durl) > 0 {
		for iNdEx := len(m.Durl) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Durl[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.VideoProject {
		i--
		if m.VideoProject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Fnval != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x30
	}
	if m.Fnver != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x28
	}
	if m.VideoCodecid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.VideoCodecid))
		i--
		dAtA[i] = 0x20
	}
	if m.Timelength != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Timelength))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if m.Quality != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BackupUrl) > 0 {
		for iNdEx := len(m.BackupUrl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BackupUrl[iNdEx])
			copy(dAtA[i:], m.BackupUrl[iNdEx])
			i = encodeVarintPlayurl(dAtA, i, uint64(len(m.BackupUrl[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x22
	}
	if m.Size_ != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if m.Length != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Order != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseDash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseDash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseDash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Audio) > 0 {
		for iNdEx := len(m.Audio) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Audio[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Video) > 0 {
		for iNdEx := len(m.Video) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Video[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DashItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DashItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DashItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FrameRate) > 0 {
		i -= len(m.FrameRate)
		copy(dAtA[i:], m.FrameRate)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.FrameRate)))
		i--
		dAtA[i] = 0x42
	}
	if m.Size_ != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x32
	}
	if m.Codecid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Codecid))
		i--
		dAtA[i] = 0x28
	}
	if m.Bandwidth != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Bandwidth))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BackupUrl) > 0 {
		for iNdEx := len(m.BackupUrl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BackupUrl[iNdEx])
			copy(dAtA[i:], m.BackupUrl[iNdEx])
			i = encodeVarintPlayurl(dAtA, i, uint64(len(m.BackupUrl[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BaseUrl) > 0 {
		i -= len(m.BaseUrl)
		copy(dAtA[i:], m.BaseUrl)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.BaseUrl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Button != nil {
		{
			size, err := m.Button.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubMessage) > 0 {
		i -= len(m.SubMessage)
		copy(dAtA[i:], m.SubMessage)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.SubMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ButtonStyle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonStyle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ButtonStyle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JumpLink) > 0 {
		i -= len(m.JumpLink)
		copy(dAtA[i:], m.JumpLink)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.JumpLink)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BgColor) > 0 {
		i -= len(m.BgColor)
		copy(dAtA[i:], m.BgColor)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.BgColor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TextColor) > 0 {
		i -= len(m.TextColor)
		copy(dAtA[i:], m.TextColor)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.TextColor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Button != nil {
		{
			size, err := m.Button.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeButton) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeButton) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeButton) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FormatDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FormatDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FormatDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Superscript) > 0 {
		i -= len(m.Superscript)
		copy(dAtA[i:], m.Superscript)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Superscript)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DisplayDesc) > 0 {
		i -= len(m.DisplayDesc)
		copy(dAtA[i:], m.DisplayDesc)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.DisplayDesc)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewDescription) > 0 {
		i -= len(m.NewDescription)
		copy(dAtA[i:], m.NewDescription)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.NewDescription)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if m.Quality != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProjectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeviceType != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.DeviceType))
		i--
		dAtA[i] = 0x60
	}
	if m.Protocol != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x58
	}
	if len(m.FromSpmid) > 0 {
		i -= len(m.FromSpmid)
		copy(dAtA[i:], m.FromSpmid)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.FromSpmid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Spmid) > 0 {
		i -= len(m.Spmid)
		copy(dAtA[i:], m.Spmid)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Spmid)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Fourk {
		i--
		if m.Fourk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ForceHost != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.ForceHost))
		i--
		dAtA[i] = 0x38
	}
	if m.Download != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Download))
		i--
		dAtA[i] = 0x30
	}
	if m.Fnval != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x28
	}
	if m.Fnver != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x20
	}
	if m.Qn != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Qn))
		i--
		dAtA[i] = 0x18
	}
	if m.Cid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProjectReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayViewReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayViewReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayViewReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VoiceBalance != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.VoiceBalance))
		i--
		dAtA[i] = 0x70
	}
	if m.Business != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Business))
		i--
		dAtA[i] = 0x68
	}
	if m.PreferCodecType != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.PreferCodecType))
		i--
		dAtA[i] = 0x60
	}
	if m.TeenagersMode != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.TeenagersMode))
		i--
		dAtA[i] = 0x58
	}
	if len(m.FromSpmid) > 0 {
		i -= len(m.FromSpmid)
		copy(dAtA[i:], m.FromSpmid)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.FromSpmid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Spmid) > 0 {
		i -= len(m.Spmid)
		copy(dAtA[i:], m.Spmid)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Spmid)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Fourk {
		i--
		if m.Fourk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ForceHost != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.ForceHost))
		i--
		dAtA[i] = 0x38
	}
	if m.Download != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Download))
		i--
		dAtA[i] = 0x30
	}
	if m.Fnval != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x28
	}
	if m.Fnver != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x20
	}
	if m.Qn != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Qn))
		i--
		dAtA[i] = 0x18
	}
	if m.Cid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayViewReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayViewReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayViewReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayLimit != nil {
		{
			size, err := m.PlayLimit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Ab != nil {
		{
			size, err := m.Ab.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PlayArc != nil {
		{
			size, err := m.PlayArc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Chronos != nil {
		{
			size, err := m.Chronos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UpgradeLimit != nil {
		{
			size, err := m.UpgradeLimit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PlayConf != nil {
		{
			size, err := m.PlayConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.VideoInfo != nil {
		{
			size, err := m.VideoInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VolumeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetTp != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TargetTp))))
		i--
		dAtA[i] = 0x39
	}
	if m.TargetI != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TargetI))))
		i--
		dAtA[i] = 0x31
	}
	if m.TargetOffset != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TargetOffset))))
		i--
		dAtA[i] = 0x29
	}
	if m.MeasuredThreshold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MeasuredThreshold))))
		i--
		dAtA[i] = 0x21
	}
	if m.MeasuredTp != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MeasuredTp))))
		i--
		dAtA[i] = 0x19
	}
	if m.MeasuredLra != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MeasuredLra))))
		i--
		dAtA[i] = 0x11
	}
	if m.MeasuredI != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MeasuredI))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *AB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Group != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if m.Glance != nil {
		{
			size, err := m.Glance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Glance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Glance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Glance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Duration != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x18
	}
	if m.Times != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Times))
		i--
		dAtA[i] = 0x10
	}
	if m.CanWatch {
		i--
		if m.CanWatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Shake != nil {
		{
			size, err := m.Shake.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Shake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayConfReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayConfReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayConfReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PlayConfReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayConfReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayConfReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayConf != nil {
		{
			size, err := m.PlayConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Chronos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chronos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chronos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayAbilityConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayAbilityConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayAbilityConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LossLessConf != nil {
		{
			size, err := m.LossLessConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.ColorFilterConf != nil {
		{
			size, err := m.ColorFilterConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.DolbyConf != nil {
		{
			size, err := m.DolbyConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.PanoramaConf != nil {
		{
			size, err := m.PanoramaConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.InnerDmConf != nil {
		{
			size, err := m.InnerDmConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.OuterDmConf != nil {
		{
			size, err := m.OuterDmConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.ShakeConf != nil {
		{
			size, err := m.ShakeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.SmallWindowConf != nil {
		{
			size, err := m.SmallWindowConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.EditDmConf != nil {
		{
			size, err := m.EditDmConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.NextConf != nil {
		{
			size, err := m.NextConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.SelectionsConf != nil {
		{
			size, err := m.SelectionsConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.DefinitionConf != nil {
		{
			size, err := m.DefinitionConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.PlaybackSpeedConf != nil {
		{
			size, err := m.PlaybackSpeedConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.RecommendConf != nil {
		{
			size, err := m.RecommendConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.LockScreenConf != nil {
		{
			size, err := m.LockScreenConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ScreenShotConf != nil {
		{
			size, err := m.ScreenShotConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ShareConf != nil {
		{
			size, err := m.ShareConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ElecConf != nil {
		{
			size, err := m.ElecConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.CoinConf != nil {
		{
			size, err := m.CoinConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DislikeConf != nil {
		{
			size, err := m.DislikeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.LikeConf != nil {
		{
			size, err := m.LikeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ScaleModeConf != nil {
		{
			size, err := m.ScaleModeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.PlaybackModeConf != nil {
		{
			size, err := m.PlaybackModeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TimeUpConf != nil {
		{
			size, err := m.TimeUpConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PlaybackRateConf != nil {
		{
			size, err := m.PlaybackRateConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SubtitleConf != nil {
		{
			size, err := m.SubtitleConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FeedbackConf != nil {
		{
			size, err := m.FeedbackConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CastConf != nil {
		{
			size, err := m.CastConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FlipConf != nil {
		{
			size, err := m.FlipConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BackgroundPlayConf != nil {
		{
			size, err := m.BackgroundPlayConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayArcConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayArcConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayArcConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LossLessConf != nil {
		{
			size, err := m.LossLessConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.ColorFilterConf != nil {
		{
			size, err := m.ColorFilterConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.ScreenRecordingConf != nil {
		{
			size, err := m.ScreenRecordingConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.DolbyConf != nil {
		{
			size, err := m.DolbyConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.PanoramaConf != nil {
		{
			size, err := m.PanoramaConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.InnerDmConf != nil {
		{
			size, err := m.InnerDmConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.OuterDmConf != nil {
		{
			size, err := m.OuterDmConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.ShakeConf != nil {
		{
			size, err := m.ShakeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.SmallWindowConf != nil {
		{
			size, err := m.SmallWindowConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.EditDmConf != nil {
		{
			size, err := m.EditDmConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.NextConf != nil {
		{
			size, err := m.NextConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.SelectionsConf != nil {
		{
			size, err := m.SelectionsConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.DefinitionConf != nil {
		{
			size, err := m.DefinitionConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.PlaybackSpeedConf != nil {
		{
			size, err := m.PlaybackSpeedConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.RecommendConf != nil {
		{
			size, err := m.RecommendConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.LockScreenConf != nil {
		{
			size, err := m.LockScreenConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ScreenShotConf != nil {
		{
			size, err := m.ScreenShotConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ShareConf != nil {
		{
			size, err := m.ShareConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ElecConf != nil {
		{
			size, err := m.ElecConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.CoinConf != nil {
		{
			size, err := m.CoinConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DislikeConf != nil {
		{
			size, err := m.DislikeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.LikeConf != nil {
		{
			size, err := m.LikeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ScaleModeConf != nil {
		{
			size, err := m.ScaleModeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.PlaybackModeConf != nil {
		{
			size, err := m.PlaybackModeConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TimeUpConf != nil {
		{
			size, err := m.TimeUpConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PlaybackRateConf != nil {
		{
			size, err := m.PlaybackRateConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SubtitleConf != nil {
		{
			size, err := m.SubtitleConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FeedbackConf != nil {
		{
			size, err := m.FeedbackConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CastConf != nil {
		{
			size, err := m.CastConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FlipConf != nil {
		{
			size, err := m.FlipConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BackgroundPlayConf != nil {
		{
			size, err := m.BackgroundPlayConf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConfValue_SwitchVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfValue_SwitchVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.SwitchVal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ConfValue_SelectedVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfValue_SelectedVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlayurl(dAtA, i, uint64(m.SelectedVal))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *CloudConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfValue != nil {
		{
			size, err := m.ConfValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.FieldValue != nil {
		{
			size, err := m.FieldValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ConfType != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.ConfType))
		i--
		dAtA[i] = 0x10
	}
	if m.Show {
		i--
		if m.Show {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnsupportScene) > 0 {
		dAtA82 := make([]byte, len(m.UnsupportScene)*10)
		var j81 int
		for _, num1 := range m.UnsupportScene {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA82[j81] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j81++
			}
			dAtA82[j81] = uint8(num)
			j81++
		}
		i -= j81
		copy(dAtA[i:], dAtA82[:j81])
		i = encodeVarintPlayurl(dAtA, i, uint64(j81))
		i--
		dAtA[i] = 0x22
	}
	if m.ExtraContent != nil {
		{
			size, err := m.ExtraContent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsSupport {
		i--
		if m.IsSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtraContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtraContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DisabledCode != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.DisabledCode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DisabledReason) > 0 {
		i -= len(m.DisabledReason)
		copy(dAtA[i:], m.DisabledReason)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.DisabledReason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VideoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LossLessItem != nil {
		{
			size, err := m.LossLessItem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Volume != nil {
		{
			size, err := m.Volume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Dolby != nil {
		{
			size, err := m.Dolby.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DashAudio) > 0 {
		for iNdEx := len(m.DashAudio) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DashAudio[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.StreamList) > 0 {
		for iNdEx := len(m.StreamList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StreamList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.VideoCodecid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.VideoCodecid))
		i--
		dAtA[i] = 0x20
	}
	if m.Timelength != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Timelength))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if m.Quality != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LossLessItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LossLessItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LossLessItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedVip {
		i--
		if m.NeedVip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Audio != nil {
		{
			size, err := m.Audio.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IsLosslessAudio {
		i--
		if m.IsLosslessAudio {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DolbyItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DolbyItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DolbyItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Audio) > 0 {
		for iNdEx := len(m.Audio) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Audio[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StreamInfo != nil {
		{
			size, err := m.StreamInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Stream_DashVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream_DashVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DashVideo != nil {
		{
			size, err := m.DashVideo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Stream_SegmentVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream_SegmentVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SegmentVideo != nil {
		{
			size, err := m.SegmentVideo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SegmentVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegmentVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Segment) > 0 {
		for iNdEx := len(m.Segment) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Segment[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StreamInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Subtitle) > 0 {
		i -= len(m.Subtitle)
		copy(dAtA[i:], m.Subtitle)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Subtitle)))
		i--
		dAtA[i] = 0x7a
	}
	if m.VipFree {
		i--
		if m.VipFree {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.Superscript) > 0 {
		i -= len(m.Superscript)
		copy(dAtA[i:], m.Superscript)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Superscript)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.DisplayDesc) > 0 {
		i -= len(m.DisplayDesc)
		copy(dAtA[i:], m.DisplayDesc)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.DisplayDesc)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.NewDescription) > 0 {
		i -= len(m.NewDescription)
		copy(dAtA[i:], m.NewDescription)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.NewDescription)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Attribute != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Attribute))
		i--
		dAtA[i] = 0x50
	}
	if m.NoRexcode {
		i--
		if m.NoRexcode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Intact {
		i--
		if m.Intact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.NeedLogin {
		i--
		if m.NeedLogin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NeedVip {
		i--
		if m.NeedVip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ErrCode != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.ErrCode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if m.Quality != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayConfEditReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayConfEditReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayConfEditReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PlayConfEditReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayConfEditReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayConfEditReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PlayConf) > 0 {
		for iNdEx := len(m.PlayConf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlayConf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayurl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlayConfState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayConfState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayConfState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfValue != nil {
		{
			size, err := m.ConfValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.FieldValue != nil {
		{
			size, err := m.FieldValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayurl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Show {
		i--
		if m.Show {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ConfType != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.ConfType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FieldValue_Switch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldValue_Switch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Switch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *DashVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DashVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DashVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Height != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x58
	}
	if m.Width != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x50
	}
	if len(m.FrameRate) > 0 {
		i -= len(m.FrameRate)
		copy(dAtA[i:], m.FrameRate)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.FrameRate)))
		i--
		dAtA[i] = 0x4a
	}
	if m.NoRexcode {
		i--
		if m.NoRexcode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.AudioId != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.AudioId))
		i--
		dAtA[i] = 0x38
	}
	if m.Size_ != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Codecid != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Codecid))
		i--
		dAtA[i] = 0x20
	}
	if m.Bandwidth != 0 {
		i = encodeVarintPlayurl(dAtA, i, uint64(m.Bandwidth))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BackupUrl) > 0 {
		for iNdEx := len(m.BackupUrl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BackupUrl[iNdEx])
			copy(dAtA[i:], m.BackupUrl[iNdEx])
			i = encodeVarintPlayurl(dAtA, i, uint64(len(m.BackupUrl[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BaseUrl) > 0 {
		i -= len(m.BaseUrl)
		copy(dAtA[i:], m.BaseUrl)
		i = encodeVarintPlayurl(dAtA, i, uint64(len(m.BaseUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlayurl(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlayurl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PlayURLReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovPlayurl(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovPlayurl(uint64(m.Cid))
	}
	if m.Qn != 0 {
		n += 1 + sovPlayurl(uint64(m.Qn))
	}
	if m.Fnver != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnval))
	}
	if m.Download != 0 {
		n += 1 + sovPlayurl(uint64(m.Download))
	}
	if m.ForceHost != 0 {
		n += 1 + sovPlayurl(uint64(m.ForceHost))
	}
	if m.Fourk {
		n += 2
	}
	l = len(m.Spmid)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.FromSpmid)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.VoiceBalance != 0 {
		n += 1 + sovPlayurl(uint64(m.VoiceBalance))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayURLReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quality != 0 {
		n += 1 + sovPlayurl(uint64(m.Quality))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Timelength != 0 {
		n += 1 + sovPlayurl(uint64(m.Timelength))
	}
	if m.VideoCodecid != 0 {
		n += 1 + sovPlayurl(uint64(m.VideoCodecid))
	}
	if m.Fnver != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnval))
	}
	if m.VideoProject {
		n += 2
	}
	if len(m.Durl) > 0 {
		for _, e := range m.Durl {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.Dash != nil {
		l = m.Dash.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.NoRexcode != 0 {
		n += 1 + sovPlayurl(uint64(m.NoRexcode))
	}
	if m.UpgradeLimit != nil {
		l = m.UpgradeLimit.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if len(m.SupportFormats) > 0 {
		for _, e := range m.SupportFormats {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovPlayurl(uint64(m.Type))
	}
	if m.Volume != nil {
		l = m.Volume.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != 0 {
		n += 1 + sovPlayurl(uint64(m.Order))
	}
	if m.Length != 0 {
		n += 1 + sovPlayurl(uint64(m.Length))
	}
	if m.Size_ != 0 {
		n += 1 + sovPlayurl(uint64(m.Size_))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if len(m.BackupUrl) > 0 {
		for _, s := range m.BackupUrl {
			l = len(s)
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseDash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Video) > 0 {
		for _, e := range m.Video {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if len(m.Audio) > 0 {
		for _, e := range m.Audio {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DashItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayurl(uint64(m.Id))
	}
	l = len(m.BaseUrl)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if len(m.BackupUrl) > 0 {
		for _, s := range m.BackupUrl {
			l = len(s)
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.Bandwidth != 0 {
		n += 1 + sovPlayurl(uint64(m.Bandwidth))
	}
	if m.Codecid != 0 {
		n += 1 + sovPlayurl(uint64(m.Codecid))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovPlayurl(uint64(m.Size_))
	}
	l = len(m.FrameRate)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPlayurl(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.SubMessage)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Button != nil {
		l = m.Button.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ButtonStyle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.TextColor)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.BgColor)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.JumpLink)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPlayurl(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Button != nil {
		l = m.Button.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeButton) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FormatDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quality != 0 {
		n += 1 + sovPlayurl(uint64(m.Quality))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.NewDescription)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.DisplayDesc)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Superscript)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProjectReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovPlayurl(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovPlayurl(uint64(m.Cid))
	}
	if m.Qn != 0 {
		n += 1 + sovPlayurl(uint64(m.Qn))
	}
	if m.Fnver != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnval))
	}
	if m.Download != 0 {
		n += 1 + sovPlayurl(uint64(m.Download))
	}
	if m.ForceHost != 0 {
		n += 1 + sovPlayurl(uint64(m.ForceHost))
	}
	if m.Fourk {
		n += 2
	}
	l = len(m.Spmid)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.FromSpmid)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovPlayurl(uint64(m.Protocol))
	}
	if m.DeviceType != 0 {
		n += 1 + sovPlayurl(uint64(m.DeviceType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProjectReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayViewReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovPlayurl(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovPlayurl(uint64(m.Cid))
	}
	if m.Qn != 0 {
		n += 1 + sovPlayurl(uint64(m.Qn))
	}
	if m.Fnver != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovPlayurl(uint64(m.Fnval))
	}
	if m.Download != 0 {
		n += 1 + sovPlayurl(uint64(m.Download))
	}
	if m.ForceHost != 0 {
		n += 1 + sovPlayurl(uint64(m.ForceHost))
	}
	if m.Fourk {
		n += 2
	}
	l = len(m.Spmid)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.FromSpmid)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.TeenagersMode != 0 {
		n += 1 + sovPlayurl(uint64(m.TeenagersMode))
	}
	if m.PreferCodecType != 0 {
		n += 1 + sovPlayurl(uint64(m.PreferCodecType))
	}
	if m.Business != 0 {
		n += 1 + sovPlayurl(uint64(m.Business))
	}
	if m.VoiceBalance != 0 {
		n += 1 + sovPlayurl(uint64(m.VoiceBalance))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayViewReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VideoInfo != nil {
		l = m.VideoInfo.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.PlayConf != nil {
		l = m.PlayConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.UpgradeLimit != nil {
		l = m.UpgradeLimit.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Chronos != nil {
		l = m.Chronos.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.PlayArc != nil {
		l = m.PlayArc.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Ab != nil {
		l = m.Ab.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.PlayLimit != nil {
		l = m.PlayLimit.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VolumeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MeasuredI != 0 {
		n += 9
	}
	if m.MeasuredLra != 0 {
		n += 9
	}
	if m.MeasuredTp != 0 {
		n += 9
	}
	if m.MeasuredThreshold != 0 {
		n += 9
	}
	if m.TargetOffset != 0 {
		n += 9
	}
	if m.TargetI != 0 {
		n += 9
	}
	if m.TargetTp != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Glance != nil {
		l = m.Glance.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovPlayurl(uint64(m.Group))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Glance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CanWatch {
		n += 2
	}
	if m.Times != 0 {
		n += 1 + sovPlayurl(uint64(m.Times))
	}
	if m.Duration != 0 {
		n += 1 + sovPlayurl(uint64(m.Duration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shake != nil {
		l = m.Shake.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayConfReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayConfReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayConf != nil {
		l = m.PlayConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Chronos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayAbilityConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BackgroundPlayConf != nil {
		l = m.BackgroundPlayConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.FlipConf != nil {
		l = m.FlipConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.CastConf != nil {
		l = m.CastConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.FeedbackConf != nil {
		l = m.FeedbackConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.SubtitleConf != nil {
		l = m.SubtitleConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.PlaybackRateConf != nil {
		l = m.PlaybackRateConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.TimeUpConf != nil {
		l = m.TimeUpConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.PlaybackModeConf != nil {
		l = m.PlaybackModeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ScaleModeConf != nil {
		l = m.ScaleModeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.LikeConf != nil {
		l = m.LikeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.DislikeConf != nil {
		l = m.DislikeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.CoinConf != nil {
		l = m.CoinConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ElecConf != nil {
		l = m.ElecConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ShareConf != nil {
		l = m.ShareConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ScreenShotConf != nil {
		l = m.ScreenShotConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.LockScreenConf != nil {
		l = m.LockScreenConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.RecommendConf != nil {
		l = m.RecommendConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.PlaybackSpeedConf != nil {
		l = m.PlaybackSpeedConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.DefinitionConf != nil {
		l = m.DefinitionConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.SelectionsConf != nil {
		l = m.SelectionsConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.NextConf != nil {
		l = m.NextConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.EditDmConf != nil {
		l = m.EditDmConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.SmallWindowConf != nil {
		l = m.SmallWindowConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.ShakeConf != nil {
		l = m.ShakeConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.OuterDmConf != nil {
		l = m.OuterDmConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.InnerDmConf != nil {
		l = m.InnerDmConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.PanoramaConf != nil {
		l = m.PanoramaConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.DolbyConf != nil {
		l = m.DolbyConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.ColorFilterConf != nil {
		l = m.ColorFilterConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.LossLessConf != nil {
		l = m.LossLessConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayArcConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BackgroundPlayConf != nil {
		l = m.BackgroundPlayConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.FlipConf != nil {
		l = m.FlipConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.CastConf != nil {
		l = m.CastConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.FeedbackConf != nil {
		l = m.FeedbackConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.SubtitleConf != nil {
		l = m.SubtitleConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.PlaybackRateConf != nil {
		l = m.PlaybackRateConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.TimeUpConf != nil {
		l = m.TimeUpConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.PlaybackModeConf != nil {
		l = m.PlaybackModeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ScaleModeConf != nil {
		l = m.ScaleModeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.LikeConf != nil {
		l = m.LikeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.DislikeConf != nil {
		l = m.DislikeConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.CoinConf != nil {
		l = m.CoinConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ElecConf != nil {
		l = m.ElecConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ShareConf != nil {
		l = m.ShareConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ScreenShotConf != nil {
		l = m.ScreenShotConf.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.LockScreenConf != nil {
		l = m.LockScreenConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.RecommendConf != nil {
		l = m.RecommendConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.PlaybackSpeedConf != nil {
		l = m.PlaybackSpeedConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.DefinitionConf != nil {
		l = m.DefinitionConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.SelectionsConf != nil {
		l = m.SelectionsConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.NextConf != nil {
		l = m.NextConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.EditDmConf != nil {
		l = m.EditDmConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.SmallWindowConf != nil {
		l = m.SmallWindowConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.ShakeConf != nil {
		l = m.ShakeConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.OuterDmConf != nil {
		l = m.OuterDmConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.InnerDmConf != nil {
		l = m.InnerDmConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.PanoramaConf != nil {
		l = m.PanoramaConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.DolbyConf != nil {
		l = m.DolbyConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.ScreenRecordingConf != nil {
		l = m.ScreenRecordingConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.ColorFilterConf != nil {
		l = m.ColorFilterConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.LossLessConf != nil {
		l = m.LossLessConf.Size()
		n += 2 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfValue_SwitchVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ConfValue_SelectedVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlayurl(uint64(m.SelectedVal))
	return n
}
func (m *CloudConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Show {
		n += 2
	}
	if m.ConfType != 0 {
		n += 1 + sovPlayurl(uint64(m.ConfType))
	}
	if m.FieldValue != nil {
		l = m.FieldValue.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ConfValue != nil {
		l = m.ConfValue.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsSupport {
		n += 2
	}
	if m.Disabled {
		n += 2
	}
	if m.ExtraContent != nil {
		l = m.ExtraContent.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if len(m.UnsupportScene) > 0 {
		l = 0
		for _, e := range m.UnsupportScene {
			l += sovPlayurl(uint64(e))
		}
		n += 1 + sovPlayurl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtraContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisabledReason)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.DisabledCode != 0 {
		n += 1 + sovPlayurl(uint64(m.DisabledCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quality != 0 {
		n += 1 + sovPlayurl(uint64(m.Quality))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Timelength != 0 {
		n += 1 + sovPlayurl(uint64(m.Timelength))
	}
	if m.VideoCodecid != 0 {
		n += 1 + sovPlayurl(uint64(m.VideoCodecid))
	}
	if len(m.StreamList) > 0 {
		for _, e := range m.StreamList {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if len(m.DashAudio) > 0 {
		for _, e := range m.DashAudio {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.Dolby != nil {
		l = m.Dolby.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Volume != nil {
		l = m.Volume.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.LossLessItem != nil {
		l = m.LossLessItem.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LossLessItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsLosslessAudio {
		n += 2
	}
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.NeedVip {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DolbyItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlayurl(uint64(m.Type))
	}
	if len(m.Audio) > 0 {
		for _, e := range m.Audio {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamInfo != nil {
		l = m.StreamInfo.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Content != nil {
		n += m.Content.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stream_DashVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DashVideo != nil {
		l = m.DashVideo.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	return n
}
func (m *Stream_SegmentVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegmentVideo != nil {
		l = m.SegmentVideo.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	return n
}
func (m *SegmentVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Segment) > 0 {
		for _, e := range m.Segment {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quality != 0 {
		n += 1 + sovPlayurl(uint64(m.Quality))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ErrCode != 0 {
		n += 1 + sovPlayurl(uint64(m.ErrCode))
	}
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.NeedVip {
		n += 2
	}
	if m.NeedLogin {
		n += 2
	}
	if m.Intact {
		n += 2
	}
	if m.NoRexcode {
		n += 2
	}
	if m.Attribute != 0 {
		n += 1 + sovPlayurl(uint64(m.Attribute))
	}
	l = len(m.NewDescription)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.DisplayDesc)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Superscript)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.VipFree {
		n += 2
	}
	l = len(m.Subtitle)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayConfEditReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayConfEditReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayConf) > 0 {
		for _, e := range m.PlayConf {
			l = e.Size()
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayConfState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfType != 0 {
		n += 1 + sovPlayurl(uint64(m.ConfType))
	}
	if m.Show {
		n += 2
	}
	if m.FieldValue != nil {
		l = m.FieldValue.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.ConfValue != nil {
		l = m.ConfValue.Size()
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldValue_Switch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *DashVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseUrl)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if len(m.BackupUrl) > 0 {
		for _, s := range m.BackupUrl {
			l = len(s)
			n += 1 + l + sovPlayurl(uint64(l))
		}
	}
	if m.Bandwidth != 0 {
		n += 1 + sovPlayurl(uint64(m.Bandwidth))
	}
	if m.Codecid != 0 {
		n += 1 + sovPlayurl(uint64(m.Codecid))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovPlayurl(uint64(m.Size_))
	}
	if m.AudioId != 0 {
		n += 1 + sovPlayurl(uint64(m.AudioId))
	}
	if m.NoRexcode {
		n += 2
	}
	l = len(m.FrameRate)
	if l > 0 {
		n += 1 + l + sovPlayurl(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovPlayurl(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovPlayurl(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPlayurl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlayurl(x uint64) (n int) {
	return sovPlayurl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlayURLReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayURLReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayURLReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qn", wireType)
			}
			m.Qn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Download", wireType)
			}
			m.Download = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Download |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceHost", wireType)
			}
			m.ForceHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceHost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fourk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fourk = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spmid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spmid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromSpmid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromSpmid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceBalance", wireType)
			}
			m.VoiceBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoiceBalance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayURLReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayURLReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayURLReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timelength", wireType)
			}
			m.Timelength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timelength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoCodecid", wireType)
			}
			m.VideoCodecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoCodecid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoProject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VideoProject = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Durl = append(m.Durl, &ResponseUrl{})
			if err := m.Durl[len(m.Durl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dash == nil {
				m.Dash = &ResponseDash{}
			}
			if err := m.Dash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRexcode", wireType)
			}
			m.NoRexcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoRexcode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeLimit == nil {
				m.UpgradeLimit = &UpgradeLimit{}
			}
			if err := m.UpgradeLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportFormats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportFormats = append(m.SupportFormats, &FormatDescription{})
			if err := m.SupportFormats[len(m.SupportFormats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VideoType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Volume == nil {
				m.Volume = &VolumeInfo{}
			}
			if err := m.Volume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupUrl = append(m.BackupUrl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseDash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseDash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseDash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Video = append(m.Video, &DashItem{})
			if err := m.Video[len(m.Video)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audio = append(m.Audio, &DashItem{})
			if err := m.Audio[len(m.Audio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DashItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DashItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DashItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupUrl = append(m.BackupUrl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codecid", wireType)
			}
			m.Codecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codecid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= PlayLimitCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Button", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Button == nil {
				m.Button = &ButtonStyle{}
			}
			if err := m.Button.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonStyle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonStyle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonStyle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Button", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Button == nil {
				m.Button = &UpgradeButton{}
			}
			if err := m.Button.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeButton) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeButton: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeButton: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FormatDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FormatDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FormatDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Superscript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Superscript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qn", wireType)
			}
			m.Qn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Download", wireType)
			}
			m.Download = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Download |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceHost", wireType)
			}
			m.ForceHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceHost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fourk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fourk = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spmid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spmid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromSpmid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromSpmid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &PlayURLReply{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayViewReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayViewReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayViewReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qn", wireType)
			}
			m.Qn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Download", wireType)
			}
			m.Download = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Download |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceHost", wireType)
			}
			m.ForceHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceHost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fourk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fourk = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spmid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spmid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromSpmid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromSpmid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeenagersMode", wireType)
			}
			m.TeenagersMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeenagersMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferCodecType", wireType)
			}
			m.PreferCodecType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreferCodecType |= CodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			m.Business = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Business |= Business(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceBalance", wireType)
			}
			m.VoiceBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoiceBalance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayViewReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayViewReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayViewReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoInfo == nil {
				m.VideoInfo = &VideoInfo{}
			}
			if err := m.VideoInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayConf == nil {
				m.PlayConf = &PlayAbilityConf{}
			}
			if err := m.PlayConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeLimit == nil {
				m.UpgradeLimit = &UpgradeLimit{}
			}
			if err := m.UpgradeLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chronos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chronos == nil {
				m.Chronos = &Chronos{}
			}
			if err := m.Chronos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayArc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayArc == nil {
				m.PlayArc = &PlayArcConf{}
			}
			if err := m.PlayArc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &Event{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ab", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ab == nil {
				m.Ab = &AB{}
			}
			if err := m.Ab.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayLimit == nil {
				m.PlayLimit = &PlayLimit{}
			}
			if err := m.PlayLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasuredI", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MeasuredI = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasuredLra", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MeasuredLra = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasuredTp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MeasuredTp = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasuredThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MeasuredThreshold = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetOffset", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TargetOffset = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetI", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TargetI = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TargetTp = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Glance == nil {
				m.Glance = &Glance{}
			}
			if err := m.Glance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= Group(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Glance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Glance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Glance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanWatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanWatch = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shake == nil {
				m.Shake = &Shake{}
			}
			if err := m.Shake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayConfReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayConfReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayConfReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayConfReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayConfReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayConfReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayConf == nil {
				m.PlayConf = &PlayAbilityConf{}
			}
			if err := m.PlayConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chronos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chronos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chronos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayAbilityConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayAbilityConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayAbilityConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundPlayConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackgroundPlayConf == nil {
				m.BackgroundPlayConf = &CloudConf{}
			}
			if err := m.BackgroundPlayConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlipConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlipConf == nil {
				m.FlipConf = &CloudConf{}
			}
			if err := m.FlipConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CastConf == nil {
				m.CastConf = &CloudConf{}
			}
			if err := m.CastConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedbackConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeedbackConf == nil {
				m.FeedbackConf = &CloudConf{}
			}
			if err := m.FeedbackConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitleConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubtitleConf == nil {
				m.SubtitleConf = &CloudConf{}
			}
			if err := m.SubtitleConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaybackRateConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlaybackRateConf == nil {
				m.PlaybackRateConf = &CloudConf{}
			}
			if err := m.PlaybackRateConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeUpConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeUpConf == nil {
				m.TimeUpConf = &CloudConf{}
			}
			if err := m.TimeUpConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaybackModeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlaybackModeConf == nil {
				m.PlaybackModeConf = &CloudConf{}
			}
			if err := m.PlaybackModeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleModeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleModeConf == nil {
				m.ScaleModeConf = &CloudConf{}
			}
			if err := m.ScaleModeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LikeConf == nil {
				m.LikeConf = &CloudConf{}
			}
			if err := m.LikeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DislikeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DislikeConf == nil {
				m.DislikeConf = &CloudConf{}
			}
			if err := m.DislikeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinConf == nil {
				m.CoinConf = &CloudConf{}
			}
			if err := m.CoinConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElecConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ElecConf == nil {
				m.ElecConf = &CloudConf{}
			}
			if err := m.ElecConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShareConf == nil {
				m.ShareConf = &CloudConf{}
			}
			if err := m.ShareConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenShotConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScreenShotConf == nil {
				m.ScreenShotConf = &CloudConf{}
			}
			if err := m.ScreenShotConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockScreenConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockScreenConf == nil {
				m.LockScreenConf = &CloudConf{}
			}
			if err := m.LockScreenConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecommendConf == nil {
				m.RecommendConf = &CloudConf{}
			}
			if err := m.RecommendConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaybackSpeedConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlaybackSpeedConf == nil {
				m.PlaybackSpeedConf = &CloudConf{}
			}
			if err := m.PlaybackSpeedConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefinitionConf == nil {
				m.DefinitionConf = &CloudConf{}
			}
			if err := m.DefinitionConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectionsConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelectionsConf == nil {
				m.SelectionsConf = &CloudConf{}
			}
			if err := m.SelectionsConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextConf == nil {
				m.NextConf = &CloudConf{}
			}
			if err := m.NextConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDmConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EditDmConf == nil {
				m.EditDmConf = &CloudConf{}
			}
			if err := m.EditDmConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallWindowConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SmallWindowConf == nil {
				m.SmallWindowConf = &CloudConf{}
			}
			if err := m.SmallWindowConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShakeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShakeConf == nil {
				m.ShakeConf = &CloudConf{}
			}
			if err := m.ShakeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterDmConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OuterDmConf == nil {
				m.OuterDmConf = &CloudConf{}
			}
			if err := m.OuterDmConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerDmConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerDmConf == nil {
				m.InnerDmConf = &CloudConf{}
			}
			if err := m.InnerDmConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanoramaConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PanoramaConf == nil {
				m.PanoramaConf = &CloudConf{}
			}
			if err := m.PanoramaConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DolbyConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DolbyConf == nil {
				m.DolbyConf = &CloudConf{}
			}
			if err := m.DolbyConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorFilterConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColorFilterConf == nil {
				m.ColorFilterConf = &CloudConf{}
			}
			if err := m.ColorFilterConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossLessConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LossLessConf == nil {
				m.LossLessConf = &CloudConf{}
			}
			if err := m.LossLessConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayArcConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayArcConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayArcConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundPlayConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackgroundPlayConf == nil {
				m.BackgroundPlayConf = &ArcConf{}
			}
			if err := m.BackgroundPlayConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlipConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlipConf == nil {
				m.FlipConf = &ArcConf{}
			}
			if err := m.FlipConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CastConf == nil {
				m.CastConf = &ArcConf{}
			}
			if err := m.CastConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedbackConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeedbackConf == nil {
				m.FeedbackConf = &ArcConf{}
			}
			if err := m.FeedbackConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitleConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubtitleConf == nil {
				m.SubtitleConf = &ArcConf{}
			}
			if err := m.SubtitleConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaybackRateConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlaybackRateConf == nil {
				m.PlaybackRateConf = &ArcConf{}
			}
			if err := m.PlaybackRateConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeUpConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeUpConf == nil {
				m.TimeUpConf = &ArcConf{}
			}
			if err := m.TimeUpConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaybackModeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlaybackModeConf == nil {
				m.PlaybackModeConf = &ArcConf{}
			}
			if err := m.PlaybackModeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleModeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleModeConf == nil {
				m.ScaleModeConf = &ArcConf{}
			}
			if err := m.ScaleModeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LikeConf == nil {
				m.LikeConf = &ArcConf{}
			}
			if err := m.LikeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DislikeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DislikeConf == nil {
				m.DislikeConf = &ArcConf{}
			}
			if err := m.DislikeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinConf == nil {
				m.CoinConf = &ArcConf{}
			}
			if err := m.CoinConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElecConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ElecConf == nil {
				m.ElecConf = &ArcConf{}
			}
			if err := m.ElecConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShareConf == nil {
				m.ShareConf = &ArcConf{}
			}
			if err := m.ShareConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenShotConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScreenShotConf == nil {
				m.ScreenShotConf = &ArcConf{}
			}
			if err := m.ScreenShotConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockScreenConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockScreenConf == nil {
				m.LockScreenConf = &ArcConf{}
			}
			if err := m.LockScreenConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecommendConf == nil {
				m.RecommendConf = &ArcConf{}
			}
			if err := m.RecommendConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaybackSpeedConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlaybackSpeedConf == nil {
				m.PlaybackSpeedConf = &ArcConf{}
			}
			if err := m.PlaybackSpeedConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefinitionConf == nil {
				m.DefinitionConf = &ArcConf{}
			}
			if err := m.DefinitionConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectionsConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelectionsConf == nil {
				m.SelectionsConf = &ArcConf{}
			}
			if err := m.SelectionsConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextConf == nil {
				m.NextConf = &ArcConf{}
			}
			if err := m.NextConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDmConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EditDmConf == nil {
				m.EditDmConf = &ArcConf{}
			}
			if err := m.EditDmConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallWindowConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SmallWindowConf == nil {
				m.SmallWindowConf = &ArcConf{}
			}
			if err := m.SmallWindowConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShakeConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShakeConf == nil {
				m.ShakeConf = &ArcConf{}
			}
			if err := m.ShakeConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterDmConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OuterDmConf == nil {
				m.OuterDmConf = &ArcConf{}
			}
			if err := m.OuterDmConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerDmConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerDmConf == nil {
				m.InnerDmConf = &ArcConf{}
			}
			if err := m.InnerDmConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanoramaConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PanoramaConf == nil {
				m.PanoramaConf = &ArcConf{}
			}
			if err := m.PanoramaConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DolbyConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DolbyConf == nil {
				m.DolbyConf = &ArcConf{}
			}
			if err := m.DolbyConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenRecordingConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScreenRecordingConf == nil {
				m.ScreenRecordingConf = &ArcConf{}
			}
			if err := m.ScreenRecordingConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorFilterConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColorFilterConf == nil {
				m.ColorFilterConf = &ArcConf{}
			}
			if err := m.ColorFilterConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossLessConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LossLessConf == nil {
				m.LossLessConf = &ArcConf{}
			}
			if err := m.LossLessConf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &ConfValue_SwitchVal{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedVal", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &ConfValue_SelectedVal{v}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Show", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Show = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfType", wireType)
			}
			m.ConfType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfType |= ConfType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldValue == nil {
				m.FieldValue = &FieldValue{}
			}
			if err := m.FieldValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfValue == nil {
				m.ConfValue = &ConfValue{}
			}
			if err := m.ConfValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSupport = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraContent == nil {
				m.ExtraContent = &ExtraContent{}
			}
			if err := m.ExtraContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayurl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnsupportScene = append(m.UnsupportScene, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayurl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayurl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlayurl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnsupportScene) == 0 {
					m.UnsupportScene = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayurl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnsupportScene = append(m.UnsupportScene, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsupportScene", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisabledReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledCode", wireType)
			}
			m.DisabledCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisabledCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timelength", wireType)
			}
			m.Timelength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timelength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoCodecid", wireType)
			}
			m.VideoCodecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoCodecid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamList = append(m.StreamList, &Stream{})
			if err := m.StreamList[len(m.StreamList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DashAudio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DashAudio = append(m.DashAudio, &DashItem{})
			if err := m.DashAudio[len(m.DashAudio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dolby", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dolby == nil {
				m.Dolby = &DolbyItem{}
			}
			if err := m.Dolby.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Volume == nil {
				m.Volume = &VolumeInfo{}
			}
			if err := m.Volume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossLessItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LossLessItem == nil {
				m.LossLessItem = &LossLessItem{}
			}
			if err := m.LossLessItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LossLessItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LossLessItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LossLessItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLosslessAudio", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLosslessAudio = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audio == nil {
				m.Audio = &DashItem{}
			}
			if err := m.Audio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedVip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedVip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DolbyItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DolbyItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DolbyItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DolbyItem_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audio = append(m.Audio, &DashItem{})
			if err := m.Audio[len(m.Audio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamInfo == nil {
				m.StreamInfo = &StreamInfo{}
			}
			if err := m.StreamInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DashVideo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DashVideo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Stream_DashVideo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentVideo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SegmentVideo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Stream_SegmentVideo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segment = append(m.Segment, &ResponseUrl{})
			if err := m.Segment[len(m.Segment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= PlayErr(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &StreamLimit{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedVip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedVip = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLogin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedLogin = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Intact = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRexcode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRexcode = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			m.Attribute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attribute |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Superscript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Superscript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipFree", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VipFree = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayConfEditReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayConfEditReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayConfEditReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayConfEditReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayConfEditReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayConfEditReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayConf = append(m.PlayConf, &PlayConfState{})
			if err := m.PlayConf[len(m.PlayConf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayConfState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayConfState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayConfState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfType", wireType)
			}
			m.ConfType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfType |= ConfType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Show", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Show = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldValue == nil {
				m.FieldValue = &FieldValue{}
			}
			if err := m.FieldValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfValue == nil {
				m.ConfValue = &ConfValue{}
			}
			if err := m.ConfValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &FieldValue_Switch{b}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DashVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DashVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DashVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupUrl = append(m.BackupUrl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codecid", wireType)
			}
			m.Codecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codecid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioId", wireType)
			}
			m.AudioId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudioId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRexcode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRexcode = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayurl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayurl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayurl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayurl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlayurl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlayurl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayurl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlayurl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlayurl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlayurl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlayurl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlayurl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlayurl = fmt.Errorf("proto: unexpected end of group")
)
