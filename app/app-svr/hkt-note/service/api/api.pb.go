// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NoteListType int32

const (
	NoteListType_USER_ALL          NoteListType = 0
	NoteListType_USER_PUBLISHED    NoteListType = 1
	NoteListType_ARCHIVE_PUBLISHED NoteListType = 2
)

var NoteListType_name = map[int32]string{
	0: "USER_ALL",
	1: "USER_PUBLISHED",
	2: "ARCHIVE_PUBLISHED",
}

var NoteListType_value = map[string]int32{
	"USER_ALL":          0,
	"USER_PUBLISHED":    1,
	"ARCHIVE_PUBLISHED": 2,
}

func (x NoteListType) String() string {
	return proto.EnumName(NoteListType_name, int32(x))
}

func (NoteListType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type SimpleNoteType int32

const (
	SimpleNoteType_DEFAULT SimpleNoteType = 0
	SimpleNoteType_PUBLISH SimpleNoteType = 1
)

var SimpleNoteType_name = map[int32]string{
	0: "DEFAULT",
	1: "PUBLISH",
}

var SimpleNoteType_value = map[string]int32{
	"DEFAULT": 0,
	"PUBLISH": 1,
}

func (x SimpleNoteType) String() string {
	return proto.EnumName(SimpleNoteType_name, int32(x))
}

func (SimpleNoteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type UpArcReq struct {
	Oid                  int64    `protobuf:"varint,1,opt,name=oid,proto3" json:"oid,omitempty" form:"oid" validate:"gt=0"`
	OidType              int64    `protobuf:"varint,2,opt,name=oid_type,json=oidType,proto3" json:"oid_type,omitempty" form:"oid_type"`
	UpperId              int64    `protobuf:"varint,3,opt,name=upper_id,json=upperId,proto3" json:"upper_id,omitempty" form:"upper_id" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpArcReq) Reset()         { *m = UpArcReq{} }
func (m *UpArcReq) String() string { return proto.CompactTextString(m) }
func (*UpArcReq) ProtoMessage()    {}
func (*UpArcReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *UpArcReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpArcReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpArcReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpArcReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpArcReq.Merge(m, src)
}
func (m *UpArcReq) XXX_Size() int {
	return m.Size()
}
func (m *UpArcReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpArcReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpArcReq proto.InternalMessageInfo

type UpArcReply struct {
	// 存在up主笔记则note_id>0,否则=0
	NoteId               int64    `protobuf:"varint,1,opt,name=note_id,json=noteId,proto3" json:"note_id"`
	JumpLink             string   `protobuf:"bytes,2,opt,name=jump_link,json=jumpLink,proto3" json:"jump_link"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpArcReply) Reset()         { *m = UpArcReply{} }
func (m *UpArcReply) String() string { return proto.CompactTextString(m) }
func (*UpArcReply) ProtoMessage()    {}
func (*UpArcReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *UpArcReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpArcReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpArcReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpArcReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpArcReply.Merge(m, src)
}
func (m *UpArcReply) XXX_Size() int {
	return m.Size()
}
func (m *UpArcReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpArcReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpArcReply proto.InternalMessageInfo

type ArcsForbidReq struct {
	Aids                 []int64  `protobuf:"varint,1,rep,packed,name=aids,proto3" json:"aids,omitempty" form:"aids`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcsForbidReq) Reset()         { *m = ArcsForbidReq{} }
func (m *ArcsForbidReq) String() string { return proto.CompactTextString(m) }
func (*ArcsForbidReq) ProtoMessage()    {}
func (*ArcsForbidReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *ArcsForbidReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsForbidReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsForbidReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsForbidReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsForbidReq.Merge(m, src)
}
func (m *ArcsForbidReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcsForbidReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsForbidReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsForbidReq proto.InternalMessageInfo

type ArcsForbidReply struct {
	Items                map[int64]bool `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ArcsForbidReply) Reset()         { *m = ArcsForbidReply{} }
func (m *ArcsForbidReply) String() string { return proto.CompactTextString(m) }
func (*ArcsForbidReply) ProtoMessage()    {}
func (*ArcsForbidReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *ArcsForbidReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsForbidReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsForbidReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsForbidReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsForbidReply.Merge(m, src)
}
func (m *ArcsForbidReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcsForbidReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsForbidReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsForbidReply proto.InternalMessageInfo

type PublishNoteInfoReq struct {
	Cvid                 int64    `protobuf:"varint,1,opt,name=cvid,proto3" json:"cvid,omitempty" form:"cvid" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishNoteInfoReq) Reset()         { *m = PublishNoteInfoReq{} }
func (m *PublishNoteInfoReq) String() string { return proto.CompactTextString(m) }
func (*PublishNoteInfoReq) ProtoMessage()    {}
func (*PublishNoteInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *PublishNoteInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishNoteInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishNoteInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishNoteInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishNoteInfoReq.Merge(m, src)
}
func (m *PublishNoteInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *PublishNoteInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishNoteInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_PublishNoteInfoReq proto.InternalMessageInfo

type PublishNoteInfoReply struct {
	Title                string     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Summary              string     `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	Content              string     `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Tags                 []*NoteTag `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	CidCount             int64      `protobuf:"varint,5,opt,name=cid_count,json=cidCount,proto3" json:"cid_count,omitempty"`
	PubStatus            int64      `protobuf:"varint,6,opt,name=pub_status,json=pubStatus,proto3" json:"pub_status,omitempty"`
	PubReason            string     `protobuf:"bytes,7,opt,name=pub_reason,json=pubReason,proto3" json:"pub_reason,omitempty"`
	Oid                  int64      `protobuf:"varint,8,opt,name=oid,proto3" json:"oid,omitempty"`
	OidType              int64      `protobuf:"varint,9,opt,name=oid_type,json=oidType,proto3" json:"oid_type,omitempty"`
	Cvid                 int64      `protobuf:"varint,10,opt,name=cvid,proto3" json:"cvid,omitempty"`
	NoteId               int64      `protobuf:"varint,11,opt,name=note_id,json=noteId,proto3" json:"note_id,omitempty"`
	Mid                  int64      `protobuf:"varint,12,opt,name=mid,proto3" json:"mid,omitempty"`
	ArcCvidCnt           int64      `protobuf:"varint,13,opt,name=arc_cvid_cnt,json=arcCvidCnt,proto3" json:"arc_cvid_cnt,omitempty"`
	Mtime                int64      `protobuf:"varint,14,opt,name=mtime,proto3" json:"mtime,omitempty"`
	PubTime              int64      `protobuf:"varint,15,opt,name=pub_time,json=pubTime,proto3" json:"pub_time,omitempty"`
	HasPubSuccessBefore  bool       `protobuf:"varint,16,opt,name=has_pub_success_before,json=hasPubSuccessBefore,proto3" json:"has_pub_success_before,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PublishNoteInfoReply) Reset()         { *m = PublishNoteInfoReply{} }
func (m *PublishNoteInfoReply) String() string { return proto.CompactTextString(m) }
func (*PublishNoteInfoReply) ProtoMessage()    {}
func (*PublishNoteInfoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *PublishNoteInfoReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishNoteInfoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishNoteInfoReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishNoteInfoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishNoteInfoReply.Merge(m, src)
}
func (m *PublishNoteInfoReply) XXX_Size() int {
	return m.Size()
}
func (m *PublishNoteInfoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishNoteInfoReply.DiscardUnknown(m)
}

var xxx_messageInfo_PublishNoteInfoReply proto.InternalMessageInfo

type PublishImgsReq struct {
	ImageIds             []int64  `protobuf:"varint,1,rep,packed,name=image_ids,json=imageIds,proto3" json:"image_ids,omitempty" form:"image_ids" validate:"required,dive,gt=0"`
	Mid                  int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishImgsReq) Reset()         { *m = PublishImgsReq{} }
func (m *PublishImgsReq) String() string { return proto.CompactTextString(m) }
func (*PublishImgsReq) ProtoMessage()    {}
func (*PublishImgsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *PublishImgsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishImgsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishImgsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishImgsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishImgsReq.Merge(m, src)
}
func (m *PublishImgsReq) XXX_Size() int {
	return m.Size()
}
func (m *PublishImgsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishImgsReq.DiscardUnknown(m)
}

var xxx_messageInfo_PublishImgsReq proto.InternalMessageInfo

type PublishImgInfo struct {
	ImageId              int64    `protobuf:"varint,1,opt,name=image_id,json=imageId,proto3" json:"image_id"`
	Location             string   `protobuf:"bytes,2,opt,name=location,proto3" json:"location"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishImgInfo) Reset()         { *m = PublishImgInfo{} }
func (m *PublishImgInfo) String() string { return proto.CompactTextString(m) }
func (*PublishImgInfo) ProtoMessage()    {}
func (*PublishImgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *PublishImgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishImgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishImgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishImgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishImgInfo.Merge(m, src)
}
func (m *PublishImgInfo) XXX_Size() int {
	return m.Size()
}
func (m *PublishImgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishImgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PublishImgInfo proto.InternalMessageInfo

type PublishImgsReply struct {
	Items                map[int64]*PublishImgInfo `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Host                 string                    `protobuf:"bytes,2,opt,name=host,proto3" json:"host"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *PublishImgsReply) Reset()         { *m = PublishImgsReply{} }
func (m *PublishImgsReply) String() string { return proto.CompactTextString(m) }
func (*PublishImgsReply) ProtoMessage()    {}
func (*PublishImgsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *PublishImgsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishImgsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishImgsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishImgsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishImgsReply.Merge(m, src)
}
func (m *PublishImgsReply) XXX_Size() int {
	return m.Size()
}
func (m *PublishImgsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishImgsReply.DiscardUnknown(m)
}

var xxx_messageInfo_PublishImgsReply proto.InternalMessageInfo

type NoteListInArcReq struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"gt=0"`
	Oid                  int64    `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty" form:"oid" validate:"gt=0"`
	OidType              int64    `protobuf:"varint,3,opt,name=oid_type,json=oidType,proto3" json:"oid_type,omitempty" form:"oid_type" validate:"lt=2"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteListInArcReq) Reset()         { *m = NoteListInArcReq{} }
func (m *NoteListInArcReq) String() string { return proto.CompactTextString(m) }
func (*NoteListInArcReq) ProtoMessage()    {}
func (*NoteListInArcReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *NoteListInArcReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteListInArcReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteListInArcReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteListInArcReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteListInArcReq.Merge(m, src)
}
func (m *NoteListInArcReq) XXX_Size() int {
	return m.Size()
}
func (m *NoteListInArcReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteListInArcReq.DiscardUnknown(m)
}

var xxx_messageInfo_NoteListInArcReq proto.InternalMessageInfo

type NoteListInArcReply struct {
	NoteIds              []int64  `protobuf:"varint,1,rep,packed,name=noteIds,proto3" json:"noteIds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteListInArcReply) Reset()         { *m = NoteListInArcReply{} }
func (m *NoteListInArcReply) String() string { return proto.CompactTextString(m) }
func (*NoteListInArcReply) ProtoMessage()    {}
func (*NoteListInArcReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *NoteListInArcReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteListInArcReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteListInArcReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteListInArcReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteListInArcReply.Merge(m, src)
}
func (m *NoteListInArcReply) XXX_Size() int {
	return m.Size()
}
func (m *NoteListInArcReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteListInArcReply.DiscardUnknown(m)
}

var xxx_messageInfo_NoteListInArcReply proto.InternalMessageInfo

type NoteCountReq struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteCountReq) Reset()         { *m = NoteCountReq{} }
func (m *NoteCountReq) String() string { return proto.CompactTextString(m) }
func (*NoteCountReq) ProtoMessage()    {}
func (*NoteCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *NoteCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteCountReq.Merge(m, src)
}
func (m *NoteCountReq) XXX_Size() int {
	return m.Size()
}
func (m *NoteCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_NoteCountReq proto.InternalMessageInfo

type NoteCountReply struct {
	NoteCount            int64    `protobuf:"varint,1,opt,name=note_count,json=noteCount,proto3" json:"note_count,omitempty"`
	FromArchive          int64    `protobuf:"varint,2,opt,name=from_archive,json=fromArchive,proto3" json:"from_archive,omitempty"`
	FromCheese           int64    `protobuf:"varint,3,opt,name=from_cheese,json=fromCheese,proto3" json:"from_cheese,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteCountReply) Reset()         { *m = NoteCountReply{} }
func (m *NoteCountReply) String() string { return proto.CompactTextString(m) }
func (*NoteCountReply) ProtoMessage()    {}
func (*NoteCountReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *NoteCountReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteCountReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteCountReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteCountReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteCountReply.Merge(m, src)
}
func (m *NoteCountReply) XXX_Size() int {
	return m.Size()
}
func (m *NoteCountReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteCountReply.DiscardUnknown(m)
}

var xxx_messageInfo_NoteCountReply proto.InternalMessageInfo

type NoteSizeReq struct {
	NoteId               int64    `protobuf:"varint,1,opt,name=note_id,json=noteId,proto3" json:"note_id,omitempty"`
	Mid                  int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteSizeReq) Reset()         { *m = NoteSizeReq{} }
func (m *NoteSizeReq) String() string { return proto.CompactTextString(m) }
func (*NoteSizeReq) ProtoMessage()    {}
func (*NoteSizeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *NoteSizeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteSizeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteSizeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteSizeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteSizeReq.Merge(m, src)
}
func (m *NoteSizeReq) XXX_Size() int {
	return m.Size()
}
func (m *NoteSizeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteSizeReq.DiscardUnknown(m)
}

var xxx_messageInfo_NoteSizeReq proto.InternalMessageInfo

type NoteSizeReply struct {
	// 该用户笔记使用总容量,kb
	TotalSize int64 `protobuf:"varint,1,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	// 当前笔记使用总容量,kb
	SingleSize           int64    `protobuf:"varint,2,opt,name=single_size,json=singleSize,proto3" json:"single_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteSizeReply) Reset()         { *m = NoteSizeReply{} }
func (m *NoteSizeReply) String() string { return proto.CompactTextString(m) }
func (*NoteSizeReply) ProtoMessage()    {}
func (*NoteSizeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *NoteSizeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteSizeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteSizeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteSizeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteSizeReply.Merge(m, src)
}
func (m *NoteSizeReply) XXX_Size() int {
	return m.Size()
}
func (m *NoteSizeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteSizeReply.DiscardUnknown(m)
}

var xxx_messageInfo_NoteSizeReply proto.InternalMessageInfo

type ImgAddReq struct {
	Location             string   `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Mid                  int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImgAddReq) Reset()         { *m = ImgAddReq{} }
func (m *ImgAddReq) String() string { return proto.CompactTextString(m) }
func (*ImgAddReq) ProtoMessage()    {}
func (*ImgAddReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *ImgAddReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImgAddReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImgAddReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImgAddReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImgAddReq.Merge(m, src)
}
func (m *ImgAddReq) XXX_Size() int {
	return m.Size()
}
func (m *ImgAddReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ImgAddReq.DiscardUnknown(m)
}

var xxx_messageInfo_ImgAddReq proto.InternalMessageInfo

type ImgAddReply struct {
	ImageId              int64    `protobuf:"varint,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImgAddReply) Reset()         { *m = ImgAddReply{} }
func (m *ImgAddReply) String() string { return proto.CompactTextString(m) }
func (*ImgAddReply) ProtoMessage()    {}
func (*ImgAddReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *ImgAddReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImgAddReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImgAddReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImgAddReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImgAddReply.Merge(m, src)
}
func (m *ImgAddReply) XXX_Size() int {
	return m.Size()
}
func (m *ImgAddReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ImgAddReply.DiscardUnknown(m)
}

var xxx_messageInfo_ImgAddReply proto.InternalMessageInfo

type ImgReq struct {
	ImageId              int64    `protobuf:"varint,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty" form:"image_id" validate:"gt=0"`
	Mid                  int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImgReq) Reset()         { *m = ImgReq{} }
func (m *ImgReq) String() string { return proto.CompactTextString(m) }
func (*ImgReq) ProtoMessage()    {}
func (*ImgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *ImgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImgReq.Merge(m, src)
}
func (m *ImgReq) XXX_Size() int {
	return m.Size()
}
func (m *ImgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ImgReq.DiscardUnknown(m)
}

var xxx_messageInfo_ImgReq proto.InternalMessageInfo

type ImgReply struct {
	Location             string   `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImgReply) Reset()         { *m = ImgReply{} }
func (m *ImgReply) String() string { return proto.CompactTextString(m) }
func (*ImgReply) ProtoMessage()    {}
func (*ImgReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *ImgReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImgReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImgReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImgReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImgReply.Merge(m, src)
}
func (m *ImgReply) XXX_Size() int {
	return m.Size()
}
func (m *ImgReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ImgReply.DiscardUnknown(m)
}

var xxx_messageInfo_ImgReply proto.InternalMessageInfo

type NoteListReq struct {
	Mid                  int64        `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid"`
	Pn                   int64        `protobuf:"varint,2,opt,name=pn,proto3" json:"pn,omitempty" form:"pn" default:"1" validate:"min=1"`
	Ps                   int64        `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" default:"10" validate:"min=1,max=50"`
	Type                 NoteListType `protobuf:"varint,4,opt,name=type,proto3,enum=hkt.node.service.NoteListType" json:"type,omitempty" form:"type"`
	Oid                  int64        `protobuf:"varint,5,opt,name=oid,proto3" json:"oid,omitempty" form:"oid"`
	OidType              int64        `protobuf:"varint,6,opt,name=oid_type,json=oidType,proto3" json:"oid_type,omitempty" form:"oid_type"`
	UperMid              int64        `protobuf:"varint,7,opt,name=uper_mid,json=uperMid,proto3" json:"uper_mid,omitempty" form:"uper_mid"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NoteListReq) Reset()         { *m = NoteListReq{} }
func (m *NoteListReq) String() string { return proto.CompactTextString(m) }
func (*NoteListReq) ProtoMessage()    {}
func (*NoteListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *NoteListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteListReq.Merge(m, src)
}
func (m *NoteListReq) XXX_Size() int {
	return m.Size()
}
func (m *NoteListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteListReq.DiscardUnknown(m)
}

var xxx_messageInfo_NoteListReq proto.InternalMessageInfo

type NoteListReply struct {
	List                 []*NoteSimple `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	Page                 *Page         `protobuf:"bytes,2,opt,name=page,proto3" json:"page,omitempty"`
	NoteSize             *NoteSize     `protobuf:"bytes,3,opt,name=note_size,json=noteSize,proto3" json:"note_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *NoteListReply) Reset()         { *m = NoteListReply{} }
func (m *NoteListReply) String() string { return proto.CompactTextString(m) }
func (*NoteListReply) ProtoMessage()    {}
func (*NoteListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *NoteListReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteListReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteListReply.Merge(m, src)
}
func (m *NoteListReply) XXX_Size() int {
	return m.Size()
}
func (m *NoteListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteListReply.DiscardUnknown(m)
}

var xxx_messageInfo_NoteListReply proto.InternalMessageInfo

type NoteSimple struct {
	Title       string     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Summary     string     `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	Mtime       string     `protobuf:"bytes,3,opt,name=mtime,proto3" json:"mtime,omitempty"`
	Arc         *ArcSimple `protobuf:"bytes,4,opt,name=arc,proto3" json:"arc,omitempty"`
	NoteId      int64      `protobuf:"varint,5,opt,name=note_id,json=noteId,proto3" json:"note_id,omitempty"`
	AuditStatus int64      `protobuf:"varint,6,opt,name=audit_status,json=auditStatus,proto3" json:"audit_status"`
	WebUrl      string     `protobuf:"bytes,7,opt,name=web_url,json=webUrl,proto3" json:"web_url"`
	NoteIdStr   string     `protobuf:"bytes,8,opt,name=note_id_str,json=noteIdStr,proto3" json:"note_id_str,omitempty"`
	// 客态笔记相关
	// 专栏id
	Cvid int64 `protobuf:"varint,9,opt,name=cvid,proto3" json:"cvid,omitempty"`
	// 专栏审核状态，1-进行中，2-已通过 3-已驳回 4-已锁定 5-待审核 6-审核失败
	PubStatus int64 `protobuf:"varint,10,opt,name=pub_status,json=pubStatus,proto3" json:"pub_status,omitempty"`
	// 列表展示文案，审核状态/更新时间
	Message string `protobuf:"bytes,11,opt,name=message,proto3" json:"message,omitempty"`
	// 专栏发布时间
	Pubtime string `protobuf:"bytes,12,opt,name=pubtime,proto3" json:"pubtime,omitempty"`
	// 专栏作者id
	Mid int64 `protobuf:"varint,13,opt,name=mid,proto3" json:"mid,omitempty"`
	// 该稿件是否可记笔记
	ForbidNoteEntrance bool `protobuf:"varint,14,opt,name=forbid_note_entrance,json=forbidNoteEntrance,proto3" json:"forbid_note_entrance"`
	// 专栏点赞数
	Likes int64 `protobuf:"varint,15,opt,name=likes,proto3" json:"likes"`
	// 是否点赞
	HasLike              bool     `protobuf:"varint,16,opt,name=has_like,json=hasLike,proto3" json:"has_like"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteSimple) Reset()         { *m = NoteSimple{} }
func (m *NoteSimple) String() string { return proto.CompactTextString(m) }
func (*NoteSimple) ProtoMessage()    {}
func (*NoteSimple) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *NoteSimple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteSimple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteSimple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteSimple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteSimple.Merge(m, src)
}
func (m *NoteSimple) XXX_Size() int {
	return m.Size()
}
func (m *NoteSimple) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteSimple.DiscardUnknown(m)
}

var xxx_messageInfo_NoteSimple proto.InternalMessageInfo

type NoteSize struct {
	Total                string   `protobuf:"bytes,1,opt,name=total,proto3" json:"total,omitempty"`
	Used                 string   `protobuf:"bytes,2,opt,name=used,proto3" json:"used,omitempty"`
	Percentage           string   `protobuf:"bytes,3,opt,name=percentage,proto3" json:"percentage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteSize) Reset()         { *m = NoteSize{} }
func (m *NoteSize) String() string { return proto.CompactTextString(m) }
func (*NoteSize) ProtoMessage()    {}
func (*NoteSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *NoteSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteSize.Merge(m, src)
}
func (m *NoteSize) XXX_Size() int {
	return m.Size()
}
func (m *NoteSize) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteSize.DiscardUnknown(m)
}

var xxx_messageInfo_NoteSize proto.InternalMessageInfo

type ArcSimple struct {
	Oid     int64  `protobuf:"varint,1,opt,name=oid,proto3" json:"oid"`
	Bvid    string `protobuf:"bytes,2,opt,name=bvid,proto3" json:"bvid,omitempty"`
	Pic     string `protobuf:"bytes,3,opt,name=pic,proto3" json:"pic,omitempty"`
	Desc    string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	Status  int64  `protobuf:"varint,5,opt,name=status,proto3" json:"status"`
	OidType int64  `protobuf:"varint,6,opt,name=oid_type,json=oidType,proto3" json:"oid_type"`
	// TODO del aid
	Aid                  int64    `protobuf:"varint,7,opt,name=aid,proto3" json:"aid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcSimple) Reset()         { *m = ArcSimple{} }
func (m *ArcSimple) String() string { return proto.CompactTextString(m) }
func (*ArcSimple) ProtoMessage()    {}
func (*ArcSimple) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *ArcSimple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcSimple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcSimple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcSimple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcSimple.Merge(m, src)
}
func (m *ArcSimple) XXX_Size() int {
	return m.Size()
}
func (m *ArcSimple) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcSimple.DiscardUnknown(m)
}

var xxx_messageInfo_ArcSimple proto.InternalMessageInfo

type Page struct {
	Total                int64    `protobuf:"varint,1,opt,name=total,proto3" json:"total"`
	Size_                int64    `protobuf:"varint,2,opt,name=size,proto3" json:"size"`
	Num                  int64    `protobuf:"varint,3,opt,name=num,proto3" json:"num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Page) Reset()         { *m = Page{} }
func (m *Page) String() string { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()    {}
func (*Page) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *Page) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Page) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Page.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Page) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Page.Merge(m, src)
}
func (m *Page) XXX_Size() int {
	return m.Size()
}
func (m *Page) XXX_DiscardUnknown() {
	xxx_messageInfo_Page.DiscardUnknown(m)
}

var xxx_messageInfo_Page proto.InternalMessageInfo

type NoteInfoReq struct {
	NoteId               int64    `protobuf:"varint,1,opt,name=note_id,json=noteId,proto3" json:"note_id,omitempty" form:"note_id" validate:"gt=0"`
	Mid                  int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteInfoReq) Reset()         { *m = NoteInfoReq{} }
func (m *NoteInfoReq) String() string { return proto.CompactTextString(m) }
func (*NoteInfoReq) ProtoMessage()    {}
func (*NoteInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *NoteInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteInfoReq.Merge(m, src)
}
func (m *NoteInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *NoteInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_NoteInfoReq proto.InternalMessageInfo

type NoteInfoReply struct {
	Title                string     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Summary              string     `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	Content              string     `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Tags                 []*NoteTag `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	CidCount             int64      `protobuf:"varint,5,opt,name=cid_count,json=cidCount,proto3" json:"cid_count,omitempty"`
	AuditStatus          int64      `protobuf:"varint,6,opt,name=audit_status,json=auditStatus,proto3" json:"audit_status"`
	Oid                  int64      `protobuf:"varint,7,opt,name=oid,proto3" json:"oid,omitempty"`
	PubStatus            int64      `protobuf:"varint,8,opt,name=pub_status,json=pubStatus,proto3" json:"pub_status,omitempty"`
	PubReason            string     `protobuf:"bytes,9,opt,name=pub_reason,json=pubReason,proto3" json:"pub_reason,omitempty"`
	PubVersion           int64      `protobuf:"varint,10,opt,name=pub_version,json=pubVersion,proto3" json:"pub_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NoteInfoReply) Reset()         { *m = NoteInfoReply{} }
func (m *NoteInfoReply) String() string { return proto.CompactTextString(m) }
func (*NoteInfoReply) ProtoMessage()    {}
func (*NoteInfoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *NoteInfoReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteInfoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteInfoReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteInfoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteInfoReply.Merge(m, src)
}
func (m *NoteInfoReply) XXX_Size() int {
	return m.Size()
}
func (m *NoteInfoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteInfoReply.DiscardUnknown(m)
}

var xxx_messageInfo_NoteInfoReply proto.InternalMessageInfo

type SimpleNotesReq struct {
	NoteIds []int64 `protobuf:"varint,1,rep,packed,name=note_ids,json=noteIds,proto3" json:"note_ids,omitempty" form:"note_ids" validate:"required,dive,gt=0"`
	Mid     int64   `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"required"`
	// 数据类型 0-默认 1-包括公开笔记信息
	Tp                   SimpleNoteType `protobuf:"varint,3,opt,name=tp,proto3,enum=hkt.node.service.SimpleNoteType" json:"tp,omitempty" form:"tp"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SimpleNotesReq) Reset()         { *m = SimpleNotesReq{} }
func (m *SimpleNotesReq) String() string { return proto.CompactTextString(m) }
func (*SimpleNotesReq) ProtoMessage()    {}
func (*SimpleNotesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *SimpleNotesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleNotesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleNotesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleNotesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleNotesReq.Merge(m, src)
}
func (m *SimpleNotesReq) XXX_Size() int {
	return m.Size()
}
func (m *SimpleNotesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleNotesReq.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleNotesReq proto.InternalMessageInfo

type SimpleNoteCard struct {
	NoteId  int64 `protobuf:"varint,1,opt,name=note_id,json=noteId,proto3" json:"note_id"`
	Oid     int64 `protobuf:"varint,2,opt,name=oid,proto3" json:"oid"`
	OidType int64 `protobuf:"varint,3,opt,name=oid_type,json=oidType,proto3" json:"oid_type"`
	Mid     int64 `protobuf:"varint,4,opt,name=mid,proto3" json:"mid"`
	// 公开笔记信息
	PubStatus            int64    `protobuf:"varint,5,opt,name=pub_status,json=pubStatus,proto3" json:"pub_status"`
	PubReason            string   `protobuf:"bytes,6,opt,name=pub_reason,json=pubReason,proto3" json:"pub_reason"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleNoteCard) Reset()         { *m = SimpleNoteCard{} }
func (m *SimpleNoteCard) String() string { return proto.CompactTextString(m) }
func (*SimpleNoteCard) ProtoMessage()    {}
func (*SimpleNoteCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *SimpleNoteCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleNoteCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleNoteCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleNoteCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleNoteCard.Merge(m, src)
}
func (m *SimpleNoteCard) XXX_Size() int {
	return m.Size()
}
func (m *SimpleNoteCard) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleNoteCard.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleNoteCard proto.InternalMessageInfo

type SimpleNotesReply struct {
	Items                map[int64]*SimpleNoteCard `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SimpleNotesReply) Reset()         { *m = SimpleNotesReply{} }
func (m *SimpleNotesReply) String() string { return proto.CompactTextString(m) }
func (*SimpleNotesReply) ProtoMessage()    {}
func (*SimpleNotesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *SimpleNotesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleNotesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleNotesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleNotesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleNotesReply.Merge(m, src)
}
func (m *SimpleNotesReply) XXX_Size() int {
	return m.Size()
}
func (m *SimpleNotesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleNotesReply.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleNotesReply proto.InternalMessageInfo

type NoteTag struct {
	Cid                  int64    `protobuf:"varint,1,opt,name=cid,proto3" json:"cid"`
	Status               int64    `protobuf:"varint,2,opt,name=status,proto3" json:"status"`
	Index                int64    `protobuf:"varint,3,opt,name=index,proto3" json:"index"`
	Seconds              int64    `protobuf:"varint,4,opt,name=seconds,proto3" json:"seconds"`
	Pos                  int64    `protobuf:"varint,5,opt,name=pos,proto3" json:"pos"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteTag) Reset()         { *m = NoteTag{} }
func (m *NoteTag) String() string { return proto.CompactTextString(m) }
func (*NoteTag) ProtoMessage()    {}
func (*NoteTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *NoteTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteTag.Merge(m, src)
}
func (m *NoteTag) XXX_Size() int {
	return m.Size()
}
func (m *NoteTag) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteTag.DiscardUnknown(m)
}

var xxx_messageInfo_NoteTag proto.InternalMessageInfo

type NoteSync struct {
	NoteId               int64    `protobuf:"varint,1,opt,name=note_id,json=noteId,proto3" json:"note_id"`
	Hash                 string   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteSync) Reset()         { *m = NoteSync{} }
func (m *NoteSync) String() string { return proto.CompactTextString(m) }
func (*NoteSync) ProtoMessage()    {}
func (*NoteSync) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *NoteSync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteSync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteSync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteSync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteSync.Merge(m, src)
}
func (m *NoteSync) XXX_Size() int {
	return m.Size()
}
func (m *NoteSync) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteSync.DiscardUnknown(m)
}

var xxx_messageInfo_NoteSync proto.InternalMessageInfo

type SimpleArticlesReq struct {
	Cvids                []int64  `protobuf:"varint,1,rep,packed,name=cvids,proto3" json:"cvids,omitempty" form:"cvids" validate:"required,dive,gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleArticlesReq) Reset()         { *m = SimpleArticlesReq{} }
func (m *SimpleArticlesReq) String() string { return proto.CompactTextString(m) }
func (*SimpleArticlesReq) ProtoMessage()    {}
func (*SimpleArticlesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *SimpleArticlesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleArticlesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleArticlesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleArticlesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleArticlesReq.Merge(m, src)
}
func (m *SimpleArticlesReq) XXX_Size() int {
	return m.Size()
}
func (m *SimpleArticlesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleArticlesReq.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleArticlesReq proto.InternalMessageInfo

type SimpleArticleCard struct {
	Cvid                 int64    `protobuf:"varint,1,opt,name=cvid,proto3" json:"note_id"`
	Oid                  int64    `protobuf:"varint,2,opt,name=oid,proto3" json:"oid"`
	OidType              int64    `protobuf:"varint,3,opt,name=oid_type,json=oidType,proto3" json:"oid_type"`
	Mid                  int64    `protobuf:"varint,4,opt,name=mid,proto3" json:"mid"`
	NoteId               int64    `protobuf:"varint,5,opt,name=note_id,json=noteId,proto3" json:"note_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleArticleCard) Reset()         { *m = SimpleArticleCard{} }
func (m *SimpleArticleCard) String() string { return proto.CompactTextString(m) }
func (*SimpleArticleCard) ProtoMessage()    {}
func (*SimpleArticleCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *SimpleArticleCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleArticleCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleArticleCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleArticleCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleArticleCard.Merge(m, src)
}
func (m *SimpleArticleCard) XXX_Size() int {
	return m.Size()
}
func (m *SimpleArticleCard) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleArticleCard.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleArticleCard proto.InternalMessageInfo

type SimpleArticlesReply struct {
	Items                map[int64]*SimpleArticleCard `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *SimpleArticlesReply) Reset()         { *m = SimpleArticlesReply{} }
func (m *SimpleArticlesReply) String() string { return proto.CompactTextString(m) }
func (*SimpleArticlesReply) ProtoMessage()    {}
func (*SimpleArticlesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *SimpleArticlesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleArticlesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleArticlesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleArticlesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleArticlesReply.Merge(m, src)
}
func (m *SimpleArticlesReply) XXX_Size() int {
	return m.Size()
}
func (m *SimpleArticlesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleArticlesReply.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleArticlesReply proto.InternalMessageInfo

//稿件播放页的笔记tag
type ArcTagReq struct {
	Oid     int64 `protobuf:"varint,1,opt,name=oid,proto3" json:"oid,omitempty" form:"oid" validate:"gt=0"`
	OidType int64 `protobuf:"varint,2,opt,name=oid_type,json=oidType,proto3" json:"oid_type,omitempty" form:"oid_type"`
	//当前稿件uper的mid
	UpperId int64 `protobuf:"varint,3,opt,name=upper_id,json=upperId,proto3" json:"upper_id,omitempty" form:"upper_id" validate:"gt=0"`
	//当前登录用户的mid
	LoginMid int64 `protobuf:"varint,4,opt,name=login_mid,json=loginMid,proto3" json:"login_mid,omitempty" form:"login_mid"`
	//稿件二级分区id
	SubTypeId            int32    `protobuf:"varint,5,opt,name=sub_type_id,json=subTypeId,proto3" json:"sub_type_id,omitempty" form:"sub_type_id" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcTagReq) Reset()         { *m = ArcTagReq{} }
func (m *ArcTagReq) String() string { return proto.CompactTextString(m) }
func (*ArcTagReq) ProtoMessage()    {}
func (*ArcTagReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *ArcTagReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcTagReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcTagReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcTagReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcTagReq.Merge(m, src)
}
func (m *ArcTagReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcTagReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcTagReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcTagReq proto.InternalMessageInfo

type ArcTagReply struct {
	// 存在up主笔记则note_id>0,否则=0 用于埋点
	NoteId int64 `protobuf:"varint,1,opt,name=note_id,proto3" json:"note_id"`
	// tag跳转链接
	JumpLink string `protobuf:"bytes,2,opt,name=jump_link,proto3" json:"jump_link"`
	//tag展示文案
	TagShowText string `protobuf:"bytes,3,opt,name=tag_show_text,proto3" json:"tag_show_text"`
	// 稿件下公开笔记个数
	NotesCount int64 `protobuf:"varint,4,opt,name=notes_count,proto3" json:"notes_count"`
	// 命中直接拉起笔记的专栏id
	AutoPullCvid         int64    `protobuf:"varint,5,opt,name=auto_pull_cvid,proto3" json:"auto_pull_cvid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcTagReply) Reset()         { *m = ArcTagReply{} }
func (m *ArcTagReply) String() string { return proto.CompactTextString(m) }
func (*ArcTagReply) ProtoMessage()    {}
func (*ArcTagReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *ArcTagReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcTagReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcTagReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcTagReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcTagReply.Merge(m, src)
}
func (m *ArcTagReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcTagReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcTagReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcTagReply proto.InternalMessageInfo

type AutoPullAidCivdReq struct {
	AidToCvids           []string `protobuf:"bytes,1,rep,name=aidToCvids,proto3" json:"aidToCvids,omitempty" form:"aidToCvids" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutoPullAidCivdReq) Reset()         { *m = AutoPullAidCivdReq{} }
func (m *AutoPullAidCivdReq) String() string { return proto.CompactTextString(m) }
func (*AutoPullAidCivdReq) ProtoMessage()    {}
func (*AutoPullAidCivdReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *AutoPullAidCivdReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoPullAidCivdReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoPullAidCivdReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoPullAidCivdReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoPullAidCivdReq.Merge(m, src)
}
func (m *AutoPullAidCivdReq) XXX_Size() int {
	return m.Size()
}
func (m *AutoPullAidCivdReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoPullAidCivdReq.DiscardUnknown(m)
}

var xxx_messageInfo_AutoPullAidCivdReq proto.InternalMessageInfo

type AutoPullAidCivdReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutoPullAidCivdReply) Reset()         { *m = AutoPullAidCivdReply{} }
func (m *AutoPullAidCivdReply) String() string { return proto.CompactTextString(m) }
func (*AutoPullAidCivdReply) ProtoMessage()    {}
func (*AutoPullAidCivdReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *AutoPullAidCivdReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoPullAidCivdReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoPullAidCivdReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoPullAidCivdReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoPullAidCivdReply.Merge(m, src)
}
func (m *AutoPullAidCivdReply) XXX_Size() int {
	return m.Size()
}
func (m *AutoPullAidCivdReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoPullAidCivdReply.DiscardUnknown(m)
}

var xxx_messageInfo_AutoPullAidCivdReply proto.InternalMessageInfo

type ArcNotesCountReq struct {
	Oid                  int64    `protobuf:"varint,1,opt,name=oid,proto3" json:"oid,omitempty" form:"oid" validate:"gt=0"`
	OidType              int64    `protobuf:"varint,2,opt,name=oid_type,json=oidType,proto3" json:"oid_type,omitempty" form:"oid_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcNotesCountReq) Reset()         { *m = ArcNotesCountReq{} }
func (m *ArcNotesCountReq) String() string { return proto.CompactTextString(m) }
func (*ArcNotesCountReq) ProtoMessage()    {}
func (*ArcNotesCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *ArcNotesCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcNotesCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcNotesCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcNotesCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcNotesCountReq.Merge(m, src)
}
func (m *ArcNotesCountReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcNotesCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcNotesCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcNotesCountReq proto.InternalMessageInfo

type ArcNotesCountReply struct {
	// 稿件下公开笔记个数
	NotesCount           int64    `protobuf:"varint,1,opt,name=notes_count,proto3" json:"notes_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcNotesCountReply) Reset()         { *m = ArcNotesCountReply{} }
func (m *ArcNotesCountReply) String() string { return proto.CompactTextString(m) }
func (*ArcNotesCountReply) ProtoMessage()    {}
func (*ArcNotesCountReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *ArcNotesCountReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcNotesCountReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcNotesCountReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcNotesCountReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcNotesCountReply.Merge(m, src)
}
func (m *ArcNotesCountReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcNotesCountReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcNotesCountReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcNotesCountReply proto.InternalMessageInfo

type BatchGetReplyRenderInfoReq struct {
	Cvids                []int64  `protobuf:"varint,1,rep,packed,name=cvids,proto3" json:"cvids,omitempty" form:"cvids" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchGetReplyRenderInfoReq) Reset()         { *m = BatchGetReplyRenderInfoReq{} }
func (m *BatchGetReplyRenderInfoReq) String() string { return proto.CompactTextString(m) }
func (*BatchGetReplyRenderInfoReq) ProtoMessage()    {}
func (*BatchGetReplyRenderInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *BatchGetReplyRenderInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchGetReplyRenderInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchGetReplyRenderInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchGetReplyRenderInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchGetReplyRenderInfoReq.Merge(m, src)
}
func (m *BatchGetReplyRenderInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *BatchGetReplyRenderInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchGetReplyRenderInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_BatchGetReplyRenderInfoReq proto.InternalMessageInfo

type BatchGetReplyRenderInfoRes struct {
	Items                map[int64]*ReplyRenderInfoItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *BatchGetReplyRenderInfoRes) Reset()         { *m = BatchGetReplyRenderInfoRes{} }
func (m *BatchGetReplyRenderInfoRes) String() string { return proto.CompactTextString(m) }
func (*BatchGetReplyRenderInfoRes) ProtoMessage()    {}
func (*BatchGetReplyRenderInfoRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *BatchGetReplyRenderInfoRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchGetReplyRenderInfoRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchGetReplyRenderInfoRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchGetReplyRenderInfoRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchGetReplyRenderInfoRes.Merge(m, src)
}
func (m *BatchGetReplyRenderInfoRes) XXX_Size() int {
	return m.Size()
}
func (m *BatchGetReplyRenderInfoRes) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchGetReplyRenderInfoRes.DiscardUnknown(m)
}

var xxx_messageInfo_BatchGetReplyRenderInfoRes proto.InternalMessageInfo

type ReplyRenderInfoItem struct {
	// 笔记的摘要
	Summary string `protobuf:"bytes,1,opt,name=summary,proto3" json:"summary"`
	// 笔记的截屏图片,可能为空
	Images []string `protobuf:"bytes,2,rep,name=images,proto3" json:"images"`
	// 点击跳转url
	ClickUrl string `protobuf:"bytes,3,opt,name=click_url,proto3" json:"click_url"`
	// 最近一次修改展示文案
	LastMtimeText        string   `protobuf:"bytes,4,opt,name=last_mtime_text,proto3" json:"last_mtime_text"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplyRenderInfoItem) Reset()         { *m = ReplyRenderInfoItem{} }
func (m *ReplyRenderInfoItem) String() string { return proto.CompactTextString(m) }
func (*ReplyRenderInfoItem) ProtoMessage()    {}
func (*ReplyRenderInfoItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{43}
}
func (m *ReplyRenderInfoItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyRenderInfoItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyRenderInfoItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyRenderInfoItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyRenderInfoItem.Merge(m, src)
}
func (m *ReplyRenderInfoItem) XXX_Size() int {
	return m.Size()
}
func (m *ReplyRenderInfoItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyRenderInfoItem.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyRenderInfoItem proto.InternalMessageInfo

type GetAttachedRpidReq struct {
	Cvid                 int64    `protobuf:"varint,1,opt,name=cvid,proto3" json:"cvid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAttachedRpidReq) Reset()         { *m = GetAttachedRpidReq{} }
func (m *GetAttachedRpidReq) String() string { return proto.CompactTextString(m) }
func (*GetAttachedRpidReq) ProtoMessage()    {}
func (*GetAttachedRpidReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{44}
}
func (m *GetAttachedRpidReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAttachedRpidReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAttachedRpidReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAttachedRpidReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAttachedRpidReq.Merge(m, src)
}
func (m *GetAttachedRpidReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAttachedRpidReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAttachedRpidReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAttachedRpidReq proto.InternalMessageInfo

type GetAttachedRpidReply struct {
	Rpid                 int64    `protobuf:"varint,1,opt,name=rpid,proto3" json:"rpid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAttachedRpidReply) Reset()         { *m = GetAttachedRpidReply{} }
func (m *GetAttachedRpidReply) String() string { return proto.CompactTextString(m) }
func (*GetAttachedRpidReply) ProtoMessage()    {}
func (*GetAttachedRpidReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45}
}
func (m *GetAttachedRpidReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAttachedRpidReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAttachedRpidReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAttachedRpidReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAttachedRpidReply.Merge(m, src)
}
func (m *GetAttachedRpidReply) XXX_Size() int {
	return m.Size()
}
func (m *GetAttachedRpidReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAttachedRpidReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetAttachedRpidReply proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("hkt.node.service.NoteListType", NoteListType_name, NoteListType_value)
	proto.RegisterEnum("hkt.node.service.SimpleNoteType", SimpleNoteType_name, SimpleNoteType_value)
	proto.RegisterType((*UpArcReq)(nil), "hkt.node.service.UpArcReq")
	proto.RegisterType((*UpArcReply)(nil), "hkt.node.service.UpArcReply")
	proto.RegisterType((*ArcsForbidReq)(nil), "hkt.node.service.ArcsForbidReq")
	proto.RegisterType((*ArcsForbidReply)(nil), "hkt.node.service.ArcsForbidReply")
	proto.RegisterMapType((map[int64]bool)(nil), "hkt.node.service.ArcsForbidReply.ItemsEntry")
	proto.RegisterType((*PublishNoteInfoReq)(nil), "hkt.node.service.PublishNoteInfoReq")
	proto.RegisterType((*PublishNoteInfoReply)(nil), "hkt.node.service.PublishNoteInfoReply")
	proto.RegisterType((*PublishImgsReq)(nil), "hkt.node.service.PublishImgsReq")
	proto.RegisterType((*PublishImgInfo)(nil), "hkt.node.service.PublishImgInfo")
	proto.RegisterType((*PublishImgsReply)(nil), "hkt.node.service.PublishImgsReply")
	proto.RegisterMapType((map[int64]*PublishImgInfo)(nil), "hkt.node.service.PublishImgsReply.ItemsEntry")
	proto.RegisterType((*NoteListInArcReq)(nil), "hkt.node.service.NoteListInArcReq")
	proto.RegisterType((*NoteListInArcReply)(nil), "hkt.node.service.NoteListInArcReply")
	proto.RegisterType((*NoteCountReq)(nil), "hkt.node.service.NoteCountReq")
	proto.RegisterType((*NoteCountReply)(nil), "hkt.node.service.NoteCountReply")
	proto.RegisterType((*NoteSizeReq)(nil), "hkt.node.service.NoteSizeReq")
	proto.RegisterType((*NoteSizeReply)(nil), "hkt.node.service.NoteSizeReply")
	proto.RegisterType((*ImgAddReq)(nil), "hkt.node.service.ImgAddReq")
	proto.RegisterType((*ImgAddReply)(nil), "hkt.node.service.ImgAddReply")
	proto.RegisterType((*ImgReq)(nil), "hkt.node.service.ImgReq")
	proto.RegisterType((*ImgReply)(nil), "hkt.node.service.ImgReply")
	proto.RegisterType((*NoteListReq)(nil), "hkt.node.service.NoteListReq")
	proto.RegisterType((*NoteListReply)(nil), "hkt.node.service.NoteListReply")
	proto.RegisterType((*NoteSimple)(nil), "hkt.node.service.NoteSimple")
	proto.RegisterType((*NoteSize)(nil), "hkt.node.service.NoteSize")
	proto.RegisterType((*ArcSimple)(nil), "hkt.node.service.ArcSimple")
	proto.RegisterType((*Page)(nil), "hkt.node.service.Page")
	proto.RegisterType((*NoteInfoReq)(nil), "hkt.node.service.NoteInfoReq")
	proto.RegisterType((*NoteInfoReply)(nil), "hkt.node.service.NoteInfoReply")
	proto.RegisterType((*SimpleNotesReq)(nil), "hkt.node.service.SimpleNotesReq")
	proto.RegisterType((*SimpleNoteCard)(nil), "hkt.node.service.SimpleNoteCard")
	proto.RegisterType((*SimpleNotesReply)(nil), "hkt.node.service.SimpleNotesReply")
	proto.RegisterMapType((map[int64]*SimpleNoteCard)(nil), "hkt.node.service.SimpleNotesReply.ItemsEntry")
	proto.RegisterType((*NoteTag)(nil), "hkt.node.service.NoteTag")
	proto.RegisterType((*NoteSync)(nil), "hkt.node.service.NoteSync")
	proto.RegisterType((*SimpleArticlesReq)(nil), "hkt.node.service.SimpleArticlesReq")
	proto.RegisterType((*SimpleArticleCard)(nil), "hkt.node.service.SimpleArticleCard")
	proto.RegisterType((*SimpleArticlesReply)(nil), "hkt.node.service.SimpleArticlesReply")
	proto.RegisterMapType((map[int64]*SimpleArticleCard)(nil), "hkt.node.service.SimpleArticlesReply.ItemsEntry")
	proto.RegisterType((*ArcTagReq)(nil), "hkt.node.service.ArcTagReq")
	proto.RegisterType((*ArcTagReply)(nil), "hkt.node.service.ArcTagReply")
	proto.RegisterType((*AutoPullAidCivdReq)(nil), "hkt.node.service.AutoPullAidCivdReq")
	proto.RegisterType((*AutoPullAidCivdReply)(nil), "hkt.node.service.AutoPullAidCivdReply")
	proto.RegisterType((*ArcNotesCountReq)(nil), "hkt.node.service.ArcNotesCountReq")
	proto.RegisterType((*ArcNotesCountReply)(nil), "hkt.node.service.ArcNotesCountReply")
	proto.RegisterType((*BatchGetReplyRenderInfoReq)(nil), "hkt.node.service.BatchGetReplyRenderInfoReq")
	proto.RegisterType((*BatchGetReplyRenderInfoRes)(nil), "hkt.node.service.BatchGetReplyRenderInfoRes")
	proto.RegisterMapType((map[int64]*ReplyRenderInfoItem)(nil), "hkt.node.service.BatchGetReplyRenderInfoRes.ItemsEntry")
	proto.RegisterType((*ReplyRenderInfoItem)(nil), "hkt.node.service.ReplyRenderInfoItem")
	proto.RegisterType((*GetAttachedRpidReq)(nil), "hkt.node.service.GetAttachedRpidReq")
	proto.RegisterType((*GetAttachedRpidReply)(nil), "hkt.node.service.GetAttachedRpidReply")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 3072 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x8f, 0xdb, 0xc6,
	0x15, 0x8f, 0x56, 0xda, 0x95, 0xf4, 0xb4, 0x5f, 0x1e, 0x7f, 0x44, 0x56, 0x9c, 0xe5, 0x86, 0xfe,
	0x88, 0xe3, 0xda, 0x6b, 0x7b, 0x9d, 0x36, 0xc9, 0xa6, 0x76, 0x23, 0xad, 0x1d, 0x47, 0xc1, 0x26,
	0x31, 0xb8, 0x76, 0x9a, 0xa4, 0x69, 0x55, 0x8a, 0xa4, 0x25, 0x76, 0xc5, 0x0f, 0xf3, 0x63, 0x93,
	0x35, 0x7a, 0xeb, 0xa9, 0x7f, 0x41, 0xd1, 0x43, 0x6f, 0x3d, 0x14, 0x68, 0xcf, 0x05, 0xfa, 0x1f,
	0xe4, 0xd0, 0x43, 0x7b, 0x28, 0x0a, 0xf4, 0x40, 0xb4, 0x39, 0xb4, 0x80, 0x2e, 0x05, 0x54, 0xa0,
	0xe7, 0xe2, 0xcd, 0x0c, 0xc5, 0x21, 0x45, 0xad, 0x14, 0x17, 0x39, 0x14, 0xe8, 0x45, 0xe2, 0xbc,
	0x79, 0xef, 0xcd, 0xcc, 0x9b, 0xf7, 0xf1, 0x9b, 0x21, 0xa1, 0xaa, 0xba, 0xe6, 0x96, 0xeb, 0x39,
	0x81, 0x43, 0xd6, 0xfb, 0x07, 0xc1, 0x96, 0xed, 0xe8, 0xc6, 0x96, 0x6f, 0x78, 0x87, 0xa6, 0x66,
	0x34, 0xae, 0xf5, 0xcc, 0xa0, 0x1f, 0x76, 0xb7, 0x34, 0xc7, 0xba, 0xde, 0x73, 0x7a, 0xce, 0x75,
	0xca, 0xd8, 0x0d, 0x1f, 0xd3, 0x16, 0x6d, 0xd0, 0x27, 0xa6, 0x40, 0xfe, 0x4d, 0x01, 0x2a, 0x8f,
	0xdc, 0xa6, 0xa7, 0x29, 0xc6, 0x13, 0x72, 0x03, 0x8a, 0x8e, 0xa9, 0xd7, 0x0b, 0x9b, 0x85, 0xcb,
	0xc5, 0xd6, 0xc6, 0x28, 0x92, 0x1a, 0x8f, 0x1d, 0xcf, 0xda, 0x91, 0x1d, 0x53, 0x97, 0x37, 0x0f,
	0xd5, 0x81, 0xa9, 0xab, 0x81, 0xb1, 0x23, 0xf7, 0x82, 0xdb, 0x37, 0x64, 0x05, 0x59, 0xc9, 0x16,
	0x54, 0x1c, 0x53, 0xef, 0x04, 0x47, 0xae, 0x51, 0x5f, 0xa0, 0x62, 0x27, 0x47, 0x91, 0xb4, 0x36,
	0x16, 0xa3, 0x3d, 0xb2, 0x52, 0x76, 0x4c, 0xfd, 0xe1, 0x91, 0x6b, 0x90, 0x3b, 0x50, 0x09, 0x5d,
	0xd7, 0xf0, 0x3a, 0xa6, 0x5e, 0x2f, 0x52, 0xfe, 0xf3, 0xa3, 0x48, 0x92, 0x18, 0x7f, 0xdc, 0x33,
	0x39, 0x56, 0x99, 0x76, 0xb5, 0x75, 0xf9, 0x07, 0x00, 0x7c, 0xb6, 0xee, 0xe0, 0x88, 0x5c, 0x80,
	0xb2, 0xed, 0x04, 0x46, 0x67, 0x3c, 0xe7, 0xda, 0x30, 0x92, 0x62, 0x92, 0xb2, 0x84, 0x0f, 0x6d,
	0x9d, 0x5c, 0x81, 0xea, 0x8f, 0x42, 0xcb, 0xed, 0x0c, 0x4c, 0xfb, 0x80, 0x4e, 0xb2, 0xda, 0x5a,
	0x19, 0x46, 0x52, 0x42, 0x54, 0x2a, 0xf8, 0xb8, 0x67, 0xda, 0x07, 0xf2, 0x2d, 0x58, 0x69, 0x7a,
	0x9a, 0xff, 0xb6, 0xe3, 0x75, 0x4d, 0x1d, 0x4d, 0x22, 0x43, 0x49, 0x35, 0x75, 0xbf, 0x5e, 0xd8,
	0x2c, 0x5e, 0x2e, 0xb6, 0x56, 0x47, 0x91, 0x04, 0x6c, 0xb2, 0x48, 0x55, 0x68, 0x9f, 0xfc, 0xcb,
	0x02, 0xac, 0x89, 0x52, 0x38, 0xb5, 0xef, 0xc2, 0xa2, 0x19, 0x18, 0x16, 0x13, 0xac, 0x6d, 0x5f,
	0xdd, 0xca, 0x6e, 0xd4, 0x56, 0x46, 0x62, 0xab, 0x8d, 0xec, 0xf7, 0xec, 0xc0, 0x3b, 0x6a, 0x9d,
	0x1c, 0x46, 0xd2, 0x1a, 0x15, 0xbf, 0xea, 0x58, 0xf8, 0xef, 0x06, 0x47, 0x0a, 0xd3, 0xd7, 0x78,
	0x1d, 0x20, 0xe1, 0x24, 0xeb, 0x50, 0x3c, 0x30, 0x8e, 0xd8, 0xea, 0x15, 0x7c, 0x24, 0xa7, 0x60,
	0xf1, 0x50, 0x1d, 0x84, 0x6c, 0x3b, 0x2a, 0x0a, 0x6b, 0xec, 0x2c, 0xbc, 0x5e, 0x90, 0xdb, 0x40,
	0x1e, 0x84, 0xdd, 0x81, 0xe9, 0xf7, 0xdf, 0x47, 0xc3, 0xd8, 0x8f, 0x1d, 0x5c, 0xe0, 0x2d, 0x28,
	0x69, 0x87, 0x63, 0x03, 0x4a, 0xa3, 0x48, 0x7a, 0x81, 0x2d, 0x10, 0xa9, 0x93, 0x3b, 0x41, 0x99,
	0xe5, 0xbf, 0x2c, 0xc1, 0xa9, 0x09, 0x5d, 0xb8, 0xec, 0x57, 0x60, 0x31, 0x30, 0x83, 0x81, 0x41,
	0xd5, 0x55, 0xd9, 0x42, 0x28, 0x41, 0x5c, 0x08, 0x25, 0x90, 0xeb, 0x50, 0xf6, 0x43, 0xcb, 0x52,
	0xbd, 0x23, 0xbe, 0x29, 0xa7, 0x87, 0x91, 0x74, 0x82, 0x93, 0x04, 0xf6, 0x98, 0x0b, 0x05, 0x34,
	0xc7, 0x0e, 0x0c, 0x3b, 0xa0, 0xae, 0xc3, 0x05, 0x38, 0x49, 0x14, 0xe0, 0x24, 0xd2, 0x84, 0x52,
	0xa0, 0xf6, 0xfc, 0x7a, 0x89, 0x6e, 0xc1, 0xd9, 0xc9, 0x2d, 0xc0, 0xb9, 0x3f, 0x54, 0x7b, 0x2d,
	0x32, 0x8c, 0xa4, 0x55, 0x64, 0x15, 0xb4, 0x50, 0x51, 0xf2, 0x2a, 0x54, 0x35, 0x53, 0xef, 0x68,
	0x4e, 0x68, 0x07, 0xf5, 0x45, 0x6a, 0xa2, 0xe7, 0x87, 0x91, 0x74, 0x72, 0x4c, 0x14, 0x24, 0x2a,
	0x9a, 0xa9, 0xef, 0x22, 0x8d, 0xbc, 0x06, 0xe0, 0x86, 0xdd, 0x8e, 0x1f, 0xa8, 0x41, 0xe8, 0xd7,
	0x97, 0xa8, 0x58, 0x7d, 0x18, 0x49, 0xa7, 0x12, 0xaa, 0x20, 0x57, 0x75, 0xc3, 0xee, 0x3e, 0x25,
	0xc6, 0x82, 0x9e, 0xa1, 0xfa, 0x8e, 0x5d, 0x2f, 0xd3, 0x55, 0x8e, 0x05, 0x19, 0x35, 0x23, 0xa8,
	0x50, 0x22, 0x39, 0xcf, 0x22, 0xb7, 0x42, 0x87, 0x3a, 0x31, 0x8c, 0xa4, 0x15, 0xc7, 0xd4, 0x05,
	0x56, 0x1a, 0xac, 0x37, 0x85, 0x60, 0xad, 0x52, 0xce, 0x33, 0xc3, 0x48, 0x22, 0x31, 0x4d, 0x34,
	0x61, 0x1c, 0xaf, 0x97, 0xb8, 0x77, 0x00, 0x65, 0xa7, 0x76, 0xc2, 0xb6, 0x68, 0x27, 0x6c, 0x93,
	0xad, 0x24, 0x12, 0x6b, 0x94, 0x95, 0xee, 0x0d, 0x27, 0x09, 0xdc, 0x71, 0x4c, 0x9e, 0x87, 0xa2,
	0x65, 0xea, 0xf5, 0xe5, 0x64, 0xbe, 0x56, 0x7a, 0xbe, 0x96, 0xa9, 0x93, 0x6f, 0xc3, 0xb2, 0xea,
	0x69, 0x1d, 0x1c, 0xa0, 0xa3, 0xd9, 0x41, 0x7d, 0x85, 0x72, 0x37, 0x86, 0x91, 0x74, 0x46, 0xa4,
	0x0b, 0x62, 0xa0, 0x7a, 0xda, 0xee, 0xa1, 0xa9, 0xef, 0xda, 0x01, 0xba, 0xa2, 0x15, 0x98, 0x96,
	0x51, 0x5f, 0x65, 0x79, 0x09, 0x5d, 0x91, 0x12, 0x44, 0x57, 0xa4, 0x04, 0x34, 0x0c, 0x1a, 0x98,
	0x72, 0xaf, 0x25, 0x86, 0x89, 0x69, 0xa2, 0x61, 0xdc, 0xb0, 0xfb, 0x10, 0x45, 0x3e, 0x86, 0x33,
	0x7d, 0xd5, 0xef, 0xd0, 0x0d, 0x0d, 0x35, 0xcd, 0xf0, 0xfd, 0x4e, 0xd7, 0x78, 0xec, 0x78, 0x46,
	0x7d, 0x1d, 0xe3, 0xae, 0x75, 0x61, 0x18, 0x49, 0x9b, 0xf9, 0x1c, 0x82, 0xba, 0x93, 0x7d, 0xd5,
	0x7f, 0x10, 0x76, 0xf7, 0x59, 0x7f, 0x8b, 0x76, 0xcb, 0x3f, 0x2b, 0xc0, 0x2a, 0x0f, 0xae, 0xb6,
	0xd5, 0xf3, 0x31, 0x48, 0x3f, 0x80, 0xaa, 0x69, 0xa9, 0x3d, 0x34, 0x66, 0x9c, 0x8a, 0xb6, 0x47,
	0x91, 0xb4, 0xc5, 0x22, 0x75, 0xdc, 0x25, 0x86, 0xab, 0x67, 0x3c, 0x09, 0x4d, 0xcf, 0xd0, 0xaf,
	0xea, 0xe6, 0xa1, 0x71, 0x95, 0x05, 0x6f, 0x85, 0x72, 0xb6, 0x75, 0xf4, 0x6b, 0x6a, 0x7f, 0x96,
	0xb2, 0xe5, 0x51, 0x24, 0x6d, 0x30, 0x55, 0x56, 0x3a, 0xe6, 0x63, 0x25, 0x32, 0xdd, 0x10, 0x59,
	0x13, 0x27, 0x86, 0x41, 0x4f, 0x5e, 0x86, 0x4a, 0x3c, 0x3a, 0xcf, 0x20, 0xcb, 0xc3, 0x48, 0x1a,
	0xd3, 0x94, 0x32, 0x1f, 0x91, 0x5c, 0x86, 0xca, 0xc0, 0xd1, 0xd4, 0xc0, 0x74, 0x6c, 0x1e, 0xee,
	0x94, 0x31, 0xa6, 0x29, 0xe3, 0x27, 0xf9, 0xef, 0x05, 0x58, 0x4f, 0x2d, 0x1f, 0xf3, 0xca, 0x47,
	0xe9, 0x74, 0x7a, 0x6d, 0x32, 0x96, 0xb3, 0x22, 0x73, 0xe6, 0x53, 0x72, 0x0e, 0x4a, 0x7d, 0xc7,
	0x0f, 0xf8, 0xa4, 0x2a, 0xc3, 0x48, 0xa2, 0x6d, 0x85, 0xfe, 0x36, 0x3e, 0x99, 0x91, 0x6d, 0xbf,
	0x25, 0x66, 0xdb, 0xda, 0xf6, 0xe6, 0x71, 0xf3, 0xa2, 0x59, 0x52, 0xc8, 0xc7, 0xbf, 0x2d, 0xc0,
	0x3a, 0x66, 0xa0, 0x3d, 0xd3, 0x0f, 0xda, 0x76, 0x52, 0x82, 0xad, 0xbc, 0x12, 0x6c, 0xe5, 0x96,
	0x60, 0x8c, 0x12, 0x5e, 0xb4, 0x17, 0xe6, 0x2f, 0xda, 0x77, 0x84, 0x3c, 0x30, 0x51, 0x84, 0xc7,
	0x45, 0x5b, 0x90, 0x1d, 0x04, 0xb7, 0xb7, 0x93, 0x22, 0x2e, 0x6f, 0x01, 0xc9, 0xcc, 0x1b, 0xb7,
	0xa8, 0xce, 0x52, 0x40, 0x3b, 0xf6, 0x50, 0x25, 0x6e, 0xca, 0x6f, 0xc1, 0x32, 0xf2, 0xd3, 0xdc,
	0xf8, 0x4c, 0x6b, 0x94, 0x7d, 0x58, 0x15, 0x34, 0xe0, 0x68, 0x2f, 0x02, 0xd0, 0xec, 0xc2, 0x32,
	0x33, 0xdb, 0x91, 0xaa, 0x1d, 0xf3, 0x90, 0x97, 0x60, 0xf9, 0xb1, 0xe7, 0x58, 0x1d, 0xd5, 0xd3,
	0xfa, 0xe6, 0x21, 0xc7, 0x26, 0x4a, 0x0d, 0x69, 0x4d, 0x46, 0x22, 0x12, 0xd0, 0x66, 0x47, 0xeb,
	0x1b, 0x86, 0xcf, 0x0d, 0xa1, 0x00, 0x92, 0x76, 0x29, 0x45, 0xfe, 0x08, 0x6a, 0x38, 0xe8, 0xbe,
	0xf9, 0xd4, 0xc0, 0x59, 0x3f, 0x9f, 0x01, 0x1b, 0xe3, 0x5c, 0x76, 0x43, 0x8c, 0xa5, 0xb9, 0x96,
	0xf3, 0x01, 0xac, 0x24, 0x9a, 0xf9, 0x6a, 0x02, 0x27, 0x50, 0x07, 0x1d, 0xdf, 0x7c, 0x6a, 0xc4,
	0xab, 0xa1, 0x14, 0xe4, 0xc1, 0xa9, 0xfa, 0xa6, 0xdd, 0x1b, 0x18, 0xac, 0x9f, 0x2d, 0x06, 0x18,
	0x09, 0x19, 0xe4, 0x37, 0xa0, 0xda, 0xb6, 0x7a, 0x4d, 0x9d, 0x42, 0x96, 0x86, 0x10, 0x6a, 0xb4,
	0x0c, 0x27, 0xc1, 0x85, 0x1e, 0x3c, 0x9e, 0x2b, 0x9b, 0xcb, 0x65, 0xa8, 0xc5, 0xa2, 0x38, 0x93,
	0xb3, 0xd9, 0x80, 0x1e, 0x87, 0xb0, 0xfc, 0x14, 0x96, 0xda, 0x56, 0x0f, 0x47, 0xb8, 0x33, 0x11,
	0xf5, 0x82, 0x03, 0xc5, 0x3d, 0x39, 0x28, 0x2e, 0x4e, 0x06, 0x5f, 0xdd, 0x62, 0x97, 0xa0, 0x42,
	0xc7, 0xc6, 0x29, 0x1e, 0xb3, 0x3e, 0xf9, 0xdf, 0x0b, 0x6c, 0xd3, 0xd0, 0x37, 0x71, 0xa6, 0x9b,
	0xa2, 0xab, 0x09, 0xe8, 0x0d, 0x75, 0xb2, 0xf0, 0xd9, 0x81, 0x05, 0xd7, 0xe6, 0x53, 0xb9, 0x32,
	0x8a, 0xa4, 0x4b, 0x8c, 0xc1, 0xb5, 0xe5, 0x4d, 0xdd, 0x78, 0xac, 0x86, 0x83, 0x60, 0x47, 0xbe,
	0x29, 0xce, 0xca, 0x32, 0xed, 0xdb, 0x37, 0x65, 0x65, 0xc1, 0xb5, 0x49, 0x0b, 0x16, 0x5c, 0x9f,
	0x87, 0x90, 0x90, 0x8f, 0x5d, 0x5f, 0x94, 0xbd, 0x31, 0x21, 0x7c, 0xd5, 0x52, 0x3f, 0xbf, 0xfd,
	0xcd, 0x1b, 0xa8, 0xc3, 0x27, 0xbb, 0x50, 0xa2, 0x81, 0x58, 0xda, 0x2c, 0x5c, 0x5e, 0xdd, 0xde,
	0xc8, 0x07, 0x29, 0xb8, 0x1c, 0x0c, 0xbd, 0xd6, 0xda, 0x28, 0x92, 0x6a, 0x6c, 0x14, 0x86, 0xac,
	0xa9, 0x30, 0x2e, 0x13, 0x73, 0xc0, 0x62, 0x76, 0x99, 0x0e, 0x5d, 0x66, 0x16, 0xa8, 0x2f, 0xcd,
	0x01, 0xd4, 0xb7, 0x10, 0xa8, 0x1b, 0x5e, 0x07, 0xad, 0x57, 0xce, 0xf2, 0xc7, 0x3d, 0x14, 0x98,
	0x1b, 0xde, 0x7b, 0xa6, 0x2e, 0xff, 0xa3, 0xc0, 0x7c, 0x9a, 0x19, 0x1e, 0xb7, 0xe9, 0x2e, 0x94,
	0x06, 0xa6, 0x1f, 0xf0, 0x8c, 0x7d, 0x2e, 0x7f, 0x61, 0xfb, 0xa6, 0xe5, 0x0e, 0x0c, 0x06, 0x2c,
	0x90, 0x5b, 0x04, 0x16, 0xd8, 0x26, 0x77, 0xa0, 0xe4, 0xaa, 0xbd, 0x38, 0xbf, 0x9e, 0xc9, 0xc9,
	0xaf, 0x6a, 0x8f, 0xcb, 0x23, 0x9f, 0x28, 0x8f, 0x6d, 0xf2, 0x00, 0x68, 0x56, 0x60, 0x81, 0x53,
	0xa4, 0x4a, 0x1a, 0xd3, 0xa6, 0xf2, 0xd4, 0x60, 0xe0, 0x6e, 0x2c, 0x20, 0x82, 0x3b, 0x9b, 0xb3,
	0xc8, 0x3f, 0x5f, 0x02, 0x48, 0xa6, 0xfe, 0xb5, 0x22, 0xde, 0x31, 0x84, 0x29, 0x26, 0xba, 0xa7,
	0x40, 0x98, 0xb7, 0xa0, 0xa8, 0x7a, 0x1a, 0xf5, 0xa2, 0xda, 0xf6, 0x0b, 0xb9, 0xa7, 0x0d, 0x6e,
	0x6b, 0x8a, 0xb6, 0x54, 0x4f, 0x13, 0xd1, 0x96, 0xea, 0x69, 0x22, 0x84, 0x5b, 0x9c, 0x07, 0xc2,
	0xdd, 0x82, 0x65, 0x35, 0xd4, 0xcd, 0x20, 0x0d, 0x73, 0xd7, 0x87, 0x91, 0x94, 0xa2, 0x2b, 0x35,
	0xda, 0xe2, 0x00, 0xf7, 0x02, 0x94, 0x3f, 0x33, 0xba, 0x9d, 0xd0, 0x1b, 0x70, 0x74, 0x4b, 0x4f,
	0x6c, 0x9c, 0xa4, 0x2c, 0x7d, 0x66, 0x74, 0x1f, 0x79, 0x03, 0xf2, 0x06, 0xd4, 0xf8, 0xb8, 0x1d,
	0x3f, 0xf0, 0x28, 0xaa, 0xad, 0xb6, 0xce, 0x0e, 0x23, 0xe9, 0xb4, 0x40, 0x16, 0x81, 0x30, 0x9b,
	0xd2, 0x7e, 0xe0, 0x8d, 0x01, 0x6b, 0x75, 0x06, 0x60, 0x4d, 0x43, 0x74, 0x98, 0x1f, 0xa2, 0x5f,
	0x87, 0xb2, 0x65, 0xf8, 0x3e, 0xfa, 0x64, 0x2d, 0xd9, 0x44, 0x4e, 0x12, 0x37, 0x91, 0x93, 0x50,
	0xc0, 0x0d, 0xbb, 0x74, 0x1b, 0x97, 0x13, 0x01, 0x4e, 0xca, 0x40, 0x4b, 0xba, 0x95, 0x1c, 0x1b,
	0xaf, 0x1c, 0x8b, 0x8d, 0xdf, 0x85, 0x53, 0x8f, 0xe9, 0xe1, 0xb1, 0x43, 0x4d, 0x62, 0xd8, 0x81,
	0xa7, 0xda, 0x1a, 0x03, 0xbb, 0x15, 0xb6, 0x92, 0xbc, 0x7e, 0x85, 0x30, 0x2a, 0x3a, 0xf0, 0x3d,
	0x4e, 0x23, 0x12, 0x2c, 0x0e, 0xcc, 0x03, 0xc3, 0xe7, 0xd8, 0xb7, 0x3a, 0x8c, 0x24, 0x46, 0x50,
	0xd8, 0x1f, 0xa2, 0x3c, 0x84, 0xb2, 0xd8, 0xe0, 0xf0, 0x96, 0x82, 0xb7, 0x98, 0xa6, 0x94, 0xfb,
	0xaa, 0xbf, 0x67, 0x1e, 0x18, 0xf2, 0x43, 0xa8, 0xc4, 0xa1, 0x84, 0x07, 0x51, 0x5a, 0xc1, 0x78,
	0x8e, 0x66, 0x0d, 0x42, 0xa0, 0x14, 0xfa, 0x06, 0xcb, 0xfd, 0x55, 0x85, 0x3e, 0x93, 0x0d, 0x00,
	0xd7, 0xf0, 0x34, 0xc3, 0x0e, 0xd0, 0xaa, 0xd4, 0xd7, 0x15, 0x81, 0x22, 0xff, 0x64, 0x01, 0xaa,
	0x63, 0xff, 0x25, 0x67, 0xc5, 0x4b, 0x8a, 0xf2, 0x30, 0x92, 0xb0, 0xc9, 0x92, 0xdc, 0x25, 0x28,
	0x75, 0x0f, 0x79, 0x61, 0xa9, 0xb2, 0xcd, 0xef, 0x66, 0x36, 0x1f, 0xdb, 0x68, 0x61, 0xd7, 0xd4,
	0x78, 0x54, 0x51, 0x0b, 0xbb, 0x66, 0x2a, 0x1e, 0x5c, 0x53, 0x43, 0x65, 0xba, 0xe1, 0xb3, 0x90,
	0xe2, 0xca, 0xb0, 0x2d, 0x2a, 0xc3, 0x36, 0x91, 0x61, 0x89, 0x7b, 0x11, 0x0b, 0x1b, 0x18, 0x46,
	0x12, 0xa7, 0x28, 0xfc, 0x1f, 0x0d, 0x98, 0xc9, 0xbe, 0xd4, 0x80, 0x31, 0x2d, 0x49, 0xbb, 0x67,
	0xa1, 0xa8, 0x8e, 0x33, 0x2e, 0x5d, 0x9c, 0x8a, 0x8b, 0x53, 0x4d, 0x5d, 0xfe, 0x21, 0x94, 0x30,
	0xd7, 0xe1, 0x6e, 0x25, 0x76, 0xe5, 0xbb, 0x45, 0x09, 0xb1, 0x89, 0xcf, 0x41, 0x29, 0x81, 0x09,
	0x0c, 0xd1, 0x62, 0x5b, 0xa1, 0xbf, 0x38, 0x82, 0x1d, 0x5a, 0xbc, 0x68, 0xd1, 0x11, 0xec, 0xd0,
	0x52, 0xf0, 0x47, 0xfe, 0x31, 0xab, 0x9d, 0xf1, 0xcd, 0xc0, 0x9b, 0xd9, 0xdb, 0x15, 0xe1, 0x9c,
	0xc0, 0x3b, 0x26, 0xab, 0xf5, 0xb3, 0x83, 0xa2, 0x5f, 0x94, 0x58, 0x05, 0xf9, 0xff, 0x65, 0x42,
	0xfa, 0x32, 0xe1, 0x99, 0xf2, 0x2c, 0xbf, 0x0f, 0x28, 0x1f, 0x7b, 0x1f, 0x90, 0xce, 0x81, 0x95,
	0x67, 0xbd, 0xa6, 0xa8, 0xce, 0x7f, 0x4d, 0xb1, 0x03, 0x35, 0x64, 0x39, 0x34, 0x3c, 0x1f, 0xd1,
	0x1b, 0x4b, 0xbb, 0x34, 0xb1, 0x0b, 0x64, 0xf1, 0x3c, 0xef, 0x86, 0xdd, 0x0f, 0x19, 0x55, 0xfe,
	0x53, 0x01, 0x56, 0x59, 0x0a, 0x40, 0x4b, 0xd3, 0x63, 0xf1, 0x1e, 0x54, 0xb8, 0x23, 0xc6, 0xa7,
	0xe2, 0x9b, 0xa3, 0x48, 0xba, 0x96, 0x72, 0xd1, 0x99, 0x87, 0xe2, 0xf8, 0x98, 0xf2, 0x6c, 0x67,
	0x62, 0xf2, 0x1d, 0x58, 0x08, 0x5c, 0xea, 0x43, 0xab, 0x79, 0xc7, 0xbf, 0x64, 0xc6, 0x14, 0xbf,
	0xad, 0x8c, 0x22, 0xa9, 0xca, 0xf1, 0x9b, 0x2b, 0x2b, 0x0b, 0x81, 0x2b, 0xff, 0x2b, 0xb5, 0xae,
	0x5d, 0xd5, 0xd3, 0xe7, 0xbc, 0xd7, 0x3c, 0x2b, 0x1e, 0xfc, 0xd2, 0x89, 0xf0, 0xe5, 0x89, 0x13,
	0xde, 0xf4, 0x7c, 0x83, 0x6b, 0x2e, 0x25, 0x3a, 0x2c, 0xd4, 0x81, 0x0b, 0xbb, 0x96, 0xf2, 0x0e,
	0x0e, 0x2d, 0x87, 0x91, 0x24, 0x50, 0x45, 0x9f, 0xb8, 0x96, 0xf2, 0x89, 0x25, 0xea, 0x13, 0x63,
	0x76, 0x46, 0x15, 0x3c, 0x41, 0xfe, 0xa2, 0x00, 0xeb, 0xa9, 0xdd, 0x9c, 0xef, 0x94, 0x9f, 0x15,
	0x99, 0xf7, 0xd6, 0xf4, 0xbf, 0x3f, 0xc7, 0xa7, 0xb7, 0x48, 0x3c, 0xc7, 0xff, 0xba, 0x00, 0x65,
	0x1e, 0xfc, 0x68, 0x4f, 0x2d, 0x5d, 0x9c, 0x34, 0xb4, 0xa7, 0x66, 0xea, 0x42, 0x9d, 0x58, 0x98,
	0x5a, 0x27, 0x24, 0x58, 0x34, 0x6d, 0xdd, 0xf8, 0x9c, 0x6f, 0x1a, 0xcd, 0xed, 0x94, 0xa0, 0xb0,
	0x3f, 0x72, 0x11, 0xca, 0xbe, 0xa1, 0x39, 0xb6, 0xee, 0xf3, 0x3d, 0xa3, 0x9e, 0xc1, 0x49, 0x4a,
	0xfc, 0x80, 0xd3, 0x70, 0x9d, 0x78, 0xd3, 0xe8, 0x34, 0x5c, 0xc7, 0x57, 0xf0, 0x47, 0x7e, 0x9f,
	0x97, 0xe8, 0x23, 0x5b, 0x9b, 0xd3, 0xcf, 0xce, 0x41, 0xa9, 0xaf, 0xfa, 0xfd, 0xd4, 0x0d, 0x89,
	0xea, 0xf7, 0x15, 0xfa, 0x2b, 0x7f, 0x0c, 0x27, 0x98, 0x69, 0x9a, 0x5e, 0x60, 0x6a, 0x03, 0x16,
	0x98, 0x77, 0x61, 0x11, 0x51, 0x56, 0x1c, 0x95, 0x5b, 0xa3, 0x48, 0xba, 0x92, 0xdc, 0x2a, 0xcf,
	0x0c, 0x49, 0x26, 0x2c, 0xff, 0xae, 0x90, 0xd1, 0x4d, 0x83, 0x43, 0x4a, 0x5d, 0x58, 0xa7, 0x66,
	0xcc, 0xa0, 0xdd, 0xd7, 0x1c, 0x17, 0x17, 0xb2, 0x38, 0x39, 0xcf, 0x68, 0xf2, 0x1f, 0x0b, 0x70,
	0x32, 0x6b, 0x17, 0x74, 0xf1, 0xef, 0xa5, 0x5d, 0xfc, 0xc6, 0x34, 0x47, 0x4b, 0x49, 0xcd, 0xeb,
	0xe5, 0xdf, 0x9f, 0xe1, 0xe5, 0x6f, 0xa4, 0xbd, 0xfc, 0xfc, 0x8c, 0xc1, 0xb3, 0x8e, 0xfe, 0x2b,
	0x86, 0xc3, 0x1e, 0xaa, 0xbd, 0xff, 0x89, 0x97, 0x45, 0xe4, 0x26, 0x54, 0x07, 0x4e, 0xcf, 0xb4,
	0x3b, 0xc9, 0x56, 0x9e, 0x1a, 0x45, 0xd2, 0x3a, 0x53, 0x30, 0xee, 0x92, 0x95, 0x0a, 0x7d, 0x7e,
	0xcf, 0xd4, 0xc9, 0xdb, 0x50, 0xf3, 0xc3, 0x2e, 0x9d, 0x48, 0xbc, 0xc1, 0x8b, 0xad, 0x4b, 0xa3,
	0x48, 0x92, 0x99, 0x90, 0xd0, 0x39, 0x39, 0x70, 0xd5, 0x0f, 0xbb, 0x38, 0xf1, 0xb6, 0x2e, 0xff,
	0x74, 0x01, 0x6a, 0xb1, 0xa9, 0x70, 0xdb, 0x2f, 0x1e, 0x1b, 0x69, 0xf1, 0x03, 0xf9, 0xc6, 0xcc,
	0x57, 0x55, 0xc9, 0x23, 0x79, 0x0d, 0x56, 0x02, 0xb5, 0xd7, 0xf1, 0xfb, 0xce, 0x67, 0x9d, 0xc0,
	0xf8, 0x3c, 0x10, 0xf1, 0x6c, 0xaa, 0x43, 0x49, 0x37, 0xc9, 0x4d, 0x76, 0xbc, 0xf2, 0x39, 0x12,
	0x61, 0x96, 0x59, 0x1b, 0x46, 0x92, 0x48, 0x56, 0xc4, 0x06, 0xd9, 0x81, 0x55, 0x35, 0x0c, 0x9c,
	0x8e, 0x1b, 0x0e, 0x06, 0xf4, 0xe2, 0x9d, 0xfb, 0x3e, 0x05, 0x3b, 0xe9, 0x1e, 0x25, 0xd3, 0x96,
	0x3b, 0x40, 0x9a, 0x61, 0xe0, 0x3c, 0x08, 0x07, 0x83, 0xa6, 0xa9, 0xef, 0x9a, 0x87, 0xf4, 0x96,
	0xaa, 0x0d, 0xa0, 0x9a, 0xfa, 0x43, 0x67, 0x77, 0x9c, 0x27, 0xaa, 0xad, 0x57, 0x46, 0x91, 0x74,
	0x71, 0xfc, 0x7a, 0x8d, 0xf7, 0xe5, 0xd7, 0x5e, 0x41, 0x58, 0x3e, 0x03, 0xa7, 0x26, 0x06, 0x70,
	0x07, 0x47, 0x72, 0x00, 0xeb, 0x4d, 0x4f, 0xa3, 0xc5, 0x42, 0xbc, 0x7b, 0xfc, 0x7a, 0xbd, 0x56,
	0xbe, 0x0f, 0x24, 0x33, 0x2a, 0x3a, 0x40, 0xc6, 0xe6, 0x85, 0xd9, 0x36, 0x97, 0x3f, 0x82, 0x46,
	0x4b, 0x0d, 0xb4, 0xfe, 0x7d, 0x83, 0xe9, 0x50, 0x0c, 0x5b, 0x37, 0xbc, 0x18, 0x9d, 0xef, 0xa4,
	0x53, 0xec, 0x85, 0x51, 0x24, 0x6d, 0xce, 0x48, 0xb1, 0xe3, 0xc4, 0xfa, 0xe7, 0xc2, 0x31, 0xaa,
	0xfd, 0x6c, 0x19, 0x7e, 0x6d, 0x32, 0x4d, 0x4c, 0x17, 0x16, 0x53, 0x15, 0x2b, 0x5f, 0xd8, 0x8e,
	0x13, 0x54, 0x67, 0x46, 0x82, 0x7a, 0x33, 0x9d, 0xa0, 0x2e, 0x4e, 0x8e, 0x9c, 0x19, 0x11, 0xb5,
	0x89, 0x29, 0xea, 0xf7, 0x05, 0x38, 0x99, 0xc3, 0x42, 0xeb, 0x26, 0x3f, 0x1f, 0x14, 0x92, 0x7b,
	0x07, 0x4e, 0x4a, 0x4e, 0x05, 0x32, 0x2c, 0xd1, 0x3b, 0x4a, 0xac, 0xd1, 0xe8, 0x90, 0xb4, 0x46,
	0x33, 0x8a, 0xc2, 0xff, 0x31, 0x46, 0xb5, 0x81, 0xa9, 0x1d, 0xd0, 0x4b, 0x8c, 0x62, 0x12, 0xa3,
	0x63, 0xa2, 0x92, 0x3c, 0x92, 0xdb, 0xb0, 0x36, 0x50, 0xfd, 0xa0, 0x43, 0x2f, 0x69, 0x58, 0x94,
	0x96, 0x92, 0xc3, 0x4c, 0xa6, 0x4b, 0xc9, 0x12, 0xe4, 0x6d, 0x20, 0xf7, 0x8d, 0xa0, 0x19, 0x04,
	0xaa, 0xd6, 0x37, 0x74, 0xc5, 0x65, 0xef, 0xa4, 0xcf, 0xa5, 0x2a, 0x20, 0x2d, 0xc8, 0x34, 0xf0,
	0xd8, 0xbb, 0xd9, 0x57, 0xe1, 0xd4, 0x84, 0x0c, 0x7a, 0xe0, 0x39, 0x28, 0x79, 0x6e, 0x5a, 0x0a,
	0xdb, 0x0a, 0xfd, 0xbd, 0x72, 0x9f, 0xdd, 0xd1, 0xc7, 0x17, 0x8d, 0x64, 0x19, 0x2a, 0x8f, 0xf6,
	0xef, 0x29, 0x9d, 0xe6, 0xde, 0xde, 0xfa, 0x73, 0x84, 0xc0, 0x2a, 0x6d, 0x3d, 0x78, 0xd4, 0xda,
	0x6b, 0xef, 0xbf, 0x73, 0xef, 0xee, 0x7a, 0x81, 0x9c, 0x86, 0x13, 0x4d, 0x65, 0xf7, 0x9d, 0xf6,
	0x87, 0xf7, 0x04, 0xf2, 0xc2, 0x95, 0x2b, 0x22, 0x9a, 0xa5, 0xaa, 0x6a, 0x50, 0xbe, 0x7b, 0xef,
	0xed, 0xe6, 0xa3, 0xbd, 0x87, 0xeb, 0xcf, 0x61, 0x83, 0x73, 0xaf, 0x17, 0xb6, 0xff, 0x59, 0x83,
	0xf2, 0x3b, 0x07, 0x01, 0x72, 0x92, 0x77, 0x85, 0xab, 0x83, 0x17, 0xa7, 0xdf, 0xd0, 0x29, 0xc6,
	0x93, 0x86, 0x74, 0x5c, 0x37, 0x2e, 0x95, 0xeb, 0xa2, 0x6f, 0xa8, 0xa6, 0xe8, 0xe2, 0x61, 0x34,
	0x4d, 0x57, 0x72, 0x08, 0xe5, 0xba, 0xd0, 0x30, 0xd3, 0x74, 0xf1, 0xcb, 0xe6, 0x69, 0xba, 0xc4,
	0x2b, 0xd1, 0x25, 0x76, 0xd7, 0x4e, 0x72, 0x6e, 0xe8, 0xc6, 0x17, 0xf8, 0x8d, 0x17, 0xa7, 0x77,
	0xa2, 0x96, 0x37, 0xa1, 0xd8, 0xb6, 0x7a, 0xa4, 0x9e, 0xcb, 0x85, 0xf2, 0x8d, 0x29, 0x3d, 0x28,
	0xfc, 0x1e, 0x54, 0xc7, 0x6f, 0x52, 0xc8, 0x94, 0xdb, 0xe6, 0x38, 0x59, 0x36, 0x36, 0x8f, 0xed,
	0x47, 0x75, 0x1f, 0x27, 0xb7, 0xbe, 0xf4, 0x55, 0x10, 0x91, 0xa7, 0xdb, 0x20, 0x7e, 0xc7, 0xd5,
	0xb8, 0x30, 0x93, 0x07, 0x55, 0xef, 0x43, 0x4d, 0x40, 0xfb, 0x64, 0x73, 0xc6, 0x61, 0xe0, 0x49,
	0x43, 0x9e, 0x7d, 0x5c, 0x20, 0x9f, 0xc6, 0xde, 0x19, 0xe3, 0x2b, 0x72, 0x7e, 0x36, 0x02, 0x7b,
	0xd2, 0xb8, 0x38, 0x17, 0x4c, 0xc3, 0x29, 0x0b, 0xaf, 0x21, 0xc9, 0xe6, 0x8c, 0xb7, 0x94, 0xb9,
	0x53, 0x9e, 0x78, 0xf5, 0xd9, 0x81, 0xb5, 0xcc, 0xa7, 0x16, 0xe4, 0xc2, 0x54, 0x31, 0xd1, 0xb5,
	0x2f, 0xcd, 0xc1, 0x85, 0x03, 0x3c, 0x00, 0x48, 0xbe, 0x45, 0x21, 0xd2, 0xf1, 0x5f, 0xaa, 0x3c,
	0x69, 0xbc, 0x34, 0xf3, 0x53, 0x16, 0xd2, 0x84, 0x45, 0xfa, 0x95, 0x0e, 0xc9, 0xf1, 0xc4, 0xf8,
	0x63, 0xa3, 0xc6, 0xb9, 0xa9, 0x7d, 0x3c, 0x54, 0x18, 0x7e, 0x22, 0xf9, 0x97, 0xd9, 0x0c, 0x84,
	0xe6, 0x85, 0x8a, 0x08, 0xbb, 0x3e, 0x85, 0xe5, 0x18, 0x19, 0x20, 0x54, 0xc8, 0x33, 0xdc, 0x24,
	0x34, 0xc9, 0x33, 0x5c, 0x1e, 0xbe, 0x40, 0xe7, 0x4f, 0x55, 0xfa, 0x3c, 0xe7, 0xcf, 0x02, 0x90,
	0x3c, 0xe7, 0xcf, 0x81, 0x0b, 0x21, 0x3c, 0x3f, 0xa5, 0xc6, 0x92, 0xab, 0x5f, 0xa1, 0x1c, 0x3f,
	0x69, 0x7c, 0x15, 0x6e, 0x1f, 0x7d, 0x2d, 0x53, 0x3b, 0xf2, 0x4c, 0x36, 0x59, 0x92, 0xf2, 0x4c,
	0x96, 0x57, 0x84, 0x5a, 0xa7, 0xbf, 0xf8, 0xdb, 0xc6, 0x73, 0x5f, 0x7c, 0xb9, 0x51, 0xf8, 0xc3,
	0x97, 0x1b, 0x85, 0xbf, 0x7e, 0xb9, 0x51, 0xf8, 0xa4, 0xa8, 0xba, 0x66, 0x77, 0x89, 0x7e, 0x8c,
	0x76, 0xeb, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x5b, 0x3c, 0x99, 0xda, 0x26, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HktNoteClient is the client API for HktNote service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HktNoteClient interface {
	NoteSize(ctx context.Context, in *NoteSizeReq, opts ...grpc.CallOption) (*NoteSizeReply, error)
	NoteInfo(ctx context.Context, in *NoteInfoReq, opts ...grpc.CallOption) (*NoteInfoReply, error)
	NoteList(ctx context.Context, in *NoteListReq, opts ...grpc.CallOption) (*NoteListReply, error)
	ImgAdd(ctx context.Context, in *ImgAddReq, opts ...grpc.CallOption) (*ImgAddReply, error)
	Img(ctx context.Context, in *ImgReq, opts ...grpc.CallOption) (*ImgReply, error)
	NoteCount(ctx context.Context, in *NoteCountReq, opts ...grpc.CallOption) (*NoteCountReply, error)
	NoteListInArc(ctx context.Context, in *NoteListInArcReq, opts ...grpc.CallOption) (*NoteListInArcReply, error)
	SimpleNotes(ctx context.Context, in *SimpleNotesReq, opts ...grpc.CallOption) (*SimpleNotesReply, error)
	SimpleArticles(ctx context.Context, in *SimpleArticlesReq, opts ...grpc.CallOption) (*SimpleArticlesReply, error)
	PublishImgs(ctx context.Context, in *PublishImgsReq, opts ...grpc.CallOption) (*PublishImgsReply, error)
	PublishNoteInfo(ctx context.Context, in *PublishNoteInfoReq, opts ...grpc.CallOption) (*PublishNoteInfoReply, error)
	// 稿件是否允许记笔记
	ArcsForbid(ctx context.Context, in *ArcsForbidReq, opts ...grpc.CallOption) (*ArcsForbidReply, error)
	// 稿件下是否有UP主笔记
	UpArc(ctx context.Context, in *UpArcReq, opts ...grpc.CallOption) (*UpArcReply, error)
	// 稿件播放页笔记tag
	ArcTag(ctx context.Context, in *ArcTagReq, opts ...grpc.CallOption) (*ArcTagReply, error)
	AutoPullCvid(ctx context.Context, in *AutoPullAidCivdReq, opts ...grpc.CallOption) (*AutoPullAidCivdReply, error)
	// 获取稿件下公开笔记个数
	ArcNotesCount(ctx context.Context, in *ArcNotesCountReq, opts ...grpc.CallOption) (*ArcNotesCountReply, error)
	// 评论区笔记图文展示数据
	BatchGetReplyRenderInfo(ctx context.Context, in *BatchGetReplyRenderInfoReq, opts ...grpc.CallOption) (*BatchGetReplyRenderInfoRes, error)
	// 根据根据专栏id获取评论id 返回值为0表示无对应评论id
	GetAttachedRpid(ctx context.Context, in *GetAttachedRpidReq, opts ...grpc.CallOption) (*GetAttachedRpidReply, error)
}

type hktNoteClient struct {
	cc *grpc.ClientConn
}

func NewHktNoteClient(cc *grpc.ClientConn) HktNoteClient {
	return &hktNoteClient{cc}
}

func (c *hktNoteClient) NoteSize(ctx context.Context, in *NoteSizeReq, opts ...grpc.CallOption) (*NoteSizeReply, error) {
	out := new(NoteSizeReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/NoteSize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) NoteInfo(ctx context.Context, in *NoteInfoReq, opts ...grpc.CallOption) (*NoteInfoReply, error) {
	out := new(NoteInfoReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/NoteInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) NoteList(ctx context.Context, in *NoteListReq, opts ...grpc.CallOption) (*NoteListReply, error) {
	out := new(NoteListReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/NoteList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) ImgAdd(ctx context.Context, in *ImgAddReq, opts ...grpc.CallOption) (*ImgAddReply, error) {
	out := new(ImgAddReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/ImgAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) Img(ctx context.Context, in *ImgReq, opts ...grpc.CallOption) (*ImgReply, error) {
	out := new(ImgReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/Img", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) NoteCount(ctx context.Context, in *NoteCountReq, opts ...grpc.CallOption) (*NoteCountReply, error) {
	out := new(NoteCountReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/NoteCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) NoteListInArc(ctx context.Context, in *NoteListInArcReq, opts ...grpc.CallOption) (*NoteListInArcReply, error) {
	out := new(NoteListInArcReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/NoteListInArc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) SimpleNotes(ctx context.Context, in *SimpleNotesReq, opts ...grpc.CallOption) (*SimpleNotesReply, error) {
	out := new(SimpleNotesReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/SimpleNotes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) SimpleArticles(ctx context.Context, in *SimpleArticlesReq, opts ...grpc.CallOption) (*SimpleArticlesReply, error) {
	out := new(SimpleArticlesReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/SimpleArticles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) PublishImgs(ctx context.Context, in *PublishImgsReq, opts ...grpc.CallOption) (*PublishImgsReply, error) {
	out := new(PublishImgsReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/PublishImgs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) PublishNoteInfo(ctx context.Context, in *PublishNoteInfoReq, opts ...grpc.CallOption) (*PublishNoteInfoReply, error) {
	out := new(PublishNoteInfoReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/PublishNoteInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) ArcsForbid(ctx context.Context, in *ArcsForbidReq, opts ...grpc.CallOption) (*ArcsForbidReply, error) {
	out := new(ArcsForbidReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/ArcsForbid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) UpArc(ctx context.Context, in *UpArcReq, opts ...grpc.CallOption) (*UpArcReply, error) {
	out := new(UpArcReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/UpArc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) ArcTag(ctx context.Context, in *ArcTagReq, opts ...grpc.CallOption) (*ArcTagReply, error) {
	out := new(ArcTagReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/ArcTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) AutoPullCvid(ctx context.Context, in *AutoPullAidCivdReq, opts ...grpc.CallOption) (*AutoPullAidCivdReply, error) {
	out := new(AutoPullAidCivdReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/AutoPullCvid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) ArcNotesCount(ctx context.Context, in *ArcNotesCountReq, opts ...grpc.CallOption) (*ArcNotesCountReply, error) {
	out := new(ArcNotesCountReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/ArcNotesCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) BatchGetReplyRenderInfo(ctx context.Context, in *BatchGetReplyRenderInfoReq, opts ...grpc.CallOption) (*BatchGetReplyRenderInfoRes, error) {
	out := new(BatchGetReplyRenderInfoRes)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/BatchGetReplyRenderInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hktNoteClient) GetAttachedRpid(ctx context.Context, in *GetAttachedRpidReq, opts ...grpc.CallOption) (*GetAttachedRpidReply, error) {
	out := new(GetAttachedRpidReply)
	err := c.cc.Invoke(ctx, "/hkt.node.service.HktNote/GetAttachedRpid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HktNoteServer is the server API for HktNote service.
type HktNoteServer interface {
	NoteSize(context.Context, *NoteSizeReq) (*NoteSizeReply, error)
	NoteInfo(context.Context, *NoteInfoReq) (*NoteInfoReply, error)
	NoteList(context.Context, *NoteListReq) (*NoteListReply, error)
	ImgAdd(context.Context, *ImgAddReq) (*ImgAddReply, error)
	Img(context.Context, *ImgReq) (*ImgReply, error)
	NoteCount(context.Context, *NoteCountReq) (*NoteCountReply, error)
	NoteListInArc(context.Context, *NoteListInArcReq) (*NoteListInArcReply, error)
	SimpleNotes(context.Context, *SimpleNotesReq) (*SimpleNotesReply, error)
	SimpleArticles(context.Context, *SimpleArticlesReq) (*SimpleArticlesReply, error)
	PublishImgs(context.Context, *PublishImgsReq) (*PublishImgsReply, error)
	PublishNoteInfo(context.Context, *PublishNoteInfoReq) (*PublishNoteInfoReply, error)
	// 稿件是否允许记笔记
	ArcsForbid(context.Context, *ArcsForbidReq) (*ArcsForbidReply, error)
	// 稿件下是否有UP主笔记
	UpArc(context.Context, *UpArcReq) (*UpArcReply, error)
	// 稿件播放页笔记tag
	ArcTag(context.Context, *ArcTagReq) (*ArcTagReply, error)
	AutoPullCvid(context.Context, *AutoPullAidCivdReq) (*AutoPullAidCivdReply, error)
	// 获取稿件下公开笔记个数
	ArcNotesCount(context.Context, *ArcNotesCountReq) (*ArcNotesCountReply, error)
	// 评论区笔记图文展示数据
	BatchGetReplyRenderInfo(context.Context, *BatchGetReplyRenderInfoReq) (*BatchGetReplyRenderInfoRes, error)
	// 根据根据专栏id获取评论id 返回值为0表示无对应评论id
	GetAttachedRpid(context.Context, *GetAttachedRpidReq) (*GetAttachedRpidReply, error)
}

// UnimplementedHktNoteServer can be embedded to have forward compatible implementations.
type UnimplementedHktNoteServer struct {
}

func (*UnimplementedHktNoteServer) NoteSize(ctx context.Context, req *NoteSizeReq) (*NoteSizeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoteSize not implemented")
}
func (*UnimplementedHktNoteServer) NoteInfo(ctx context.Context, req *NoteInfoReq) (*NoteInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoteInfo not implemented")
}
func (*UnimplementedHktNoteServer) NoteList(ctx context.Context, req *NoteListReq) (*NoteListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoteList not implemented")
}
func (*UnimplementedHktNoteServer) ImgAdd(ctx context.Context, req *ImgAddReq) (*ImgAddReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImgAdd not implemented")
}
func (*UnimplementedHktNoteServer) Img(ctx context.Context, req *ImgReq) (*ImgReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Img not implemented")
}
func (*UnimplementedHktNoteServer) NoteCount(ctx context.Context, req *NoteCountReq) (*NoteCountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoteCount not implemented")
}
func (*UnimplementedHktNoteServer) NoteListInArc(ctx context.Context, req *NoteListInArcReq) (*NoteListInArcReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoteListInArc not implemented")
}
func (*UnimplementedHktNoteServer) SimpleNotes(ctx context.Context, req *SimpleNotesReq) (*SimpleNotesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimpleNotes not implemented")
}
func (*UnimplementedHktNoteServer) SimpleArticles(ctx context.Context, req *SimpleArticlesReq) (*SimpleArticlesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimpleArticles not implemented")
}
func (*UnimplementedHktNoteServer) PublishImgs(ctx context.Context, req *PublishImgsReq) (*PublishImgsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishImgs not implemented")
}
func (*UnimplementedHktNoteServer) PublishNoteInfo(ctx context.Context, req *PublishNoteInfoReq) (*PublishNoteInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishNoteInfo not implemented")
}
func (*UnimplementedHktNoteServer) ArcsForbid(ctx context.Context, req *ArcsForbidReq) (*ArcsForbidReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcsForbid not implemented")
}
func (*UnimplementedHktNoteServer) UpArc(ctx context.Context, req *UpArcReq) (*UpArcReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpArc not implemented")
}
func (*UnimplementedHktNoteServer) ArcTag(ctx context.Context, req *ArcTagReq) (*ArcTagReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcTag not implemented")
}
func (*UnimplementedHktNoteServer) AutoPullCvid(ctx context.Context, req *AutoPullAidCivdReq) (*AutoPullAidCivdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutoPullCvid not implemented")
}
func (*UnimplementedHktNoteServer) ArcNotesCount(ctx context.Context, req *ArcNotesCountReq) (*ArcNotesCountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcNotesCount not implemented")
}
func (*UnimplementedHktNoteServer) BatchGetReplyRenderInfo(ctx context.Context, req *BatchGetReplyRenderInfoReq) (*BatchGetReplyRenderInfoRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetReplyRenderInfo not implemented")
}
func (*UnimplementedHktNoteServer) GetAttachedRpid(ctx context.Context, req *GetAttachedRpidReq) (*GetAttachedRpidReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttachedRpid not implemented")
}

func RegisterHktNoteServer(s *grpc.Server, srv HktNoteServer) {
	s.RegisterService(&_HktNote_serviceDesc, srv)
}

func _HktNote_NoteSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteSizeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).NoteSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/NoteSize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).NoteSize(ctx, req.(*NoteSizeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_NoteInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).NoteInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/NoteInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).NoteInfo(ctx, req.(*NoteInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_NoteList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).NoteList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/NoteList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).NoteList(ctx, req.(*NoteListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_ImgAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImgAddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).ImgAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/ImgAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).ImgAdd(ctx, req.(*ImgAddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_Img_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).Img(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/Img",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).Img(ctx, req.(*ImgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_NoteCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).NoteCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/NoteCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).NoteCount(ctx, req.(*NoteCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_NoteListInArc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteListInArcReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).NoteListInArc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/NoteListInArc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).NoteListInArc(ctx, req.(*NoteListInArcReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_SimpleNotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimpleNotesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).SimpleNotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/SimpleNotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).SimpleNotes(ctx, req.(*SimpleNotesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_SimpleArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimpleArticlesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).SimpleArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/SimpleArticles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).SimpleArticles(ctx, req.(*SimpleArticlesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_PublishImgs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishImgsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).PublishImgs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/PublishImgs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).PublishImgs(ctx, req.(*PublishImgsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_PublishNoteInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishNoteInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).PublishNoteInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/PublishNoteInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).PublishNoteInfo(ctx, req.(*PublishNoteInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_ArcsForbid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcsForbidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).ArcsForbid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/ArcsForbid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).ArcsForbid(ctx, req.(*ArcsForbidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_UpArc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpArcReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).UpArc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/UpArc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).UpArc(ctx, req.(*UpArcReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_ArcTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcTagReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).ArcTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/ArcTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).ArcTag(ctx, req.(*ArcTagReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_AutoPullCvid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoPullAidCivdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).AutoPullCvid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/AutoPullCvid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).AutoPullCvid(ctx, req.(*AutoPullAidCivdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_ArcNotesCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcNotesCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).ArcNotesCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/ArcNotesCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).ArcNotesCount(ctx, req.(*ArcNotesCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_BatchGetReplyRenderInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetReplyRenderInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).BatchGetReplyRenderInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/BatchGetReplyRenderInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).BatchGetReplyRenderInfo(ctx, req.(*BatchGetReplyRenderInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HktNote_GetAttachedRpid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttachedRpidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HktNoteServer).GetAttachedRpid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hkt.node.service.HktNote/GetAttachedRpid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HktNoteServer).GetAttachedRpid(ctx, req.(*GetAttachedRpidReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _HktNote_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hkt.node.service.HktNote",
	HandlerType: (*HktNoteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NoteSize",
			Handler:    _HktNote_NoteSize_Handler,
		},
		{
			MethodName: "NoteInfo",
			Handler:    _HktNote_NoteInfo_Handler,
		},
		{
			MethodName: "NoteList",
			Handler:    _HktNote_NoteList_Handler,
		},
		{
			MethodName: "ImgAdd",
			Handler:    _HktNote_ImgAdd_Handler,
		},
		{
			MethodName: "Img",
			Handler:    _HktNote_Img_Handler,
		},
		{
			MethodName: "NoteCount",
			Handler:    _HktNote_NoteCount_Handler,
		},
		{
			MethodName: "NoteListInArc",
			Handler:    _HktNote_NoteListInArc_Handler,
		},
		{
			MethodName: "SimpleNotes",
			Handler:    _HktNote_SimpleNotes_Handler,
		},
		{
			MethodName: "SimpleArticles",
			Handler:    _HktNote_SimpleArticles_Handler,
		},
		{
			MethodName: "PublishImgs",
			Handler:    _HktNote_PublishImgs_Handler,
		},
		{
			MethodName: "PublishNoteInfo",
			Handler:    _HktNote_PublishNoteInfo_Handler,
		},
		{
			MethodName: "ArcsForbid",
			Handler:    _HktNote_ArcsForbid_Handler,
		},
		{
			MethodName: "UpArc",
			Handler:    _HktNote_UpArc_Handler,
		},
		{
			MethodName: "ArcTag",
			Handler:    _HktNote_ArcTag_Handler,
		},
		{
			MethodName: "AutoPullCvid",
			Handler:    _HktNote_AutoPullCvid_Handler,
		},
		{
			MethodName: "ArcNotesCount",
			Handler:    _HktNote_ArcNotesCount_Handler,
		},
		{
			MethodName: "BatchGetReplyRenderInfo",
			Handler:    _HktNote_BatchGetReplyRenderInfo_Handler,
		},
		{
			MethodName: "GetAttachedRpid",
			Handler:    _HktNote_GetAttachedRpid_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *UpArcReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpArcReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpArcReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UpperId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UpperId))
		i--
		dAtA[i] = 0x18
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x10
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpArcReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpArcReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpArcReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JumpLink) > 0 {
		i -= len(m.JumpLink)
		copy(dAtA[i:], m.JumpLink)
		i = encodeVarintApi(dAtA, i, uint64(len(m.JumpLink)))
		i--
		dAtA[i] = 0x12
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcsForbidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsForbidReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsForbidReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Aids) > 0 {
		dAtA2 := make([]byte, len(m.Aids)*10)
		var j1 int
		for _, num1 := range m.Aids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArcsForbidReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsForbidReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsForbidReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PublishNoteInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishNoteInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishNoteInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cvid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cvid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PublishNoteInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishNoteInfoReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishNoteInfoReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasPubSuccessBefore {
		i--
		if m.HasPubSuccessBefore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PubTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PubTime))
		i--
		dAtA[i] = 0x78
	}
	if m.Mtime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x70
	}
	if m.ArcCvidCnt != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArcCvidCnt))
		i--
		dAtA[i] = 0x68
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x60
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x58
	}
	if m.Cvid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cvid))
		i--
		dAtA[i] = 0x50
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x48
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PubReason) > 0 {
		i -= len(m.PubReason)
		copy(dAtA[i:], m.PubReason)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PubReason)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PubStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PubStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.CidCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CidCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishImgsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishImgsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishImgsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ImageIds) > 0 {
		dAtA4 := make([]byte, len(m.ImageIds)*10)
		var j3 int
		for _, num1 := range m.ImageIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishImgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishImgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishImgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x12
	}
	if m.ImageId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ImageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PublishImgsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishImgsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishImgsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NoteListInArcReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteListInArcReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteListInArcReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x18
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteListInArcReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteListInArcReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteListInArcReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NoteIds) > 0 {
		dAtA7 := make([]byte, len(m.NoteIds)*10)
		var j6 int
		for _, num1 := range m.NoteIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintApi(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteCountReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteCountReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteCountReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FromCheese != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FromCheese))
		i--
		dAtA[i] = 0x18
	}
	if m.FromArchive != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FromArchive))
		i--
		dAtA[i] = 0x10
	}
	if m.NoteCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteSizeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteSizeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteSizeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteSizeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteSizeReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteSizeReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SingleSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SingleSize))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImgAddReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImgAddReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImgAddReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImgAddReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImgAddReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImgAddReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImageId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ImageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.ImageId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ImageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImgReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImgReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImgReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UperMid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UperMid))
		i--
		dAtA[i] = 0x38
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x30
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteListReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteListReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NoteSize != nil {
		{
			size, err := m.NoteSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NoteSimple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteSimple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteSimple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasLike {
		i--
		if m.HasLike {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Likes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Likes))
		i--
		dAtA[i] = 0x78
	}
	if m.ForbidNoteEntrance {
		i--
		if m.ForbidNoteEntrance {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Pubtime) > 0 {
		i -= len(m.Pubtime)
		copy(dAtA[i:], m.Pubtime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Pubtime)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PubStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PubStatus))
		i--
		dAtA[i] = 0x50
	}
	if m.Cvid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cvid))
		i--
		dAtA[i] = 0x48
	}
	if len(m.NoteIdStr) > 0 {
		i -= len(m.NoteIdStr)
		copy(dAtA[i:], m.NoteIdStr)
		i = encodeVarintApi(dAtA, i, uint64(len(m.NoteIdStr)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.WebUrl) > 0 {
		i -= len(m.WebUrl)
		copy(dAtA[i:], m.WebUrl)
		i = encodeVarintApi(dAtA, i, uint64(len(m.WebUrl)))
		i--
		dAtA[i] = 0x3a
	}
	if m.AuditStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AuditStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x28
	}
	if m.Arc != nil {
		{
			size, err := m.Arc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Mtime) > 0 {
		i -= len(m.Mtime)
		copy(dAtA[i:], m.Mtime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Mtime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Percentage) > 0 {
		i -= len(m.Percentage)
		copy(dAtA[i:], m.Percentage)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Percentage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Used) > 0 {
		i -= len(m.Used)
		copy(dAtA[i:], m.Used)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Used)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Total) > 0 {
		i -= len(m.Total)
		copy(dAtA[i:], m.Total)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Total)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArcSimple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcSimple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcSimple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x38
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Pic) > 0 {
		i -= len(m.Pic)
		copy(dAtA[i:], m.Pic)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Pic)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bvid) > 0 {
		i -= len(m.Bvid)
		copy(dAtA[i:], m.Bvid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Bvid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteInfoReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteInfoReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PubVersion != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PubVersion))
		i--
		dAtA[i] = 0x50
	}
	if len(m.PubReason) > 0 {
		i -= len(m.PubReason)
		copy(dAtA[i:], m.PubReason)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PubReason)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PubStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PubStatus))
		i--
		dAtA[i] = 0x40
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x38
	}
	if m.AuditStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AuditStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.CidCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CidCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleNotesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleNotesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleNotesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Tp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tp))
		i--
		dAtA[i] = 0x18
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NoteIds) > 0 {
		dAtA12 := make([]byte, len(m.NoteIds)*10)
		var j11 int
		for _, num1 := range m.NoteIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintApi(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleNoteCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleNoteCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleNoteCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PubReason) > 0 {
		i -= len(m.PubReason)
		copy(dAtA[i:], m.PubReason)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PubReason)))
		i--
		dAtA[i] = 0x32
	}
	if m.PubStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PubStatus))
		i--
		dAtA[i] = 0x28
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x20
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x18
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SimpleNotesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleNotesReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleNotesReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NoteTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x28
	}
	if m.Seconds != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x20
	}
	if m.Index != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Cid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteSync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteSync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteSync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SimpleArticlesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleArticlesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleArticlesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cvids) > 0 {
		dAtA15 := make([]byte, len(m.Cvids)*10)
		var j14 int
		for _, num1 := range m.Cvids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintApi(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleArticleCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleArticleCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleArticleCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x28
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x20
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x18
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.Cvid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cvid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SimpleArticlesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleArticlesReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleArticlesReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArcTagReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcTagReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcTagReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubTypeId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SubTypeId))
		i--
		dAtA[i] = 0x28
	}
	if m.LoginMid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LoginMid))
		i--
		dAtA[i] = 0x20
	}
	if m.UpperId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UpperId))
		i--
		dAtA[i] = 0x18
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x10
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcTagReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcTagReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcTagReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AutoPullCvid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AutoPullCvid))
		i--
		dAtA[i] = 0x28
	}
	if m.NotesCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NotesCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TagShowText) > 0 {
		i -= len(m.TagShowText)
		copy(dAtA[i:], m.TagShowText)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TagShowText)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JumpLink) > 0 {
		i -= len(m.JumpLink)
		copy(dAtA[i:], m.JumpLink)
		i = encodeVarintApi(dAtA, i, uint64(len(m.JumpLink)))
		i--
		dAtA[i] = 0x12
	}
	if m.NoteId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutoPullAidCivdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoPullAidCivdReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoPullAidCivdReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AidToCvids) > 0 {
		for iNdEx := len(m.AidToCvids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AidToCvids[iNdEx])
			copy(dAtA[i:], m.AidToCvids[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.AidToCvids[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AutoPullAidCivdReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoPullAidCivdReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoPullAidCivdReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ArcNotesCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcNotesCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcNotesCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OidType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OidType))
		i--
		dAtA[i] = 0x10
	}
	if m.Oid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcNotesCountReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcNotesCountReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcNotesCountReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NotesCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NotesCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchGetReplyRenderInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetReplyRenderInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchGetReplyRenderInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cvids) > 0 {
		dAtA18 := make([]byte, len(m.Cvids)*10)
		var j17 int
		for _, num1 := range m.Cvids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintApi(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchGetReplyRenderInfoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetReplyRenderInfoRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchGetReplyRenderInfoRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplyRenderInfoItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyRenderInfoItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyRenderInfoItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastMtimeText) > 0 {
		i -= len(m.LastMtimeText)
		copy(dAtA[i:], m.LastMtimeText)
		i = encodeVarintApi(dAtA, i, uint64(len(m.LastMtimeText)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClickUrl) > 0 {
		i -= len(m.ClickUrl)
		copy(dAtA[i:], m.ClickUrl)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ClickUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Images) > 0 {
		for iNdEx := len(m.Images) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Images[iNdEx])
			copy(dAtA[i:], m.Images[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Images[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAttachedRpidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAttachedRpidReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAttachedRpidReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cvid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cvid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetAttachedRpidReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAttachedRpidReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAttachedRpidReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rpid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rpid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UpArcReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.UpperId != 0 {
		n += 1 + sovApi(uint64(m.UpperId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpArcReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	l = len(m.JumpLink)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsForbidReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Aids) > 0 {
		l = 0
		for _, e := range m.Aids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsForbidReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishNoteInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cvid != 0 {
		n += 1 + sovApi(uint64(m.Cvid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishNoteInfoReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.CidCount != 0 {
		n += 1 + sovApi(uint64(m.CidCount))
	}
	if m.PubStatus != 0 {
		n += 1 + sovApi(uint64(m.PubStatus))
	}
	l = len(m.PubReason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.Cvid != 0 {
		n += 1 + sovApi(uint64(m.Cvid))
	}
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.ArcCvidCnt != 0 {
		n += 1 + sovApi(uint64(m.ArcCvidCnt))
	}
	if m.Mtime != 0 {
		n += 1 + sovApi(uint64(m.Mtime))
	}
	if m.PubTime != 0 {
		n += 1 + sovApi(uint64(m.PubTime))
	}
	if m.HasPubSuccessBefore {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishImgsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ImageIds) > 0 {
		l = 0
		for _, e := range m.ImageIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishImgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageId != 0 {
		n += 1 + sovApi(uint64(m.ImageId))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishImgsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteListInArcReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteListInArcReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NoteIds) > 0 {
		l = 0
		for _, e := range m.NoteIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteCountReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteCount != 0 {
		n += 1 + sovApi(uint64(m.NoteCount))
	}
	if m.FromArchive != 0 {
		n += 1 + sovApi(uint64(m.FromArchive))
	}
	if m.FromCheese != 0 {
		n += 1 + sovApi(uint64(m.FromCheese))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteSizeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteSizeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalSize != 0 {
		n += 1 + sovApi(uint64(m.TotalSize))
	}
	if m.SingleSize != 0 {
		n += 1 + sovApi(uint64(m.SingleSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImgAddReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImgAddReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageId != 0 {
		n += 1 + sovApi(uint64(m.ImageId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageId != 0 {
		n += 1 + sovApi(uint64(m.ImageId))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImgReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.UperMid != 0 {
		n += 1 + sovApi(uint64(m.UperMid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteListReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NoteSize != nil {
		l = m.NoteSize.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteSimple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Mtime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Arc != nil {
		l = m.Arc.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	if m.AuditStatus != 0 {
		n += 1 + sovApi(uint64(m.AuditStatus))
	}
	l = len(m.WebUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.NoteIdStr)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Cvid != 0 {
		n += 1 + sovApi(uint64(m.Cvid))
	}
	if m.PubStatus != 0 {
		n += 1 + sovApi(uint64(m.PubStatus))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Pubtime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.ForbidNoteEntrance {
		n += 2
	}
	if m.Likes != 0 {
		n += 1 + sovApi(uint64(m.Likes))
	}
	if m.HasLike {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Total)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Used)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Percentage)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcSimple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Bvid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Pic)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteInfoReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.CidCount != 0 {
		n += 1 + sovApi(uint64(m.CidCount))
	}
	if m.AuditStatus != 0 {
		n += 1 + sovApi(uint64(m.AuditStatus))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.PubStatus != 0 {
		n += 1 + sovApi(uint64(m.PubStatus))
	}
	l = len(m.PubReason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PubVersion != 0 {
		n += 1 + sovApi(uint64(m.PubVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleNotesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NoteIds) > 0 {
		l = 0
		for _, e := range m.NoteIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Tp != 0 {
		n += 1 + sovApi(uint64(m.Tp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleNoteCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.PubStatus != 0 {
		n += 1 + sovApi(uint64(m.PubStatus))
	}
	l = len(m.PubReason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleNotesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Index != 0 {
		n += 1 + sovApi(uint64(m.Index))
	}
	if m.Seconds != 0 {
		n += 1 + sovApi(uint64(m.Seconds))
	}
	if m.Pos != 0 {
		n += 1 + sovApi(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteSync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleArticlesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cvids) > 0 {
		l = 0
		for _, e := range m.Cvids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleArticleCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cvid != 0 {
		n += 1 + sovApi(uint64(m.Cvid))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleArticlesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcTagReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.UpperId != 0 {
		n += 1 + sovApi(uint64(m.UpperId))
	}
	if m.LoginMid != 0 {
		n += 1 + sovApi(uint64(m.LoginMid))
	}
	if m.SubTypeId != 0 {
		n += 1 + sovApi(uint64(m.SubTypeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcTagReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteId != 0 {
		n += 1 + sovApi(uint64(m.NoteId))
	}
	l = len(m.JumpLink)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.TagShowText)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NotesCount != 0 {
		n += 1 + sovApi(uint64(m.NotesCount))
	}
	if m.AutoPullCvid != 0 {
		n += 1 + sovApi(uint64(m.AutoPullCvid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoPullAidCivdReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AidToCvids) > 0 {
		for _, s := range m.AidToCvids {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoPullAidCivdReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcNotesCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.OidType != 0 {
		n += 1 + sovApi(uint64(m.OidType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcNotesCountReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotesCount != 0 {
		n += 1 + sovApi(uint64(m.NotesCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchGetReplyRenderInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cvids) > 0 {
		l = 0
		for _, e := range m.Cvids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchGetReplyRenderInfoRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplyRenderInfoItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.ClickUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.LastMtimeText)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAttachedRpidReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cvid != 0 {
		n += 1 + sovApi(uint64(m.Cvid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAttachedRpidReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rpid != 0 {
		n += 1 + sovApi(uint64(m.Rpid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpArcReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpArcReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpArcReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperId", wireType)
			}
			m.UpperId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpArcReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpArcReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpArcReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsForbidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsForbidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsForbidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aids = append(m.Aids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Aids) == 0 {
					m.Aids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aids = append(m.Aids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsForbidReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsForbidReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsForbidReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishNoteInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishNoteInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishNoteInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvid", wireType)
			}
			m.Cvid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cvid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishNoteInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishNoteInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishNoteInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &NoteTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidCount", wireType)
			}
			m.CidCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CidCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubStatus", wireType)
			}
			m.PubStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvid", wireType)
			}
			m.Cvid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cvid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArcCvidCnt", wireType)
			}
			m.ArcCvidCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArcCvidCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubTime", wireType)
			}
			m.PubTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPubSuccessBefore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPubSuccessBefore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishImgsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishImgsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishImgsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ImageIds = append(m.ImageIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ImageIds) == 0 {
					m.ImageIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ImageIds = append(m.ImageIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishImgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishImgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishImgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			m.ImageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishImgsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishImgsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishImgsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int64]*PublishImgInfo)
			}
			var mapkey int64
			var mapvalue *PublishImgInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PublishImgInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteListInArcReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteListInArcReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteListInArcReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteListInArcReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteListInArcReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteListInArcReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoteIds = append(m.NoteIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NoteIds) == 0 {
					m.NoteIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoteIds = append(m.NoteIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteCountReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteCountReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteCountReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteCount", wireType)
			}
			m.NoteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromArchive", wireType)
			}
			m.FromArchive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromArchive |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromCheese", wireType)
			}
			m.FromCheese = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromCheese |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteSizeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteSizeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteSizeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteSizeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteSizeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteSizeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleSize", wireType)
			}
			m.SingleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SingleSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImgAddReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImgAddReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImgAddReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImgAddReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImgAddReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImgAddReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			m.ImageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			m.ImageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImgReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImgReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImgReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NoteListType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UperMid", wireType)
			}
			m.UperMid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UperMid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &NoteSimple{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Page == nil {
				m.Page = &Page{}
			}
			if err := m.Page.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NoteSize == nil {
				m.NoteSize = &NoteSize{}
			}
			if err := m.NoteSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteSimple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteSimple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteSimple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arc == nil {
				m.Arc = &ArcSimple{}
			}
			if err := m.Arc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditStatus", wireType)
			}
			m.AuditStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuditStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteIdStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoteIdStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvid", wireType)
			}
			m.Cvid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cvid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubStatus", wireType)
			}
			m.PubStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbidNoteEntrance", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForbidNoteEntrance = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likes", wireType)
			}
			m.Likes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Likes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLike", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasLike = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Total = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Used = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Percentage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcSimple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcSimple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcSimple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bvid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bvid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &NoteTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidCount", wireType)
			}
			m.CidCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CidCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditStatus", wireType)
			}
			m.AuditStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuditStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubStatus", wireType)
			}
			m.PubStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubVersion", wireType)
			}
			m.PubVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleNotesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleNotesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleNotesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoteIds = append(m.NoteIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NoteIds) == 0 {
					m.NoteIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoteIds = append(m.NoteIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= SimpleNoteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleNoteCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleNoteCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleNoteCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubStatus", wireType)
			}
			m.PubStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleNotesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleNotesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleNotesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int64]*SimpleNoteCard)
			}
			var mapkey int64
			var mapvalue *SimpleNoteCard
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SimpleNoteCard{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteSync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteSync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteSync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleArticlesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleArticlesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleArticlesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cvids = append(m.Cvids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cvids) == 0 {
					m.Cvids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cvids = append(m.Cvids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleArticleCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleArticleCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleArticleCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvid", wireType)
			}
			m.Cvid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cvid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleArticlesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleArticlesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleArticlesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int64]*SimpleArticleCard)
			}
			var mapkey int64
			var mapvalue *SimpleArticleCard
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SimpleArticleCard{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcTagReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcTagReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcTagReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperId", wireType)
			}
			m.UpperId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginMid", wireType)
			}
			m.LoginMid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginMid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTypeId", wireType)
			}
			m.SubTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcTagReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcTagReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcTagReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			m.NoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagShowText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagShowText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotesCount", wireType)
			}
			m.NotesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotesCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoPullCvid", wireType)
			}
			m.AutoPullCvid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoPullCvid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoPullAidCivdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoPullAidCivdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoPullAidCivdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AidToCvids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AidToCvids = append(m.AidToCvids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoPullAidCivdReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoPullAidCivdReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoPullAidCivdReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcNotesCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcNotesCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcNotesCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidType", wireType)
			}
			m.OidType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OidType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcNotesCountReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcNotesCountReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcNotesCountReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotesCount", wireType)
			}
			m.NotesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotesCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetReplyRenderInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetReplyRenderInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetReplyRenderInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cvids = append(m.Cvids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cvids) == 0 {
					m.Cvids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cvids = append(m.Cvids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetReplyRenderInfoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetReplyRenderInfoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetReplyRenderInfoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int64]*ReplyRenderInfoItem)
			}
			var mapkey int64
			var mapvalue *ReplyRenderInfoItem
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReplyRenderInfoItem{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyRenderInfoItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyRenderInfoItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyRenderInfoItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClickUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClickUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMtimeText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastMtimeText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAttachedRpidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAttachedRpidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAttachedRpidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvid", wireType)
			}
			m.Cvid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cvid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAttachedRpidReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAttachedRpidReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAttachedRpidReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpid", wireType)
			}
			m.Rpid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rpid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
