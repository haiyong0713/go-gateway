// Code generated by kratos tool mcgen. DO NOT EDIT.

/*
  Package task is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=taskKey -struct_name=Dao
		CacheTask(c context.Context, id int64) (*task.Task, error)
		// mc: -key=taskKey -expire=d.mcTaskExpire -encode=pb -struct_name=Dao
		AddCacheTask(c context.Context, id int64, data *task.Task) error
		// mc: -key=taskKey -struct_name=Dao
		DelCacheTask(c context.Context, id int64) error
		// mc: -key=taskKey -struct_name=Dao
		CacheTasks(c context.Context, ids []int64) (map[int64]*task.Task, error)
		// mc: -key=taskKey -expire=d.mcTaskExpire -encode=pb -struct_name=Dao
		AddCacheTasks(c context.Context, data map[int64]*task.Task) error
		// mc: -key=taskIDsKey -struct_name=Dao
		CacheTaskIDs(c context.Context, businessID int64, foreignID int64) ([]int64, error)
		// mc: -key=taskIDsKey -expire=d.mcTaskExpire -struct_name=Dao
		AddCacheTaskIDs(c context.Context, businessID int64, taskIDs []int64, foreignID int64) error
		// mc: -key=taskIDsKey -struct_name=Dao
		DelCacheTaskIDs(c context.Context, businessID int64, foreignID int64) error
		// mc: -key=taskRuleKey -struct_name=Dao
		CacheTaskRule(c context.Context, taskID int64) (res *task.TaskRule, err error)
		// mc: -key=taskRuleKey -expire=d.mcTaskExpire -struct_name=Dao
		AddCacheTaskRule(c context.Context, taskID int64, val *task.TaskRule) error
	}
*/

package task

import (
	"context"
	"fmt"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-gateway/app/web-svr/activity/interface/model/task"
)

var _ _mc

// CacheTask get data from mc
func (d *Dao) CacheTask(c context.Context, id int64) (res *task.Task, err error) {
	key := taskKey(id)
	res = &task.Task{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheTask", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheTask Set data to mc
func (d *Dao) AddCacheTask(c context.Context, id int64, val *task.Task) (err error) {
	if val == nil {
		return
	}
	key := taskKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcTaskExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheTask", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheTask delete data from mc
func (d *Dao) DelCacheTask(c context.Context, id int64) (err error) {
	key := taskKey(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheTask", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheTasks get data from mc
func (d *Dao) CacheTasks(c context.Context, ids []int64) (res map[int64]*task.Task, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := taskKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	replies, err := d.mc.GetMulti(c, keys)
	if err != nil {
		log.Errorv(c, log.KV("CacheTasks", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for _, key := range replies.Keys() {
		v := &task.Task{}
		err = replies.Scan(key, v)
		if err != nil {
			log.Errorv(c, log.KV("CacheTasks", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*task.Task, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheTasks Set data to mc
func (d *Dao) AddCacheTasks(c context.Context, values map[int64]*task.Task) (err error) {
	if len(values) == 0 {
		return
	}
	for id, val := range values {
		key := taskKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcTaskExpire, Flags: memcache.FlagProtobuf}
		if err = d.mc.Set(c, item); err != nil {
			log.Errorv(c, log.KV("AddCacheTasks", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheTaskIDs get data from mc
func (d *Dao) CacheTaskIDs(c context.Context, id int64, foreignID int64) (res []int64, err error) {
	key := taskIDsKey(id, foreignID)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheTaskIDs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheTaskIDs Set data to mc
func (d *Dao) AddCacheTaskIDs(c context.Context, id int64, val []int64, foreignID int64) (err error) {
	if len(val) == 0 {
		return
	}
	key := taskIDsKey(id, foreignID)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcTaskExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheTaskIDs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheTaskIDs delete data from mc
func (d *Dao) DelCacheTaskIDs(c context.Context, id int64, foreignID int64) (err error) {
	key := taskIDsKey(id, foreignID)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheTaskIDs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheTaskRule get data from mc
func (d *Dao) CacheTaskRule(c context.Context, id int64) (res *task.TaskRule, err error) {
	key := taskRuleKey(id)
	res = &task.TaskRule{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheTaskRule", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheTaskRule Set data to mc
func (d *Dao) AddCacheTaskRule(c context.Context, id int64, val *task.TaskRule) (err error) {
	if val == nil {
		return
	}
	key := taskRuleKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcTaskExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheTaskRule", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
