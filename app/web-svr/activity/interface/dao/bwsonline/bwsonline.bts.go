// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package bwsonline is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// bts: -struct_name=Dao
		AwardPackageList(ctx context.Context, bid int64) ([]int64, error)
		// bts: -struct_name=Dao
		AwardPackage(ctx context.Context, id int64) (*bwsonline.AwardPackage, error)
		// bts: -struct_name=Dao
		AwardPackageByIDs(ctx context.Context, ids []int64) (map[int64]*bwsonline.AwardPackage, error)
		// bts: -struct_name=Dao
		Award(ctx context.Context, id int64) (*bwsonline.Award, error)
		// bts: -struct_name=Dao
		AwardByIDs(ctx context.Context, ids []int64) (map[int64]*bwsonline.Award, error)
		// bts: -struct_name=Dao -nullcache=[]*bwsonline.AwardPackage{{ID:-1}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].ID==-1
		UserPackage(ctx context.Context, mid int64) ([]*bwsonline.AwardPackage, error)
		// bts: -struct_name=Dao -nullcache=[]*bwsonline.UserAward{{Award:&bwsonline.Award{ID:-1}}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].Award!=nil&&$[0].Award.ID==-1
		UserAward(ctx context.Context, mid int64, bid int64) ([]*bwsonline.UserAward, error)
		// bts: -struct_name=Dao -nullcache=map[int64]int64{-1:-1} -check_null_code=len($)==1&&$[-1]==-1
		UserCurrency(ctx context.Context, mid int64, bid int64) (map[int64]int64, error)
		// bts: -struct_name=Dao
		Dress(ctx context.Context, id int64) (*bwsonline.Dress, error)
		// bts: -struct_name=Dao
		DressByIDs(ctx context.Context, ids []int64) (map[int64]*bwsonline.Dress, error)
		// bts: -struct_name=Dao -nullcache=[]*bwsonline.UserDress{{ID:-1}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].ID==-1
		UserDress(ctx context.Context, mid int64) ([]*bwsonline.UserDress, error)
		// bts: -struct_name=Dao
		Piece(ctx context.Context, id int64) (*bwsonline.Piece, error)
		// bts: -struct_name=Dao -nullcache=[]*bwsonline.UserPiece{{Pid:-1}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].Pid==-1
		UserPiece(ctx context.Context, mid int64, bid int64) ([]*bwsonline.UserPiece, error)
		// bts: -struct_name=Dao
		PrintList(ctx context.Context, bid int64) ([]int64, error)
		// bts: -struct_name=Dao
		Print(ctx context.Context, id int64) (*bwsonline.Print, error)
		// bts: -struct_name=Dao
		PrintByIDs(ctx context.Context, ids []int64) (map[int64]*bwsonline.Print, error)
		// bts: -struct_name=Dao -nullcache=map[int64]string{-1:"-1"} -check_null_code=len($)==1&&$[-1]=="-1"
		UserPrint(ctx context.Context, mid int64) (map[int64]string, error)
		// bts: -struct_name=Dao
		PieceUsedLog(ctx context.Context, mid int64, batchIDs []string) (map[string]map[int64]int64, error)
		// bts: -struct_name=Dao -nullcache=-1 -check_null_code=$==-1
		LastAutoEnergy(ctx context.Context, mid int64, bid int64) (int64, error)
	}
*/

package bwsonline

import (
	"context"

	"go-common/library/cache"
	"go-gateway/app/web-svr/activity/interface/model/bwsonline"
)

var _ _bts

// AwardPackageList get data from cache if miss will call source method, then add to cache.
func (d *Dao) AwardPackageList(c context.Context, bid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheAwardPackageList(c, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:AwardPackageList")
		return
	}
	cache.MetricMisses.Inc("bts:AwardPackageList")
	res, err = d.RawAwardPackageList(c, bid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheAwardPackageList(c, bid, miss)
	})
	return
}

// AwardPackage get data from cache if miss will call source method, then add to cache.
func (d *Dao) AwardPackage(c context.Context, id int64) (res *bwsonline.AwardPackage, err error) {
	addCache := true
	res, err = d.CacheAwardPackage(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:AwardPackage")
		return
	}
	cache.MetricMisses.Inc("bts:AwardPackage")
	res, err = d.RawAwardPackage(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheAwardPackage(c, id, miss)
	})
	return
}

// AwardPackageByIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) AwardPackageByIDs(c context.Context, ids []int64) (res map[int64]*bwsonline.AwardPackage, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheAwardPackageByIDs(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:AwardPackageByIDs")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsonline.AwardPackage
	cache.MetricMisses.Add(float64(len(miss)), "bts:AwardPackageByIDs")
	missData, err = d.RawAwardPackageByIDs(c, miss)
	if res == nil {
		res = make(map[int64]*bwsonline.AwardPackage, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheAwardPackageByIDs(c, missData)
	})
	return
}

// Award get data from cache if miss will call source method, then add to cache.
func (d *Dao) Award(c context.Context, id int64) (res *bwsonline.Award, err error) {
	addCache := true
	res, err = d.CacheAward(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:Award")
		return
	}
	cache.MetricMisses.Inc("bts:Award")
	res, err = d.RawAward(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheAward(c, id, miss)
	})
	return
}

// AwardByIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) AwardByIDs(c context.Context, ids []int64) (res map[int64]*bwsonline.Award, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheAwardByIDs(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:AwardByIDs")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsonline.Award
	cache.MetricMisses.Add(float64(len(miss)), "bts:AwardByIDs")
	missData, err = d.RawAwardByIDs(c, miss)
	if res == nil {
		res = make(map[int64]*bwsonline.Award, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheAwardByIDs(c, missData)
	})
	return
}

// UserPackage get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserPackage(c context.Context, mid int64) (res []*bwsonline.AwardPackage, err error) {
	addCache := true
	res, err = d.CacheUserPackage(c, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] != nil && res[0].ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserPackage")
		return
	}
	cache.MetricMisses.Inc("bts:UserPackage")
	res, err = d.RawUserPackage(c, mid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*bwsonline.AwardPackage{{ID: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserPackage(c, mid, miss)
	})
	return
}

// UserAward get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserAward(c context.Context, mid int64, bid int64) (res []*bwsonline.UserAward, err error) {
	addCache := true
	res, err = d.CacheUserAward(c, mid, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] != nil && res[0].Award != nil && res[0].Award.ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserAward")
		return
	}
	cache.MetricMisses.Inc("bts:UserAward")
	res, err = d.RawUserAward(c, mid, bid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*bwsonline.UserAward{{Award: &bwsonline.Award{ID: -1}}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserAward(c, mid, miss, bid)
	})
	return
}

// UserCurrency get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserCurrency(c context.Context, mid int64, bid int64) (res map[int64]int64, err error) {
	addCache := true
	res, err = d.CacheUserCurrency(c, mid, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[-1] == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserCurrency")
		return
	}
	cache.MetricMisses.Inc("bts:UserCurrency")
	res, err = d.RawUserCurrency(c, mid, bid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = map[int64]int64{-1: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserCurrency(c, mid, miss, bid)
	})
	return
}

// Dress get data from cache if miss will call source method, then add to cache.
func (d *Dao) Dress(c context.Context, id int64) (res *bwsonline.Dress, err error) {
	addCache := true
	res, err = d.CacheDress(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:Dress")
		return
	}
	cache.MetricMisses.Inc("bts:Dress")
	res, err = d.RawDress(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheDress(c, id, miss)
	})
	return
}

// DressByIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) DressByIDs(c context.Context, ids []int64) (res map[int64]*bwsonline.Dress, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheDressByIDs(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:DressByIDs")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsonline.Dress
	cache.MetricMisses.Add(float64(len(miss)), "bts:DressByIDs")
	missData, err = d.RawDressByIDs(c, miss)
	if res == nil {
		res = make(map[int64]*bwsonline.Dress, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheDressByIDs(c, missData)
	})
	return
}

// UserDress get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserDress(c context.Context, mid int64) (res []*bwsonline.UserDress, err error) {
	addCache := true
	res, err = d.CacheUserDress(c, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] != nil && res[0].ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserDress")
		return
	}
	cache.MetricMisses.Inc("bts:UserDress")
	res, err = d.RawUserDress(c, mid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*bwsonline.UserDress{{ID: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserDress(c, mid, miss)
	})
	return
}

// Piece get data from cache if miss will call source method, then add to cache.
func (d *Dao) Piece(c context.Context, id int64) (res *bwsonline.Piece, err error) {
	addCache := true
	res, err = d.CachePiece(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:Piece")
		return
	}
	cache.MetricMisses.Inc("bts:Piece")
	res, err = d.RawPiece(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCachePiece(c, id, miss)
	})
	return
}

// UserPiece get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserPiece(c context.Context, mid int64, bid int64) (res []*bwsonline.UserPiece, err error) {
	addCache := true
	res, err = d.CacheUserPiece(c, mid, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] != nil && res[0].Pid == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserPiece")
		return
	}
	cache.MetricMisses.Inc("bts:UserPiece")
	res, err = d.RawUserPiece(c, mid, bid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*bwsonline.UserPiece{{Pid: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserPiece(c, mid, miss, bid)
	})
	return
}

// PrintList get data from cache if miss will call source method, then add to cache.
func (d *Dao) PrintList(c context.Context, bid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CachePrintList(c, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:PrintList")
		return
	}
	cache.MetricMisses.Inc("bts:PrintList")
	res, err = d.RawPrintList(c, bid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCachePrintList(c, bid, miss)
	})
	return
}

// Print get data from cache if miss will call source method, then add to cache.
func (d *Dao) Print(c context.Context, id int64) (res *bwsonline.Print, err error) {
	addCache := true
	res, err = d.CachePrint(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:Print")
		return
	}
	cache.MetricMisses.Inc("bts:Print")
	res, err = d.RawPrint(c, id)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCachePrint(c, id, miss)
	})
	return
}

// PrintByIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) PrintByIDs(c context.Context, ids []int64) (res map[int64]*bwsonline.Print, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CachePrintByIDs(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:PrintByIDs")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsonline.Print
	cache.MetricMisses.Add(float64(len(miss)), "bts:PrintByIDs")
	missData, err = d.RawPrintByIDs(c, miss)
	if res == nil {
		res = make(map[int64]*bwsonline.Print, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCachePrintByIDs(c, missData)
	})
	return
}

// UserPrint get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserPrint(c context.Context, mid int64) (res map[int64]string, err error) {
	addCache := true
	res, err = d.CacheUserPrint(c, mid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[-1] == "-1" {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserPrint")
		return
	}
	cache.MetricMisses.Inc("bts:UserPrint")
	res, err = d.RawUserPrint(c, mid)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = map[int64]string{-1: "-1"}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserPrint(c, mid, miss)
	})
	return
}

// PieceUsedLog get data from cache if miss will call source method, then add to cache.
func (d *Dao) PieceUsedLog(c context.Context, mid int64, batchIDs []string) (res map[string]map[int64]int64, err error) {
	addCache := true
	res, err = d.CachePieceUsedLog(c, mid, batchIDs)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:PieceUsedLog")
		return
	}
	cache.MetricMisses.Inc("bts:PieceUsedLog")
	res, err = d.RawPieceUsedLog(c, mid, batchIDs)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCachePieceUsedLog(c, mid, miss, batchIDs)
	})
	return
}

// LastAutoEnergy get data from cache if miss will call source method, then add to cache.
func (d *Dao) LastAutoEnergy(c context.Context, mid int64, bid int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheLastAutoEnergy(c, mid, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:LastAutoEnergy")
		return
	}
	cache.MetricMisses.Inc("bts:LastAutoEnergy")
	res, err = d.RawLastAutoEnergy(c, mid, bid)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheLastAutoEnergy(c, mid, miss, bid)
	})
	return
}
