// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package search

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// --------------------------- 请求和返回的定义 ----------------------------
type BatchOptWebReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid" form:"uid"`
	Uname                string   `protobuf:"bytes,2,opt,name=uname,proto3" json:"uname" form:"uname"`
	Ids                  []int64  `protobuf:"varint,3,rep,packed,name=ids,proto3" json:"ids" form:"ids,split" validate:"required"`
	Option               string   `protobuf:"bytes,4,opt,name=option,proto3" json:"option" form:"option" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchOptWebReq) Reset()         { *m = BatchOptWebReq{} }
func (m *BatchOptWebReq) String() string { return proto.CompactTextString(m) }
func (*BatchOptWebReq) ProtoMessage()    {}
func (*BatchOptWebReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *BatchOptWebReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchOptWebReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchOptWebReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchOptWebReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchOptWebReq.Merge(m, src)
}
func (m *BatchOptWebReq) XXX_Size() int {
	return m.Size()
}
func (m *BatchOptWebReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchOptWebReq.DiscardUnknown(m)
}

var xxx_messageInfo_BatchOptWebReq proto.InternalMessageInfo

func (m *BatchOptWebReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *BatchOptWebReq) GetUname() string {
	if m != nil {
		return m.Uname
	}
	return ""
}

func (m *BatchOptWebReq) GetIds() []int64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *BatchOptWebReq) GetOption() string {
	if m != nil {
		return m.Option
	}
	return ""
}

type BatchOptWebResp struct {
	InvalidIds           []*BatchInvalidItem `protobuf:"bytes,1,rep,name=invalid_ids,json=invalidIds,proto3" json:"invalid_ids"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BatchOptWebResp) Reset()         { *m = BatchOptWebResp{} }
func (m *BatchOptWebResp) String() string { return proto.CompactTextString(m) }
func (*BatchOptWebResp) ProtoMessage()    {}
func (*BatchOptWebResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *BatchOptWebResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchOptWebResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchOptWebResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchOptWebResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchOptWebResp.Merge(m, src)
}
func (m *BatchOptWebResp) XXX_Size() int {
	return m.Size()
}
func (m *BatchOptWebResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchOptWebResp.DiscardUnknown(m)
}

var xxx_messageInfo_BatchOptWebResp proto.InternalMessageInfo

func (m *BatchOptWebResp) GetInvalidIds() []*BatchInvalidItem {
	if m != nil {
		return m.InvalidIds
	}
	return nil
}

type BatchOptResultSpreadReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid" form:"uid"`
	Uname                string   `protobuf:"bytes,2,opt,name=uname,proto3" json:"uname" form:"uname"`
	SpreadIds            []int64  `protobuf:"varint,3,rep,packed,name=spread_ids,proto3" json:"spread_ids" form:"spread_ids,split" validate:"required"`
	Option               string   `protobuf:"bytes,4,opt,name=option,proto3" json:"option" form:"option" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchOptResultSpreadReq) Reset()         { *m = BatchOptResultSpreadReq{} }
func (m *BatchOptResultSpreadReq) String() string { return proto.CompactTextString(m) }
func (*BatchOptResultSpreadReq) ProtoMessage()    {}
func (*BatchOptResultSpreadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *BatchOptResultSpreadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchOptResultSpreadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchOptResultSpreadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchOptResultSpreadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchOptResultSpreadReq.Merge(m, src)
}
func (m *BatchOptResultSpreadReq) XXX_Size() int {
	return m.Size()
}
func (m *BatchOptResultSpreadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchOptResultSpreadReq.DiscardUnknown(m)
}

var xxx_messageInfo_BatchOptResultSpreadReq proto.InternalMessageInfo

func (m *BatchOptResultSpreadReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *BatchOptResultSpreadReq) GetUname() string {
	if m != nil {
		return m.Uname
	}
	return ""
}

func (m *BatchOptResultSpreadReq) GetSpreadIds() []int64 {
	if m != nil {
		return m.SpreadIds
	}
	return nil
}

func (m *BatchOptResultSpreadReq) GetOption() string {
	if m != nil {
		return m.Option
	}
	return ""
}

type BatchOptResultSpreadResp struct {
	InvalidIds           []*BatchInvalidItem `protobuf:"bytes,1,rep,name=invalid_ids,json=invalidIds,proto3" json:"invalid_ids"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BatchOptResultSpreadResp) Reset()         { *m = BatchOptResultSpreadResp{} }
func (m *BatchOptResultSpreadResp) String() string { return proto.CompactTextString(m) }
func (*BatchOptResultSpreadResp) ProtoMessage()    {}
func (*BatchOptResultSpreadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *BatchOptResultSpreadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchOptResultSpreadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchOptResultSpreadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchOptResultSpreadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchOptResultSpreadResp.Merge(m, src)
}
func (m *BatchOptResultSpreadResp) XXX_Size() int {
	return m.Size()
}
func (m *BatchOptResultSpreadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchOptResultSpreadResp.DiscardUnknown(m)
}

var xxx_messageInfo_BatchOptResultSpreadResp proto.InternalMessageInfo

func (m *BatchOptResultSpreadResp) GetInvalidIds() []*BatchInvalidItem {
	if m != nil {
		return m.InvalidIds
	}
	return nil
}

type BatchInvalidItem struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchInvalidItem) Reset()         { *m = BatchInvalidItem{} }
func (m *BatchInvalidItem) String() string { return proto.CompactTextString(m) }
func (*BatchInvalidItem) ProtoMessage()    {}
func (*BatchInvalidItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *BatchInvalidItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchInvalidItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchInvalidItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchInvalidItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchInvalidItem.Merge(m, src)
}
func (m *BatchInvalidItem) XXX_Size() int {
	return m.Size()
}
func (m *BatchInvalidItem) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchInvalidItem.DiscardUnknown(m)
}

var xxx_messageInfo_BatchInvalidItem proto.InternalMessageInfo

func (m *BatchInvalidItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BatchInvalidItem) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type AddUpAliasReq struct {
	// 用户mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// 用户昵称
	Nickname string `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	// 搜索词
	SearchWords string `protobuf:"bytes,3,opt,name=search_words,json=searchWords,proto3" json:"search_words"`
	// 生效开始时间
	Stime int64 `protobuf:"varint,4,opt,name=stime,proto3" json:"stime,omitempty"`
	// 生效结束时间
	Etime int64 `protobuf:"varint,5,opt,name=etime,proto3" json:"etime,omitempty"`
	// 是否永久
	IsForever int32 `protobuf:"varint,6,opt,name=is_forever,json=isForever,proto3" json:"is_forever"`
	// 申请人
	Applier              string   `protobuf:"bytes,7,opt,name=applier,proto3" json:"applier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddUpAliasReq) Reset()         { *m = AddUpAliasReq{} }
func (m *AddUpAliasReq) String() string { return proto.CompactTextString(m) }
func (*AddUpAliasReq) ProtoMessage()    {}
func (*AddUpAliasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *AddUpAliasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddUpAliasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddUpAliasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddUpAliasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUpAliasReq.Merge(m, src)
}
func (m *AddUpAliasReq) XXX_Size() int {
	return m.Size()
}
func (m *AddUpAliasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUpAliasReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddUpAliasReq proto.InternalMessageInfo

func (m *AddUpAliasReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *AddUpAliasReq) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *AddUpAliasReq) GetSearchWords() string {
	if m != nil {
		return m.SearchWords
	}
	return ""
}

func (m *AddUpAliasReq) GetStime() int64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

func (m *AddUpAliasReq) GetEtime() int64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *AddUpAliasReq) GetIsForever() int32 {
	if m != nil {
		return m.IsForever
	}
	return 0
}

func (m *AddUpAliasReq) GetApplier() string {
	if m != nil {
		return m.Applier
	}
	return ""
}

type EditUpAliasReq struct {
	// 记录id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 用户mid
	Mid int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	// 用户昵称
	Nickname string `protobuf:"bytes,3,opt,name=nickname,proto3" json:"nickname,omitempty"`
	// 搜索词
	SearchWords string `protobuf:"bytes,4,opt,name=search_words,json=searchWords,proto3" json:"search_words"`
	// 生效开始时间
	Stime int64 `protobuf:"varint,5,opt,name=stime,proto3" json:"stime,omitempty"`
	// 生效结束时间
	Etime int64 `protobuf:"varint,6,opt,name=etime,proto3" json:"etime,omitempty"`
	// 是否永久
	IsForever int32 `protobuf:"varint,7,opt,name=is_forever,json=isForever,proto3" json:"is_forever"`
	// 申请人
	Applier              string   `protobuf:"bytes,8,opt,name=applier,proto3" json:"applier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EditUpAliasReq) Reset()         { *m = EditUpAliasReq{} }
func (m *EditUpAliasReq) String() string { return proto.CompactTextString(m) }
func (*EditUpAliasReq) ProtoMessage()    {}
func (*EditUpAliasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *EditUpAliasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditUpAliasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditUpAliasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditUpAliasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditUpAliasReq.Merge(m, src)
}
func (m *EditUpAliasReq) XXX_Size() int {
	return m.Size()
}
func (m *EditUpAliasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EditUpAliasReq.DiscardUnknown(m)
}

var xxx_messageInfo_EditUpAliasReq proto.InternalMessageInfo

func (m *EditUpAliasReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EditUpAliasReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *EditUpAliasReq) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *EditUpAliasReq) GetSearchWords() string {
	if m != nil {
		return m.SearchWords
	}
	return ""
}

func (m *EditUpAliasReq) GetStime() int64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

func (m *EditUpAliasReq) GetEtime() int64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *EditUpAliasReq) GetIsForever() int32 {
	if m != nil {
		return m.IsForever
	}
	return 0
}

func (m *EditUpAliasReq) GetApplier() string {
	if m != nil {
		return m.Applier
	}
	return ""
}

type ToggleUpAliasReq struct {
	// 记录id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 是否在线
	State                int32    `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ToggleUpAliasReq) Reset()         { *m = ToggleUpAliasReq{} }
func (m *ToggleUpAliasReq) String() string { return proto.CompactTextString(m) }
func (*ToggleUpAliasReq) ProtoMessage()    {}
func (*ToggleUpAliasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *ToggleUpAliasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToggleUpAliasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToggleUpAliasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToggleUpAliasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToggleUpAliasReq.Merge(m, src)
}
func (m *ToggleUpAliasReq) XXX_Size() int {
	return m.Size()
}
func (m *ToggleUpAliasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ToggleUpAliasReq.DiscardUnknown(m)
}

var xxx_messageInfo_ToggleUpAliasReq proto.InternalMessageInfo

func (m *ToggleUpAliasReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ToggleUpAliasReq) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

type SearchUpAliasReq struct {
	// 分页大小
	Ps int32 `protobuf:"varint,1,opt,name=ps,proto3" json:"ps,omitempty" form:"ps"`
	// 页码
	Pn int32 `protobuf:"varint,2,opt,name=pn,proto3" json:"pn,omitempty" form:"pn"`
	// 用户mid
	Mid int64 `protobuf:"varint,3,opt,name=mid,proto3" json:"mid,omitempty" form:"mid"`
	// 用户昵称
	Nickname string `protobuf:"bytes,4,opt,name=nickname,proto3" json:"nickname,omitempty" form:"nickname"`
	// 搜索词
	SearchWords string `protobuf:"bytes,5,opt,name=search_words,json=searchWords,proto3" json:"search_words,omitempty" form:"search_words"`
	// 申请人
	Applier              string   `protobuf:"bytes,6,opt,name=applier,proto3" json:"applier,omitempty" form:"applier"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchUpAliasReq) Reset()         { *m = SearchUpAliasReq{} }
func (m *SearchUpAliasReq) String() string { return proto.CompactTextString(m) }
func (*SearchUpAliasReq) ProtoMessage()    {}
func (*SearchUpAliasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *SearchUpAliasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchUpAliasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchUpAliasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchUpAliasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchUpAliasReq.Merge(m, src)
}
func (m *SearchUpAliasReq) XXX_Size() int {
	return m.Size()
}
func (m *SearchUpAliasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchUpAliasReq.DiscardUnknown(m)
}

var xxx_messageInfo_SearchUpAliasReq proto.InternalMessageInfo

func (m *SearchUpAliasReq) GetPs() int32 {
	if m != nil {
		return m.Ps
	}
	return 0
}

func (m *SearchUpAliasReq) GetPn() int32 {
	if m != nil {
		return m.Pn
	}
	return 0
}

func (m *SearchUpAliasReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *SearchUpAliasReq) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *SearchUpAliasReq) GetSearchWords() string {
	if m != nil {
		return m.SearchWords
	}
	return ""
}

func (m *SearchUpAliasReq) GetApplier() string {
	if m != nil {
		return m.Applier
	}
	return ""
}

type SearchUpAliasRep struct {
	Items                []*UpAlias `protobuf:"bytes,1,rep,name=items,proto3" json:"items"`
	Pager                *PageInfo  `protobuf:"bytes,2,opt,name=pager,proto3" json:"pager"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SearchUpAliasRep) Reset()         { *m = SearchUpAliasRep{} }
func (m *SearchUpAliasRep) String() string { return proto.CompactTextString(m) }
func (*SearchUpAliasRep) ProtoMessage()    {}
func (*SearchUpAliasRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *SearchUpAliasRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchUpAliasRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchUpAliasRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchUpAliasRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchUpAliasRep.Merge(m, src)
}
func (m *SearchUpAliasRep) XXX_Size() int {
	return m.Size()
}
func (m *SearchUpAliasRep) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchUpAliasRep.DiscardUnknown(m)
}

var xxx_messageInfo_SearchUpAliasRep proto.InternalMessageInfo

func (m *SearchUpAliasRep) GetItems() []*UpAlias {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *SearchUpAliasRep) GetPager() *PageInfo {
	if m != nil {
		return m.Pager
	}
	return nil
}

type UpAlias struct {
	// 记录id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 用户mid
	Mid int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid"`
	// 用户昵称
	Nickname string `protobuf:"bytes,3,opt,name=nickname,proto3" json:"nickname"`
	// 搜索词
	SearchWords string `protobuf:"bytes,4,opt,name=search_words,json=searchWords,proto3" json:"search_words"`
	// 生效开始时间
	Stime int64 `protobuf:"varint,5,opt,name=stime,proto3" json:"stime"`
	// 生效结束时间
	Etime int64 `protobuf:"varint,6,opt,name=etime,proto3" json:"etime"`
	// 是否永久
	IsForever int32 `protobuf:"varint,7,opt,name=is_forever,json=isForever,proto3" json:"is_forever"`
	// 申请人
	Applier string `protobuf:"bytes,8,opt,name=applier,proto3" json:"applier"`
	// 是否在线
	State int32 `protobuf:"varint,9,opt,name=state,proto3" json:"state"`
	// 粉丝数
	FansCount int64 `protobuf:"varint,10,opt,name=fans_count,json=fansCount,proto3" json:"fans_count"`
	// 创建时间
	Ctime                int64    `protobuf:"varint,11,opt,name=ctime,proto3" json:"ctime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpAlias) Reset()         { *m = UpAlias{} }
func (m *UpAlias) String() string { return proto.CompactTextString(m) }
func (*UpAlias) ProtoMessage()    {}
func (*UpAlias) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *UpAlias) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpAlias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpAlias.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpAlias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpAlias.Merge(m, src)
}
func (m *UpAlias) XXX_Size() int {
	return m.Size()
}
func (m *UpAlias) XXX_DiscardUnknown() {
	xxx_messageInfo_UpAlias.DiscardUnknown(m)
}

var xxx_messageInfo_UpAlias proto.InternalMessageInfo

func (m *UpAlias) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpAlias) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *UpAlias) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *UpAlias) GetSearchWords() string {
	if m != nil {
		return m.SearchWords
	}
	return ""
}

func (m *UpAlias) GetStime() int64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

func (m *UpAlias) GetEtime() int64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *UpAlias) GetIsForever() int32 {
	if m != nil {
		return m.IsForever
	}
	return 0
}

func (m *UpAlias) GetApplier() string {
	if m != nil {
		return m.Applier
	}
	return ""
}

func (m *UpAlias) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *UpAlias) GetFansCount() int64 {
	if m != nil {
		return m.FansCount
	}
	return 0
}

func (m *UpAlias) GetCtime() int64 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

type PageInfo struct {
	Num                  int32    `protobuf:"varint,1,opt,name=num,proto3" json:"num"`
	Size_                int32    `protobuf:"varint,2,opt,name=size,proto3" json:"size"`
	Total                int32    `protobuf:"varint,3,opt,name=total,proto3" json:"total"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PageInfo) Reset()         { *m = PageInfo{} }
func (m *PageInfo) String() string { return proto.CompactTextString(m) }
func (*PageInfo) ProtoMessage()    {}
func (*PageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *PageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageInfo.Merge(m, src)
}
func (m *PageInfo) XXX_Size() int {
	return m.Size()
}
func (m *PageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PageInfo proto.InternalMessageInfo

func (m *PageInfo) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *PageInfo) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PageInfo) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type SyncUpAliasReq struct {
	EffectTime           int64    `protobuf:"varint,1,opt,name=effect_time,json=effectTime,proto3" json:"effect_time,omitempty" form:"effect_time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncUpAliasReq) Reset()         { *m = SyncUpAliasReq{} }
func (m *SyncUpAliasReq) String() string { return proto.CompactTextString(m) }
func (*SyncUpAliasReq) ProtoMessage()    {}
func (*SyncUpAliasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *SyncUpAliasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncUpAliasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncUpAliasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncUpAliasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncUpAliasReq.Merge(m, src)
}
func (m *SyncUpAliasReq) XXX_Size() int {
	return m.Size()
}
func (m *SyncUpAliasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncUpAliasReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncUpAliasReq proto.InternalMessageInfo

func (m *SyncUpAliasReq) GetEffectTime() int64 {
	if m != nil {
		return m.EffectTime
	}
	return 0
}

type SyncUpAliasRep struct {
	Items                []*SyncUpAlias `protobuf:"bytes,1,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SyncUpAliasRep) Reset()         { *m = SyncUpAliasRep{} }
func (m *SyncUpAliasRep) String() string { return proto.CompactTextString(m) }
func (*SyncUpAliasRep) ProtoMessage()    {}
func (*SyncUpAliasRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *SyncUpAliasRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncUpAliasRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncUpAliasRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncUpAliasRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncUpAliasRep.Merge(m, src)
}
func (m *SyncUpAliasRep) XXX_Size() int {
	return m.Size()
}
func (m *SyncUpAliasRep) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncUpAliasRep.DiscardUnknown(m)
}

var xxx_messageInfo_SyncUpAliasRep proto.InternalMessageInfo

func (m *SyncUpAliasRep) GetItems() []*SyncUpAlias {
	if m != nil {
		return m.Items
	}
	return nil
}

type SyncUpAlias struct {
	// 记录id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 用户mid
	Mid int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid"`
	// 用户昵称
	Nickname string `protobuf:"bytes,3,opt,name=nickname,proto3" json:"nickname"`
	// 搜索词
	SearchWords []string `protobuf:"bytes,4,rep,name=search_words,json=searchWords,proto3" json:"search_words"`
	// 编辑时间
	Mtime                int64    `protobuf:"varint,5,opt,name=mtime,proto3" json:"mtime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncUpAlias) Reset()         { *m = SyncUpAlias{} }
func (m *SyncUpAlias) String() string { return proto.CompactTextString(m) }
func (*SyncUpAlias) ProtoMessage()    {}
func (*SyncUpAlias) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *SyncUpAlias) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncUpAlias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncUpAlias.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncUpAlias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncUpAlias.Merge(m, src)
}
func (m *SyncUpAlias) XXX_Size() int {
	return m.Size()
}
func (m *SyncUpAlias) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncUpAlias.DiscardUnknown(m)
}

var xxx_messageInfo_SyncUpAlias proto.InternalMessageInfo

func (m *SyncUpAlias) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SyncUpAlias) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *SyncUpAlias) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *SyncUpAlias) GetSearchWords() []string {
	if m != nil {
		return m.SearchWords
	}
	return nil
}

func (m *SyncUpAlias) GetMtime() int64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func init() {
	proto.RegisterType((*BatchOptWebReq)(nil), "main.feed.admin.search.api.BatchOptWebReq")
	proto.RegisterType((*BatchOptWebResp)(nil), "main.feed.admin.search.api.BatchOptWebResp")
	proto.RegisterType((*BatchOptResultSpreadReq)(nil), "main.feed.admin.search.api.BatchOptResultSpreadReq")
	proto.RegisterType((*BatchOptResultSpreadResp)(nil), "main.feed.admin.search.api.BatchOptResultSpreadResp")
	proto.RegisterType((*BatchInvalidItem)(nil), "main.feed.admin.search.api.BatchInvalidItem")
	proto.RegisterType((*AddUpAliasReq)(nil), "main.feed.admin.search.api.AddUpAliasReq")
	proto.RegisterType((*EditUpAliasReq)(nil), "main.feed.admin.search.api.EditUpAliasReq")
	proto.RegisterType((*ToggleUpAliasReq)(nil), "main.feed.admin.search.api.ToggleUpAliasReq")
	proto.RegisterType((*SearchUpAliasReq)(nil), "main.feed.admin.search.api.SearchUpAliasReq")
	proto.RegisterType((*SearchUpAliasRep)(nil), "main.feed.admin.search.api.SearchUpAliasRep")
	proto.RegisterType((*UpAlias)(nil), "main.feed.admin.search.api.UpAlias")
	proto.RegisterType((*PageInfo)(nil), "main.feed.admin.search.api.PageInfo")
	proto.RegisterType((*SyncUpAliasReq)(nil), "main.feed.admin.search.api.SyncUpAliasReq")
	proto.RegisterType((*SyncUpAliasRep)(nil), "main.feed.admin.search.api.SyncUpAliasRep")
	proto.RegisterType((*SyncUpAlias)(nil), "main.feed.admin.search.api.SyncUpAlias")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1154 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x6f, 0xdc, 0x44,
	0x14, 0x97, 0xd7, 0xf1, 0x26, 0xfb, 0x36, 0xd9, 0x44, 0xd3, 0x90, 0x6e, 0x17, 0x88, 0x17, 0x53,
	0xd4, 0xa5, 0x4d, 0x1d, 0x29, 0x41, 0x02, 0x45, 0xe2, 0x10, 0x43, 0x80, 0x9c, 0x0a, 0x93, 0x56,
	0x95, 0x2a, 0xc1, 0xca, 0x59, 0xcf, 0x3a, 0xa3, 0xae, 0xed, 0x89, 0xc7, 0x5b, 0xd4, 0xde, 0xf8,
	0x00, 0x7c, 0x02, 0x0e, 0x5c, 0xf8, 0x20, 0x48, 0x5c, 0x38, 0xf2, 0x09, 0x2c, 0x94, 0x0b, 0xd2,
	0x1e, 0xf7, 0x80, 0x38, 0xa2, 0x99, 0xb1, 0x63, 0x7b, 0x9b, 0x6c, 0x13, 0xfe, 0xf4, 0x62, 0xcf,
	0x7b, 0xf3, 0xfe, 0xcc, 0x7b, 0xbf, 0xf7, 0x66, 0x1e, 0x34, 0x5c, 0x46, 0x6d, 0x16, 0x47, 0x49,
	0x84, 0x3a, 0x81, 0x4b, 0x43, 0x7b, 0x48, 0x88, 0x67, 0xbb, 0x5e, 0x40, 0x43, 0x9b, 0x13, 0x37,
	0x1e, 0x9c, 0xd8, 0x2e, 0xa3, 0x9d, 0xfb, 0x3e, 0x4d, 0x4e, 0xc6, 0xc7, 0xf6, 0x20, 0x0a, 0xb6,
	0xfd, 0xc8, 0x8f, 0xb6, 0xa5, 0xca, 0xf1, 0x78, 0x28, 0x29, 0x49, 0xc8, 0x95, 0x32, 0xd5, 0x79,
	0xd3, 0x8f, 0x22, 0x7f, 0x44, 0x0a, 0x29, 0x12, 0xb0, 0xe4, 0xb9, 0xda, 0xb4, 0xfe, 0xd4, 0xa0,
	0xe5, 0xb8, 0xc9, 0xe0, 0xe4, 0x01, 0x4b, 0x1e, 0x93, 0x63, 0x4c, 0x4e, 0xd1, 0x1d, 0xd0, 0xc7,
	0xd4, 0x6b, 0x6b, 0x5d, 0xad, 0xa7, 0x3b, 0x6f, 0x4c, 0x52, 0x53, 0x90, 0xd3, 0xd4, 0x84, 0x61,
	0x14, 0x07, 0x7b, 0xd6, 0x98, 0x7a, 0x16, 0x16, 0x2c, 0xb4, 0x0d, 0xc6, 0x38, 0x74, 0x03, 0xd2,
	0xae, 0x75, 0xb5, 0x5e, 0xc3, 0xb9, 0x35, 0x49, 0x4d, 0xc5, 0x98, 0xa6, 0xe6, 0x72, 0x26, 0x2c,
	0x48, 0x0b, 0x2b, 0x36, 0xda, 0x07, 0x9d, 0x7a, 0xbc, 0xad, 0x77, 0xf5, 0x9e, 0xee, 0x6c, 0x0b,
	0xcb, 0xd4, 0xe3, 0xd3, 0xd4, 0xbc, 0xad, 0x84, 0xa9, 0xc7, 0xb7, 0x38, 0x1b, 0xd1, 0xc4, 0xea,
	0x3e, 0x73, 0x47, 0xd4, 0x73, 0x13, 0xb2, 0x67, 0xc5, 0xe4, 0x74, 0x4c, 0x63, 0x22, 0x7c, 0x52,
	0x8f, 0xa3, 0xcf, 0xa1, 0x1e, 0xb1, 0x84, 0x46, 0x61, 0x7b, 0x41, 0x3a, 0x15, 0x56, 0x32, 0xce,
	0x34, 0x35, 0xdf, 0x51, 0x86, 0x14, 0x7d, 0xb1, 0x95, 0x4c, 0xd8, 0x3a, 0x85, 0xd5, 0x4a, 0xdc,
	0x9c, 0xa1, 0x6f, 0xa0, 0x49, 0x43, 0xa9, 0xd3, 0x17, 0xc7, 0xd4, 0xba, 0x7a, 0xaf, 0xb9, 0xb3,
	0x65, 0x5f, 0x8e, 0x84, 0x2d, 0x2d, 0x1c, 0x2a, 0x9d, 0xc3, 0x84, 0x04, 0xce, 0xea, 0x24, 0x35,
	0xcb, 0x46, 0x30, 0x64, 0xc4, 0xa1, 0xc7, 0xad, 0x1f, 0x6a, 0x70, 0x33, 0xf7, 0x89, 0x09, 0x1f,
	0x8f, 0x92, 0x23, 0x16, 0x13, 0xd7, 0xfb, 0x7f, 0x93, 0xfe, 0x35, 0x00, 0x97, 0x6e, 0xfa, 0x45,
	0xee, 0x3f, 0x9e, 0xa4, 0x66, 0x89, 0x3b, 0x4d, 0xcd, 0x7b, 0x4a, 0xb5, 0xe0, 0xcd, 0x43, 0xa2,
	0xa4, 0xfa, 0xdf, 0x01, 0xf2, 0x02, 0xda, 0x17, 0x27, 0xe7, 0x35, 0x20, 0x73, 0x00, 0x6b, 0xb3,
	0x0a, 0x68, 0x03, 0x6a, 0xe7, 0x80, 0xd4, 0x27, 0xa9, 0x59, 0xa3, 0x1e, 0xae, 0x51, 0x0f, 0xdd,
	0x02, 0x3d, 0xe0, 0x7e, 0x96, 0xfe, 0x45, 0x81, 0x54, 0xc0, 0x7d, 0x2c, 0x3e, 0xd6, 0x1f, 0x1a,
	0xac, 0xec, 0x7b, 0xde, 0x23, 0xb6, 0x3f, 0xa2, 0x2e, 0x17, 0xb0, 0xae, 0x81, 0x1e, 0xe4, 0x56,
	0xb0, 0x58, 0xa2, 0x0e, 0x2c, 0x85, 0x74, 0xf0, 0xb4, 0x80, 0x10, 0x9f, 0xd3, 0x68, 0x17, 0x96,
	0x55, 0x08, 0xfd, 0x6f, 0xa3, 0x58, 0x82, 0x25, 0x7c, 0xac, 0x4d, 0x52, 0xb3, 0xc2, 0xc7, 0x4d,
	0x45, 0x3d, 0x16, 0x04, 0x5a, 0x07, 0x83, 0x27, 0x34, 0x20, 0x32, 0xff, 0x3a, 0x56, 0x84, 0xe0,
	0x12, 0xc9, 0x35, 0x14, 0x57, 0x12, 0xe8, 0x3e, 0x00, 0xe5, 0xfd, 0x61, 0x14, 0x93, 0x67, 0x24,
	0x6e, 0xd7, 0xbb, 0x5a, 0xcf, 0x70, 0x5a, 0xa2, 0x16, 0x0a, 0x2e, 0x6e, 0x50, 0xfe, 0x99, 0x5a,
	0xa2, 0x36, 0x2c, 0xba, 0x8c, 0x8d, 0x28, 0x89, 0xdb, 0x8b, 0xf2, 0xa8, 0x39, 0x69, 0xfd, 0xa5,
	0x41, 0xeb, 0xc0, 0xa3, 0x49, 0x29, 0xd4, 0x56, 0x91, 0x2f, 0x99, 0xa7, 0x2c, 0xf4, 0xda, 0xc5,
	0xa1, 0xeb, 0xaf, 0x08, 0x7d, 0xe1, 0x5a, 0xa1, 0x1b, 0x17, 0x86, 0x5e, 0xbf, 0x3c, 0xf4, 0xc5,
	0x6b, 0x84, 0xbe, 0x54, 0x0d, 0xfd, 0x23, 0x58, 0x7b, 0x18, 0xf9, 0xfe, 0x88, 0xcc, 0x89, 0x5d,
	0x1e, 0xcc, 0x4d, 0x14, 0xc2, 0x06, 0x56, 0x84, 0xf5, 0x7d, 0x0d, 0xd6, 0x8e, 0xe4, 0xf1, 0x4b,
	0xaa, 0x6f, 0x43, 0x8d, 0x71, 0xa9, 0x6a, 0x38, 0x2b, 0xd3, 0xd4, 0x6c, 0xa8, 0x8e, 0x61, 0xdc,
	0xc2, 0x35, 0xc6, 0xe5, 0x76, 0xa8, 0xcc, 0x54, 0xb6, 0x43, 0xb1, 0x1d, 0xa2, 0xae, 0x4a, 0xb2,
	0x2e, 0xab, 0xb4, 0x55, 0xdc, 0x17, 0x81, 0xbc, 0x2f, 0x02, 0x79, 0x5f, 0x14, 0x49, 0x57, 0x49,
	0xbd, 0x31, 0x4d, 0xcd, 0x55, 0x25, 0x96, 0xef, 0x58, 0x25, 0x24, 0xf6, 0x66, 0x90, 0x30, 0xa4,
	0xd2, 0xcd, 0x69, 0x6a, 0xde, 0xc8, 0xee, 0x88, 0xd2, 0xae, 0x55, 0x05, 0x64, 0xab, 0xc8, 0x5a,
	0x5d, 0xaa, 0xa1, 0x69, 0x6a, 0xb6, 0x94, 0x5a, 0x9e, 0xbf, 0x22, 0x93, 0x3f, 0x6a, 0x2f, 0xe5,
	0x83, 0xa1, 0x4f, 0xc1, 0xa0, 0x09, 0x09, 0xf2, 0x26, 0x7f, 0x77, 0x5e, 0x93, 0x67, 0x6a, 0x4e,
	0x43, 0x5c, 0x82, 0x52, 0x0b, 0xab, 0x1f, 0x3a, 0x00, 0x83, 0xb9, 0x3e, 0x89, 0x65, 0xe6, 0x9a,
	0x3b, 0xb7, 0xe7, 0x59, 0xf9, 0xd2, 0xf5, 0xc9, 0x61, 0x38, 0x8c, 0x94, 0x19, 0xa9, 0x86, 0xd5,
	0xcf, 0xfa, 0x49, 0x87, 0xc5, 0xcc, 0xc9, 0xdc, 0xfb, 0x20, 0xaf, 0xf3, 0xec, 0x3e, 0xa0, 0x9e,
	0xca, 0x7d, 0x6f, 0xb6, 0xe0, 0x9d, 0xe5, 0x49, 0x6a, 0x9e, 0xf3, 0xfe, 0x6d, 0xf9, 0x9b, 0x95,
	0xf2, 0x57, 0xc7, 0x97, 0x8c, 0xbc, 0x13, 0xcc, 0x4a, 0x27, 0x28, 0x01, 0xa2, 0x04, 0xfe, 0x51,
	0x53, 0xbc, 0x37, 0xd3, 0x14, 0x4e, 0x73, 0x92, 0x9a, 0x39, 0xeb, 0x1c, 0x57, 0x75, 0x2e, 0x51,
	0xfd, 0x0d, 0x69, 0x30, 0x3b, 0x97, 0x9b, 0x90, 0xac, 0x11, 0x84, 0xdb, 0xa1, 0x1b, 0xf2, 0xfe,
	0x20, 0x1a, 0x87, 0x49, 0x1b, 0x54, 0xf1, 0x0a, 0xb7, 0x05, 0x17, 0x37, 0xc4, 0xfa, 0x13, 0xb1,
	0x14, 0xf6, 0x06, 0x32, 0x8c, 0x66, 0x11, 0xc6, 0x40, 0x85, 0x21, 0x7f, 0x96, 0x07, 0x4b, 0x39,
	0x88, 0x02, 0x8e, 0x70, 0x1c, 0x64, 0x0d, 0x25, 0xe1, 0x08, 0xc7, 0x01, 0x16, 0x1f, 0xf4, 0x16,
	0x2c, 0x70, 0xfa, 0x22, 0x6b, 0x4a, 0x67, 0x69, 0x92, 0x9a, 0x92, 0xc6, 0xf2, 0x2b, 0xbc, 0x24,
	0x51, 0xe2, 0x8e, 0x24, 0x52, 0xd9, 0xa9, 0x25, 0x03, 0xab, 0x9f, 0x75, 0x08, 0xad, 0xa3, 0xe7,
	0xe1, 0xa0, 0xd4, 0xbb, 0x1f, 0x42, 0x93, 0x0c, 0x87, 0x64, 0x90, 0xf4, 0xe5, 0xf1, 0x54, 0x6d,
	0x6c, 0x4c, 0x53, 0x13, 0xa9, 0x92, 0x2f, 0x6d, 0x5a, 0x18, 0x14, 0xf5, 0x50, 0x10, 0x4f, 0x66,
	0x4c, 0x31, 0xf4, 0x45, 0xb5, 0xec, 0xef, 0xcc, 0x2b, 0xd8, 0x92, 0xea, 0xcb, 0xa5, 0x6f, 0xfd,
	0xac, 0x41, 0xb3, 0x24, 0xf1, 0xba, 0xeb, 0x56, 0xbf, 0x52, 0xdd, 0x06, 0xb3, 0x75, 0x1b, 0x28,
	0x3c, 0xe5, 0x6f, 0xe7, 0x17, 0x03, 0xea, 0xea, 0x62, 0x40, 0x43, 0x68, 0x96, 0xc6, 0x34, 0x74,
	0xf7, 0x95, 0x6f, 0xfe, 0xf9, 0x1c, 0xdb, 0xb9, 0x77, 0x65, 0x59, 0xce, 0xd0, 0x77, 0x1a, 0xac,
	0x5f, 0x34, 0x7e, 0xa0, 0xdd, 0xab, 0x58, 0x99, 0x99, 0xe6, 0x3a, 0x1f, 0x5c, 0x5f, 0x89, 0x33,
	0xf4, 0x00, 0xa0, 0x98, 0x1e, 0xd0, 0xfb, 0xf3, 0x6c, 0x54, 0xa6, 0x8c, 0xce, 0x86, 0xad, 0x46,
	0x7c, 0x3b, 0x1f, 0xf1, 0xed, 0x03, 0x31, 0xe2, 0xa3, 0xaf, 0xa0, 0x59, 0x7a, 0xa4, 0xe7, 0x27,
	0xaf, 0xfa, 0x9a, 0x5f, 0x6a, 0xf2, 0x11, 0xac, 0x54, 0x5e, 0x3f, 0x34, 0x77, 0x0a, 0x9b, 0x7d,
	0x28, 0x2f, 0x35, 0xfb, 0x14, 0x56, 0x2a, 0x2f, 0xc1, 0x7c, 0xb3, 0xb3, 0x8f, 0x68, 0xe7, 0x3a,
	0xd2, 0x0c, 0x91, 0x6a, 0x83, 0xdc, 0xbd, 0x62, 0xaf, 0x09, 0x47, 0x57, 0x97, 0x65, 0xce, 0xfa,
	0xaf, 0x67, 0x9b, 0xda, 0x6f, 0x67, 0x9b, 0xda, 0xef, 0x67, 0x9b, 0xda, 0x93, 0xba, 0x12, 0x3c,
	0xae, 0xcb, 0xc8, 0x77, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x06, 0xc9, 0x14, 0xec, 0x0d,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SearchClient is the client API for Search service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SearchClient interface {
	BatchOptWeb(ctx context.Context, in *BatchOptWebReq, opts ...grpc.CallOption) (*BatchOptWebResp, error)
	BatchOptResultSpread(ctx context.Context, in *BatchOptResultSpreadReq, opts ...grpc.CallOption) (*BatchOptResultSpreadResp, error)
	// 搜索后台-up主别名管理
	// 新增
	AddUpAlias(ctx context.Context, in *AddUpAliasReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 编辑
	EditUpAlias(ctx context.Context, in *EditUpAliasReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 审核
	ToggleUpAlias(ctx context.Context, in *ToggleUpAliasReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 查询
	SearchUpAlias(ctx context.Context, in *SearchUpAliasReq, opts ...grpc.CallOption) (*SearchUpAliasRep, error)
	// 同步信息
	SyncUpAlias(ctx context.Context, in *SyncUpAliasReq, opts ...grpc.CallOption) (*SyncUpAliasRep, error)
}

type searchClient struct {
	cc *grpc.ClientConn
}

func NewSearchClient(cc *grpc.ClientConn) SearchClient {
	return &searchClient{cc}
}

func (c *searchClient) BatchOptWeb(ctx context.Context, in *BatchOptWebReq, opts ...grpc.CallOption) (*BatchOptWebResp, error) {
	out := new(BatchOptWebResp)
	err := c.cc.Invoke(ctx, "/main.feed.admin.search.api.Search/BatchOptWeb", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) BatchOptResultSpread(ctx context.Context, in *BatchOptResultSpreadReq, opts ...grpc.CallOption) (*BatchOptResultSpreadResp, error) {
	out := new(BatchOptResultSpreadResp)
	err := c.cc.Invoke(ctx, "/main.feed.admin.search.api.Search/BatchOptResultSpread", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) AddUpAlias(ctx context.Context, in *AddUpAliasReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/main.feed.admin.search.api.Search/AddUpAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) EditUpAlias(ctx context.Context, in *EditUpAliasReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/main.feed.admin.search.api.Search/EditUpAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) ToggleUpAlias(ctx context.Context, in *ToggleUpAliasReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/main.feed.admin.search.api.Search/ToggleUpAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) SearchUpAlias(ctx context.Context, in *SearchUpAliasReq, opts ...grpc.CallOption) (*SearchUpAliasRep, error) {
	out := new(SearchUpAliasRep)
	err := c.cc.Invoke(ctx, "/main.feed.admin.search.api.Search/SearchUpAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) SyncUpAlias(ctx context.Context, in *SyncUpAliasReq, opts ...grpc.CallOption) (*SyncUpAliasRep, error) {
	out := new(SyncUpAliasRep)
	err := c.cc.Invoke(ctx, "/main.feed.admin.search.api.Search/SyncUpAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServer is the server API for Search service.
type SearchServer interface {
	BatchOptWeb(context.Context, *BatchOptWebReq) (*BatchOptWebResp, error)
	BatchOptResultSpread(context.Context, *BatchOptResultSpreadReq) (*BatchOptResultSpreadResp, error)
	// 搜索后台-up主别名管理
	// 新增
	AddUpAlias(context.Context, *AddUpAliasReq) (*empty.Empty, error)
	// 编辑
	EditUpAlias(context.Context, *EditUpAliasReq) (*empty.Empty, error)
	// 审核
	ToggleUpAlias(context.Context, *ToggleUpAliasReq) (*empty.Empty, error)
	// 查询
	SearchUpAlias(context.Context, *SearchUpAliasReq) (*SearchUpAliasRep, error)
	// 同步信息
	SyncUpAlias(context.Context, *SyncUpAliasReq) (*SyncUpAliasRep, error)
}

// UnimplementedSearchServer can be embedded to have forward compatible implementations.
type UnimplementedSearchServer struct {
}

func (*UnimplementedSearchServer) BatchOptWeb(ctx context.Context, req *BatchOptWebReq) (*BatchOptWebResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchOptWeb not implemented")
}
func (*UnimplementedSearchServer) BatchOptResultSpread(ctx context.Context, req *BatchOptResultSpreadReq) (*BatchOptResultSpreadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchOptResultSpread not implemented")
}
func (*UnimplementedSearchServer) AddUpAlias(ctx context.Context, req *AddUpAliasReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUpAlias not implemented")
}
func (*UnimplementedSearchServer) EditUpAlias(ctx context.Context, req *EditUpAliasReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditUpAlias not implemented")
}
func (*UnimplementedSearchServer) ToggleUpAlias(ctx context.Context, req *ToggleUpAliasReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleUpAlias not implemented")
}
func (*UnimplementedSearchServer) SearchUpAlias(ctx context.Context, req *SearchUpAliasReq) (*SearchUpAliasRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchUpAlias not implemented")
}
func (*UnimplementedSearchServer) SyncUpAlias(ctx context.Context, req *SyncUpAliasReq) (*SyncUpAliasRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncUpAlias not implemented")
}

func RegisterSearchServer(s *grpc.Server, srv SearchServer) {
	s.RegisterService(&_Search_serviceDesc, srv)
}

func _Search_BatchOptWeb_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchOptWebReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).BatchOptWeb(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.feed.admin.search.api.Search/BatchOptWeb",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).BatchOptWeb(ctx, req.(*BatchOptWebReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_BatchOptResultSpread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchOptResultSpreadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).BatchOptResultSpread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.feed.admin.search.api.Search/BatchOptResultSpread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).BatchOptResultSpread(ctx, req.(*BatchOptResultSpreadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_AddUpAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUpAliasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).AddUpAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.feed.admin.search.api.Search/AddUpAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).AddUpAlias(ctx, req.(*AddUpAliasReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_EditUpAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditUpAliasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).EditUpAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.feed.admin.search.api.Search/EditUpAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).EditUpAlias(ctx, req.(*EditUpAliasReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_ToggleUpAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleUpAliasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).ToggleUpAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.feed.admin.search.api.Search/ToggleUpAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).ToggleUpAlias(ctx, req.(*ToggleUpAliasReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_SearchUpAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchUpAliasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).SearchUpAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.feed.admin.search.api.Search/SearchUpAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).SearchUpAlias(ctx, req.(*SearchUpAliasReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_SyncUpAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncUpAliasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).SyncUpAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.feed.admin.search.api.Search/SyncUpAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).SyncUpAlias(ctx, req.(*SyncUpAliasReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Search_serviceDesc = grpc.ServiceDesc{
	ServiceName: "main.feed.admin.search.api.Search",
	HandlerType: (*SearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchOptWeb",
			Handler:    _Search_BatchOptWeb_Handler,
		},
		{
			MethodName: "BatchOptResultSpread",
			Handler:    _Search_BatchOptResultSpread_Handler,
		},
		{
			MethodName: "AddUpAlias",
			Handler:    _Search_AddUpAlias_Handler,
		},
		{
			MethodName: "EditUpAlias",
			Handler:    _Search_EditUpAlias_Handler,
		},
		{
			MethodName: "ToggleUpAlias",
			Handler:    _Search_ToggleUpAlias_Handler,
		},
		{
			MethodName: "SearchUpAlias",
			Handler:    _Search_SearchUpAlias_Handler,
		},
		{
			MethodName: "SyncUpAlias",
			Handler:    _Search_SyncUpAlias_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *BatchOptWebReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchOptWebReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchOptWebReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Option) > 0 {
		i -= len(m.Option)
		copy(dAtA[i:], m.Option)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Option)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ids) > 0 {
		dAtA2 := make([]byte, len(m.Ids)*10)
		var j1 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uname) > 0 {
		i -= len(m.Uname)
		copy(dAtA[i:], m.Uname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Uname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchOptWebResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchOptWebResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchOptWebResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InvalidIds) > 0 {
		for iNdEx := len(m.InvalidIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InvalidIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchOptResultSpreadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchOptResultSpreadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchOptResultSpreadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Option) > 0 {
		i -= len(m.Option)
		copy(dAtA[i:], m.Option)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Option)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SpreadIds) > 0 {
		dAtA4 := make([]byte, len(m.SpreadIds)*10)
		var j3 int
		for _, num1 := range m.SpreadIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uname) > 0 {
		i -= len(m.Uname)
		copy(dAtA[i:], m.Uname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Uname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchOptResultSpreadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchOptResultSpreadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchOptResultSpreadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InvalidIds) > 0 {
		for iNdEx := len(m.InvalidIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InvalidIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchInvalidItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchInvalidItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchInvalidItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddUpAliasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUpAliasReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddUpAliasReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Applier) > 0 {
		i -= len(m.Applier)
		copy(dAtA[i:], m.Applier)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Applier)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsForever != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.IsForever))
		i--
		dAtA[i] = 0x30
	}
	if m.Etime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x28
	}
	if m.Stime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SearchWords) > 0 {
		i -= len(m.SearchWords)
		copy(dAtA[i:], m.SearchWords)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SearchWords)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EditUpAliasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditUpAliasReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditUpAliasReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Applier) > 0 {
		i -= len(m.Applier)
		copy(dAtA[i:], m.Applier)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Applier)))
		i--
		dAtA[i] = 0x42
	}
	if m.IsForever != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.IsForever))
		i--
		dAtA[i] = 0x38
	}
	if m.Etime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x30
	}
	if m.Stime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SearchWords) > 0 {
		i -= len(m.SearchWords)
		copy(dAtA[i:], m.SearchWords)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SearchWords)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ToggleUpAliasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToggleUpAliasReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToggleUpAliasReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchUpAliasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUpAliasReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchUpAliasReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Applier) > 0 {
		i -= len(m.Applier)
		copy(dAtA[i:], m.Applier)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Applier)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SearchWords) > 0 {
		i -= len(m.SearchWords)
		copy(dAtA[i:], m.SearchWords)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SearchWords)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x22
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchUpAliasRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUpAliasRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchUpAliasRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pager != nil {
		{
			size, err := m.Pager.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpAlias) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ctime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x58
	}
	if m.FansCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FansCount))
		i--
		dAtA[i] = 0x50
	}
	if m.State != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Applier) > 0 {
		i -= len(m.Applier)
		copy(dAtA[i:], m.Applier)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Applier)))
		i--
		dAtA[i] = 0x42
	}
	if m.IsForever != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.IsForever))
		i--
		dAtA[i] = 0x38
	}
	if m.Etime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Etime))
		i--
		dAtA[i] = 0x30
	}
	if m.Stime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Stime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SearchWords) > 0 {
		i -= len(m.SearchWords)
		copy(dAtA[i:], m.SearchWords)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SearchWords)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncUpAliasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncUpAliasReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncUpAliasReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EffectTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EffectTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncUpAliasRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncUpAliasRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncUpAliasRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SyncUpAlias) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncUpAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncUpAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SearchWords) > 0 {
		for iNdEx := len(m.SearchWords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchWords[iNdEx])
			copy(dAtA[i:], m.SearchWords[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.SearchWords[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BatchOptWebReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	l = len(m.Option)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchOptWebResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InvalidIds) > 0 {
		for _, e := range m.InvalidIds {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchOptResultSpreadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SpreadIds) > 0 {
		l = 0
		for _, e := range m.SpreadIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	l = len(m.Option)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchOptResultSpreadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InvalidIds) > 0 {
		for _, e := range m.InvalidIds {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchInvalidItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddUpAliasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SearchWords)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Stime != 0 {
		n += 1 + sovApi(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovApi(uint64(m.Etime))
	}
	if m.IsForever != 0 {
		n += 1 + sovApi(uint64(m.IsForever))
	}
	l = len(m.Applier)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EditUpAliasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SearchWords)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Stime != 0 {
		n += 1 + sovApi(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovApi(uint64(m.Etime))
	}
	if m.IsForever != 0 {
		n += 1 + sovApi(uint64(m.IsForever))
	}
	l = len(m.Applier)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ToggleUpAliasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchUpAliasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SearchWords)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Applier)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchUpAliasRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Pager != nil {
		l = m.Pager.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SearchWords)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Stime != 0 {
		n += 1 + sovApi(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovApi(uint64(m.Etime))
	}
	if m.IsForever != 0 {
		n += 1 + sovApi(uint64(m.IsForever))
	}
	l = len(m.Applier)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.FansCount != 0 {
		n += 1 + sovApi(uint64(m.FansCount))
	}
	if m.Ctime != 0 {
		n += 1 + sovApi(uint64(m.Ctime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncUpAliasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectTime != 0 {
		n += 1 + sovApi(uint64(m.EffectTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncUpAliasRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncUpAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SearchWords) > 0 {
		for _, s := range m.SearchWords {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Mtime != 0 {
		n += 1 + sovApi(uint64(m.Mtime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BatchOptWebReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchOptWebReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchOptWebReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchOptWebResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchOptWebResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchOptWebResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvalidIds = append(m.InvalidIds, &BatchInvalidItem{})
			if err := m.InvalidIds[len(m.InvalidIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchOptResultSpreadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchOptResultSpreadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchOptResultSpreadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpreadIds = append(m.SpreadIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SpreadIds) == 0 {
					m.SpreadIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpreadIds = append(m.SpreadIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpreadIds", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchOptResultSpreadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchOptResultSpreadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchOptResultSpreadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvalidIds = append(m.InvalidIds, &BatchInvalidItem{})
			if err := m.InvalidIds[len(m.InvalidIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchInvalidItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchInvalidItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchInvalidItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddUpAliasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUpAliasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUpAliasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchWords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForever", wireType)
			}
			m.IsForever = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsForever |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditUpAliasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditUpAliasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditUpAliasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchWords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForever", wireType)
			}
			m.IsForever = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsForever |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToggleUpAliasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToggleUpAliasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToggleUpAliasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUpAliasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUpAliasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUpAliasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchWords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUpAliasRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUpAliasRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUpAliasRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &UpAlias{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pager == nil {
				m.Pager = &PageInfo{}
			}
			if err := m.Pager.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpAlias) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchWords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForever", wireType)
			}
			m.IsForever = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsForever |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FansCount", wireType)
			}
			m.FansCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FansCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncUpAliasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncUpAliasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncUpAliasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectTime", wireType)
			}
			m.EffectTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncUpAliasRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncUpAliasRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncUpAliasRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SyncUpAlias{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncUpAlias) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncUpAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncUpAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchWords = append(m.SearchWords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
