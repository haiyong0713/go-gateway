// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	go_common_library_time "go-common/library/time"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SearchOrder int32

const (
	// pubtime 稿件发布时间
	SearchOrder_pubtime SearchOrder = 0
	// click 稿件点击(播放)数
	SearchOrder_click SearchOrder = 1
	// fav 稿件收藏数
	SearchOrder_fav SearchOrder = 2
	// share 稿件分享数
	SearchOrder_share SearchOrder = 3
	// reply 稿件评论数
	SearchOrder_reply SearchOrder = 4
	// coin 稿件投币数
	SearchOrder_coin SearchOrder = 5
	// dm 稿件弹幕数
	SearchOrder_dm SearchOrder = 6
	// likes 稿件点赞数
	SearchOrder_likes SearchOrder = 7
)

var SearchOrder_name = map[int32]string{
	0: "pubtime",
	1: "click",
	2: "fav",
	3: "share",
	4: "reply",
	5: "coin",
	6: "dm",
	7: "likes",
}

var SearchOrder_value = map[string]int32{
	"pubtime": 0,
	"click":   1,
	"fav":     2,
	"share":   3,
	"reply":   4,
	"coin":    5,
	"dm":      6,
	"likes":   7,
}

func (x SearchOrder) String() string {
	return proto.EnumName(SearchOrder_name, int32(x))
}

func (SearchOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type Sort int32

const (
	// desc:降序
	Sort_desc Sort = 0
	// asc:升序
	Sort_asc Sort = 1
)

var Sort_name = map[int32]string{
	0: "desc",
	1: "asc",
}

var Sort_value = map[string]int32{
	"desc": 0,
	"asc":  1,
}

func (x Sort) String() string {
	return proto.EnumName(Sort_name, int32(x))
}

func (Sort) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type KwField int32

const (
	// title 标题
	KwField_title KwField = 0
	// content 描述
	KwField_content KwField = 1
)

var KwField_name = map[int32]string{
	0: "title",
	1: "content",
}

var KwField_value = map[string]int32{
	"title":   0,
	"content": 1,
}

func (x KwField) String() string {
	return proto.EnumName(KwField_name, int32(x))
}

func (KwField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type Without int32

const (
	// 什么都不去除
	Without_none Without = 0
	// staff 去除联合投稿
	Without_staff Without = 1
	// live_playback 去除直播回放
	Without_live_playback Without = 2
	// no_space 去除空间禁止
	Without_no_space Without = 3
)

var Without_name = map[int32]string{
	0: "none",
	1: "staff",
	2: "live_playback",
	3: "no_space",
}

var Without_value = map[string]int32{
	"none":          0,
	"staff":         1,
	"live_playback": 2,
	"no_space":      3,
}

func (x Without) String() string {
	return proto.EnumName(Without_name, int32(x))
}

func (Without) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}

type ArcPassedReq struct {
	// mid 用户id 必传
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"min=1"`
	// pn 第几页
	Pn int64 `protobuf:"varint,2,opt,name=pn,proto3" json:"pn,omitempty" form:"pn" validate:"min=1"`
	// ps 分页大小
	Ps int64 `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" validate:"min=1,max=50"`
	// sort 排序方式 非必传 desc:降序 asc:升序 (默认降序)
	Sort string `protobuf:"bytes,4,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	// Deprecated: 废弃，请使用without
	WithoutStaff bool `protobuf:"varint,5,opt,name=without_staff,json=withoutStaff,proto3" json:"without_staff,omitempty" form:"without_staff"`
	// order 排序字段 非必传 (默认稿件发布时间)
	Order SearchOrder `protobuf:"varint,6,opt,name=order,proto3,enum=up.archive.service.v1.SearchOrder" json:"order,omitempty" form:"order"`
	// without 去除特定类型稿件
	Without              []Without `protobuf:"varint,7,rep,packed,name=without,proto3,enum=up.archive.service.v1.Without" json:"without,omitempty" form:"without"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ArcPassedReq) Reset()         { *m = ArcPassedReq{} }
func (m *ArcPassedReq) String() string { return proto.CompactTextString(m) }
func (*ArcPassedReq) ProtoMessage()    {}
func (*ArcPassedReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *ArcPassedReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedReq.Merge(m, src)
}
func (m *ArcPassedReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedReq proto.InternalMessageInfo

type ArcPassedReply struct {
	// archives 稿件信息列表
	Archives []*Arc `protobuf:"bytes,1,rep,name=archives,proto3" json:"archives"`
	// total 稿件总数
	Total                int64    `protobuf:"varint,2,opt,name=total,proto3" json:"total"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassedReply) Reset()         { *m = ArcPassedReply{} }
func (m *ArcPassedReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedReply) ProtoMessage()    {}
func (*ArcPassedReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *ArcPassedReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedReply.Merge(m, src)
}
func (m *ArcPassedReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedReply proto.InternalMessageInfo

type Arc struct {
	Aid int64 `protobuf:"varint,1,opt,name=Aid,json=aid,proto3" json:"aid"`
	// 稿件一共有多少分P
	Videos int64 `protobuf:"varint,2,opt,name=Videos,json=videos,proto3" json:"videos"`
	// 分区ID
	TypeID int32 `protobuf:"varint,3,opt,name=TypeID,json=tid,proto3" json:"tid"`
	// 分区名
	TypeName string `protobuf:"bytes,4,opt,name=TypeName,json=tname,proto3" json:"tname"`
	// 是否转载  1=原创  2=转载 0=历史上可能遗留的脏数据
	Copyright int32 `protobuf:"varint,5,opt,name=Copyright,json=copyright,proto3" json:"copyright"`
	// 稿件封面图地址，绝对地址 如 http://i0.hdslb.com/bfs/xxx.jpg
	Pic string `protobuf:"bytes,6,opt,name=Pic,json=pic,proto3" json:"pic"`
	// 稿件标题
	Title string `protobuf:"bytes,7,opt,name=Title,json=title,proto3" json:"title"`
	// 稿件发布时间 对外展示的标准时间  时间戳格式
	PubDate go_common_library_time.Time `protobuf:"varint,8,opt,name=PubDate,json=pubdate,proto3,casttype=go-common/library/time.Time" json:"pubdate"`
	// 用户提交稿件的时间 一般不对外展示 时间戳格式
	Ctime go_common_library_time.Time `protobuf:"varint,9,opt,name=Ctime,json=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	// 稿件简介
	Desc string `protobuf:"bytes,10,opt,name=Desc,json=desc,proto3" json:"desc"`
	// 稿件状态，>=0为前台用户可见状态，其他值详见 http://info.bilibili.co/pages/viewpage.action?pageId=3686597#id-%E7%A8%BF%E4%BB%B6%E5%AD%97%E6%AE%B5%E6%9E%9A%E4%B8%BE%E5%80%BC%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E-%E7%A8%BF%E4%BB%B6%E7%8A%B6%E6%80%81state&access
	State int32 `protobuf:"varint,11,opt,name=State,json=state,proto3" json:"state"`
	// 稿件访问属性 0=全员可见 10000=登录用户可见（极少)
	Access int32 `protobuf:"varint,12,opt,name=Access,json=access,proto3" json:"access,omitempty"`
	// 稿件属性 详见State字段的文档
	Attribute int32 `protobuf:"varint,13,opt,name=Attribute,json=attribute,proto3" json:"attribute,omitempty"`
	// 废弃字段
	Tag string `protobuf:"bytes,14,opt,name=Tag,proto3" json:"-"`
	// 废弃字段
	Tags []string `protobuf:"bytes,15,rep,name=Tags,json=tags,proto3" json:"tags,omitempty"`
	// 稿件总时长（所有分P加起来的） 单位=秒
	Duration int64 `protobuf:"varint,16,opt,name=Duration,json=duration,proto3" json:"duration"`
	// 稿件绑定的活动id
	MissionID int64 `protobuf:"varint,17,opt,name=MissionID,json=mission_id,proto3" json:"mission_id,omitempty"`
	// 稿件绑定的商单id
	OrderID int64 `protobuf:"varint,18,opt,name=OrderID,json=order_id,proto3" json:"order_id,omitempty"`
	// 稿件后台设置的强制跳转地址，如果该值不为空，则必须调转到它对应的页面上
	RedirectURL string `protobuf:"bytes,19,opt,name=RedirectURL,json=redirect_url,proto3" json:"redirect_url,omitempty"`
	Forward     int64  `protobuf:"varint,20,opt,name=Forward,json=forward,proto3" json:"forward,omitempty"`
	// 见Rights字段说明
	Rights Rights `protobuf:"bytes,21,opt,name=Rights,json=rights,proto3" json:"rights"`
	// 稿件作者信息，详见Author字段说明
	Author Author `protobuf:"bytes,22,opt,name=Author,json=owner,proto3" json:"owner"`
	// 稿件计数信息，详见Stat字段说明
	Stat         Stat   `protobuf:"bytes,23,opt,name=Stat,json=stat,proto3" json:"stat"`
	ReportResult string `protobuf:"bytes,24,opt,name=ReportResult,json=report_result,proto3" json:"report_result,omitempty"`
	// 发布稿件时Up主设置的动态描述（仅在动态展示）
	Dynamic string `protobuf:"bytes,25,opt,name=Dynamic,json=dynamic,proto3" json:"dynamic"`
	// 稿件第一P的cid，供秒开使用
	FirstCid int64 `protobuf:"varint,26,opt,name=FirstCid,json=cid,proto3" json:"cid,omitempty"`
	// 稿件第一P的分辨率，详见Dimession字段说明
	Dimension Dimension `protobuf:"bytes,27,opt,name=Dimension,json=dimension,proto3" json:"dimension,omitempty"`
	// 联合投稿信息，内部使用，详见StaffInfo说明
	StaffInfo []*StaffInfo `protobuf:"bytes,28,rep,name=StaffInfo,proto3" json:"-"`
	// 剧集ID
	SeasonID int64 `protobuf:"varint,29,opt,name=SeasonID,json=season_id,proto3" json:"season_id,omitempty"`
	// 新版attibute属性，老业务的int32已经用完
	AttributeV2 int64 `protobuf:"varint,30,opt,name=AttributeV2,json=attribute_v2,proto3" json:"attribute_v2,omitempty"`
	// 活动合集主题色（仅在 Arcs、ArcsWithPlayurl、Views 接口会赋值）
	SeasonTheme *SeasonTheme `protobuf:"bytes,31,opt,name=season_theme,json=seasonTheme,proto3" json:"season_theme,omitempty"`
	// 短链
	ShortLink string `protobuf:"bytes,32,opt,name=short_link,json=shortLink,proto3" json:"short_link,omitempty"`
	// 投稿来源(仅22-直播回放有效)
	UpFrom               int32    `protobuf:"varint,33,opt,name=up_from,json=upFrom,proto3" json:"up_from,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Arc) Reset()         { *m = Arc{} }
func (m *Arc) String() string { return proto.CompactTextString(m) }
func (*Arc) ProtoMessage()    {}
func (*Arc) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *Arc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Arc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Arc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Arc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Arc.Merge(m, src)
}
func (m *Arc) XXX_Size() int {
	return m.Size()
}
func (m *Arc) XXX_DiscardUnknown() {
	xxx_messageInfo_Arc.DiscardUnknown(m)
}

var xxx_messageInfo_Arc proto.InternalMessageInfo

// 活动合集主题色
type SeasonTheme struct {
	// 背景色
	BgColor string `protobuf:"bytes,1,opt,name=bg_color,json=bgColor,proto3" json:"bg_color,omitempty"`
	// 选中背景色
	SelectedBgColor string `protobuf:"bytes,2,opt,name=selected_bg_color,json=selectedBgColor,proto3" json:"selected_bg_color,omitempty"`
	// 字色
	TextColor            string   `protobuf:"bytes,3,opt,name=text_color,json=textColor,proto3" json:"text_color,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SeasonTheme) Reset()         { *m = SeasonTheme{} }
func (m *SeasonTheme) String() string { return proto.CompactTextString(m) }
func (*SeasonTheme) ProtoMessage()    {}
func (*SeasonTheme) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *SeasonTheme) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeasonTheme) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeasonTheme.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeasonTheme) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeasonTheme.Merge(m, src)
}
func (m *SeasonTheme) XXX_Size() int {
	return m.Size()
}
func (m *SeasonTheme) XXX_DiscardUnknown() {
	xxx_messageInfo_SeasonTheme.DiscardUnknown(m)
}

var xxx_messageInfo_SeasonTheme proto.InternalMessageInfo

type StaffInfo struct {
	// 联合投稿的成员Up主id
	Mid int64 `protobuf:"varint,1,opt,name=Mid,json=mid,proto3" json:"mid"`
	// 联合投稿的成员角色（如 声优、字幕）
	Title string `protobuf:"bytes,2,opt,name=Title,json=title,proto3" json:"title"`
	// 属性位（文档见https://info.bilibili.co/pages/viewpage.action?pageId=83773767）
	Attribute            int64    `protobuf:"varint,3,opt,name=Attribute,proto3" json:"Attribute,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StaffInfo) Reset()         { *m = StaffInfo{} }
func (m *StaffInfo) String() string { return proto.CompactTextString(m) }
func (*StaffInfo) ProtoMessage()    {}
func (*StaffInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *StaffInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaffInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaffInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaffInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaffInfo.Merge(m, src)
}
func (m *StaffInfo) XXX_Size() int {
	return m.Size()
}
func (m *StaffInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StaffInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StaffInfo proto.InternalMessageInfo

// Dimension 视频分辨率
type Dimension struct {
	// 宽 如 1920
	Width int64 `protobuf:"varint,1,opt,name=Width,json=width,proto3" json:"width"`
	// 高 如 1080
	Height int64 `protobuf:"varint,2,opt,name=Height,json=height,proto3" json:"height"`
	// 是否翻转 0=否 1=是
	Rotate               int64    `protobuf:"varint,3,opt,name=Rotate,json=rotate,proto3" json:"rotate"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Dimension) Reset()         { *m = Dimension{} }
func (m *Dimension) String() string { return proto.CompactTextString(m) }
func (*Dimension) ProtoMessage()    {}
func (*Dimension) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *Dimension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dimension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dimension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dimension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dimension.Merge(m, src)
}
func (m *Dimension) XXX_Size() int {
	return m.Size()
}
func (m *Dimension) XXX_DiscardUnknown() {
	xxx_messageInfo_Dimension.DiscardUnknown(m)
}

var xxx_messageInfo_Dimension proto.InternalMessageInfo

// Rights 稿件各常用属性 0=否 1=是
type Rights struct {
	// 老版是否付费
	Bp int32 `protobuf:"varint,1,opt,name=Bp,json=bp,proto3" json:"bp"`
	// 是否支持充电 （不可直接使用，网关层请求业务方后才有值）
	Elec int32 `protobuf:"varint,2,opt,name=Elec,json=elec,proto3" json:"elec"`
	// 是否下载（不可直接使用，网关层请求业务方后才有值）
	Download int32 `protobuf:"varint,3,opt,name=Download,json=download,proto3" json:"download"`
	// 是否电影
	Movie int32 `protobuf:"varint,4,opt,name=Movie,json=download,proto3" json:"download"`
	// 是否PGC付费
	Pay int32 `protobuf:"varint,5,opt,name=Pay,json=pay,proto3" json:"pay"`
	// 无用
	HD5 int32 `protobuf:"varint,6,opt,name=HD5,json=hd5,proto3" json:"hd5"`
	// 是否允许转发
	NoReprint int32 `protobuf:"varint,7,opt,name=NoReprint,json=no_reprint,proto3" json:"no_reprint"`
	// 是否可以自动播放
	Autoplay int32 `protobuf:"varint,8,opt,name=Autoplay,json=autoplay,proto3" json:"autoplay"`
	// 是否UGC付费
	UGCPay int32 `protobuf:"varint,9,opt,name=UGCPay,json=ugc_pay,proto3" json:"ugc_pay"`
	// 是否联合投稿
	IsCooperation int32 `protobuf:"varint,10,opt,name=IsCooperation,json=is_cooperation,proto3" json:"is_cooperation"`
	// 是否有UGC付费预览
	UGCPayPreview int32 `protobuf:"varint,11,opt,name=UGCPayPreview,json=ugc_pay_preview,proto3" json:"ugc_pay_preview"`
	// 是否禁止后台播放
	NoBackground int32 `protobuf:"varint,12,opt,name=NoBackground,json=no_background,proto3" json:"no_background"`
	// 是否付费稿件(attribute_v2 右移13位为付费时)
	ArcPay int32 `protobuf:"varint,13,opt,name=ArcPay,json=arc_pay,proto3" json:"arc_pay"`
	// 是否付费稿件可免费观看, 0无法观看, 1合集内免费观看
	ArcPayFreeWatch      int32    `protobuf:"varint,14,opt,name=ArcPayFreeWatch,json=pay_free_watch,proto3" json:"pay_free_watch"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rights) Reset()         { *m = Rights{} }
func (m *Rights) String() string { return proto.CompactTextString(m) }
func (*Rights) ProtoMessage()    {}
func (*Rights) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *Rights) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rights) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rights.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rights) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rights.Merge(m, src)
}
func (m *Rights) XXX_Size() int {
	return m.Size()
}
func (m *Rights) XXX_DiscardUnknown() {
	xxx_messageInfo_Rights.DiscardUnknown(m)
}

var xxx_messageInfo_Rights proto.InternalMessageInfo

// Author 稿件作者信息
type Author struct {
	// Up主mid
	Mid int64 `protobuf:"varint,1,opt,name=Mid,json=mid,proto3" json:"mid"`
	// Up主名称
	Name string `protobuf:"bytes,2,opt,name=Name,json=name,proto3" json:"name"`
	// Up主头像地址 绝对地址
	Face                 string   `protobuf:"bytes,3,opt,name=Face,json=face,proto3" json:"face"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Author) Reset()         { *m = Author{} }
func (m *Author) String() string { return proto.CompactTextString(m) }
func (*Author) ProtoMessage()    {}
func (*Author) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *Author) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Author) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Author.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Author) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Author.Merge(m, src)
}
func (m *Author) XXX_Size() int {
	return m.Size()
}
func (m *Author) XXX_DiscardUnknown() {
	xxx_messageInfo_Author.DiscardUnknown(m)
}

var xxx_messageInfo_Author proto.InternalMessageInfo

// Stat 稿件的所有计数信息
type Stat struct {
	Aid int64 `protobuf:"varint,1,opt,name=Aid,json=aid,proto3" json:"aid"`
	// 播放数
	View int32 `protobuf:"varint,2,opt,name=View,json=view,proto3" json:"view"`
	// 弹幕数
	Danmaku int32 `protobuf:"varint,3,opt,name=Danmaku,json=danmaku,proto3" json:"danmaku"`
	// 评论数
	Reply int32 `protobuf:"varint,4,opt,name=Reply,json=reply,proto3" json:"reply"`
	// 收藏数
	Fav int32 `protobuf:"varint,5,opt,name=Fav,json=favorite,proto3" json:"favorite"`
	// 投币数
	Coin int32 `protobuf:"varint,6,opt,name=Coin,json=coin,proto3" json:"coin"`
	// 分享数
	Share int32 `protobuf:"varint,7,opt,name=Share,json=share,proto3" json:"share"`
	// 当前排名
	NowRank int32 `protobuf:"varint,8,opt,name=NowRank,json=now_rank,proto3" json:"now_rank"`
	// 历史最高排名
	HisRank int32 `protobuf:"varint,9,opt,name=HisRank,json=his_rank,proto3" json:"his_rank"`
	// 点赞数
	Like int32 `protobuf:"varint,10,opt,name=Like,json=like,proto3" json:"like"`
	// 点踩数 已取消前台展示，现在均返回0
	DisLike int32 `protobuf:"varint,11,opt,name=DisLike,json=dislike,proto3" json:"dislike"`
	// 追番数 内部冗余数据，请勿使用
	Follow               int32    `protobuf:"varint,12,opt,name=Follow,proto3" json:"-"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Stat) Reset()         { *m = Stat{} }
func (m *Stat) String() string { return proto.CompactTextString(m) }
func (*Stat) ProtoMessage()    {}
func (*Stat) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *Stat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stat.Merge(m, src)
}
func (m *Stat) XXX_Size() int {
	return m.Size()
}
func (m *Stat) XXX_DiscardUnknown() {
	xxx_messageInfo_Stat.DiscardUnknown(m)
}

var xxx_messageInfo_Stat proto.InternalMessageInfo

type ArcPassedTotalReq struct {
	// mid 用户id 必传
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"min=1"`
	// Deprecated: 废弃，请使用without
	WithoutStaff bool `protobuf:"varint,2,opt,name=without_staff,json=withoutStaff,proto3" json:"without_staff,omitempty" form:"without_staff"`
	// without 去除特定类型稿件
	Without []Without `protobuf:"varint,3,rep,packed,name=without,proto3,enum=up.archive.service.v1.Without" json:"without,omitempty" form:"without"`
	// tid 一级分区ID
	Tid                  int64    `protobuf:"varint,4,opt,name=tid,proto3" json:"tid,omitempty" form:"tid" validate:"min=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassedTotalReq) Reset()         { *m = ArcPassedTotalReq{} }
func (m *ArcPassedTotalReq) String() string { return proto.CompactTextString(m) }
func (*ArcPassedTotalReq) ProtoMessage()    {}
func (*ArcPassedTotalReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *ArcPassedTotalReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedTotalReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedTotalReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedTotalReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedTotalReq.Merge(m, src)
}
func (m *ArcPassedTotalReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedTotalReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedTotalReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedTotalReq proto.InternalMessageInfo

type ArcPassedTotalReply struct {
	// total 稿件总数
	Total                int64    `protobuf:"varint,2,opt,name=total,proto3" json:"total"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassedTotalReply) Reset()         { *m = ArcPassedTotalReply{} }
func (m *ArcPassedTotalReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedTotalReply) ProtoMessage()    {}
func (*ArcPassedTotalReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *ArcPassedTotalReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedTotalReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedTotalReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedTotalReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedTotalReply.Merge(m, src)
}
func (m *ArcPassedTotalReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedTotalReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedTotalReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedTotalReply proto.InternalMessageInfo

type ArcPassedCursorReq struct {
	// mid 用户id 必传
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"min=1"`
	// 上次请求最后一项数据score值
	Score int64 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty" form:"score"`
	// ps 请求个数
	Ps int64 `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" validate:"min=1,max=50"`
	// sort 排序方式 非必传 desc:降序 asc:升序 (默认降序)
	Sort string `protobuf:"bytes,4,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	// Deprecated: 废弃，请使用without
	WithoutStaff bool `protobuf:"varint,5,opt,name=without_staff,json=withoutStaff,proto3" json:"without_staff,omitempty" form:"without_staff"`
	// without 去除特定类型稿件
	Without              []Without `protobuf:"varint,6,rep,packed,name=without,proto3,enum=up.archive.service.v1.Without" json:"without,omitempty" form:"without"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ArcPassedCursorReq) Reset()         { *m = ArcPassedCursorReq{} }
func (m *ArcPassedCursorReq) String() string { return proto.CompactTextString(m) }
func (*ArcPassedCursorReq) ProtoMessage()    {}
func (*ArcPassedCursorReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *ArcPassedCursorReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedCursorReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedCursorReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedCursorReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedCursorReq.Merge(m, src)
}
func (m *ArcPassedCursorReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedCursorReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedCursorReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedCursorReq proto.InternalMessageInfo

type ArcPassedCursorReply struct {
	// archives 稿件信息列表
	List                 []*ArcPassed `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ArcPassedCursorReply) Reset()         { *m = ArcPassedCursorReply{} }
func (m *ArcPassedCursorReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedCursorReply) ProtoMessage()    {}
func (*ArcPassedCursorReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *ArcPassedCursorReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedCursorReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedCursorReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedCursorReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedCursorReply.Merge(m, src)
}
func (m *ArcPassedCursorReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedCursorReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedCursorReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedCursorReply proto.InternalMessageInfo

type ArcPassed struct {
	// 稿件aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid"`
	// 稿件score
	Score                int64    `protobuf:"varint,2,opt,name=score,proto3" json:"score"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassed) Reset()         { *m = ArcPassed{} }
func (m *ArcPassed) String() string { return proto.CompactTextString(m) }
func (*ArcPassed) ProtoMessage()    {}
func (*ArcPassed) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *ArcPassed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassed.Merge(m, src)
}
func (m *ArcPassed) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassed) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassed.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassed proto.InternalMessageInfo

type ArcPassedStoryReq struct {
	// mid 用户id 必传
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"min=1"`
	// aid 稿件aid
	Aid int64 `protobuf:"varint,2,opt,name=aid,proto3" json:"aid,omitempty" form:"aid"`
	// sort 排序方式 非必传 desc:降序 asc:升序 (默认降序)
	Sort string `protobuf:"bytes,3,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	// prev_count 是否需要aid排序前的稿件，和next_count两个必传一个
	PrevCount int64 `protobuf:"varint,4,opt,name=prev_count,json=prevCount,proto3" json:"prev_count,omitempty" form:"prev_count"`
	// next_count 是否需要aid排序后的稿件，和prev_count两个必传一个
	NextCount int64 `protobuf:"varint,5,opt,name=next_count,json=nextCount,proto3" json:"next_count,omitempty" form:"next_count"`
	// rank aid在当前排序下rank值，从1开始
	Rank                 int64    `protobuf:"varint,6,opt,name=rank,proto3" json:"rank,omitempty" form:"rank"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassedStoryReq) Reset()         { *m = ArcPassedStoryReq{} }
func (m *ArcPassedStoryReq) String() string { return proto.CompactTextString(m) }
func (*ArcPassedStoryReq) ProtoMessage()    {}
func (*ArcPassedStoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *ArcPassedStoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedStoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedStoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedStoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedStoryReq.Merge(m, src)
}
func (m *ArcPassedStoryReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedStoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedStoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedStoryReq proto.InternalMessageInfo

type ArcPassedStoryReply struct {
	// 请求aid是第几个稿件，从1开始
	Rank int64 `protobuf:"varint,1,opt,name=rank,proto3" json:"rank"`
	// 列表总稿件数
	Total int64 `protobuf:"varint,2,opt,name=total,proto3" json:"total"`
	// 请求aid前的列表
	PrevArcs []*StoryArcs `protobuf:"bytes,3,rep,name=prev_arcs,json=prev_aids,proto3" json:"prev_aids"`
	// 请求aid后的列表
	NextArcs             []*StoryArcs `protobuf:"bytes,4,rep,name=next_arcs,json=next_aids,proto3" json:"next_aids"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ArcPassedStoryReply) Reset()         { *m = ArcPassedStoryReply{} }
func (m *ArcPassedStoryReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedStoryReply) ProtoMessage()    {}
func (*ArcPassedStoryReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *ArcPassedStoryReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedStoryReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedStoryReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedStoryReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedStoryReply.Merge(m, src)
}
func (m *ArcPassedStoryReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedStoryReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedStoryReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedStoryReply proto.InternalMessageInfo

type StoryArcs struct {
	// aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid"`
	// aid在当前排序规则下rank值，从1开始
	Rank                 int64    `protobuf:"varint,2,opt,name=rank,proto3" json:"rank"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoryArcs) Reset()         { *m = StoryArcs{} }
func (m *StoryArcs) String() string { return proto.CompactTextString(m) }
func (*StoryArcs) ProtoMessage()    {}
func (*StoryArcs) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *StoryArcs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoryArcs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoryArcs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoryArcs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoryArcs.Merge(m, src)
}
func (m *StoryArcs) XXX_Size() int {
	return m.Size()
}
func (m *StoryArcs) XXX_DiscardUnknown() {
	xxx_messageInfo_StoryArcs.DiscardUnknown(m)
}

var xxx_messageInfo_StoryArcs proto.InternalMessageInfo

type ArcsPassedReq struct {
	// mids 用户id 必传
	Mids []int64 `protobuf:"varint,1,rep,packed,name=mids,proto3" json:"mids,omitempty" form:"mids,split" validate:"min=1,max=100,dive,gt=0"`
	// pn 第几页
	Pn int64 `protobuf:"varint,2,opt,name=pn,proto3" json:"pn,omitempty" form:"pn" validate:"min=1"`
	// ps 分页大小
	Ps int64 `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" validate:"min=1,max=50"`
	// sort 排序方式 非必传 desc:降序 asc:升序 (默认降序)
	Sort string `protobuf:"bytes,4,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	// without_staff 是否去除联合投稿稿件
	WithoutStaff         bool     `protobuf:"varint,5,opt,name=without_staff,json=withoutStaff,proto3" json:"without_staff,omitempty" form:"without_staff"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcsPassedReq) Reset()         { *m = ArcsPassedReq{} }
func (m *ArcsPassedReq) String() string { return proto.CompactTextString(m) }
func (*ArcsPassedReq) ProtoMessage()    {}
func (*ArcsPassedReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *ArcsPassedReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsPassedReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsPassedReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsPassedReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsPassedReq.Merge(m, src)
}
func (m *ArcsPassedReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcsPassedReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsPassedReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsPassedReq proto.InternalMessageInfo

type ArcsPassedReply struct {
	Archives             map[int64]*ArcPassedReply `protobuf:"bytes,1,rep,name=archives,proto3" json:"archives" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ArcsPassedReply) Reset()         { *m = ArcsPassedReply{} }
func (m *ArcsPassedReply) String() string { return proto.CompactTextString(m) }
func (*ArcsPassedReply) ProtoMessage()    {}
func (*ArcsPassedReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *ArcsPassedReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsPassedReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsPassedReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsPassedReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsPassedReply.Merge(m, src)
}
func (m *ArcsPassedReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcsPassedReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsPassedReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsPassedReply proto.InternalMessageInfo

type ArcsPassedTotalReq struct {
	// mids 用户id 必传
	Mids []int64 `protobuf:"varint,1,rep,packed,name=mids,proto3" json:"mids,omitempty" form:"mids,split" validate:"min=1,max=100,dive,gt=0"`
	// without_staff 不带联合投稿稿件
	WithoutStaff         bool     `protobuf:"varint,2,opt,name=without_staff,json=withoutStaff,proto3" json:"without_staff,omitempty" form:"without_staff"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcsPassedTotalReq) Reset()         { *m = ArcsPassedTotalReq{} }
func (m *ArcsPassedTotalReq) String() string { return proto.CompactTextString(m) }
func (*ArcsPassedTotalReq) ProtoMessage()    {}
func (*ArcsPassedTotalReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *ArcsPassedTotalReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsPassedTotalReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsPassedTotalReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsPassedTotalReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsPassedTotalReq.Merge(m, src)
}
func (m *ArcsPassedTotalReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcsPassedTotalReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsPassedTotalReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsPassedTotalReq proto.InternalMessageInfo

type ArcsPassedTotalReply struct {
	// total 稿件总数
	Total                map[int64]int64 `protobuf:"bytes,1,rep,name=total,proto3" json:"total" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ArcsPassedTotalReply) Reset()         { *m = ArcsPassedTotalReply{} }
func (m *ArcsPassedTotalReply) String() string { return proto.CompactTextString(m) }
func (*ArcsPassedTotalReply) ProtoMessage()    {}
func (*ArcsPassedTotalReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *ArcsPassedTotalReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsPassedTotalReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsPassedTotalReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsPassedTotalReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsPassedTotalReply.Merge(m, src)
}
func (m *ArcsPassedTotalReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcsPassedTotalReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsPassedTotalReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsPassedTotalReply proto.InternalMessageInfo

type ArcPassedByAidReq struct {
	// mid 用户id 必传
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"min=1"`
	// aid 为0，或者传递了错误的aid，则默认从第一页开始
	Aid int64 `protobuf:"varint,2,opt,name=aid,proto3" json:"aid,omitempty" form:"aid" validate:"min=0"`
	// ps 请求个数
	Ps int64 `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" validate:"min=1,max=100"`
	// sort 排序方式 非必传 desc:降序 asc:升序 (默认降序)
	Sort string `protobuf:"bytes,4,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	// Deprecated: 废弃，请使用without
	WithoutStaff bool `protobuf:"varint,5,opt,name=without_staff,json=withoutStaff,proto3" json:"without_staff,omitempty" form:"without_staff"`
	// without 去除特定类型稿件
	Without []Without `protobuf:"varint,6,rep,packed,name=without,proto3,enum=up.archive.service.v1.Without" json:"without,omitempty" form:"without"`
	// tid 一级分区ID
	Tid int64 `protobuf:"varint,7,opt,name=tid,proto3" json:"tid,omitempty" form:"tid" validate:"min=0"`
	// order 排序字段 非必传 (默认稿件发布时间)
	Order                SearchOrder `protobuf:"varint,8,opt,name=order,proto3,enum=up.archive.service.v1.SearchOrder" json:"order,omitempty" form:"order"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ArcPassedByAidReq) Reset()         { *m = ArcPassedByAidReq{} }
func (m *ArcPassedByAidReq) String() string { return proto.CompactTextString(m) }
func (*ArcPassedByAidReq) ProtoMessage()    {}
func (*ArcPassedByAidReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *ArcPassedByAidReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedByAidReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedByAidReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedByAidReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedByAidReq.Merge(m, src)
}
func (m *ArcPassedByAidReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedByAidReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedByAidReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedByAidReq proto.InternalMessageInfo

type ArcPassedWithIndex struct {
	// archives 稿件信息列表
	Archive *ArcPassed `protobuf:"bytes,1,opt,name=archive,proto3" json:"archive"`
	// rank
	Rank                 int64    `protobuf:"varint,2,opt,name=rank,proto3" json:"rank"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassedWithIndex) Reset()         { *m = ArcPassedWithIndex{} }
func (m *ArcPassedWithIndex) String() string { return proto.CompactTextString(m) }
func (*ArcPassedWithIndex) ProtoMessage()    {}
func (*ArcPassedWithIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *ArcPassedWithIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedWithIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedWithIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedWithIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedWithIndex.Merge(m, src)
}
func (m *ArcPassedWithIndex) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedWithIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedWithIndex.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedWithIndex proto.InternalMessageInfo

// ArcPassedByAidReply 单个up主的稿件aid列表通过aid拉取的返回结果
type ArcPassedByAidReply struct {
	// aids 稿件aid列表
	Archives []*ArcPassedWithIndex `protobuf:"bytes,1,rep,name=archives,proto3" json:"archives"`
	// total 稿件总数
	Total                int64        `protobuf:"varint,2,opt,name=total,proto3" json:"total"`
	Cursor               *CursorReply `protobuf:"bytes,3,opt,name=cursor,proto3" json:"cursor"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ArcPassedByAidReply) Reset()         { *m = ArcPassedByAidReply{} }
func (m *ArcPassedByAidReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedByAidReply) ProtoMessage()    {}
func (*ArcPassedByAidReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *ArcPassedByAidReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedByAidReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedByAidReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedByAidReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedByAidReply.Merge(m, src)
}
func (m *ArcPassedByAidReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedByAidReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedByAidReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedByAidReply proto.InternalMessageInfo

type CursorReply struct {
	// 是否还有数据
	HasMore              bool     `protobuf:"varint,1,opt,name=has_more,proto3" json:"has_more"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CursorReply) Reset()         { *m = CursorReply{} }
func (m *CursorReply) String() string { return proto.CompactTextString(m) }
func (*CursorReply) ProtoMessage()    {}
func (*CursorReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *CursorReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CursorReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CursorReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CursorReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CursorReply.Merge(m, src)
}
func (m *CursorReply) XXX_Size() int {
	return m.Size()
}
func (m *CursorReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CursorReply.DiscardUnknown(m)
}

var xxx_messageInfo_CursorReply proto.InternalMessageInfo

// UpsArcsReq 多个up主的稿件列表信息请求参数
type UpsArcsReq struct {
	// mids 多个用户id 必传 最大100个
	Mids []int64 `protobuf:"varint,1,rep,packed,name=mids,proto3" json:"mids,omitempty" form:"mids,split" validate:"min=1,max=100"`
	// pn 第几页
	Pn int64 `protobuf:"varint,2,opt,name=pn,proto3" json:"pn,omitempty" form:"pn" validate:"min=1"`
	// ps 分页大小
	Ps int64 `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" validate:"min=1,max=50"`
	// without_staff 是否去除联合投稿稿件
	WithoutStaff         bool     `protobuf:"varint,4,opt,name=without_staff,json=withoutStaff,proto3" json:"without_staff,omitempty" form:"without_staff"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpsArcsReq) Reset()         { *m = UpsArcsReq{} }
func (m *UpsArcsReq) String() string { return proto.CompactTextString(m) }
func (*UpsArcsReq) ProtoMessage()    {}
func (*UpsArcsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *UpsArcsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsArcsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsArcsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsArcsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsArcsReq.Merge(m, src)
}
func (m *UpsArcsReq) XXX_Size() int {
	return m.Size()
}
func (m *UpsArcsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsArcsReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpsArcsReq proto.InternalMessageInfo

// UpsAidPubTimeReply 按发布时间的多个up的稿件aid的返回值
type UpsAidPubTimeReply struct {
	// archives 稿件信息列表
	Archives             map[int64]*UpAidPubTimeReply `protobuf:"bytes,1,rep,name=archives,proto3" json:"archives" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *UpsAidPubTimeReply) Reset()         { *m = UpsAidPubTimeReply{} }
func (m *UpsAidPubTimeReply) String() string { return proto.CompactTextString(m) }
func (*UpsAidPubTimeReply) ProtoMessage()    {}
func (*UpsAidPubTimeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *UpsAidPubTimeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsAidPubTimeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsAidPubTimeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsAidPubTimeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsAidPubTimeReply.Merge(m, src)
}
func (m *UpsAidPubTimeReply) XXX_Size() int {
	return m.Size()
}
func (m *UpsAidPubTimeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsAidPubTimeReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpsAidPubTimeReply proto.InternalMessageInfo

// UpAidPubTimeReply 按发布时间的单个up的稿件aid的返回值
type UpAidPubTimeReply struct {
	// archives 稿件信息列表
	Archives             []*AidPubTime `protobuf:"bytes,1,rep,name=archives,proto3" json:"archives"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpAidPubTimeReply) Reset()         { *m = UpAidPubTimeReply{} }
func (m *UpAidPubTimeReply) String() string { return proto.CompactTextString(m) }
func (*UpAidPubTimeReply) ProtoMessage()    {}
func (*UpAidPubTimeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *UpAidPubTimeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpAidPubTimeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpAidPubTimeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpAidPubTimeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpAidPubTimeReply.Merge(m, src)
}
func (m *UpAidPubTimeReply) XXX_Size() int {
	return m.Size()
}
func (m *UpAidPubTimeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpAidPubTimeReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpAidPubTimeReply proto.InternalMessageInfo

// AidPubTime 发布时间的稿件aid的信息
type AidPubTime struct {
	// aid 稿件aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid"`
	// pubdate 发布时间
	Pubdate go_common_library_time.Time `protobuf:"varint,2,opt,name=pubdate,proto3,casttype=go-common/library/time.Time" json:"pubdate"`
	// copyright 版权来源
	Copyright            int32    `protobuf:"varint,3,opt,name=copyright,proto3" json:"copyright"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AidPubTime) Reset()         { *m = AidPubTime{} }
func (m *AidPubTime) String() string { return proto.CompactTextString(m) }
func (*AidPubTime) ProtoMessage()    {}
func (*AidPubTime) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *AidPubTime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AidPubTime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AidPubTime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AidPubTime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AidPubTime.Merge(m, src)
}
func (m *AidPubTime) XXX_Size() int {
	return m.Size()
}
func (m *AidPubTime) XXX_DiscardUnknown() {
	xxx_messageInfo_AidPubTime.DiscardUnknown(m)
}

var xxx_messageInfo_AidPubTime proto.InternalMessageInfo

type ArcPassedSearchReq struct {
	// mid 用户id 必传
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"min=1"`
	// tid 一级分区ID
	Tid int64 `protobuf:"varint,2,opt,name=tid,proto3" json:"tid,omitempty" form:"tid" validate:"min=0"`
	// keyword 搜索关键字
	Keyword string `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty" form:"keyword" validate:"max=50"`
	// highlight 高亮
	Highlight bool `protobuf:"varint,4,opt,name=highlight,proto3" json:"highlight,omitempty" form:"highlight"`
	// pn 第几页 默认1
	Pn int64 `protobuf:"varint,5,opt,name=pn,proto3" json:"pn,omitempty" form:"pn" validate:"min=1"`
	// ps 分页大小 最大100
	Ps int64 `protobuf:"varint,6,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" validate:"min=1,max=100"`
	// order 排序字段 非必传 (默认稿件发布时间)
	Order SearchOrder `protobuf:"varint,7,opt,name=order,proto3,enum=up.archive.service.v1.SearchOrder" json:"order,omitempty" form:"order"`
	// sort 排序方式 非必传 desc:降序 asc:升序 (默认降序)
	Sort string `protobuf:"bytes,8,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	// hasTags 是否需要稿件标签列表
	HasTags bool `protobuf:"varint,9,opt,name=hasTags,proto3" json:"hasTags,omitempty" form:"has_tags"`
	// kw_fields 搜索关键字匹配哪些字段 (默认标题和描述都匹配)
	KwFields []KwField `protobuf:"varint,10,rep,packed,name=kw_fields,json=kwFields,proto3,enum=up.archive.service.v1.KwField" json:"kw_fields,omitempty" form:"kw_fields"`
	// without 去除特定类型稿件
	Without              []Without `protobuf:"varint,11,rep,packed,name=without,proto3,enum=up.archive.service.v1.Without" json:"without,omitempty" form:"without"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ArcPassedSearchReq) Reset()         { *m = ArcPassedSearchReq{} }
func (m *ArcPassedSearchReq) String() string { return proto.CompactTextString(m) }
func (*ArcPassedSearchReq) ProtoMessage()    {}
func (*ArcPassedSearchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *ArcPassedSearchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedSearchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedSearchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedSearchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedSearchReq.Merge(m, src)
}
func (m *ArcPassedSearchReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedSearchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedSearchReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedSearchReq proto.InternalMessageInfo

type ArcPassedSearchReply struct {
	// tags 稿件标签列表
	Tags []*Tag `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags"`
	// archives 稿件信息列表
	Archives []*Arc `protobuf:"bytes,2,rep,name=archives,proto3" json:"archives"`
	// total 列表总稿件数
	Total                int64    `protobuf:"varint,3,opt,name=total,proto3" json:"total"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassedSearchReply) Reset()         { *m = ArcPassedSearchReply{} }
func (m *ArcPassedSearchReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedSearchReply) ProtoMessage()    {}
func (*ArcPassedSearchReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *ArcPassedSearchReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedSearchReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedSearchReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedSearchReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedSearchReply.Merge(m, src)
}
func (m *ArcPassedSearchReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedSearchReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedSearchReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedSearchReply proto.InternalMessageInfo

type Tag struct {
	// tid 一级分区ID
	Tid int64 `protobuf:"varint,1,opt,name=tid,proto3" json:"tid"`
	// name 一级分区名
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	// count 同一分区的稿件数
	Count                int64    `protobuf:"varint,3,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
	return m.Size()
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

type ArcsPassedSortReq struct {
	// mid 用户id 必传
	Mids []int64 `protobuf:"varint,1,rep,packed,name=mids,proto3" json:"mids,omitempty" form:"mids,split" validate:"min=1,max=10,dive,gt=0"`
	// tid 一级分区ID
	Tid int64 `protobuf:"varint,2,opt,name=tid,proto3" json:"tid,omitempty" form:"tid" validate:"min=0"`
	// ps 请求个数 最大50
	Ps int64 `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty" form:"ps" validate:"min=1,max=50"`
	// order 排序字段 非必传 (默认稿件发布时间)
	Order SearchOrder `protobuf:"varint,4,opt,name=order,proto3,enum=up.archive.service.v1.SearchOrder" json:"order,omitempty" form:"order"`
	// sort 排序方式 非必传 desc:降序 asc:升序 (默认降序)
	Sort                 Sort     `protobuf:"varint,5,opt,name=sort,proto3,enum=up.archive.service.v1.Sort" json:"sort,omitempty" form:"sort"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcsPassedSortReq) Reset()         { *m = ArcsPassedSortReq{} }
func (m *ArcsPassedSortReq) String() string { return proto.CompactTextString(m) }
func (*ArcsPassedSortReq) ProtoMessage()    {}
func (*ArcsPassedSortReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *ArcsPassedSortReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsPassedSortReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsPassedSortReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsPassedSortReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsPassedSortReq.Merge(m, src)
}
func (m *ArcsPassedSortReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcsPassedSortReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsPassedSortReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsPassedSortReq proto.InternalMessageInfo

type ArcsPassedSortReply struct {
	// archives 稿件信息列表
	Archives             map[int64]*ArcPassedSortReply `protobuf:"bytes,1,rep,name=archives,proto3" json:"archives" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ArcsPassedSortReply) Reset()         { *m = ArcsPassedSortReply{} }
func (m *ArcsPassedSortReply) String() string { return proto.CompactTextString(m) }
func (*ArcsPassedSortReply) ProtoMessage()    {}
func (*ArcsPassedSortReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *ArcsPassedSortReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcsPassedSortReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcsPassedSortReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcsPassedSortReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcsPassedSortReply.Merge(m, src)
}
func (m *ArcsPassedSortReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcsPassedSortReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcsPassedSortReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcsPassedSortReply proto.InternalMessageInfo

type ArcPassedSortReply struct {
	// arhives 稿件信息列表
	Archive              []*SortArc `protobuf:"bytes,1,rep,name=archive,proto3" json:"archive"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ArcPassedSortReply) Reset()         { *m = ArcPassedSortReply{} }
func (m *ArcPassedSortReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedSortReply) ProtoMessage()    {}
func (*ArcPassedSortReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *ArcPassedSortReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedSortReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedSortReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedSortReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedSortReply.Merge(m, src)
}
func (m *ArcPassedSortReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedSortReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedSortReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedSortReply proto.InternalMessageInfo

type SortArc struct {
	// aid 稿件ID
	Aid                  int64    `protobuf:"varint,1,opt,name=Aid,json=aid,proto3" json:"aid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SortArc) Reset()         { *m = SortArc{} }
func (m *SortArc) String() string { return proto.CompactTextString(m) }
func (*SortArc) ProtoMessage()    {}
func (*SortArc) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *SortArc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortArc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortArc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortArc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortArc.Merge(m, src)
}
func (m *SortArc) XXX_Size() int {
	return m.Size()
}
func (m *SortArc) XXX_DiscardUnknown() {
	xxx_messageInfo_SortArc.DiscardUnknown(m)
}

var xxx_messageInfo_SortArc proto.InternalMessageInfo

type ArcPassedExistReq struct {
	// mid 用户id 必传
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"min=1"`
	// aid 为0，或者传递了错误的aid，则默认从第一页开始
	Aid int64 `protobuf:"varint,2,opt,name=aid,proto3" json:"aid,omitempty" form:"aid" validate:"min=1"`
	// without 去除特定类型稿件
	Without []Without `protobuf:"varint,3,rep,packed,name=without,proto3,enum=up.archive.service.v1.Without" json:"without,omitempty" form:"without"`
	// tid 一级分区ID
	Tid int64 `protobuf:"varint,4,opt,name=tid,proto3" json:"tid,omitempty" form:"tid" validate:"min=0"`
	// order 排序字段 非必传 (默认稿件发布时间)
	Order                SearchOrder `protobuf:"varint,5,opt,name=order,proto3,enum=up.archive.service.v1.SearchOrder" json:"order,omitempty" form:"order"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ArcPassedExistReq) Reset()         { *m = ArcPassedExistReq{} }
func (m *ArcPassedExistReq) String() string { return proto.CompactTextString(m) }
func (*ArcPassedExistReq) ProtoMessage()    {}
func (*ArcPassedExistReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *ArcPassedExistReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedExistReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedExistReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedExistReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedExistReq.Merge(m, src)
}
func (m *ArcPassedExistReq) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedExistReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedExistReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedExistReq proto.InternalMessageInfo

type ArcPassedExistReply struct {
	// 是否存在
	Exist                bool     `protobuf:"varint,1,opt,name=Exist,json=exist,proto3" json:"exist"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArcPassedExistReply) Reset()         { *m = ArcPassedExistReply{} }
func (m *ArcPassedExistReply) String() string { return proto.CompactTextString(m) }
func (*ArcPassedExistReply) ProtoMessage()    {}
func (*ArcPassedExistReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *ArcPassedExistReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArcPassedExistReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArcPassedExistReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArcPassedExistReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArcPassedExistReply.Merge(m, src)
}
func (m *ArcPassedExistReply) XXX_Size() int {
	return m.Size()
}
func (m *ArcPassedExistReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ArcPassedExistReply.DiscardUnknown(m)
}

var xxx_messageInfo_ArcPassedExistReply proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("up.archive.service.v1.SearchOrder", SearchOrder_name, SearchOrder_value)
	proto.RegisterEnum("up.archive.service.v1.Sort", Sort_name, Sort_value)
	proto.RegisterEnum("up.archive.service.v1.KwField", KwField_name, KwField_value)
	proto.RegisterEnum("up.archive.service.v1.Without", Without_name, Without_value)
	proto.RegisterType((*ArcPassedReq)(nil), "up.archive.service.v1.ArcPassedReq")
	proto.RegisterType((*ArcPassedReply)(nil), "up.archive.service.v1.ArcPassedReply")
	proto.RegisterType((*Arc)(nil), "up.archive.service.v1.Arc")
	proto.RegisterType((*SeasonTheme)(nil), "up.archive.service.v1.SeasonTheme")
	proto.RegisterType((*StaffInfo)(nil), "up.archive.service.v1.StaffInfo")
	proto.RegisterType((*Dimension)(nil), "up.archive.service.v1.Dimension")
	proto.RegisterType((*Rights)(nil), "up.archive.service.v1.Rights")
	proto.RegisterType((*Author)(nil), "up.archive.service.v1.Author")
	proto.RegisterType((*Stat)(nil), "up.archive.service.v1.Stat")
	proto.RegisterType((*ArcPassedTotalReq)(nil), "up.archive.service.v1.ArcPassedTotalReq")
	proto.RegisterType((*ArcPassedTotalReply)(nil), "up.archive.service.v1.ArcPassedTotalReply")
	proto.RegisterType((*ArcPassedCursorReq)(nil), "up.archive.service.v1.ArcPassedCursorReq")
	proto.RegisterType((*ArcPassedCursorReply)(nil), "up.archive.service.v1.ArcPassedCursorReply")
	proto.RegisterType((*ArcPassed)(nil), "up.archive.service.v1.ArcPassed")
	proto.RegisterType((*ArcPassedStoryReq)(nil), "up.archive.service.v1.ArcPassedStoryReq")
	proto.RegisterType((*ArcPassedStoryReply)(nil), "up.archive.service.v1.ArcPassedStoryReply")
	proto.RegisterType((*StoryArcs)(nil), "up.archive.service.v1.StoryArcs")
	proto.RegisterType((*ArcsPassedReq)(nil), "up.archive.service.v1.ArcsPassedReq")
	proto.RegisterType((*ArcsPassedReply)(nil), "up.archive.service.v1.ArcsPassedReply")
	proto.RegisterMapType((map[int64]*ArcPassedReply)(nil), "up.archive.service.v1.ArcsPassedReply.ArchivesEntry")
	proto.RegisterType((*ArcsPassedTotalReq)(nil), "up.archive.service.v1.ArcsPassedTotalReq")
	proto.RegisterType((*ArcsPassedTotalReply)(nil), "up.archive.service.v1.ArcsPassedTotalReply")
	proto.RegisterMapType((map[int64]int64)(nil), "up.archive.service.v1.ArcsPassedTotalReply.TotalEntry")
	proto.RegisterType((*ArcPassedByAidReq)(nil), "up.archive.service.v1.ArcPassedByAidReq")
	proto.RegisterType((*ArcPassedWithIndex)(nil), "up.archive.service.v1.ArcPassedWithIndex")
	proto.RegisterType((*ArcPassedByAidReply)(nil), "up.archive.service.v1.ArcPassedByAidReply")
	proto.RegisterType((*CursorReply)(nil), "up.archive.service.v1.CursorReply")
	proto.RegisterType((*UpsArcsReq)(nil), "up.archive.service.v1.UpsArcsReq")
	proto.RegisterType((*UpsAidPubTimeReply)(nil), "up.archive.service.v1.UpsAidPubTimeReply")
	proto.RegisterMapType((map[int64]*UpAidPubTimeReply)(nil), "up.archive.service.v1.UpsAidPubTimeReply.ArchivesEntry")
	proto.RegisterType((*UpAidPubTimeReply)(nil), "up.archive.service.v1.UpAidPubTimeReply")
	proto.RegisterType((*AidPubTime)(nil), "up.archive.service.v1.AidPubTime")
	proto.RegisterType((*ArcPassedSearchReq)(nil), "up.archive.service.v1.ArcPassedSearchReq")
	proto.RegisterType((*ArcPassedSearchReply)(nil), "up.archive.service.v1.ArcPassedSearchReply")
	proto.RegisterType((*Tag)(nil), "up.archive.service.v1.Tag")
	proto.RegisterType((*ArcsPassedSortReq)(nil), "up.archive.service.v1.ArcsPassedSortReq")
	proto.RegisterType((*ArcsPassedSortReply)(nil), "up.archive.service.v1.ArcsPassedSortReply")
	proto.RegisterMapType((map[int64]*ArcPassedSortReply)(nil), "up.archive.service.v1.ArcsPassedSortReply.ArchivesEntry")
	proto.RegisterType((*ArcPassedSortReply)(nil), "up.archive.service.v1.ArcPassedSortReply")
	proto.RegisterType((*SortArc)(nil), "up.archive.service.v1.SortArc")
	proto.RegisterType((*ArcPassedExistReq)(nil), "up.archive.service.v1.ArcPassedExistReq")
	proto.RegisterType((*ArcPassedExistReply)(nil), "up.archive.service.v1.ArcPassedExistReply")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 3386 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x1a, 0xcb, 0x72, 0x1b, 0xc7,
	0x51, 0x78, 0x13, 0xc3, 0x87, 0xa0, 0xd1, 0x6b, 0x45, 0x51, 0x5c, 0x6a, 0xf5, 0x30, 0x45, 0x4b,
	0xa4, 0x48, 0xeb, 0x15, 0xbb, 0x24, 0x9b, 0xe0, 0xc3, 0x56, 0x2c, 0x29, 0xca, 0x88, 0x92, 0x2a,
	0x76, 0x55, 0x90, 0xc5, 0xee, 0x10, 0x98, 0x02, 0xb0, 0xbb, 0xda, 0x5d, 0x90, 0x42, 0xe5, 0xe6,
	0x43, 0x7e, 0x20, 0x07, 0x57, 0xe5, 0x90, 0x2a, 0x5f, 0x52, 0xc9, 0x17, 0xe4, 0x0f, 0x52, 0x3e,
	0xa6, 0xca, 0x95, 0xc4, 0xa7, 0xad, 0x58, 0x95, 0x13, 0x8e, 0x38, 0xe4, 0xe0, 0x53, 0x6a, 0x7a,
	0x66, 0x17, 0x0b, 0x82, 0x00, 0x28, 0x32, 0xef, 0x0b, 0x76, 0xb6, 0xa7, 0xbb, 0xb7, 0xa7, 0xa7,
	0x5f, 0xd3, 0x03, 0x94, 0xd7, 0x1d, 0xb6, 0xe8, 0xb8, 0xb6, 0x6f, 0xe3, 0xd3, 0x4d, 0x67, 0x51,
	0x77, 0x8d, 0x2a, 0xdb, 0xa1, 0x8b, 0x1e, 0x75, 0x77, 0x98, 0x41, 0x17, 0x77, 0x96, 0xa7, 0x6f,
	0x54, 0x98, 0x5f, 0x6d, 0x96, 0x17, 0x0d, 0xbb, 0xb1, 0x54, 0xb1, 0x2b, 0xf6, 0x12, 0x60, 0x97,
	0x9b, 0xdb, 0xf0, 0x06, 0x2f, 0x30, 0x12, 0x5c, 0xa6, 0xcf, 0x57, 0x6c, 0xbb, 0x52, 0xa7, 0x5d,
	0x2c, 0xda, 0x70, 0xfc, 0x96, 0x9c, 0x9c, 0x91, 0x93, 0xba, 0xc3, 0x96, 0x74, 0xcb, 0xb2, 0x7d,
	0xdd, 0x67, 0xb6, 0xe5, 0x89, 0x59, 0xed, 0x37, 0x29, 0x34, 0xb1, 0xea, 0x1a, 0x4f, 0x75, 0xcf,
	0xa3, 0x26, 0xa1, 0xaf, 0xf0, 0x32, 0x4a, 0x35, 0x98, 0xa9, 0x24, 0xe6, 0x12, 0xf3, 0xa9, 0xa2,
	0xda, 0x09, 0xd4, 0xf3, 0xdb, 0xb6, 0xdb, 0x78, 0x5f, 0x6b, 0x30, 0x53, 0x9b, 0xdb, 0xd1, 0xeb,
	0xcc, 0xd4, 0x7d, 0xca, 0x5f, 0xad, 0xfb, 0xcb, 0x1a, 0xe1, 0xb8, 0x78, 0x11, 0x25, 0x1d, 0x4b,
	0x49, 0x02, 0xc5, 0x6c, 0x27, 0x50, 0xa7, 0x05, 0x85, 0x63, 0xed, 0x43, 0x90, 0x74, 0x2c, 0x7c,
	0x1b, 0x25, 0x1d, 0x4f, 0x49, 0x01, 0xfe, 0x95, 0x4e, 0xa0, 0x5e, 0x94, 0xf8, 0x5e, 0x1f, 0xfe,
	0xf5, 0x86, 0xfe, 0xfa, 0xfe, 0xed, 0x9b, 0x9c, 0xcc, 0xc3, 0x97, 0x50, 0xda, 0xb3, 0x5d, 0x5f,
	0x49, 0xcf, 0x25, 0xe6, 0xf3, 0xc5, 0xe3, 0x9d, 0x40, 0x1d, 0x17, 0x84, 0x1c, 0xaa, 0x11, 0x98,
	0xc4, 0xf7, 0xd1, 0xe4, 0x2e, 0xf3, 0xab, 0x76, 0xd3, 0x2f, 0x79, 0xbe, 0xbe, 0xbd, 0xad, 0x64,
	0xe6, 0x12, 0xf3, 0x63, 0x45, 0xa5, 0x13, 0xa8, 0xa7, 0x04, 0x76, 0xcf, 0xb4, 0x46, 0x26, 0xe4,
	0xfb, 0x33, 0xfe, 0x8a, 0x7f, 0x88, 0x32, 0xb6, 0x6b, 0x52, 0x57, 0xc9, 0xce, 0x25, 0xe6, 0xa7,
	0x56, 0xb4, 0xc5, 0x7d, 0xf7, 0x67, 0xf1, 0x19, 0xe5, 0xc0, 0x1f, 0x71, 0xcc, 0x62, 0xa1, 0x13,
	0xa8, 0x13, 0x82, 0x35, 0x90, 0x6a, 0x44, 0xb0, 0xc0, 0x8f, 0x50, 0x4e, 0xf2, 0x56, 0x72, 0x73,
	0xa9, 0xf9, 0xa9, 0x95, 0xd9, 0x01, 0xdc, 0x5e, 0x0a, 0xac, 0x22, 0xee, 0x04, 0xea, 0x54, 0x8f,
	0x90, 0x1a, 0x09, 0x59, 0x68, 0xbb, 0x68, 0x2a, 0xb6, 0x4f, 0x4e, 0xbd, 0x85, 0xd7, 0xd1, 0x98,
	0x64, 0xe6, 0x29, 0x89, 0xb9, 0xd4, 0xfc, 0xf8, 0xca, 0xf4, 0x80, 0x0f, 0xac, 0xba, 0x46, 0x71,
	0xa2, 0x1d, 0xa8, 0x11, 0x3e, 0x89, 0x46, 0x58, 0x45, 0x19, 0xdf, 0xf6, 0xf5, 0xba, 0xdc, 0xbf,
	0x7c, 0x3b, 0x50, 0x05, 0x80, 0x88, 0x87, 0xf6, 0xe7, 0x09, 0x94, 0x5a, 0x75, 0x0d, 0x7c, 0x0e,
	0xa5, 0x56, 0x23, 0xc3, 0xc8, 0xb5, 0x03, 0x35, 0xa5, 0x33, 0x93, 0xf0, 0x1f, 0xac, 0xa1, 0xec,
	0x0b, 0x66, 0x52, 0xdb, 0x93, 0x4c, 0x50, 0x3b, 0x50, 0xb3, 0x3b, 0x00, 0x21, 0xf2, 0x89, 0x67,
	0x50, 0x76, 0xab, 0xe5, 0xd0, 0x87, 0xeb, 0xb0, 0xf1, 0x19, 0xc1, 0xc1, 0xe7, 0x1c, 0x7c, 0xe0,
	0x30, 0xc6, 0x67, 0x9f, 0xe8, 0x0d, 0x2a, 0xf7, 0x57, 0x08, 0x62, 0xe9, 0x0d, 0x4a, 0xc4, 0x03,
	0xbf, 0x8b, 0xf2, 0x6b, 0xb6, 0xd3, 0x72, 0x59, 0xa5, 0xea, 0xc3, 0xb6, 0x66, 0x8a, 0x93, 0xed,
	0x40, 0xcd, 0x1b, 0x21, 0x90, 0x74, 0x87, 0x5c, 0xda, 0xa7, 0xcc, 0x80, 0x6d, 0xcc, 0x8b, 0x6f,
	0x39, 0xcc, 0x20, 0xfc, 0x87, 0xaf, 0x78, 0x8b, 0xf9, 0x75, 0xaa, 0xe4, 0x62, 0x1f, 0xe2, 0x00,
	0x22, 0x1e, 0x78, 0x1d, 0xe5, 0x9e, 0x36, 0xcb, 0xeb, 0xba, 0x4f, 0x95, 0x31, 0x58, 0xcf, 0x42,
	0x3b, 0x50, 0x73, 0x4e, 0xb3, 0xcc, 0x2d, 0xf3, 0xfb, 0x40, 0x3d, 0x5f, 0xb1, 0x6f, 0x18, 0x76,
	0xa3, 0x61, 0x5b, 0x4b, 0x75, 0x56, 0x76, 0x75, 0xb7, 0xb5, 0xe4, 0xb3, 0x06, 0x5d, 0xdc, 0x62,
	0x0d, 0x4a, 0x42, 0x3c, 0xfc, 0x00, 0x65, 0xd6, 0x38, 0x58, 0xc9, 0x03, 0x8f, 0x79, 0xfe, 0x19,
	0x83, 0x03, 0x46, 0x71, 0x10, 0x58, 0x78, 0x06, 0xa5, 0xd7, 0xa9, 0x67, 0x28, 0x08, 0xa4, 0x1c,
	0x6b, 0x07, 0x6a, 0xda, 0xa4, 0x9e, 0x41, 0xe0, 0x97, 0x2f, 0xe2, 0x99, 0xcf, 0x25, 0x1c, 0x07,
	0x45, 0xc0, 0x22, 0x3c, 0x0e, 0x20, 0xe2, 0x81, 0xaf, 0xa3, 0xec, 0xaa, 0x61, 0x50, 0xcf, 0x53,
	0x26, 0x00, 0xe3, 0x54, 0x3b, 0x50, 0x0b, 0x3a, 0x40, 0xae, 0xdb, 0x0d, 0xe6, 0x43, 0x88, 0x20,
	0x59, 0x01, 0xc1, 0xb7, 0x51, 0x7e, 0xd5, 0xf7, 0x5d, 0x56, 0x6e, 0xfa, 0x54, 0x99, 0x04, 0x82,
	0xb3, 0xed, 0x40, 0x3d, 0xa9, 0x87, 0xc0, 0x18, 0x4d, 0x3e, 0x02, 0xe2, 0xb3, 0x28, 0xb5, 0xa5,
	0x57, 0x94, 0x29, 0x10, 0x31, 0xd3, 0x0e, 0xd4, 0xc4, 0x0d, 0xc2, 0x21, 0xf8, 0x2a, 0x4a, 0x6f,
	0xe9, 0x15, 0x4f, 0x39, 0x3e, 0x97, 0x9a, 0xcf, 0x17, 0x71, 0x3b, 0x50, 0xa7, 0x7c, 0xbd, 0x12,
	0xff, 0x72, 0x9a, 0xbf, 0xe3, 0x79, 0x34, 0xb6, 0xde, 0x74, 0x21, 0x22, 0x29, 0x05, 0xd0, 0x13,
	0xd8, 0xa9, 0x29, 0x61, 0x24, 0x1a, 0xe1, 0xbb, 0x28, 0xff, 0x98, 0x79, 0x1e, 0xb3, 0xad, 0x87,
	0xeb, 0xca, 0x09, 0x40, 0x55, 0xda, 0x81, 0x7a, 0xaa, 0x21, 0x80, 0x25, 0x66, 0xc6, 0x98, 0xa3,
	0x2e, 0x14, 0x2f, 0xa3, 0x1c, 0x38, 0xea, 0xc3, 0x75, 0x05, 0x03, 0xd9, 0x99, 0x76, 0xa0, 0x62,
	0x70, 0xd1, 0x5e, 0xa2, 0xb1, 0x10, 0x86, 0xef, 0xa3, 0x71, 0x42, 0x4d, 0xe6, 0x52, 0xc3, 0x7f,
	0x4e, 0x1e, 0x29, 0x27, 0x61, 0x79, 0xd3, 0xed, 0x40, 0x3d, 0xe3, 0x4a, 0x70, 0xa9, 0xe9, 0xd6,
	0x63, 0xa4, 0x13, 0x71, 0x38, 0x5e, 0x42, 0xb9, 0x4d, 0xdb, 0xdd, 0xd5, 0x5d, 0x53, 0x39, 0x05,
	0x5f, 0x3c, 0xdd, 0x0e, 0xd4, 0x13, 0xdb, 0x02, 0x14, 0xa3, 0xca, 0x49, 0x10, 0xde, 0x40, 0x59,
	0xc2, 0xad, 0xd6, 0x53, 0x4e, 0xcf, 0x25, 0xe6, 0xc7, 0x57, 0x2e, 0x0c, 0xf0, 0x63, 0x81, 0x54,
	0x9c, 0xfa, 0x3a, 0x50, 0x8f, 0x71, 0x17, 0x03, 0x53, 0xf7, 0x88, 0x7c, 0xe2, 0x35, 0x94, 0x5d,
	0x6d, 0xfa, 0x55, 0xdb, 0x55, 0xce, 0x0c, 0x65, 0x23, 0x90, 0x8a, 0x93, 0x92, 0x4d, 0xc6, 0xde,
	0xb5, 0xa8, 0x4b, 0xc4, 0x03, 0xdf, 0x47, 0x69, 0x6e, 0x58, 0xca, 0x59, 0x60, 0x71, 0x7e, 0x50,
	0x00, 0xf4, 0x75, 0xbf, 0x38, 0x21, 0x19, 0xa4, 0xb9, 0xc5, 0x11, 0xf8, 0xc5, 0x1f, 0xa1, 0x09,
	0x42, 0x1d, 0xdb, 0xf5, 0x09, 0xf5, 0x9a, 0x75, 0x5f, 0x51, 0x40, 0x77, 0xe7, 0xdb, 0x81, 0x7a,
	0xd6, 0x05, 0x78, 0xc9, 0x85, 0x89, 0x98, 0x1a, 0x26, 0x7b, 0x26, 0xf0, 0x15, 0x94, 0x5b, 0x6f,
	0x59, 0x7a, 0x83, 0x19, 0xca, 0x39, 0x20, 0x1e, 0xe7, 0xde, 0x67, 0x0a, 0x10, 0x09, 0x07, 0xdc,
	0x72, 0x36, 0x99, 0xeb, 0xf9, 0x6b, 0xcc, 0x54, 0xa6, 0x41, 0xcb, 0x27, 0xda, 0x81, 0x3a, 0x69,
	0xf4, 0x6c, 0x69, 0xca, 0x60, 0x26, 0xfe, 0x1c, 0xe5, 0xd7, 0x59, 0x83, 0x5a, 0xdc, 0x20, 0x94,
	0xf3, 0xb0, 0xac, 0xb9, 0x01, 0xcb, 0x8a, 0xf0, 0x8a, 0xe7, 0xe5, 0xda, 0x4e, 0x9a, 0x21, 0x28,
	0xee, 0x01, 0x11, 0x10, 0x6f, 0xa0, 0x3c, 0x64, 0x8e, 0x87, 0xd6, 0xb6, 0xad, 0xcc, 0x40, 0x14,
	0x9e, 0x1b, 0xac, 0x33, 0x81, 0x17, 0x7a, 0x4a, 0x97, 0x12, 0xdf, 0x42, 0x63, 0xcf, 0xa8, 0xee,
	0x81, 0x71, 0x5f, 0x80, 0xd5, 0x80, 0xfb, 0x79, 0x00, 0xeb, 0x35, 0xd3, 0x7c, 0x04, 0xe4, 0x76,
	0x1a, 0x79, 0xed, 0x8b, 0x15, 0x65, 0x16, 0x08, 0xc1, 0x4e, 0x23, 0x17, 0x2d, 0xed, 0xac, 0xc4,
	0xed, 0x34, 0x0e, 0xc7, 0x1b, 0x68, 0x42, 0xf2, 0xf2, 0xab, 0xb4, 0x41, 0x15, 0x15, 0x74, 0x33,
	0x24, 0xe7, 0x79, 0xb6, 0xb5, 0xc5, 0x31, 0xc9, 0xb8, 0xd7, 0x7d, 0xc1, 0x17, 0x10, 0xf2, 0xaa,
	0x7c, 0x03, 0xeb, 0xcc, 0xaa, 0x29, 0x73, 0x7c, 0xcf, 0x48, 0x1e, 0x20, 0x8f, 0x98, 0x55, 0xc3,
	0x67, 0x51, 0xae, 0xe9, 0x94, 0xb6, 0x5d, 0xbb, 0xa1, 0x5c, 0xe4, 0x81, 0x85, 0x64, 0x9b, 0xce,
	0xa6, 0x6b, 0x37, 0x34, 0x0f, 0x8d, 0xc7, 0x78, 0xe2, 0x73, 0x68, 0xac, 0x5c, 0x29, 0x19, 0x76,
	0xdd, 0x76, 0x21, 0xc9, 0xe4, 0x49, 0xae, 0x5c, 0x59, 0xe3, 0xaf, 0x78, 0x01, 0x9d, 0xf0, 0x68,
	0x9d, 0x1a, 0x3e, 0x35, 0x4b, 0x11, 0x4e, 0x12, 0x70, 0x8e, 0x87, 0x13, 0x45, 0x89, 0x7b, 0x01,
	0x21, 0x9f, 0xbe, 0xf6, 0x25, 0x52, 0x4a, 0x48, 0xc3, 0x21, 0x30, 0xad, 0xd1, 0xd8, 0x7e, 0xf1,
	0x24, 0xf1, 0xb8, 0x37, 0xa5, 0x35, 0x78, 0x42, 0xe2, 0x35, 0x4d, 0x94, 0x24, 0x92, 0x03, 0x92,
	0xc4, 0x4c, 0x3c, 0x62, 0x42, 0x2d, 0x43, 0xba, 0x00, 0xcd, 0x8f, 0xd9, 0x1c, 0xe7, 0xf5, 0x92,
	0x99, 0x7e, 0x55, 0x7e, 0x08, 0x78, 0xed, 0x72, 0x00, 0x11, 0x0f, 0x9e, 0x3f, 0x3f, 0xa1, 0x90,
	0xd6, 0x62, 0xf9, 0xb3, 0x0a, 0x10, 0x22, 0x9f, 0x1c, 0x87, 0xd8, 0x10, 0xf1, 0x53, 0x5d, 0x1c,
	0x17, 0x20, 0x44, 0x3e, 0xb5, 0xbf, 0xa4, 0xc3, 0x40, 0x82, 0xcf, 0xa0, 0x64, 0xd1, 0x81, 0x0f,
	0x66, 0x8a, 0xd9, 0x76, 0xa0, 0x26, 0xcb, 0x0e, 0x49, 0x96, 0x1d, 0x9e, 0x55, 0x36, 0xea, 0xd4,
	0x80, 0x0f, 0x65, 0x44, 0x56, 0xe1, 0x0a, 0x24, 0xf0, 0x0b, 0xe1, 0xd8, 0xde, 0xb5, 0xea, 0xb6,
	0x6e, 0xca, 0x34, 0x2d, 0xc2, 0xb1, 0x84, 0x91, 0x68, 0x84, 0xaf, 0xa0, 0xcc, 0x63, 0x7b, 0x87,
	0x89, 0x6c, 0x3d, 0x18, 0x8d, 0xa7, 0x61, 0xbd, 0x25, 0xb3, 0xb5, 0x48, 0xc3, 0x7a, 0x8b, 0xf0,
	0x1f, 0x3e, 0xf5, 0xc9, 0xfa, 0x6d, 0xc8, 0xd0, 0x72, 0xaa, 0x6a, 0xde, 0x26, 0xfc, 0x07, 0xdf,
	0x40, 0xf9, 0x27, 0x36, 0xa1, 0x8e, 0xcb, 0x2c, 0x1f, 0xb2, 0x74, 0xa6, 0x38, 0xd5, 0x0e, 0x54,
	0x64, 0xd9, 0x25, 0x57, 0x40, 0x49, 0x6c, 0xcc, 0xa5, 0x5e, 0x6d, 0xfa, 0xb6, 0x53, 0xd7, 0x5b,
	0x90, 0xb0, 0xa5, 0x38, 0xba, 0x84, 0x91, 0x68, 0x84, 0x2f, 0xa3, 0xec, 0xf3, 0x8f, 0xd7, 0xb8,
	0x44, 0x79, 0xc0, 0x83, 0xd0, 0xd2, 0xac, 0x18, 0x25, 0x2e, 0x55, 0x38, 0xc0, 0x3f, 0x40, 0x93,
	0x0f, 0xbd, 0x35, 0xdb, 0x76, 0xa8, 0xcc, 0x4c, 0x08, 0x90, 0x21, 0x8b, 0x31, 0xaf, 0x64, 0x74,
	0x67, 0xc8, 0x9e, 0x77, 0xfc, 0x01, 0x9a, 0x14, 0x1f, 0x78, 0xea, 0xd2, 0x1d, 0x46, 0x77, 0x65,
	0x7a, 0x3e, 0xd9, 0x0e, 0xd4, 0xe3, 0x92, 0x7d, 0xc9, 0x11, 0x53, 0x64, 0x2f, 0x00, 0xdf, 0x41,
	0x13, 0x4f, 0xec, 0xa2, 0x6e, 0xd4, 0x2a, 0xae, 0xdd, 0xb4, 0x4c, 0x99, 0xb8, 0x21, 0xac, 0x59,
	0x76, 0xa9, 0x1c, 0x4d, 0x90, 0xde, 0x57, 0xbe, 0x2a, 0x28, 0x0d, 0x5b, 0x32, 0x73, 0xc3, 0xaa,
	0x74, 0x57, 0xae, 0x4a, 0x0e, 0xf0, 0x07, 0xe8, 0xb8, 0xc0, 0xda, 0x74, 0x29, 0x7d, 0xa9, 0xfb,
	0x46, 0x15, 0xf2, 0xb6, 0x5c, 0x17, 0x97, 0x63, 0xdb, 0xa5, 0xb4, 0xb4, 0xcb, 0x67, 0xc8, 0x9e,
	0x77, 0xad, 0x14, 0xa6, 0x96, 0x61, 0x3e, 0x33, 0x83, 0xd2, 0x50, 0xc0, 0x25, 0xbb, 0x15, 0x0b,
	0xd4, 0x6f, 0xf0, 0xcb, 0x67, 0x37, 0x75, 0x43, 0x98, 0xaf, 0x9c, 0xdd, 0xd6, 0x0d, 0x4a, 0xe0,
	0x57, 0xfb, 0x2a, 0x25, 0xf2, 0xce, 0xb0, 0x32, 0x73, 0x06, 0xa5, 0x5f, 0x70, 0x9d, 0xc6, 0x6c,
	0x17, 0x14, 0x09, 0xbf, 0x90, 0x37, 0x74, 0xab, 0xa1, 0xd7, 0x9a, 0xd2, 0x74, 0x45, 0xde, 0x10,
	0x20, 0x12, 0x0e, 0xb8, 0x33, 0x42, 0xf9, 0x2c, 0x0d, 0x17, 0x9c, 0xd1, 0xe5, 0x00, 0x22, 0x1e,
	0xf8, 0x12, 0x4a, 0x6d, 0xea, 0x3b, 0xd2, 0x64, 0xc1, 0x90, 0xb6, 0xf5, 0x1d, 0xdb, 0x65, 0x3e,
	0x25, 0xd1, 0x88, 0x8b, 0xb2, 0x66, 0x33, 0x4b, 0x5a, 0x2f, 0x88, 0x62, 0xd8, 0xcc, 0x22, 0xf0,
	0x0b, 0xc5, 0x59, 0x55, 0x77, 0xa9, 0xb4, 0x5d, 0x51, 0x9c, 0x71, 0x00, 0x11, 0x0f, 0xfc, 0x0e,
	0xca, 0x3d, 0xb1, 0x77, 0x89, 0x6e, 0xd5, 0xe2, 0x06, 0x6b, 0xd9, 0xbb, 0x25, 0x57, 0xb7, 0x6a,
	0x24, 0x1a, 0x71, 0xc4, 0x4f, 0x98, 0x07, 0x88, 0xf9, 0x2e, 0x62, 0x95, 0x79, 0x12, 0x31, 0x1c,
	0x71, 0x81, 0x1e, 0xb1, 0x1a, 0x95, 0xa6, 0x0a, 0x02, 0xd5, 0x59, 0x8d, 0x12, 0xf8, 0x05, 0xdd,
	0x30, 0x0f, 0x10, 0xc6, 0x63, 0xba, 0x61, 0x1e, 0xe0, 0x84, 0x03, 0x7c, 0x01, 0x65, 0x37, 0xed,
	0x7a, 0xdd, 0xde, 0x95, 0xa6, 0x27, 0xf3, 0x94, 0x04, 0x6a, 0xbf, 0x48, 0xa2, 0x13, 0xd1, 0x19,
	0x64, 0x0b, 0xce, 0x08, 0x87, 0x3b, 0x30, 0xf6, 0x1d, 0xd2, 0x92, 0x6f, 0x75, 0x48, 0x8b, 0x1d,
	0xac, 0x52, 0x47, 0x3e, 0x58, 0x71, 0xf9, 0x7d, 0x66, 0x82, 0x39, 0xf4, 0xc8, 0xef, 0xf7, 0xcb,
	0x7f, 0x53, 0x83, 0xd3, 0x8a, 0x76, 0x07, 0x9d, 0xdc, 0xab, 0x07, 0x6e, 0x39, 0x23, 0x8f, 0x52,
	0xdf, 0x26, 0x11, 0x8e, 0x08, 0xd7, 0x9a, 0xae, 0x67, 0xbb, 0x87, 0xd4, 0xe0, 0x55, 0x94, 0xf1,
	0x0c, 0xdb, 0xa5, 0xf2, 0x53, 0xb1, 0x33, 0x28, 0x80, 0x35, 0x22, 0xa6, 0xff, 0x9b, 0x8f, 0xda,
	0xb1, 0x5d, 0xcc, 0x1e, 0xfd, 0x78, 0xfc, 0x02, 0x9d, 0xea, 0xd3, 0x2c, 0xdf, 0x93, 0x07, 0x28,
	0x5d, 0x67, 0x9e, 0x2f, 0x0f, 0xc8, 0x73, 0x83, 0x0f, 0xc8, 0x82, 0x34, 0xf4, 0x1c, 0xcf, 0x27,
	0xf0, 0xab, 0x7d, 0x8c, 0xf2, 0xd1, 0x24, 0x8f, 0x4d, 0xfa, 0x80, 0xd8, 0xa4, 0xf6, 0x6e, 0x88,
	0x70, 0x79, 0x0e, 0x90, 0x3b, 0xa1, 0xfd, 0x3a, 0xee, 0x3c, 0xcf, 0x7c, 0xdb, 0x6d, 0x1d, 0x72,
	0xeb, 0xe7, 0x84, 0x10, 0xe2, 0x3b, 0x53, 0x9d, 0x40, 0x45, 0x82, 0x44, 0x67, 0xa6, 0x26, 0x64,
	0x09, 0x77, 0x2f, 0x35, 0x6c, 0xf7, 0x6e, 0x21, 0xc4, 0xf3, 0x4e, 0xc9, 0xb0, 0x9b, 0x96, 0x2f,
	0xad, 0xff, 0x74, 0x47, 0x9c, 0x53, 0xb8, 0x85, 0x44, 0x73, 0x1a, 0xc9, 0xf3, 0x97, 0x35, 0x3e,
	0xe6, 0x54, 0x96, 0xa8, 0xae, 0x38, 0x55, 0x66, 0x2f, 0x55, 0x77, 0x4e, 0x23, 0x79, 0x0b, 0x8a,
	0x2e, 0x4e, 0x75, 0x09, 0xa5, 0x79, 0x90, 0x82, 0x68, 0x99, 0x8a, 0x0b, 0xc4, 0xa1, 0x1a, 0x81,
	0x49, 0xad, 0x93, 0x88, 0x79, 0x95, 0x54, 0x10, 0xdf, 0xc1, 0x19, 0x49, 0x2c, 0x74, 0x04, 0xfb,
	0x03, 0xb1, 0x0f, 0x7e, 0x47, 0xfa, 0x1c, 0x7e, 0x8c, 0x40, 0xfc, 0x92, 0xee, 0x1a, 0x1e, 0x84,
	0x8b, 0x61, 0x05, 0xba, 0xed, 0xb6, 0x56, 0x5d, 0xc3, 0x13, 0x7d, 0x05, 0x41, 0xc6, 0x4c, 0x8f,
	0x74, 0x87, 0x9c, 0x1d, 0x2c, 0x12, 0xd8, 0xa5, 0xdf, 0x86, 0x9d, 0x20, 0x03, 0x76, 0xd1, 0x50,
	0x5b, 0xe7, 0xe5, 0xa8, 0x44, 0x1b, 0x66, 0x5e, 0xa1, 0x12, 0x92, 0xfb, 0x29, 0x41, 0xfb, 0x6d,
	0x12, 0x4d, 0x72, 0x0e, 0xdd, 0x2e, 0xde, 0x23, 0x94, 0x6e, 0x30, 0x53, 0xf4, 0x85, 0x52, 0xc5,
	0x7b, 0x9d, 0x40, 0xbd, 0x15, 0x19, 0x96, 0x77, 0xdd, 0x73, 0xea, 0xcc, 0xdf, 0x3f, 0x02, 0x2c,
	0xdf, 0xbc, 0x79, 0xdd, 0x64, 0x3b, 0xf4, 0x7a, 0xc5, 0xe7, 0xe1, 0x0e, 0xb8, 0xfc, 0x1f, 0x35,
	0xf8, 0xb4, 0x3f, 0x25, 0xa0, 0x0c, 0xf2, 0xe2, 0x8d, 0xb4, 0x9f, 0xf6, 0x35, 0xd2, 0x6e, 0x0d,
	0x8e, 0x13, 0x71, 0x4a, 0xfe, 0x0e, 0x64, 0x1b, 0x96, 0xef, 0xb6, 0x06, 0xb5, 0xd8, 0xa6, 0xcb,
	0xb0, 0x3b, 0x5d, 0x44, 0x5c, 0x40, 0xa9, 0x1a, 0x6d, 0x89, 0x8d, 0x26, 0x7c, 0x88, 0x3f, 0x40,
	0x99, 0x1d, 0xbd, 0xde, 0x14, 0xe1, 0x63, 0x7c, 0xe5, 0xca, 0xa8, 0x38, 0x45, 0x44, 0xc5, 0x02,
	0x34, 0xef, 0x27, 0xef, 0x25, 0xb4, 0xaf, 0x12, 0x90, 0x5a, 0xbc, 0x3d, 0xc9, 0xf9, 0x9f, 0x6b,
	0x07, 0x47, 0xcb, 0xdb, 0xda, 0xef, 0x12, 0x10, 0xa4, 0xbd, 0xbe, 0xc4, 0xf9, 0x32, 0x74, 0x62,
	0xa1, 0xfd, 0x3b, 0x23, 0xb5, 0xdf, 0xa5, 0x5d, 0x84, 0xa1, 0xd0, 0x7f, 0x9f, 0xf3, 0x4f, 0xdf,
	0x43, 0xa8, 0x3b, 0xbf, 0x8f, 0xda, 0x4f, 0xc5, 0xd5, 0x9e, 0x8a, 0xeb, 0xf3, 0x4d, 0x2a, 0x16,
	0xae, 0x8b, 0xad, 0x55, 0x76, 0xd8, 0xe6, 0xf8, 0x72, 0x3c, 0x5c, 0xc7, 0x48, 0xf4, 0xfd, 0xcb,
	0x0b, 0xee, 0xec, 0x77, 0x62, 0xee, 0x73, 0xb5, 0x13, 0xa8, 0xda, 0x70, 0xf7, 0x59, 0xbe, 0xf9,
	0xbf, 0x9a, 0xb5, 0xc3, 0xda, 0x2b, 0x77, 0xf0, 0xda, 0xab, 0xdb, 0xa1, 0x1f, 0x3b, 0x72, 0x87,
	0x5e, 0xfb, 0x79, 0xac, 0x1c, 0xe3, 0xf2, 0x3e, 0xb4, 0x4c, 0xfa, 0x1a, 0x7f, 0x8c, 0x72, 0x92,
	0x21, 0x6c, 0xf4, 0x41, 0xaa, 0x86, 0xf0, 0xc4, 0xc5, 0x31, 0x48, 0x38, 0x18, 0x11, 0xb4, 0xbf,
	0x89, 0xe7, 0x3b, 0x69, 0x61, 0xdc, 0x19, 0x9e, 0xf5, 0x45, 0xa3, 0x6b, 0xa3, 0xbe, 0x1f, 0xc9,
	0x7e, 0xe8, 0x2e, 0x3f, 0xde, 0x44, 0x59, 0x03, 0xca, 0x26, 0xb0, 0xbb, 0xc1, 0x5d, 0xa0, 0x58,
	0x6d, 0x25, 0x5a, 0x10, 0x82, 0x8a, 0xc8, 0xa7, 0x76, 0x17, 0x8d, 0xc7, 0xcb, 0xaf, 0x79, 0x34,
	0x56, 0xd5, 0xbd, 0x52, 0x83, 0x57, 0x46, 0x09, 0x30, 0x34, 0x71, 0x80, 0x91, 0x30, 0x12, 0x8d,
	0xb4, 0xbf, 0x27, 0x10, 0x7a, 0xee, 0x78, 0xdc, 0xc7, 0xb9, 0xa7, 0x15, 0x7b, 0x02, 0xd7, 0x62,
	0x27, 0x50, 0x17, 0x0e, 0x1c, 0xb8, 0xfe, 0xcd, 0x69, 0xab, 0xcf, 0xa3, 0xd2, 0x6f, 0x15, 0x15,
	0x83, 0x04, 0xc2, 0x7c, 0xe1, 0xcc, 0x7c, 0xda, 0x2c, 0xc3, 0x05, 0x00, 0x68, 0x4e, 0xef, 0x33,
	0x83, 0xbb, 0x03, 0xb6, 0xa4, 0x9f, 0xf8, 0x80, 0x79, 0x89, 0x8e, 0xce, 0x4b, 0x0f, 0x7a, 0xf3,
	0xd2, 0xfc, 0x40, 0x11, 0xf6, 0x48, 0x10, 0x0f, 0xa5, 0x3f, 0x43, 0x27, 0xfa, 0xe6, 0xf1, 0xa7,
	0x7d, 0xcb, 0xbb, 0x38, 0xc8, 0xca, 0x23, 0xca, 0x41, 0x0b, 0xd1, 0x7e, 0x95, 0x40, 0xa8, 0x8b,
	0x36, 0xac, 0x8e, 0x5a, 0x47, 0xe1, 0xfd, 0x8c, 0xb4, 0x8b, 0x43, 0x5d, 0xed, 0xbc, 0x8b, 0xba,
	0x37, 0x4d, 0xb2, 0xd9, 0x30, 0xf0, 0x26, 0x4a, 0xfb, 0x32, 0x13, 0x8b, 0x32, 0x22, 0x2c, 0x1d,
	0x3e, 0x95, 0xf8, 0xfb, 0xa5, 0x92, 0x21, 0xd1, 0xf2, 0x01, 0xca, 0xd5, 0x68, 0x6b, 0xd7, 0x76,
	0x4d, 0x79, 0x1a, 0xb8, 0xdc, 0x09, 0xd4, 0x39, 0x41, 0x26, 0x27, 0x7a, 0x48, 0xa5, 0x59, 0x87,
	0x44, 0x78, 0x05, 0xe5, 0xab, 0xac, 0x52, 0xad, 0xc3, 0x4a, 0x85, 0x5d, 0x9f, 0xea, 0x04, 0x6a,
	0x41, 0x70, 0x88, 0xa6, 0x34, 0xd2, 0x45, 0x93, 0x6e, 0x97, 0x39, 0xb0, 0xdb, 0x89, 0x74, 0x97,
	0x7d, 0xeb, 0x74, 0x17, 0x65, 0x82, 0xdc, 0xd1, 0xef, 0x6a, 0xc3, 0xd4, 0x39, 0x36, 0x2c, 0x75,
	0xde, 0x40, 0xb9, 0xaa, 0xee, 0xc1, 0xbd, 0x56, 0x1e, 0x54, 0x71, 0xb2, 0x13, 0xa8, 0xc7, 0xa5,
	0x2a, 0x74, 0xaf, 0xe4, 0xeb, 0x15, 0x4f, 0x23, 0x21, 0x0e, 0xfe, 0x31, 0xca, 0xd7, 0x76, 0x4b,
	0xdb, 0x8c, 0xd6, 0x4d, 0x4f, 0x41, 0x43, 0x93, 0xe5, 0xa7, 0xbb, 0x9b, 0x1c, 0x2d, 0xae, 0xdb,
	0x88, 0x54, 0x23, 0x63, 0x35, 0x31, 0xed, 0xc5, 0xb3, 0xef, 0xf8, 0xd1, 0xcf, 0xcc, 0xbf, 0x4f,
	0xc4, 0x0e, 0xcd, 0xa1, 0x65, 0x72, 0xe7, 0xbc, 0x87, 0xe0, 0x76, 0x6e, 0xc4, 0xad, 0xf2, 0x96,
	0x5e, 0x11, 0x49, 0x8d, 0xe3, 0xca, 0xfb, 0xbc, 0xf8, 0x9d, 0x74, 0xf2, 0xe8, 0x77, 0xd2, 0xa9,
	0x01, 0x8d, 0x94, 0x12, 0xdc, 0x3b, 0x72, 0x47, 0xf7, 0x7b, 0x1d, 0x3d, 0xba, 0x50, 0x9e, 0x41,
	0xd0, 0x75, 0x1c, 0xd0, 0x8b, 0x54, 0x51, 0x46, 0x9c, 0x60, 0x63, 0x1f, 0x00, 0x00, 0x11, 0x0f,
	0xed, 0x5b, 0x71, 0x5a, 0x97, 0xe5, 0xe6, 0x33, 0xb8, 0xcf, 0x7a, 0x85, 0x3f, 0xed, 0x49, 0x4a,
	0x77, 0x3b, 0x81, 0xfa, 0xde, 0x41, 0x93, 0x52, 0x7f, 0x31, 0x7d, 0x08, 0x6f, 0x3e, 0x64, 0x82,
	0x8a, 0x1c, 0x25, 0x7d, 0x74, 0x47, 0xf9, 0x48, 0x3a, 0x4a, 0x06, 0x58, 0x0d, 0xbc, 0x1e, 0xb4,
	0x5d, 0x7f, 0x80, 0x17, 0x69, 0xdf, 0x89, 0xba, 0xa7, 0x47, 0xb5, 0xdc, 0xe8, 0xca, 0x7d, 0x19,
	0xe1, 0xde, 0xc8, 0x73, 0x40, 0x44, 0x7d, 0xc0, 0x8c, 0xb7, 0x3d, 0x3a, 0xe3, 0x7d, 0xd8, 0x9b,
	0xf1, 0x46, 0xd6, 0x5e, 0x91, 0x08, 0xf1, 0x94, 0xf7, 0x79, 0x3c, 0xe4, 0x47, 0x2b, 0xdc, 0x88,
	0x17, 0x96, 0x7c, 0x81, 0xb3, 0x43, 0xd4, 0xc7, 0xfd, 0x63, 0xdf, 0xb2, 0x52, 0xbb, 0x8c, 0x72,
	0x12, 0x61, 0x48, 0xb3, 0x5c, 0xfb, 0x43, 0xbc, 0xdf, 0xb4, 0xf1, 0x9a, 0x79, 0xfe, 0xbf, 0xfe,
	0x00, 0xb3, 0x2c, 0x0f, 0x30, 0xff, 0xe9, 0x06, 0x6d, 0xd7, 0xe2, 0x33, 0x47, 0x3f, 0x24, 0xc4,
	0x9b, 0xbd, 0x52, 0x8f, 0xb2, 0xd9, 0x0b, 0x6f, 0xb2, 0xac, 0x85, 0x10, 0x42, 0x61, 0x5a, 0x3c,
	0x16, 0x74, 0xb8, 0xde, 0x0c, 0xf9, 0xe3, 0x71, 0xa8, 0x3c, 0x78, 0x31, 0x51, 0x38, 0x86, 0xf3,
	0x28, 0x63, 0xd4, 0x99, 0x51, 0x2b, 0x24, 0x70, 0x0e, 0xa5, 0xb6, 0xf5, 0x9d, 0x42, 0x92, 0xc3,
	0xe0, 0x72, 0xa0, 0x90, 0xe2, 0x43, 0xb8, 0x8b, 0x28, 0xa4, 0xf1, 0x18, 0x82, 0x2b, 0x85, 0x42,
	0x06, 0x67, 0x51, 0xd2, 0x6c, 0x14, 0xb2, 0x7c, 0xb2, 0xce, 0x6a, 0xd4, 0x2b, 0xe4, 0x16, 0xce,
	0xa1, 0x34, 0xb7, 0x04, 0x8e, 0x64, 0x52, 0xcf, 0x28, 0x1c, 0xe3, 0xdc, 0x74, 0xcf, 0x28, 0x24,
	0x16, 0x2e, 0xa2, 0x9c, 0x4c, 0x2a, 0x9c, 0x00, 0xae, 0x2c, 0x0b, 0xc7, 0xb8, 0x10, 0x86, 0x6d,
	0xf9, 0xd4, 0xf2, 0x0b, 0x89, 0x85, 0x0f, 0x51, 0x4e, 0xea, 0x9f, 0x33, 0xb0, 0x6c, 0x4b, 0x4a,
	0x06, 0x55, 0x6a, 0x21, 0x81, 0x4f, 0xa0, 0xc9, 0x3a, 0xdb, 0xa1, 0x25, 0xa7, 0xae, 0xb7, 0xca,
	0xba, 0x51, 0x2b, 0x24, 0xf1, 0x04, 0x1a, 0xb3, 0xec, 0x92, 0xe7, 0xe8, 0x06, 0x2d, 0xa4, 0x56,
	0xbe, 0xcf, 0xa3, 0xfc, 0x73, 0x47, 0x3a, 0x14, 0xbe, 0x83, 0xd2, 0x4f, 0x99, 0x55, 0xc1, 0x67,
	0x16, 0xc5, 0x1f, 0xce, 0x16, 0xc3, 0x7f, 0xa3, 0x2d, 0x6e, 0x34, 0x1c, 0xbf, 0x35, 0x3d, 0x00,
	0x8e, 0xbf, 0x48, 0xc4, 0x5b, 0xac, 0x97, 0x46, 0x77, 0x3e, 0x5e, 0x4d, 0x1f, 0xac, 0x3d, 0xa2,
	0x5d, 0xfb, 0xe2, 0x9b, 0xbf, 0xfd, 0x32, 0x79, 0x09, 0x5f, 0x5c, 0x7a, 0xbd, 0xc4, 0x2c, 0x9f,
	0xba, 0x96, 0x5e, 0x5f, 0x6a, 0x3a, 0x4b, 0x92, 0x92, 0x3f, 0x97, 0x1c, 0xf1, 0xd9, 0x2f, 0x13,
	0xb1, 0xbf, 0x57, 0x41, 0xcb, 0x00, 0xcf, 0x8f, 0xfa, 0x48, 0xd8, 0x64, 0x99, 0x5e, 0x38, 0x20,
	0x26, 0x97, 0x69, 0x09, 0x64, 0xba, 0x86, 0xdf, 0x19, 0x29, 0xd3, 0x92, 0x38, 0x98, 0x31, 0x79,
	0x6d, 0xd7, 0x6d, 0x6c, 0xe3, 0x91, 0x31, 0x29, 0xba, 0x5a, 0x98, 0x7e, 0xf7, 0xa0, 0xa8, 0xdc,
	0xa4, 0xb7, 0x63, 0x3a, 0x80, 0xae, 0xe4, 0x68, 0x1d, 0x84, 0x8d, 0xec, 0xd1, 0x3a, 0x88, 0x75,
	0x74, 0x3f, 0x43, 0xa8, 0x1b, 0xc2, 0xf1, 0xe5, 0x03, 0xf4, 0xda, 0x5e, 0x4d, 0x5f, 0x3d, 0x58,
	0x47, 0x4e, 0xaa, 0x2b, 0xde, 0x26, 0x1a, 0xa6, 0xae, 0x3d, 0xed, 0xb2, 0x61, 0xea, 0xea, 0xef,
	0x5a, 0xc5, 0xd5, 0x05, 0xe7, 0xf7, 0xd1, 0xea, 0x0a, 0x1b, 0x49, 0xa3, 0xd5, 0x15, 0x6b, 0x08,
	0xfc, 0x84, 0x7b, 0x59, 0xa8, 0xad, 0x8b, 0x43, 0x0e, 0x81, 0xe2, 0xe8, 0x3c, 0x7d, 0xed, 0xc0,
	0xe7, 0xc4, 0x1e, 0xe3, 0x12, 0xc1, 0x6a, 0xb4, 0x71, 0x45, 0x47, 0x98, 0xd1, 0xc6, 0x15, 0xaf,
	0x29, 0x85, 0xb6, 0x62, 0x79, 0x7b, 0x98, 0xb6, 0x7a, 0xeb, 0xae, 0x61, 0xda, 0xea, 0x2b, 0x23,
	0xe2, 0xbb, 0x02, 0x01, 0x7a, 0xf4, 0xae, 0x84, 0xd9, 0x71, 0xf4, 0xae, 0x74, 0xe3, 0x7f, 0xf1,
	0xf4, 0xd7, 0xdf, 0xcd, 0x1e, 0xfb, 0xfa, 0xcd, 0x6c, 0xe2, 0x8f, 0x6f, 0x66, 0x13, 0x7f, 0x7d,
	0x33, 0x9b, 0xf8, 0x2c, 0xa5, 0x3b, 0xac, 0x9c, 0x85, 0xe8, 0xf6, 0xde, 0x3f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x19, 0xc3, 0x7f, 0x73, 0xe4, 0x2b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UpArchiveClient is the client API for UpArchive service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UpArchiveClient interface {
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ArcPassed 投稿列表接口分页模式
	ArcPassed(ctx context.Context, in *ArcPassedReq, opts ...grpc.CallOption) (*ArcPassedReply, error)
	// ArcPassedTotal 投稿列表总投稿数接口
	ArcPassedTotal(ctx context.Context, in *ArcPassedTotalReq, opts ...grpc.CallOption) (*ArcPassedTotalReply, error)
	// ArcPassedCursor 投稿列表游标接口score模式
	ArcPassedCursor(ctx context.Context, in *ArcPassedCursorReq, opts ...grpc.CallOption) (*ArcPassedCursorReply, error)
	// ArcPassedStory story模式专供接口
	ArcPassedStory(ctx context.Context, in *ArcPassedStoryReq, opts ...grpc.CallOption) (*ArcPassedStoryReply, error)
	// ArcsPassed 批量投稿列表接口分页模式
	ArcsPassed(ctx context.Context, in *ArcsPassedReq, opts ...grpc.CallOption) (*ArcsPassedReply, error)
	// ArcsPassedTotal 批量投稿列表总投稿数接口
	ArcsPassedTotal(ctx context.Context, in *ArcsPassedTotalReq, opts ...grpc.CallOption) (*ArcsPassedTotalReply, error)
	// ArcPassedByAid 通过aid获取UP主稿件
	ArcPassedByAid(ctx context.Context, in *ArcPassedByAidReq, opts ...grpc.CallOption) (*ArcPassedByAidReply, error)
	// UpsPassed 多个up主的按分布时间排序的aid接口
	UpsPassed(ctx context.Context, in *UpsArcsReq, opts ...grpc.CallOption) (*UpsAidPubTimeReply, error)
	// ArcPassedSearch 投稿列表稿件搜索
	ArcPassedSearch(ctx context.Context, in *ArcPassedSearchReq, opts ...grpc.CallOption) (*ArcPassedSearchReply, error)
	// ArcsPassedSort 批量投稿列表，包含多种维度排序
	ArcsPassedSort(ctx context.Context, in *ArcsPassedSortReq, opts ...grpc.CallOption) (*ArcsPassedSortReply, error)
	// ArcPassedExist 稿件是否在列表中存在
	ArcPassedExist(ctx context.Context, in *ArcPassedExistReq, opts ...grpc.CallOption) (*ArcPassedExistReply, error)
}

type upArchiveClient struct {
	cc *grpc.ClientConn
}

func NewUpArchiveClient(cc *grpc.ClientConn) UpArchiveClient {
	return &upArchiveClient{cc}
}

func (c *upArchiveClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcPassed(ctx context.Context, in *ArcPassedReq, opts ...grpc.CallOption) (*ArcPassedReply, error) {
	out := new(ArcPassedReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcPassed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcPassedTotal(ctx context.Context, in *ArcPassedTotalReq, opts ...grpc.CallOption) (*ArcPassedTotalReply, error) {
	out := new(ArcPassedTotalReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcPassedTotal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcPassedCursor(ctx context.Context, in *ArcPassedCursorReq, opts ...grpc.CallOption) (*ArcPassedCursorReply, error) {
	out := new(ArcPassedCursorReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcPassedCursor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcPassedStory(ctx context.Context, in *ArcPassedStoryReq, opts ...grpc.CallOption) (*ArcPassedStoryReply, error) {
	out := new(ArcPassedStoryReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcPassedStory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcsPassed(ctx context.Context, in *ArcsPassedReq, opts ...grpc.CallOption) (*ArcsPassedReply, error) {
	out := new(ArcsPassedReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcsPassed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcsPassedTotal(ctx context.Context, in *ArcsPassedTotalReq, opts ...grpc.CallOption) (*ArcsPassedTotalReply, error) {
	out := new(ArcsPassedTotalReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcsPassedTotal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcPassedByAid(ctx context.Context, in *ArcPassedByAidReq, opts ...grpc.CallOption) (*ArcPassedByAidReply, error) {
	out := new(ArcPassedByAidReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcPassedByAid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) UpsPassed(ctx context.Context, in *UpsArcsReq, opts ...grpc.CallOption) (*UpsAidPubTimeReply, error) {
	out := new(UpsAidPubTimeReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/UpsPassed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcPassedSearch(ctx context.Context, in *ArcPassedSearchReq, opts ...grpc.CallOption) (*ArcPassedSearchReply, error) {
	out := new(ArcPassedSearchReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcPassedSearch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcsPassedSort(ctx context.Context, in *ArcsPassedSortReq, opts ...grpc.CallOption) (*ArcsPassedSortReply, error) {
	out := new(ArcsPassedSortReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcsPassedSort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upArchiveClient) ArcPassedExist(ctx context.Context, in *ArcPassedExistReq, opts ...grpc.CallOption) (*ArcPassedExistReply, error) {
	out := new(ArcPassedExistReply)
	err := c.cc.Invoke(ctx, "/up.archive.service.v1.UpArchive/ArcPassedExist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UpArchiveServer is the server API for UpArchive service.
type UpArchiveServer interface {
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// ArcPassed 投稿列表接口分页模式
	ArcPassed(context.Context, *ArcPassedReq) (*ArcPassedReply, error)
	// ArcPassedTotal 投稿列表总投稿数接口
	ArcPassedTotal(context.Context, *ArcPassedTotalReq) (*ArcPassedTotalReply, error)
	// ArcPassedCursor 投稿列表游标接口score模式
	ArcPassedCursor(context.Context, *ArcPassedCursorReq) (*ArcPassedCursorReply, error)
	// ArcPassedStory story模式专供接口
	ArcPassedStory(context.Context, *ArcPassedStoryReq) (*ArcPassedStoryReply, error)
	// ArcsPassed 批量投稿列表接口分页模式
	ArcsPassed(context.Context, *ArcsPassedReq) (*ArcsPassedReply, error)
	// ArcsPassedTotal 批量投稿列表总投稿数接口
	ArcsPassedTotal(context.Context, *ArcsPassedTotalReq) (*ArcsPassedTotalReply, error)
	// ArcPassedByAid 通过aid获取UP主稿件
	ArcPassedByAid(context.Context, *ArcPassedByAidReq) (*ArcPassedByAidReply, error)
	// UpsPassed 多个up主的按分布时间排序的aid接口
	UpsPassed(context.Context, *UpsArcsReq) (*UpsAidPubTimeReply, error)
	// ArcPassedSearch 投稿列表稿件搜索
	ArcPassedSearch(context.Context, *ArcPassedSearchReq) (*ArcPassedSearchReply, error)
	// ArcsPassedSort 批量投稿列表，包含多种维度排序
	ArcsPassedSort(context.Context, *ArcsPassedSortReq) (*ArcsPassedSortReply, error)
	// ArcPassedExist 稿件是否在列表中存在
	ArcPassedExist(context.Context, *ArcPassedExistReq) (*ArcPassedExistReply, error)
}

// UnimplementedUpArchiveServer can be embedded to have forward compatible implementations.
type UnimplementedUpArchiveServer struct {
}

func (*UnimplementedUpArchiveServer) Ping(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedUpArchiveServer) ArcPassed(ctx context.Context, req *ArcPassedReq) (*ArcPassedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcPassed not implemented")
}
func (*UnimplementedUpArchiveServer) ArcPassedTotal(ctx context.Context, req *ArcPassedTotalReq) (*ArcPassedTotalReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcPassedTotal not implemented")
}
func (*UnimplementedUpArchiveServer) ArcPassedCursor(ctx context.Context, req *ArcPassedCursorReq) (*ArcPassedCursorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcPassedCursor not implemented")
}
func (*UnimplementedUpArchiveServer) ArcPassedStory(ctx context.Context, req *ArcPassedStoryReq) (*ArcPassedStoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcPassedStory not implemented")
}
func (*UnimplementedUpArchiveServer) ArcsPassed(ctx context.Context, req *ArcsPassedReq) (*ArcsPassedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcsPassed not implemented")
}
func (*UnimplementedUpArchiveServer) ArcsPassedTotal(ctx context.Context, req *ArcsPassedTotalReq) (*ArcsPassedTotalReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcsPassedTotal not implemented")
}
func (*UnimplementedUpArchiveServer) ArcPassedByAid(ctx context.Context, req *ArcPassedByAidReq) (*ArcPassedByAidReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcPassedByAid not implemented")
}
func (*UnimplementedUpArchiveServer) UpsPassed(ctx context.Context, req *UpsArcsReq) (*UpsAidPubTimeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsPassed not implemented")
}
func (*UnimplementedUpArchiveServer) ArcPassedSearch(ctx context.Context, req *ArcPassedSearchReq) (*ArcPassedSearchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcPassedSearch not implemented")
}
func (*UnimplementedUpArchiveServer) ArcsPassedSort(ctx context.Context, req *ArcsPassedSortReq) (*ArcsPassedSortReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcsPassedSort not implemented")
}
func (*UnimplementedUpArchiveServer) ArcPassedExist(ctx context.Context, req *ArcPassedExistReq) (*ArcPassedExistReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArcPassedExist not implemented")
}

func RegisterUpArchiveServer(s *grpc.Server, srv UpArchiveServer) {
	s.RegisterService(&_UpArchive_serviceDesc, srv)
}

func _UpArchive_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcPassed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcPassedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcPassed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcPassed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcPassed(ctx, req.(*ArcPassedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcPassedTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcPassedTotalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcPassedTotal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcPassedTotal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcPassedTotal(ctx, req.(*ArcPassedTotalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcPassedCursor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcPassedCursorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcPassedCursor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcPassedCursor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcPassedCursor(ctx, req.(*ArcPassedCursorReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcPassedStory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcPassedStoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcPassedStory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcPassedStory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcPassedStory(ctx, req.(*ArcPassedStoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcsPassed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcsPassedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcsPassed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcsPassed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcsPassed(ctx, req.(*ArcsPassedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcsPassedTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcsPassedTotalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcsPassedTotal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcsPassedTotal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcsPassedTotal(ctx, req.(*ArcsPassedTotalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcPassedByAid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcPassedByAidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcPassedByAid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcPassedByAid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcPassedByAid(ctx, req.(*ArcPassedByAidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_UpsPassed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsArcsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).UpsPassed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/UpsPassed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).UpsPassed(ctx, req.(*UpsArcsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcPassedSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcPassedSearchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcPassedSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcPassedSearch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcPassedSearch(ctx, req.(*ArcPassedSearchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcsPassedSort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcsPassedSortReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcsPassedSort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcsPassedSort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcsPassedSort(ctx, req.(*ArcsPassedSortReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpArchive_ArcPassedExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcPassedExistReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpArchiveServer).ArcPassedExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/up.archive.service.v1.UpArchive/ArcPassedExist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpArchiveServer).ArcPassedExist(ctx, req.(*ArcPassedExistReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _UpArchive_serviceDesc = grpc.ServiceDesc{
	ServiceName: "up.archive.service.v1.UpArchive",
	HandlerType: (*UpArchiveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _UpArchive_Ping_Handler,
		},
		{
			MethodName: "ArcPassed",
			Handler:    _UpArchive_ArcPassed_Handler,
		},
		{
			MethodName: "ArcPassedTotal",
			Handler:    _UpArchive_ArcPassedTotal_Handler,
		},
		{
			MethodName: "ArcPassedCursor",
			Handler:    _UpArchive_ArcPassedCursor_Handler,
		},
		{
			MethodName: "ArcPassedStory",
			Handler:    _UpArchive_ArcPassedStory_Handler,
		},
		{
			MethodName: "ArcsPassed",
			Handler:    _UpArchive_ArcsPassed_Handler,
		},
		{
			MethodName: "ArcsPassedTotal",
			Handler:    _UpArchive_ArcsPassedTotal_Handler,
		},
		{
			MethodName: "ArcPassedByAid",
			Handler:    _UpArchive_ArcPassedByAid_Handler,
		},
		{
			MethodName: "UpsPassed",
			Handler:    _UpArchive_UpsPassed_Handler,
		},
		{
			MethodName: "ArcPassedSearch",
			Handler:    _UpArchive_ArcPassedSearch_Handler,
		},
		{
			MethodName: "ArcsPassedSort",
			Handler:    _UpArchive_ArcsPassedSort_Handler,
		},
		{
			MethodName: "ArcPassedExist",
			Handler:    _UpArchive_ArcPassedExist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *ArcPassedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Without) > 0 {
		dAtA2 := make([]byte, len(m.Without)*10)
		var j1 int
		for _, num := range m.Without {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x3a
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x30
	}
	if m.WithoutStaff {
		i--
		if m.WithoutStaff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x22
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Archives) > 0 {
		for iNdEx := len(m.Archives) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Archives[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Arc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Arc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Arc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UpFrom != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UpFrom))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if len(m.ShortLink) > 0 {
		i -= len(m.ShortLink)
		copy(dAtA[i:], m.ShortLink)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ShortLink)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.SeasonTheme != nil {
		{
			size, err := m.SeasonTheme.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.AttributeV2 != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AttributeV2))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.SeasonID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SeasonID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.StaffInfo) > 0 {
		for iNdEx := len(m.StaffInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaffInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.Dimension.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xda
	if m.FirstCid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FirstCid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.Dynamic) > 0 {
		i -= len(m.Dynamic)
		copy(dAtA[i:], m.Dynamic)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Dynamic)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ReportResult) > 0 {
		i -= len(m.ReportResult)
		copy(dAtA[i:], m.ReportResult)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReportResult)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	{
		size, err := m.Stat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	{
		size, err := m.Author.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	{
		size, err := m.Rights.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	if m.Forward != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Forward))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.RedirectURL) > 0 {
		i -= len(m.RedirectURL)
		copy(dAtA[i:], m.RedirectURL)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RedirectURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OrderID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OrderID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.MissionID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MissionID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Duration != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x72
	}
	if m.Attribute != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Attribute))
		i--
		dAtA[i] = 0x68
	}
	if m.Access != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Access))
		i--
		dAtA[i] = 0x60
	}
	if m.State != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x52
	}
	if m.Ctime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x48
	}
	if m.PubDate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PubDate))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Pic) > 0 {
		i -= len(m.Pic)
		copy(dAtA[i:], m.Pic)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Pic)))
		i--
		dAtA[i] = 0x32
	}
	if m.Copyright != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Copyright))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x22
	}
	if m.TypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.Videos != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Videos))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SeasonTheme) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonTheme) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeasonTheme) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TextColor) > 0 {
		i -= len(m.TextColor)
		copy(dAtA[i:], m.TextColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TextColor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SelectedBgColor) > 0 {
		i -= len(m.SelectedBgColor)
		copy(dAtA[i:], m.SelectedBgColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SelectedBgColor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BgColor) > 0 {
		i -= len(m.BgColor)
		copy(dAtA[i:], m.BgColor)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BgColor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StaffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaffInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaffInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attribute != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Attribute))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dimension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dimension) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dimension) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rotate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rotate))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Width != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Rights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rights) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rights) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArcPayFreeWatch != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArcPayFreeWatch))
		i--
		dAtA[i] = 0x70
	}
	if m.ArcPay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArcPay))
		i--
		dAtA[i] = 0x68
	}
	if m.NoBackground != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoBackground))
		i--
		dAtA[i] = 0x60
	}
	if m.UGCPayPreview != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UGCPayPreview))
		i--
		dAtA[i] = 0x58
	}
	if m.IsCooperation != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.IsCooperation))
		i--
		dAtA[i] = 0x50
	}
	if m.UGCPay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UGCPay))
		i--
		dAtA[i] = 0x48
	}
	if m.Autoplay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Autoplay))
		i--
		dAtA[i] = 0x40
	}
	if m.NoReprint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoReprint))
		i--
		dAtA[i] = 0x38
	}
	if m.HD5 != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.HD5))
		i--
		dAtA[i] = 0x30
	}
	if m.Pay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pay))
		i--
		dAtA[i] = 0x28
	}
	if m.Movie != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Movie))
		i--
		dAtA[i] = 0x20
	}
	if m.Download != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Download))
		i--
		dAtA[i] = 0x18
	}
	if m.Elec != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Elec))
		i--
		dAtA[i] = 0x10
	}
	if m.Bp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Bp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Author) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Author) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Author) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Face) > 0 {
		i -= len(m.Face)
		copy(dAtA[i:], m.Face)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Face)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Stat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Follow != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Follow))
		i--
		dAtA[i] = 0x60
	}
	if m.DisLike != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DisLike))
		i--
		dAtA[i] = 0x58
	}
	if m.Like != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Like))
		i--
		dAtA[i] = 0x50
	}
	if m.HisRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.HisRank))
		i--
		dAtA[i] = 0x48
	}
	if m.NowRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NowRank))
		i--
		dAtA[i] = 0x40
	}
	if m.Share != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Share))
		i--
		dAtA[i] = 0x38
	}
	if m.Coin != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x30
	}
	if m.Fav != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fav))
		i--
		dAtA[i] = 0x28
	}
	if m.Reply != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Reply))
		i--
		dAtA[i] = 0x20
	}
	if m.Danmaku != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Danmaku))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedTotalReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedTotalReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedTotalReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Without) > 0 {
		dAtA9 := make([]byte, len(m.Without)*10)
		var j8 int
		for _, num := range m.Without {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintApi(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	if m.WithoutStaff {
		i--
		if m.WithoutStaff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedTotalReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedTotalReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedTotalReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedCursorReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedCursorReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedCursorReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Without) > 0 {
		dAtA11 := make([]byte, len(m.Without)*10)
		var j10 int
		for _, num := range m.Without {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintApi(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x32
	}
	if m.WithoutStaff {
		i--
		if m.WithoutStaff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x22
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedCursorReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedCursorReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedCursorReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedStoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedStoryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedStoryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x30
	}
	if m.NextCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NextCount))
		i--
		dAtA[i] = 0x28
	}
	if m.PrevCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PrevCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedStoryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedStoryReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedStoryReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextArcs) > 0 {
		for iNdEx := len(m.NextArcs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NextArcs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PrevArcs) > 0 {
		for iNdEx := len(m.PrevArcs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrevArcs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StoryArcs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoryArcs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoryArcs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcsPassedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsPassedReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsPassedReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithoutStaff {
		i--
		if m.WithoutStaff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x22
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mids) > 0 {
		dAtA13 := make([]byte, len(m.Mids)*10)
		var j12 int
		for _, num1 := range m.Mids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintApi(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArcsPassedReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsPassedReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsPassedReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Archives) > 0 {
		for k := range m.Archives {
			v := m.Archives[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArcsPassedTotalReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsPassedTotalReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsPassedTotalReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithoutStaff {
		i--
		if m.WithoutStaff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mids) > 0 {
		dAtA16 := make([]byte, len(m.Mids)*10)
		var j15 int
		for _, num1 := range m.Mids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintApi(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArcsPassedTotalReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsPassedTotalReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsPassedTotalReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Total) > 0 {
		for k := range m.Total {
			v := m.Total[k]
			baseI := i
			i = encodeVarintApi(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedByAidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedByAidReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedByAidReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x40
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Without) > 0 {
		dAtA18 := make([]byte, len(m.Without)*10)
		var j17 int
		for _, num := range m.Without {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintApi(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x32
	}
	if m.WithoutStaff {
		i--
		if m.WithoutStaff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x22
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedWithIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedWithIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedWithIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x10
	}
	if m.Archive != nil {
		{
			size, err := m.Archive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedByAidReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedByAidReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedByAidReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cursor != nil {
		{
			size, err := m.Cursor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Archives) > 0 {
		for iNdEx := len(m.Archives) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Archives[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CursorReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CursorReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CursorReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasMore {
		i--
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpsArcsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsArcsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsArcsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithoutStaff {
		i--
		if m.WithoutStaff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mids) > 0 {
		dAtA22 := make([]byte, len(m.Mids)*10)
		var j21 int
		for _, num1 := range m.Mids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintApi(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpsAidPubTimeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsAidPubTimeReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsAidPubTimeReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Archives) > 0 {
		for k := range m.Archives {
			v := m.Archives[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpAidPubTimeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpAidPubTimeReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpAidPubTimeReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Archives) > 0 {
		for iNdEx := len(m.Archives) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Archives[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AidPubTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AidPubTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AidPubTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Copyright != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Copyright))
		i--
		dAtA[i] = 0x18
	}
	if m.Pubdate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pubdate))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedSearchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedSearchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedSearchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Without) > 0 {
		dAtA25 := make([]byte, len(m.Without)*10)
		var j24 int
		for _, num := range m.Without {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintApi(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.KwFields) > 0 {
		dAtA27 := make([]byte, len(m.KwFields)*10)
		var j26 int
		for _, num := range m.KwFields {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintApi(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x52
	}
	if m.HasTags {
		i--
		if m.HasTags {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x42
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x38
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x30
	}
	if m.Pn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x28
	}
	if m.Highlight {
		i--
		if m.Highlight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedSearchReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedSearchReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedSearchReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Archives) > 0 {
		for iNdEx := len(m.Archives) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Archives[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcsPassedSortReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsPassedSortReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsPassedSortReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sort != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x20
	}
	if m.Ps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mids) > 0 {
		dAtA29 := make([]byte, len(m.Mids)*10)
		var j28 int
		for _, num1 := range m.Mids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintApi(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArcsPassedSortReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsPassedSortReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcsPassedSortReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Archives) > 0 {
		for k := range m.Archives {
			v := m.Archives[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedSortReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedSortReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedSortReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Archive) > 0 {
		for iNdEx := len(m.Archive) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Archive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SortArc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortArc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortArc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedExistReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedExistReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedExistReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x28
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Without) > 0 {
		dAtA32 := make([]byte, len(m.Without)*10)
		var j31 int
		for _, num := range m.Without {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintApi(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x1a
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x10
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArcPassedExistReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcPassedExistReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArcPassedExistReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Exist {
		i--
		if m.Exist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ArcPassedReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.WithoutStaff {
		n += 2
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	if len(m.Without) > 0 {
		l = 0
		for _, e := range m.Without {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for _, e := range m.Archives {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Arc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Videos != 0 {
		n += 1 + sovApi(uint64(m.Videos))
	}
	if m.TypeID != 0 {
		n += 1 + sovApi(uint64(m.TypeID))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Copyright != 0 {
		n += 1 + sovApi(uint64(m.Copyright))
	}
	l = len(m.Pic)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PubDate != 0 {
		n += 1 + sovApi(uint64(m.PubDate))
	}
	if m.Ctime != 0 {
		n += 1 + sovApi(uint64(m.Ctime))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.Access != 0 {
		n += 1 + sovApi(uint64(m.Access))
	}
	if m.Attribute != 0 {
		n += 1 + sovApi(uint64(m.Attribute))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Duration != 0 {
		n += 2 + sovApi(uint64(m.Duration))
	}
	if m.MissionID != 0 {
		n += 2 + sovApi(uint64(m.MissionID))
	}
	if m.OrderID != 0 {
		n += 2 + sovApi(uint64(m.OrderID))
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Forward != 0 {
		n += 2 + sovApi(uint64(m.Forward))
	}
	l = m.Rights.Size()
	n += 2 + l + sovApi(uint64(l))
	l = m.Author.Size()
	n += 2 + l + sovApi(uint64(l))
	l = m.Stat.Size()
	n += 2 + l + sovApi(uint64(l))
	l = len(m.ReportResult)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Dynamic)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.FirstCid != 0 {
		n += 2 + sovApi(uint64(m.FirstCid))
	}
	l = m.Dimension.Size()
	n += 2 + l + sovApi(uint64(l))
	if len(m.StaffInfo) > 0 {
		for _, e := range m.StaffInfo {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.SeasonID != 0 {
		n += 2 + sovApi(uint64(m.SeasonID))
	}
	if m.AttributeV2 != 0 {
		n += 2 + sovApi(uint64(m.AttributeV2))
	}
	if m.SeasonTheme != nil {
		l = m.SeasonTheme.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.ShortLink)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.UpFrom != 0 {
		n += 2 + sovApi(uint64(m.UpFrom))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SeasonTheme) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BgColor)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SelectedBgColor)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.TextColor)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StaffInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Attribute != 0 {
		n += 1 + sovApi(uint64(m.Attribute))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dimension) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovApi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovApi(uint64(m.Height))
	}
	if m.Rotate != 0 {
		n += 1 + sovApi(uint64(m.Rotate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rights) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bp != 0 {
		n += 1 + sovApi(uint64(m.Bp))
	}
	if m.Elec != 0 {
		n += 1 + sovApi(uint64(m.Elec))
	}
	if m.Download != 0 {
		n += 1 + sovApi(uint64(m.Download))
	}
	if m.Movie != 0 {
		n += 1 + sovApi(uint64(m.Movie))
	}
	if m.Pay != 0 {
		n += 1 + sovApi(uint64(m.Pay))
	}
	if m.HD5 != 0 {
		n += 1 + sovApi(uint64(m.HD5))
	}
	if m.NoReprint != 0 {
		n += 1 + sovApi(uint64(m.NoReprint))
	}
	if m.Autoplay != 0 {
		n += 1 + sovApi(uint64(m.Autoplay))
	}
	if m.UGCPay != 0 {
		n += 1 + sovApi(uint64(m.UGCPay))
	}
	if m.IsCooperation != 0 {
		n += 1 + sovApi(uint64(m.IsCooperation))
	}
	if m.UGCPayPreview != 0 {
		n += 1 + sovApi(uint64(m.UGCPayPreview))
	}
	if m.NoBackground != 0 {
		n += 1 + sovApi(uint64(m.NoBackground))
	}
	if m.ArcPay != 0 {
		n += 1 + sovApi(uint64(m.ArcPay))
	}
	if m.ArcPayFreeWatch != 0 {
		n += 1 + sovApi(uint64(m.ArcPayFreeWatch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Author) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.View != 0 {
		n += 1 + sovApi(uint64(m.View))
	}
	if m.Danmaku != 0 {
		n += 1 + sovApi(uint64(m.Danmaku))
	}
	if m.Reply != 0 {
		n += 1 + sovApi(uint64(m.Reply))
	}
	if m.Fav != 0 {
		n += 1 + sovApi(uint64(m.Fav))
	}
	if m.Coin != 0 {
		n += 1 + sovApi(uint64(m.Coin))
	}
	if m.Share != 0 {
		n += 1 + sovApi(uint64(m.Share))
	}
	if m.NowRank != 0 {
		n += 1 + sovApi(uint64(m.NowRank))
	}
	if m.HisRank != 0 {
		n += 1 + sovApi(uint64(m.HisRank))
	}
	if m.Like != 0 {
		n += 1 + sovApi(uint64(m.Like))
	}
	if m.DisLike != 0 {
		n += 1 + sovApi(uint64(m.DisLike))
	}
	if m.Follow != 0 {
		n += 1 + sovApi(uint64(m.Follow))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedTotalReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.WithoutStaff {
		n += 2
	}
	if len(m.Without) > 0 {
		l = 0
		for _, e := range m.Without {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedTotalReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedCursorReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.WithoutStaff {
		n += 2
	}
	if len(m.Without) > 0 {
		l = 0
		for _, e := range m.Without {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedCursorReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedStoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PrevCount != 0 {
		n += 1 + sovApi(uint64(m.PrevCount))
	}
	if m.NextCount != 0 {
		n += 1 + sovApi(uint64(m.NextCount))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedStoryReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if len(m.PrevArcs) > 0 {
		for _, e := range m.PrevArcs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.NextArcs) > 0 {
		for _, e := range m.NextArcs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoryArcs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsPassedReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mids) > 0 {
		l = 0
		for _, e := range m.Mids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.WithoutStaff {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsPassedReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for k, v := range m.Archives {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsPassedTotalReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mids) > 0 {
		l = 0
		for _, e := range m.Mids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.WithoutStaff {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsPassedTotalReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Total) > 0 {
		for k, v := range m.Total {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedByAidReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.WithoutStaff {
		n += 2
	}
	if len(m.Without) > 0 {
		l = 0
		for _, e := range m.Without {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedWithIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Archive != nil {
		l = m.Archive.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedByAidReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for _, e := range m.Archives {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.Cursor != nil {
		l = m.Cursor.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CursorReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasMore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsArcsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mids) > 0 {
		l = 0
		for _, e := range m.Mids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	if m.WithoutStaff {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsAidPubTimeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for k, v := range m.Archives {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpAidPubTimeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for _, e := range m.Archives {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AidPubTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Pubdate != 0 {
		n += 1 + sovApi(uint64(m.Pubdate))
	}
	if m.Copyright != 0 {
		n += 1 + sovApi(uint64(m.Copyright))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedSearchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Highlight {
		n += 2
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HasTags {
		n += 2
	}
	if len(m.KwFields) > 0 {
		l = 0
		for _, e := range m.KwFields {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Without) > 0 {
		l = 0
		for _, e := range m.Without {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedSearchReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Archives) > 0 {
		for _, e := range m.Archives {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsPassedSortReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mids) > 0 {
		l = 0
		for _, e := range m.Mids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	if m.Sort != 0 {
		n += 1 + sovApi(uint64(m.Sort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcsPassedSortReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for k, v := range m.Archives {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedSortReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Archive) > 0 {
		for _, e := range m.Archive {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SortArc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedExistReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if len(m.Without) > 0 {
		l = 0
		for _, e := range m.Without {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArcPassedExistReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exist {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ArcPassedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutStaff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutStaff = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= SearchOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v Without
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Without(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Without = append(m.Without, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Without) == 0 {
					m.Without = make([]Without, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Without
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Without(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Without = append(m.Without, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Without", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Archives = append(m.Archives, &Arc{})
			if err := m.Archives[len(m.Archives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Arc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Arc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Arc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Videos", wireType)
			}
			m.Videos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Videos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copyright", wireType)
			}
			m.Copyright = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Copyright |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubDate", wireType)
			}
			m.PubDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubDate |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			m.Access = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Access |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			m.Attribute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attribute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionID", wireType)
			}
			m.MissionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissionID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forward", wireType)
			}
			m.Forward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forward |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dynamic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstCid", wireType)
			}
			m.FirstCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaffInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaffInfo = append(m.StaffInfo, &StaffInfo{})
			if err := m.StaffInfo[len(m.StaffInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonID", wireType)
			}
			m.SeasonID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeV2", wireType)
			}
			m.AttributeV2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeV2 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonTheme", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SeasonTheme == nil {
				m.SeasonTheme = &SeasonTheme{}
			}
			if err := m.SeasonTheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpFrom", wireType)
			}
			m.UpFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpFrom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonTheme) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonTheme: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonTheme: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedBgColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectedBgColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			m.Attribute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attribute |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dimension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dimension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dimension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate", wireType)
			}
			m.Rotate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bp", wireType)
			}
			m.Bp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elec", wireType)
			}
			m.Elec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Elec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Download", wireType)
			}
			m.Download = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Download |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Movie", wireType)
			}
			m.Movie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Movie |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			m.Pay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HD5", wireType)
			}
			m.HD5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HD5 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoReprint", wireType)
			}
			m.NoReprint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoReprint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autoplay", wireType)
			}
			m.Autoplay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Autoplay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UGCPay", wireType)
			}
			m.UGCPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UGCPay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCooperation", wireType)
			}
			m.IsCooperation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCooperation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UGCPayPreview", wireType)
			}
			m.UGCPayPreview = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UGCPayPreview |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBackground", wireType)
			}
			m.NoBackground = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoBackground |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArcPay", wireType)
			}
			m.ArcPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArcPay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArcPayFreeWatch", wireType)
			}
			m.ArcPayFreeWatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArcPayFreeWatch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Author) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Author: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Author: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Danmaku", wireType)
			}
			m.Danmaku = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Danmaku |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			m.Reply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fav", wireType)
			}
			m.Fav = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fav |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowRank", wireType)
			}
			m.NowRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HisRank", wireType)
			}
			m.HisRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HisRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			m.Like = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Like |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisLike", wireType)
			}
			m.DisLike = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisLike |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			m.Follow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follow |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedTotalReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedTotalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedTotalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutStaff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutStaff = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v Without
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Without(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Without = append(m.Without, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Without) == 0 {
					m.Without = make([]Without, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Without
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Without(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Without = append(m.Without, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Without", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedTotalReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedTotalReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedTotalReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedCursorReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedCursorReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedCursorReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutStaff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutStaff = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v Without
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Without(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Without = append(m.Without, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Without) == 0 {
					m.Without = make([]Without, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Without
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Without(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Without = append(m.Without, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Without", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedCursorReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedCursorReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedCursorReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ArcPassed{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedStoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedStoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedStoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevCount", wireType)
			}
			m.PrevCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextCount", wireType)
			}
			m.NextCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedStoryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedStoryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedStoryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevArcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevArcs = append(m.PrevArcs, &StoryArcs{})
			if err := m.PrevArcs[len(m.PrevArcs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextArcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextArcs = append(m.NextArcs, &StoryArcs{})
			if err := m.NextArcs[len(m.NextArcs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoryArcs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoryArcs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoryArcs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsPassedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsPassedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsPassedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mids = append(m.Mids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mids) == 0 {
					m.Mids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mids = append(m.Mids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutStaff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutStaff = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsPassedReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsPassedReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsPassedReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archives == nil {
				m.Archives = make(map[int64]*ArcPassedReply)
			}
			var mapkey int64
			var mapvalue *ArcPassedReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ArcPassedReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Archives[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsPassedTotalReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsPassedTotalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsPassedTotalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mids = append(m.Mids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mids) == 0 {
					m.Mids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mids = append(m.Mids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutStaff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutStaff = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsPassedTotalReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsPassedTotalReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsPassedTotalReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Total[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedByAidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedByAidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedByAidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutStaff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutStaff = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v Without
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Without(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Without = append(m.Without, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Without) == 0 {
					m.Without = make([]Without, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Without
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Without(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Without = append(m.Without, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Without", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= SearchOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedWithIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedWithIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedWithIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archive == nil {
				m.Archive = &ArcPassed{}
			}
			if err := m.Archive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedByAidReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedByAidReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedByAidReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Archives = append(m.Archives, &ArcPassedWithIndex{})
			if err := m.Archives[len(m.Archives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cursor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cursor == nil {
				m.Cursor = &CursorReply{}
			}
			if err := m.Cursor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CursorReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CursorReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CursorReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsArcsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsArcsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsArcsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mids = append(m.Mids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mids) == 0 {
					m.Mids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mids = append(m.Mids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutStaff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutStaff = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsAidPubTimeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsAidPubTimeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsAidPubTimeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archives == nil {
				m.Archives = make(map[int64]*UpAidPubTimeReply)
			}
			var mapkey int64
			var mapvalue *UpAidPubTimeReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UpAidPubTimeReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Archives[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpAidPubTimeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpAidPubTimeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpAidPubTimeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Archives = append(m.Archives, &AidPubTime{})
			if err := m.Archives[len(m.Archives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AidPubTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AidPubTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AidPubTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubdate", wireType)
			}
			m.Pubdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pubdate |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copyright", wireType)
			}
			m.Copyright = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Copyright |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedSearchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedSearchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedSearchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Highlight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Highlight = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= SearchOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTags", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasTags = bool(v != 0)
		case 10:
			if wireType == 0 {
				var v KwField
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= KwField(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KwFields = append(m.KwFields, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.KwFields) == 0 {
					m.KwFields = make([]KwField, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v KwField
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= KwField(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KwFields = append(m.KwFields, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KwFields", wireType)
			}
		case 11:
			if wireType == 0 {
				var v Without
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Without(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Without = append(m.Without, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Without) == 0 {
					m.Without = make([]Without, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Without
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Without(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Without = append(m.Without, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Without", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedSearchReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedSearchReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedSearchReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Archives = append(m.Archives, &Arc{})
			if err := m.Archives[len(m.Archives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsPassedSortReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsPassedSortReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsPassedSortReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mids = append(m.Mids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mids) == 0 {
					m.Mids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mids = append(m.Mids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= SearchOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= Sort(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsPassedSortReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsPassedSortReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsPassedSortReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archives == nil {
				m.Archives = make(map[int64]*ArcPassedSortReply)
			}
			var mapkey int64
			var mapvalue *ArcPassedSortReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ArcPassedSortReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Archives[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedSortReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedSortReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedSortReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Archive = append(m.Archive, &SortArc{})
			if err := m.Archive[len(m.Archive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortArc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortArc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortArc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedExistReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedExistReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedExistReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v Without
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Without(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Without = append(m.Without, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Without) == 0 {
					m.Without = make([]Without, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Without
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Without(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Without = append(m.Without, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Without", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= SearchOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcPassedExistReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcPassedExistReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcPassedExistReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
