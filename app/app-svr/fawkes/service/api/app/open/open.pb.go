// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-gateway/app/app-svr/fawkes/service/api/app/open/open.proto

package open

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CreateProjectReq struct {
	ProjectName          string   `protobuf:"bytes,1,opt,name=project_name,json=projectName,proto3" json:"project_name" form:"project_name" validate:"required"`
	Owner                []string `protobuf:"bytes,2,rep,name=owner,proto3" json:"owner" form:"owner" validate:"required"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description" form:"description"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateProjectReq) Reset()         { *m = CreateProjectReq{} }
func (m *CreateProjectReq) String() string { return proto.CompactTextString(m) }
func (*CreateProjectReq) ProtoMessage()    {}
func (*CreateProjectReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{0}
}
func (m *CreateProjectReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProjectReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProjectReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProjectReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProjectReq.Merge(m, src)
}
func (m *CreateProjectReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateProjectReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProjectReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProjectReq proto.InternalMessageInfo

type UpdateProjectReq struct {
	ProjectId            int64    `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id" validate:"required"`
	Owner                []string `protobuf:"bytes,2,rep,name=owner,proto3" json:"owner" form:"owner" `
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description" form:"description"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateProjectReq) Reset()         { *m = UpdateProjectReq{} }
func (m *UpdateProjectReq) String() string { return proto.CompactTextString(m) }
func (*UpdateProjectReq) ProtoMessage()    {}
func (*UpdateProjectReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{1}
}
func (m *UpdateProjectReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateProjectReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateProjectReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateProjectReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateProjectReq.Merge(m, src)
}
func (m *UpdateProjectReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateProjectReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateProjectReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateProjectReq proto.InternalMessageInfo

type GetProjectInfoReq struct {
	ProjectId            int64    `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetProjectInfoReq) Reset()         { *m = GetProjectInfoReq{} }
func (m *GetProjectInfoReq) String() string { return proto.CompactTextString(m) }
func (*GetProjectInfoReq) ProtoMessage()    {}
func (*GetProjectInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{2}
}
func (m *GetProjectInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjectInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjectInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjectInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjectInfoReq.Merge(m, src)
}
func (m *GetProjectInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *GetProjectInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjectInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjectInfoReq proto.InternalMessageInfo

type GetProjectInfoResp struct {
	ProjectInfo          *ProjectInfo `protobuf:"bytes,1,opt,name=project_info,json=projectInfo,proto3" json:"project_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetProjectInfoResp) Reset()         { *m = GetProjectInfoResp{} }
func (m *GetProjectInfoResp) String() string { return proto.CompactTextString(m) }
func (*GetProjectInfoResp) ProtoMessage()    {}
func (*GetProjectInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{3}
}
func (m *GetProjectInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjectInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjectInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjectInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjectInfoResp.Merge(m, src)
}
func (m *GetProjectInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *GetProjectInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjectInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjectInfoResp proto.InternalMessageInfo

type ProjectInfo struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"project_id" form:"project_id" validate:"required"`
	ProjectName          string   `protobuf:"bytes,2,opt,name=project_name,json=projectName,proto3" json:"project_name" form:"project_name"`
	Owner                []string `protobuf:"bytes,3,rep,name=owner,proto3" json:"owner" form:"owner"`
	Description          string   `protobuf:"bytes,4,opt,name=description,proto3" json:"description" form:"description"`
	Token                string   `protobuf:"bytes,5,opt,name=token,proto3" json:"token" form:"token"`
	Applicant            string   `protobuf:"bytes,6,opt,name=applicant,proto3" json:"applicant" form:"applicant"`
	IsActive             bool     `protobuf:"varint,7,opt,name=is_active,json=isActive,proto3" json:"is_active" form:"is_active"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProjectInfo) Reset()         { *m = ProjectInfo{} }
func (m *ProjectInfo) String() string { return proto.CompactTextString(m) }
func (*ProjectInfo) ProtoMessage()    {}
func (*ProjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{4}
}
func (m *ProjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectInfo.Merge(m, src)
}
func (m *ProjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectInfo proto.InternalMessageInfo

type GetProjectInfoListReq struct {
	ProjectName          string   `protobuf:"bytes,1,opt,name=project_name,json=projectName,proto3" json:"project_name" form:"project_name"`
	Pn                   int64    `protobuf:"varint,2,opt,name=pn,proto3" json:"pn" form:"pn" validate:"required"`
	Ps                   int64    `protobuf:"varint,3,opt,name=ps,proto3" json:"ps" form:"ps" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetProjectInfoListReq) Reset()         { *m = GetProjectInfoListReq{} }
func (m *GetProjectInfoListReq) String() string { return proto.CompactTextString(m) }
func (*GetProjectInfoListReq) ProtoMessage()    {}
func (*GetProjectInfoListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{5}
}
func (m *GetProjectInfoListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjectInfoListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjectInfoListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjectInfoListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjectInfoListReq.Merge(m, src)
}
func (m *GetProjectInfoListReq) XXX_Size() int {
	return m.Size()
}
func (m *GetProjectInfoListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjectInfoListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjectInfoListReq proto.InternalMessageInfo

type GetProjectInfoListResp struct {
	PageInfo             *PageInfo      `protobuf:"bytes,1,opt,name=page_info,json=pageInfo,proto3" json:"page_info" form:"page_info"`
	ProjectInfo          []*ProjectInfo `protobuf:"bytes,2,rep,name=project_info,json=projectInfo,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetProjectInfoListResp) Reset()         { *m = GetProjectInfoListResp{} }
func (m *GetProjectInfoListResp) String() string { return proto.CompactTextString(m) }
func (*GetProjectInfoListResp) ProtoMessage()    {}
func (*GetProjectInfoListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{6}
}
func (m *GetProjectInfoListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjectInfoListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjectInfoListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjectInfoListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjectInfoListResp.Merge(m, src)
}
func (m *GetProjectInfoListResp) XXX_Size() int {
	return m.Size()
}
func (m *GetProjectInfoListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjectInfoListResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjectInfoListResp proto.InternalMessageInfo

type GetOpenApiListReq struct {
	AppKey               string   `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetOpenApiListReq) Reset()         { *m = GetOpenApiListReq{} }
func (m *GetOpenApiListReq) String() string { return proto.CompactTextString(m) }
func (*GetOpenApiListReq) ProtoMessage()    {}
func (*GetOpenApiListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{7}
}
func (m *GetOpenApiListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOpenApiListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOpenApiListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOpenApiListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOpenApiListReq.Merge(m, src)
}
func (m *GetOpenApiListReq) XXX_Size() int {
	return m.Size()
}
func (m *GetOpenApiListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOpenApiListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetOpenApiListReq proto.InternalMessageInfo

type GetOpenApiListResp struct {
	Router               []*Router `protobuf:"bytes,1,rep,name=router,proto3" json:"router" form:"router"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetOpenApiListResp) Reset()         { *m = GetOpenApiListResp{} }
func (m *GetOpenApiListResp) String() string { return proto.CompactTextString(m) }
func (*GetOpenApiListResp) ProtoMessage()    {}
func (*GetOpenApiListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{8}
}
func (m *GetOpenApiListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOpenApiListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOpenApiListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOpenApiListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOpenApiListResp.Merge(m, src)
}
func (m *GetOpenApiListResp) XXX_Size() int {
	return m.Size()
}
func (m *GetOpenApiListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOpenApiListResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetOpenApiListResp proto.InternalMessageInfo

type Router struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path" form:"path"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{9}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

type PathListReq struct {
	ProjectId            int64    `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PathListReq) Reset()         { *m = PathListReq{} }
func (m *PathListReq) String() string { return proto.CompactTextString(m) }
func (*PathListReq) ProtoMessage()    {}
func (*PathListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{10}
}
func (m *PathListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathListReq.Merge(m, src)
}
func (m *PathListReq) XXX_Size() int {
	return m.Size()
}
func (m *PathListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PathListReq.DiscardUnknown(m)
}

var xxx_messageInfo_PathListReq proto.InternalMessageInfo

type PathListResp struct {
	ProjectId            int64           `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id"`
	ProjectName          string          `protobuf:"bytes,2,opt,name=project_name,json=projectName,proto3" json:"project_name" form:"project_name"`
	RouterAccess         []*RouterAccess `protobuf:"bytes,3,rep,name=router_access,json=routerAccess,proto3" json:"items" form:"items"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PathListResp) Reset()         { *m = PathListResp{} }
func (m *PathListResp) String() string { return proto.CompactTextString(m) }
func (*PathListResp) ProtoMessage()    {}
func (*PathListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{11}
}
func (m *PathListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathListResp.Merge(m, src)
}
func (m *PathListResp) XXX_Size() int {
	return m.Size()
}
func (m *PathListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PathListResp.DiscardUnknown(m)
}

var xxx_messageInfo_PathListResp proto.InternalMessageInfo

type RouterAccess struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path" form:"path"`
	AppKey               []string `protobuf:"bytes,3,rep,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	Description          string   `protobuf:"bytes,4,opt,name=description,proto3" json:"description" form:"description"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouterAccess) Reset()         { *m = RouterAccess{} }
func (m *RouterAccess) String() string { return proto.CompactTextString(m) }
func (*RouterAccess) ProtoMessage()    {}
func (*RouterAccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{12}
}
func (m *RouterAccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterAccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterAccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouterAccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterAccess.Merge(m, src)
}
func (m *RouterAccess) XXX_Size() int {
	return m.Size()
}
func (m *RouterAccess) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterAccess.DiscardUnknown(m)
}

var xxx_messageInfo_RouterAccess proto.InternalMessageInfo

type AddPathReq struct {
	ProjectId            int64           `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id" validate:"required"`
	RouterAccess         []*RouterAccess `protobuf:"bytes,2,rep,name=router_access,json=routerAccess,proto3" json:"router_access" form:"router_access"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AddPathReq) Reset()         { *m = AddPathReq{} }
func (m *AddPathReq) String() string { return proto.CompactTextString(m) }
func (*AddPathReq) ProtoMessage()    {}
func (*AddPathReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{13}
}
func (m *AddPathReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPathReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPathReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPathReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPathReq.Merge(m, src)
}
func (m *AddPathReq) XXX_Size() int {
	return m.Size()
}
func (m *AddPathReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPathReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddPathReq proto.InternalMessageInfo

type UpdatePathReq struct {
	ProjectId            int64         `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id" validate:"required"`
	PathUpdate           []*PathUpdate `protobuf:"bytes,2,rep,name=path_update,json=pathUpdate,proto3" json:"items" form:"items" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdatePathReq) Reset()         { *m = UpdatePathReq{} }
func (m *UpdatePathReq) String() string { return proto.CompactTextString(m) }
func (*UpdatePathReq) ProtoMessage()    {}
func (*UpdatePathReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{14}
}
func (m *UpdatePathReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePathReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePathReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePathReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePathReq.Merge(m, src)
}
func (m *UpdatePathReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePathReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePathReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePathReq proto.InternalMessageInfo

type PathUpdate struct {
	PathId               int64    `protobuf:"varint,1,opt,name=path_id,json=pathId,proto3" json:"path_id" form:"path_id" validate:"required"`
	AppKey               []string `protobuf:"bytes,2,rep,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key" validate:"required"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description" form:"description"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PathUpdate) Reset()         { *m = PathUpdate{} }
func (m *PathUpdate) String() string { return proto.CompactTextString(m) }
func (*PathUpdate) ProtoMessage()    {}
func (*PathUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{15}
}
func (m *PathUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathUpdate.Merge(m, src)
}
func (m *PathUpdate) XXX_Size() int {
	return m.Size()
}
func (m *PathUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_PathUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_PathUpdate proto.InternalMessageInfo

type RouterAccessUpdate struct {
	PathAccessId         int64    `protobuf:"varint,1,opt,name=path_access_id,json=pathAccessId,proto3" json:"path_access_id" form:"path_access_id"`
	IsActive             bool     `protobuf:"varint,2,opt,name=is_active,json=isActive,proto3" json:"is_active" form:"is_active"`
	AppKey               []string `protobuf:"bytes,3,rep,name=app_key,json=appKey,proto3" json:"app_key" form:"app_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouterAccessUpdate) Reset()         { *m = RouterAccessUpdate{} }
func (m *RouterAccessUpdate) String() string { return proto.CompactTextString(m) }
func (*RouterAccessUpdate) ProtoMessage()    {}
func (*RouterAccessUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{16}
}
func (m *RouterAccessUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterAccessUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterAccessUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouterAccessUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterAccessUpdate.Merge(m, src)
}
func (m *RouterAccessUpdate) XXX_Size() int {
	return m.Size()
}
func (m *RouterAccessUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterAccessUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_RouterAccessUpdate proto.InternalMessageInfo

type DeletePathReq struct {
	ProjectId            int64    `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id" validate:"required"`
	PathId               []int64  `protobuf:"varint,2,rep,packed,name=path_id,json=pathId,proto3" json:"path_id" form:"path_id" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeletePathReq) Reset()         { *m = DeletePathReq{} }
func (m *DeletePathReq) String() string { return proto.CompactTextString(m) }
func (*DeletePathReq) ProtoMessage()    {}
func (*DeletePathReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{17}
}
func (m *DeletePathReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletePathReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletePathReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletePathReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletePathReq.Merge(m, src)
}
func (m *DeletePathReq) XXX_Size() int {
	return m.Size()
}
func (m *DeletePathReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletePathReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeletePathReq proto.InternalMessageInfo

type DeletePathResp struct {
	DeletedCount         int64    `protobuf:"varint,1,opt,name=deleted_count,json=deletedCount,proto3" json:"deleted_count" form:"deleted_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeletePathResp) Reset()         { *m = DeletePathResp{} }
func (m *DeletePathResp) String() string { return proto.CompactTextString(m) }
func (*DeletePathResp) ProtoMessage()    {}
func (*DeletePathResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{18}
}
func (m *DeletePathResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletePathResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletePathResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletePathResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletePathResp.Merge(m, src)
}
func (m *DeletePathResp) XXX_Size() int {
	return m.Size()
}
func (m *DeletePathResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletePathResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeletePathResp proto.InternalMessageInfo

type ActiveProjectReq struct {
	ProjectId            int64    `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id" form:"project_id" validate:"required"`
	IsActive             bool     `protobuf:"varint,2,opt,name=is_active,json=isActive,proto3" json:"is_active" form:"is_active"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActiveProjectReq) Reset()         { *m = ActiveProjectReq{} }
func (m *ActiveProjectReq) String() string { return proto.CompactTextString(m) }
func (*ActiveProjectReq) ProtoMessage()    {}
func (*ActiveProjectReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{19}
}
func (m *ActiveProjectReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveProjectReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveProjectReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveProjectReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveProjectReq.Merge(m, src)
}
func (m *ActiveProjectReq) XXX_Size() int {
	return m.Size()
}
func (m *ActiveProjectReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveProjectReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveProjectReq proto.InternalMessageInfo

type PageInfo struct {
	Total                int64    `protobuf:"varint,1,opt,name=total,proto3" json:"total"`
	Pn                   int64    `protobuf:"varint,2,opt,name=pn,proto3" json:"pn"`
	Ps                   int64    `protobuf:"varint,3,opt,name=ps,proto3" json:"ps"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PageInfo) Reset()         { *m = PageInfo{} }
func (m *PageInfo) String() string { return proto.CompactTextString(m) }
func (*PageInfo) ProtoMessage()    {}
func (*PageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e4303c49db8273b, []int{20}
}
func (m *PageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageInfo.Merge(m, src)
}
func (m *PageInfo) XXX_Size() int {
	return m.Size()
}
func (m *PageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PageInfo proto.InternalMessageInfo

func init() {
	proto.RegisterType((*CreateProjectReq)(nil), "app.open.v1.CreateProjectReq")
	proto.RegisterType((*UpdateProjectReq)(nil), "app.open.v1.UpdateProjectReq")
	proto.RegisterType((*GetProjectInfoReq)(nil), "app.open.v1.GetProjectInfoReq")
	proto.RegisterType((*GetProjectInfoResp)(nil), "app.open.v1.GetProjectInfoResp")
	proto.RegisterType((*ProjectInfo)(nil), "app.open.v1.ProjectInfo")
	proto.RegisterType((*GetProjectInfoListReq)(nil), "app.open.v1.GetProjectInfoListReq")
	proto.RegisterType((*GetProjectInfoListResp)(nil), "app.open.v1.GetProjectInfoListResp")
	proto.RegisterType((*GetOpenApiListReq)(nil), "app.open.v1.GetOpenApiListReq")
	proto.RegisterType((*GetOpenApiListResp)(nil), "app.open.v1.GetOpenApiListResp")
	proto.RegisterType((*Router)(nil), "app.open.v1.Router")
	proto.RegisterType((*PathListReq)(nil), "app.open.v1.PathListReq")
	proto.RegisterType((*PathListResp)(nil), "app.open.v1.PathListResp")
	proto.RegisterType((*RouterAccess)(nil), "app.open.v1.RouterAccess")
	proto.RegisterType((*AddPathReq)(nil), "app.open.v1.AddPathReq")
	proto.RegisterType((*UpdatePathReq)(nil), "app.open.v1.UpdatePathReq")
	proto.RegisterType((*PathUpdate)(nil), "app.open.v1.PathUpdate")
	proto.RegisterType((*RouterAccessUpdate)(nil), "app.open.v1.RouterAccessUpdate")
	proto.RegisterType((*DeletePathReq)(nil), "app.open.v1.DeletePathReq")
	proto.RegisterType((*DeletePathResp)(nil), "app.open.v1.DeletePathResp")
	proto.RegisterType((*ActiveProjectReq)(nil), "app.open.v1.ActiveProjectReq")
	proto.RegisterType((*PageInfo)(nil), "app.open.v1.PageInfo")
}

func init() {
	proto.RegisterFile("go-gateway/app/app-svr/fawkes/service/api/app/open/open.proto", fileDescriptor_2e4303c49db8273b)
}

var fileDescriptor_2e4303c49db8273b = []byte{
	// 1465 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdf, 0x6f, 0x14, 0xd5,
	0x17, 0x67, 0xb6, 0x65, 0xdb, 0xbd, 0xbb, 0x6d, 0xca, 0xe5, 0x4b, 0x59, 0x96, 0x2f, 0x9d, 0x7e,
	0x2f, 0x5f, 0x2c, 0x08, 0xdd, 0x91, 0x22, 0x92, 0x40, 0xd4, 0xb4, 0x68, 0x10, 0x30, 0x08, 0x93,
	0x40, 0xa2, 0x26, 0xd4, 0xdb, 0x9d, 0xdb, 0xed, 0xd8, 0xdd, 0x99, 0xcb, 0xdc, 0x69, 0x6b, 0x13,
	0x4d, 0x88, 0xff, 0x81, 0xf1, 0xc5, 0xbf, 0xc1, 0x57, 0xff, 0x08, 0x79, 0x52, 0x12, 0xe3, 0xeb,
	0x28, 0xa8, 0x2f, 0x1b, 0x7d, 0xd9, 0x37, 0xdf, 0xcc, 0xfd, 0x31, 0x33, 0x77, 0xa6, 0xb3, 0x6d,
	0x29, 0xad, 0x0f, 0xd0, 0xbd, 0xe7, 0xdc, 0x7b, 0x7e, 0x7e, 0xce, 0x99, 0x73, 0xc0, 0x9b, 0x6d,
	0x7f, 0xb6, 0x8d, 0x43, 0xb2, 0x81, 0x37, 0x2d, 0x4c, 0x29, 0xff, 0x37, 0xcb, 0xd6, 0x03, 0x6b,
	0x19, 0x6f, 0xac, 0x12, 0x66, 0x31, 0x12, 0xac, 0xbb, 0x2d, 0x62, 0x61, 0xea, 0x0a, 0xb6, 0x4f,
	0x89, 0x27, 0xfe, 0x6b, 0xd2, 0xc0, 0x0f, 0x7d, 0x58, 0xc5, 0x94, 0x36, 0xc5, 0x79, 0xfd, 0x62,
	0x63, 0xb6, 0xed, 0x86, 0x2b, 0x6b, 0x4b, 0xcd, 0x96, 0xdf, 0xb5, 0xda, 0x7e, 0xdb, 0xb7, 0xc4,
	0x9d, 0xa5, 0xb5, 0x65, 0x71, 0x12, 0x07, 0xf1, 0x4b, 0xbe, 0x6d, 0xfc, 0xb7, 0xed, 0xfb, 0xed,
	0x8e, 0x92, 0xed, 0x79, 0x7e, 0x88, 0x43, 0xd7, 0xf7, 0x98, 0xe2, 0x9e, 0x54, 0xdc, 0x44, 0x06,
	0xe9, 0xd2, 0x70, 0x53, 0x32, 0xd1, 0xe3, 0x12, 0x98, 0xb8, 0x1e, 0x10, 0x1c, 0x92, 0xbb, 0x81,
	0xff, 0x29, 0x69, 0x85, 0x36, 0x79, 0x04, 0x1f, 0x82, 0x1a, 0x95, 0xa7, 0x45, 0x0f, 0x77, 0x49,
	0xdd, 0x98, 0x36, 0xce, 0x56, 0x16, 0xae, 0xf5, 0x22, 0x33, 0x43, 0xef, 0x47, 0xe6, 0xcc, 0xb2,
	0x1f, 0x74, 0xaf, 0x22, 0x9d, 0x8a, 0xa6, 0xd7, 0x71, 0xc7, 0x75, 0x70, 0x48, 0xae, 0xa2, 0x80,
	0x3c, 0x5a, 0x73, 0x03, 0xe2, 0x20, 0xbb, 0xaa, 0xae, 0xdc, 0xc1, 0x5d, 0x02, 0xaf, 0x83, 0xc3,
	0xfe, 0x86, 0x47, 0x82, 0x7a, 0x69, 0x7a, 0xe8, 0x6c, 0x65, 0x61, 0xb6, 0x17, 0x99, 0x92, 0xd0,
	0x8f, 0xcc, 0x69, 0x29, 0x51, 0x1c, 0x8b, 0x45, 0xc9, 0xab, 0xf0, 0x06, 0xa8, 0x3a, 0x84, 0xb5,
	0x02, 0x97, 0x72, 0x67, 0xeb, 0x43, 0xc2, 0xc6, 0x33, 0xbd, 0xc8, 0xd4, 0xc9, 0xfd, 0xc8, 0x84,
	0x52, 0xa0, 0x46, 0x44, 0xb6, 0x7e, 0x05, 0xfd, 0x61, 0x80, 0x89, 0xfb, 0xd4, 0xc9, 0x86, 0xe0,
	0x01, 0x00, 0xb1, 0x53, 0xae, 0x23, 0x02, 0x30, 0xb4, 0x70, 0xa5, 0x17, 0x99, 0x1a, 0xb5, 0x1f,
	0x99, 0x67, 0xb2, 0xee, 0xbb, 0x4e, 0xb1, 0xc5, 0x15, 0x75, 0xe1, 0xa6, 0x03, 0x5f, 0xcb, 0xba,
	0xde, 0xd0, 0x5d, 0x1f, 0xcb, 0xb8, 0xbe, 0xef, 0x7e, 0xae, 0x82, 0x23, 0x37, 0x48, 0xa8, 0x7c,
	0xbc, 0xe9, 0x2d, 0xfb, 0x07, 0xe8, 0x27, 0xba, 0x07, 0x60, 0x5e, 0x19, 0xa3, 0xf0, 0x5a, 0x0a,
	0x2c, 0xd7, 0x5b, 0xf6, 0x85, 0xbe, 0xea, 0x5c, 0xbd, 0xa9, 0x61, 0xbf, 0xa9, 0xbf, 0x89, 0x51,
	0xc3, 0x0f, 0xe8, 0x87, 0x21, 0x50, 0xd5, 0x98, 0xf0, 0x06, 0x28, 0xbd, 0xbc, 0xc9, 0x25, 0xd7,
	0x81, 0xb7, 0x72, 0x70, 0x2f, 0x89, 0x10, 0xcf, 0x14, 0xc0, 0xfd, 0x68, 0x01, 0xdc, 0xb3, 0xd0,
	0xb6, 0xe2, 0xfc, 0x0e, 0x89, 0xfc, 0x9e, 0xd0, 0xf3, 0x5b, 0xd3, 0xf3, 0x3b, 0x20, 0xbd, 0xc3,
	0x7b, 0x4d, 0x2f, 0xd7, 0x1c, 0xfa, 0xab, 0xc4, 0xab, 0x1f, 0x16, 0x22, 0x84, 0x66, 0x41, 0x48,
	0x35, 0x8b, 0x23, 0xb2, 0x25, 0x19, 0xbe, 0x0d, 0x2a, 0x98, 0xd2, 0x8e, 0xdb, 0xc2, 0x5e, 0x58,
	0x2f, 0x8b, 0x47, 0xff, 0xeb, 0x45, 0x66, 0x4a, 0xec, 0x47, 0xe6, 0x84, 0x7c, 0x98, 0x90, 0x90,
	0x9d, 0xb2, 0xe1, 0x5b, 0xa0, 0xe2, 0xb2, 0x45, 0xdc, 0x0a, 0xdd, 0x75, 0x52, 0x1f, 0x99, 0x36,
	0xce, 0x8e, 0x4a, 0x01, 0x09, 0x31, 0x15, 0x90, 0x90, 0x90, 0x3d, 0xea, 0xb2, 0x79, 0xf9, 0xf3,
	0x67, 0x03, 0x1c, 0xcb, 0x82, 0xe4, 0x7d, 0x97, 0x89, 0xea, 0xbb, 0x55, 0xd8, 0x80, 0xf6, 0x96,
	0x91, 0x2b, 0xa0, 0x44, 0x3d, 0x91, 0xd3, 0x21, 0x21, 0xa1, 0x44, 0x79, 0x44, 0x4e, 0xa9, 0x77,
	0xde, 0x00, 0x58, 0x50, 0x4f, 0x3c, 0x64, 0xa2, 0xde, 0xe2, 0x87, 0x4c, 0x7b, 0xc8, 0x06, 0x3d,
	0x64, 0xe8, 0x7b, 0x03, 0x4c, 0x16, 0xf9, 0xc5, 0x28, 0xbc, 0x0f, 0x2a, 0x14, 0xb7, 0x89, 0x8e,
	0xfe, 0x63, 0x59, 0xf4, 0xe3, 0x36, 0xe1, 0x2f, 0x64, 0x24, 0x93, 0xbb, 0x69, 0x24, 0x13, 0x12,
	0xb2, 0x47, 0xa9, 0xba, 0x0c, 0x1f, 0xe4, 0xea, 0x8a, 0x37, 0x97, 0x6d, 0xea, 0x4a, 0x82, 0xc3,
	0x0d, 0x49, 0x97, 0xa5, 0xe0, 0x10, 0x47, 0x94, 0x2d, 0xb9, 0xdb, 0xa2, 0x65, 0x7c, 0x40, 0x89,
	0x37, 0x4f, 0xdd, 0x38, 0x39, 0x6f, 0x80, 0x11, 0x4c, 0xe9, 0xe2, 0x2a, 0xd9, 0x54, 0x79, 0x39,
	0xd5, 0x8b, 0xcc, 0x98, 0xd4, 0x8f, 0xcc, 0xf1, 0x04, 0x33, 0x9c, 0x80, 0xec, 0x32, 0xa6, 0xf4,
	0x36, 0xd9, 0x44, 0x0f, 0x45, 0x4b, 0xc8, 0x08, 0x63, 0x14, 0xbe, 0x07, 0xca, 0x81, 0xbf, 0x16,
	0x92, 0xa0, 0x6e, 0x08, 0xa3, 0x8f, 0x66, 0x8c, 0xb6, 0x05, 0x6b, 0xe1, 0x64, 0x2f, 0x32, 0xd5,
	0xb5, 0xb4, 0x4f, 0xca, 0x33, 0xb2, 0x15, 0x03, 0x5d, 0x06, 0x65, 0x79, 0x1d, 0x9e, 0x07, 0xc3,
	0x14, 0x87, 0x2b, 0xca, 0xbc, 0xe3, 0xbd, 0xc8, 0x14, 0xe7, 0x7e, 0x64, 0x56, 0xe3, 0x20, 0x86,
	0x2b, 0xc8, 0x16, 0x44, 0x74, 0x0f, 0x54, 0xef, 0xe2, 0x70, 0x25, 0xf6, 0x6e, 0xa1, 0xa0, 0x21,
	0x9e, 0xde, 0xd2, 0x5d, 0x8e, 0x6c, 0xe9, 0x2e, 0x7a, 0xf3, 0xfb, 0xdb, 0x00, 0xb5, 0x54, 0x26,
	0xa3, 0xfb, 0x21, 0x74, 0x5f, 0xbb, 0xd4, 0x87, 0x60, 0x4c, 0x06, 0x6d, 0x11, 0xb7, 0x5a, 0x84,
	0x31, 0xd1, 0xad, 0xaa, 0x73, 0x27, 0x0a, 0x62, 0x3f, 0x2f, 0x2e, 0x6c, 0x87, 0x98, 0x5a, 0xa0,
	0x5d, 0x44, 0xcf, 0x0c, 0x50, 0xd3, 0x5f, 0xc2, 0xd3, 0x5a, 0x9b, 0x3e, 0xca, 0xcb, 0x48, 0xf8,
	0x5a, 0x51, 0x22, 0x54, 0x0b, 0x8e, 0x33, 0x56, 0xda, 0x45, 0xc6, 0x74, 0x00, 0xca, 0x2e, 0xbb,
	0x3b, 0x00, 0xee, 0x5b, 0xab, 0x45, 0x3f, 0x1a, 0x00, 0xcc, 0x3b, 0x0e, 0x4f, 0xf1, 0x41, 0xce,
	0x0a, 0x6e, 0x3e, 0x4b, 0xa5, 0x9d, 0xb2, 0x74, 0xae, 0x17, 0x99, 0xd9, 0x37, 0xfd, 0xc8, 0xfc,
	0x8f, 0x5e, 0x2e, 0x8a, 0x9c, 0xcf, 0xda, 0x53, 0x03, 0x8c, 0xa9, 0x19, 0xe8, 0x80, 0x9d, 0x6a,
	0x83, 0x2a, 0x4f, 0xe2, 0xe2, 0x9a, 0xd0, 0xa6, 0x5c, 0x3a, 0x9e, 0xeb, 0x81, 0xe1, 0x8a, 0x34,
	0x46, 0x8e, 0x86, 0x31, 0xec, 0xa6, 0x75, 0xd8, 0x15, 0xea, 0x01, 0x34, 0x79, 0x8a, 0xfe, 0x32,
	0x00, 0x48, 0x25, 0xc1, 0x5b, 0x60, 0x44, 0xe8, 0x4d, 0x9c, 0xb9, 0xc8, 0x41, 0xa3, 0x48, 0xfd,
	0xc8, 0x44, 0x29, 0xce, 0x06, 0xba, 0x51, 0xe6, 0x5c, 0x51, 0x8a, 0x09, 0x00, 0xe5, 0x18, 0x77,
	0x31, 0x0b, 0x40, 0x94, 0x05, 0x60, 0xb1, 0xac, 0x62, 0x50, 0xee, 0x7d, 0xbc, 0xfb, 0xc5, 0x00,
	0x50, 0x07, 0x83, 0xf2, 0xfb, 0x1e, 0x18, 0x17, 0x3e, 0xc9, 0xbc, 0xa7, 0xee, 0x9f, 0xef, 0x45,
	0x66, 0x8e, 0xd3, 0x8f, 0xcc, 0x63, 0x5a, 0x14, 0x12, 0x3a, 0xb2, 0x6b, 0x9c, 0x20, 0xc5, 0xde,
	0x74, 0xb2, 0xdf, 0xfd, 0xd2, 0x0b, 0x7f, 0xf7, 0xf7, 0x5a, 0xbf, 0xe8, 0x3b, 0x03, 0x8c, 0xbd,
	0x43, 0x3a, 0xe4, 0xe0, 0x41, 0xaa, 0x81, 0x85, 0x27, 0xf8, 0x65, 0xc0, 0x82, 0x3e, 0x01, 0xe3,
	0xba, 0xd1, 0x8c, 0xc2, 0x3b, 0x60, 0xcc, 0x11, 0x14, 0x67, 0xb1, 0xe5, 0xaf, 0x79, 0xa1, 0x32,
	0x5c, 0x14, 0x6f, 0x86, 0x91, 0x16, 0x6f, 0x86, 0x8c, 0xec, 0x9a, 0x3a, 0x5f, 0x17, 0xc7, 0x6f,
	0x0d, 0x30, 0x21, 0x43, 0xfb, 0x2f, 0x2c, 0x30, 0x2f, 0x99, 0x7c, 0xf4, 0x31, 0x18, 0x8d, 0x67,
	0x1c, 0x68, 0xf2, 0x91, 0x35, 0xc4, 0x1d, 0x65, 0x5e, 0x45, 0x8e, 0xac, 0x21, 0xee, 0xd8, 0xf2,
	0x0f, 0x9c, 0xd4, 0x66, 0xb7, 0xb2, 0x9c, 0xdd, 0xc4, 0x68, 0x36, 0xa9, 0x8d, 0x66, 0x92, 0xce,
	0xf8, 0xe4, 0x35, 0xf7, 0x67, 0x05, 0x0c, 0xf3, 0x01, 0x03, 0x86, 0x60, 0x2c, 0xb3, 0xd5, 0xc2,
	0x53, 0x99, 0x0e, 0x93, 0xdf, 0x78, 0x1b, 0x93, 0x4d, 0xb9, 0x24, 0x37, 0xe3, 0x25, 0xb9, 0xf9,
	0x2e, 0x5f, 0x92, 0xd1, 0x85, 0x2f, 0x7f, 0xfa, 0xfd, 0xeb, 0xd2, 0x2b, 0xe8, 0xff, 0xd6, 0x67,
	0x16, 0x76, 0xba, 0xae, 0x17, 0xaf, 0xf3, 0xc9, 0x0a, 0xaf, 0x22, 0x63, 0x61, 0xc7, 0x81, 0x8f,
	0x0d, 0x30, 0x9e, 0x1d, 0xfc, 0xe0, 0x54, 0x46, 0xef, 0x96, 0xfd, 0xab, 0x61, 0x6e, 0xcb, 0x67,
	0x14, 0xcd, 0x0a, 0x0b, 0x66, 0xe0, 0x99, 0x1d, 0x2d, 0xe0, 0x93, 0x1f, 0xfc, 0xca, 0xc8, 0x2f,
	0x5e, 0x7c, 0x08, 0x81, 0x68, 0x1b, 0x35, 0x6a, 0xf2, 0x69, 0x9c, 0xde, 0xf1, 0x0e, 0xa3, 0x68,
	0x4e, 0x98, 0x73, 0x01, 0xbe, 0xba, 0x2b, 0x73, 0xac, 0x0e, 0x57, 0xbe, 0x91, 0x7c, 0x5b, 0x0a,
	0x93, 0x91, 0xdf, 0xbd, 0x07, 0x26, 0xc3, 0x12, 0xba, 0xcf, 0xa1, 0x99, 0x1d, 0x75, 0xcb, 0x8f,
	0x0b, 0x57, 0x9c, 0xa9, 0x8b, 0x9c, 0xe2, 0x7c, 0xcd, 0xec, 0x83, 0x62, 0x89, 0x77, 0x48, 0xc1,
	0x88, 0x9a, 0x0f, 0x60, 0xf6, 0xd3, 0x96, 0x4e, 0x0d, 0x03, 0x95, 0xbd, 0x2e, 0x94, 0x35, 0xd1,
	0x85, 0x1d, 0x95, 0xf1, 0x06, 0x63, 0x11, 0x0f, 0x2f, 0x75, 0x08, 0xfc, 0x02, 0x80, 0xf4, 0xfb,
	0x0d, 0x1b, 0x45, 0x01, 0xde, 0x41, 0xef, 0x35, 0xa1, 0xf7, 0x32, 0xba, 0xb4, 0x3b, 0xbd, 0x98,
	0xd2, 0x55, 0xb2, 0x19, 0x47, 0xfa, 0x73, 0x00, 0xd2, 0x26, 0x97, 0x53, 0x9f, 0x69, 0xd9, 0x8d,
	0x93, 0x03, 0x79, 0x8c, 0xa2, 0xcb, 0xc2, 0x06, 0x0b, 0xcd, 0xee, 0xce, 0x06, 0xc7, 0x65, 0xc2,
	0x79, 0xc6, 0x7b, 0x8a, 0x1c, 0xb7, 0x61, 0x7d, 0xcb, 0x28, 0x11, 0xe3, 0xfb, 0xc4, 0x00, 0xce,
	0x0b, 0xa1, 0x5a, 0xe8, 0x15, 0xa8, 0x56, 0xc5, 0xae, 0xed, 0x33, 0x5b, 0x8b, 0x3d, 0xbb, 0x39,
	0x6d, 0x2d, 0xf6, 0xdc, 0x32, 0xf4, 0x02, 0xc5, 0x8e, 0xa9, 0xcb, 0x16, 0x1a, 0x4f, 0x9e, 0x4d,
	0x1d, 0x7a, 0xf2, 0x7c, 0xca, 0x78, 0xfa, 0x7c, 0xca, 0xf8, 0xf5, 0xf9, 0x94, 0xf1, 0xcd, 0x6f,
	0x53, 0x87, 0x3e, 0x1a, 0xe6, 0x17, 0x97, 0xca, 0x22, 0xbd, 0x97, 0xfe, 0x09, 0x00, 0x00, 0xff,
	0xff, 0xed, 0xe0, 0xd7, 0x73, 0x97, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OpenClient is the client API for Open service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OpenClient interface {
	// 新增项目
	CreateProject(ctx context.Context, in *CreateProjectReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 获取项目信息
	GetProjectInfo(ctx context.Context, in *GetProjectInfoReq, opts ...grpc.CallOption) (*GetProjectInfoResp, error)
	// 获取项目信息列表
	GetProjectInfoList(ctx context.Context, in *GetProjectInfoListReq, opts ...grpc.CallOption) (*GetProjectInfoListResp, error)
	// 更新项目信息
	UpdateProject(ctx context.Context, in *UpdateProjectReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 删除项目
	ActiveProject(ctx context.Context, in *ActiveProjectReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 新建接口权限信息
	AddPath(ctx context.Context, in *AddPathReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 更新接口appKey
	UpdatePath(ctx context.Context, in *UpdatePathReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 删除接口权限信息
	DeletePath(ctx context.Context, in *DeletePathReq, opts ...grpc.CallOption) (*DeletePathResp, error)
	// 接口权限详情列表
	PathList(ctx context.Context, in *PathListReq, opts ...grpc.CallOption) (*PathListResp, error)
	// 获取api列表
	GetOpenApiList(ctx context.Context, in *GetOpenApiListReq, opts ...grpc.CallOption) (*GetOpenApiListResp, error)
}

type openClient struct {
	cc *grpc.ClientConn
}

func NewOpenClient(cc *grpc.ClientConn) OpenClient {
	return &openClient{cc}
}

func (c *openClient) CreateProject(ctx context.Context, in *CreateProjectReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/CreateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) GetProjectInfo(ctx context.Context, in *GetProjectInfoReq, opts ...grpc.CallOption) (*GetProjectInfoResp, error) {
	out := new(GetProjectInfoResp)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/GetProjectInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) GetProjectInfoList(ctx context.Context, in *GetProjectInfoListReq, opts ...grpc.CallOption) (*GetProjectInfoListResp, error) {
	out := new(GetProjectInfoListResp)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/GetProjectInfoList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) UpdateProject(ctx context.Context, in *UpdateProjectReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/UpdateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) ActiveProject(ctx context.Context, in *ActiveProjectReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/ActiveProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) AddPath(ctx context.Context, in *AddPathReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/AddPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) UpdatePath(ctx context.Context, in *UpdatePathReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/UpdatePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) DeletePath(ctx context.Context, in *DeletePathReq, opts ...grpc.CallOption) (*DeletePathResp, error) {
	out := new(DeletePathResp)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/DeletePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) PathList(ctx context.Context, in *PathListReq, opts ...grpc.CallOption) (*PathListResp, error) {
	out := new(PathListResp)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/PathList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openClient) GetOpenApiList(ctx context.Context, in *GetOpenApiListReq, opts ...grpc.CallOption) (*GetOpenApiListResp, error) {
	out := new(GetOpenApiListResp)
	err := c.cc.Invoke(ctx, "/app.open.v1.Open/GetOpenApiList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenServer is the server API for Open service.
type OpenServer interface {
	// 新增项目
	CreateProject(context.Context, *CreateProjectReq) (*empty.Empty, error)
	// 获取项目信息
	GetProjectInfo(context.Context, *GetProjectInfoReq) (*GetProjectInfoResp, error)
	// 获取项目信息列表
	GetProjectInfoList(context.Context, *GetProjectInfoListReq) (*GetProjectInfoListResp, error)
	// 更新项目信息
	UpdateProject(context.Context, *UpdateProjectReq) (*empty.Empty, error)
	// 删除项目
	ActiveProject(context.Context, *ActiveProjectReq) (*empty.Empty, error)
	// 新建接口权限信息
	AddPath(context.Context, *AddPathReq) (*empty.Empty, error)
	// 更新接口appKey
	UpdatePath(context.Context, *UpdatePathReq) (*empty.Empty, error)
	// 删除接口权限信息
	DeletePath(context.Context, *DeletePathReq) (*DeletePathResp, error)
	// 接口权限详情列表
	PathList(context.Context, *PathListReq) (*PathListResp, error)
	// 获取api列表
	GetOpenApiList(context.Context, *GetOpenApiListReq) (*GetOpenApiListResp, error)
}

// UnimplementedOpenServer can be embedded to have forward compatible implementations.
type UnimplementedOpenServer struct {
}

func (*UnimplementedOpenServer) CreateProject(ctx context.Context, req *CreateProjectReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (*UnimplementedOpenServer) GetProjectInfo(ctx context.Context, req *GetProjectInfoReq) (*GetProjectInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectInfo not implemented")
}
func (*UnimplementedOpenServer) GetProjectInfoList(ctx context.Context, req *GetProjectInfoListReq) (*GetProjectInfoListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectInfoList not implemented")
}
func (*UnimplementedOpenServer) UpdateProject(ctx context.Context, req *UpdateProjectReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProject not implemented")
}
func (*UnimplementedOpenServer) ActiveProject(ctx context.Context, req *ActiveProjectReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActiveProject not implemented")
}
func (*UnimplementedOpenServer) AddPath(ctx context.Context, req *AddPathReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPath not implemented")
}
func (*UnimplementedOpenServer) UpdatePath(ctx context.Context, req *UpdatePathReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePath not implemented")
}
func (*UnimplementedOpenServer) DeletePath(ctx context.Context, req *DeletePathReq) (*DeletePathResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePath not implemented")
}
func (*UnimplementedOpenServer) PathList(ctx context.Context, req *PathListReq) (*PathListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PathList not implemented")
}
func (*UnimplementedOpenServer) GetOpenApiList(ctx context.Context, req *GetOpenApiListReq) (*GetOpenApiListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOpenApiList not implemented")
}

func RegisterOpenServer(s *grpc.Server, srv OpenServer) {
	s.RegisterService(&_Open_serviceDesc, srv)
}

func _Open_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).CreateProject(ctx, req.(*CreateProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_GetProjectInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).GetProjectInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/GetProjectInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).GetProjectInfo(ctx, req.(*GetProjectInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_GetProjectInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectInfoListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).GetProjectInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/GetProjectInfoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).GetProjectInfoList(ctx, req.(*GetProjectInfoListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_UpdateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).UpdateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/UpdateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).UpdateProject(ctx, req.(*UpdateProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_ActiveProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).ActiveProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/ActiveProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).ActiveProject(ctx, req.(*ActiveProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_AddPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).AddPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/AddPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).AddPath(ctx, req.(*AddPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_UpdatePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).UpdatePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/UpdatePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).UpdatePath(ctx, req.(*UpdatePathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_DeletePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).DeletePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/DeletePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).DeletePath(ctx, req.(*DeletePathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_PathList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).PathList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/PathList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).PathList(ctx, req.(*PathListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Open_GetOpenApiList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOpenApiListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenServer).GetOpenApiList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.open.v1.Open/GetOpenApiList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenServer).GetOpenApiList(ctx, req.(*GetOpenApiListReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Open_serviceDesc = grpc.ServiceDesc{
	ServiceName: "app.open.v1.Open",
	HandlerType: (*OpenServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProject",
			Handler:    _Open_CreateProject_Handler,
		},
		{
			MethodName: "GetProjectInfo",
			Handler:    _Open_GetProjectInfo_Handler,
		},
		{
			MethodName: "GetProjectInfoList",
			Handler:    _Open_GetProjectInfoList_Handler,
		},
		{
			MethodName: "UpdateProject",
			Handler:    _Open_UpdateProject_Handler,
		},
		{
			MethodName: "ActiveProject",
			Handler:    _Open_ActiveProject_Handler,
		},
		{
			MethodName: "AddPath",
			Handler:    _Open_AddPath_Handler,
		},
		{
			MethodName: "UpdatePath",
			Handler:    _Open_UpdatePath_Handler,
		},
		{
			MethodName: "DeletePath",
			Handler:    _Open_DeletePath_Handler,
		},
		{
			MethodName: "PathList",
			Handler:    _Open_PathList_Handler,
		},
		{
			MethodName: "GetOpenApiList",
			Handler:    _Open_GetOpenApiList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go-gateway/app/app-svr/fawkes/service/api/app/open/open.proto",
}

func (m *CreateProjectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProjectReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProjectReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		for iNdEx := len(m.Owner) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Owner[iNdEx])
			copy(dAtA[i:], m.Owner[iNdEx])
			i = encodeVarintOpen(dAtA, i, uint64(len(m.Owner[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ProjectName) > 0 {
		i -= len(m.ProjectName)
		copy(dAtA[i:], m.ProjectName)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.ProjectName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateProjectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateProjectReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateProjectReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		for iNdEx := len(m.Owner) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Owner[iNdEx])
			copy(dAtA[i:], m.Owner[iNdEx])
			i = encodeVarintOpen(dAtA, i, uint64(len(m.Owner[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetProjectInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjectInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjectInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetProjectInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjectInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjectInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProjectInfo != nil {
		{
			size, err := m.ProjectInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpen(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Applicant) > 0 {
		i -= len(m.Applicant)
		copy(dAtA[i:], m.Applicant)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Applicant)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		for iNdEx := len(m.Owner) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Owner[iNdEx])
			copy(dAtA[i:], m.Owner[iNdEx])
			i = encodeVarintOpen(dAtA, i, uint64(len(m.Owner[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProjectName) > 0 {
		i -= len(m.ProjectName)
		copy(dAtA[i:], m.ProjectName)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.ProjectName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetProjectInfoListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjectInfoListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjectInfoListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ps != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProjectName) > 0 {
		i -= len(m.ProjectName)
		copy(dAtA[i:], m.ProjectName)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.ProjectName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetProjectInfoListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjectInfoListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjectInfoListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProjectInfo) > 0 {
		for iNdEx := len(m.ProjectInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpen(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PageInfo != nil {
		{
			size, err := m.PageInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpen(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetOpenApiListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOpenApiListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOpenApiListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetOpenApiListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOpenApiListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOpenApiListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Router) > 0 {
		for iNdEx := len(m.Router) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Router[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpen(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PathListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RouterAccess) > 0 {
		for iNdEx := len(m.RouterAccess) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouterAccess[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpen(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProjectName) > 0 {
		i -= len(m.ProjectName)
		copy(dAtA[i:], m.ProjectName)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.ProjectName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouterAccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterAccess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouterAccess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppKey) > 0 {
		for iNdEx := len(m.AppKey) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppKey[iNdEx])
			copy(dAtA[i:], m.AppKey[iNdEx])
			i = encodeVarintOpen(dAtA, i, uint64(len(m.AppKey[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddPathReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPathReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPathReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RouterAccess) > 0 {
		for iNdEx := len(m.RouterAccess) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouterAccess[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpen(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePathReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePathReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePathReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PathUpdate) > 0 {
		for iNdEx := len(m.PathUpdate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PathUpdate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpen(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PathUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpen(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppKey) > 0 {
		for iNdEx := len(m.AppKey) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppKey[iNdEx])
			copy(dAtA[i:], m.AppKey[iNdEx])
			i = encodeVarintOpen(dAtA, i, uint64(len(m.AppKey[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PathId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.PathId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouterAccessUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterAccessUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouterAccessUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppKey) > 0 {
		for iNdEx := len(m.AppKey) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppKey[iNdEx])
			copy(dAtA[i:], m.AppKey[iNdEx])
			i = encodeVarintOpen(dAtA, i, uint64(len(m.AppKey[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PathAccessId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.PathAccessId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeletePathReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePathReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletePathReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PathId) > 0 {
		dAtA4 := make([]byte, len(m.PathId)*10)
		var j3 int
		for _, num1 := range m.PathId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintOpen(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeletePathResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePathResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletePathResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeletedCount != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.DeletedCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActiveProjectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveProjectReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveProjectReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ProjectId != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ps != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x18
	}
	if m.Pn != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintOpen(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOpen(dAtA []byte, offset int, v uint64) int {
	offset -= sovOpen(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreateProjectReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if len(m.Owner) > 0 {
		for _, s := range m.Owner {
			l = len(s)
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateProjectReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	if len(m.Owner) > 0 {
		for _, s := range m.Owner {
			l = len(s)
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetProjectInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetProjectInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectInfo != nil {
		l = m.ProjectInfo.Size()
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOpen(uint64(m.Id))
	}
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if len(m.Owner) > 0 {
		for _, s := range m.Owner {
			l = len(s)
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	l = len(m.Applicant)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetProjectInfoListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.Pn != 0 {
		n += 1 + sovOpen(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovOpen(uint64(m.Ps))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetProjectInfoListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageInfo != nil {
		l = m.PageInfo.Size()
		n += 1 + l + sovOpen(uint64(l))
	}
	if len(m.ProjectInfo) > 0 {
		for _, e := range m.ProjectInfo {
			l = e.Size()
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOpenApiListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOpenApiListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Router) > 0 {
		for _, e := range m.Router {
			l = e.Size()
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if len(m.RouterAccess) > 0 {
		for _, e := range m.RouterAccess {
			l = e.Size()
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouterAccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOpen(uint64(m.Id))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if len(m.AppKey) > 0 {
		for _, s := range m.AppKey {
			l = len(s)
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddPathReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	if len(m.RouterAccess) > 0 {
		for _, e := range m.RouterAccess {
			l = e.Size()
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdatePathReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	if len(m.PathUpdate) > 0 {
		for _, e := range m.PathUpdate {
			l = e.Size()
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PathId != 0 {
		n += 1 + sovOpen(uint64(m.PathId))
	}
	if len(m.AppKey) > 0 {
		for _, s := range m.AppKey {
			l = len(s)
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpen(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouterAccessUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PathAccessId != 0 {
		n += 1 + sovOpen(uint64(m.PathAccessId))
	}
	if m.IsActive {
		n += 2
	}
	if len(m.AppKey) > 0 {
		for _, s := range m.AppKey {
			l = len(s)
			n += 1 + l + sovOpen(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeletePathReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	if len(m.PathId) > 0 {
		l = 0
		for _, e := range m.PathId {
			l += sovOpen(uint64(e))
		}
		n += 1 + sovOpen(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeletePathResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeletedCount != 0 {
		n += 1 + sovOpen(uint64(m.DeletedCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActiveProjectReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovOpen(uint64(m.ProjectId))
	}
	if m.IsActive {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovOpen(uint64(m.Total))
	}
	if m.Pn != 0 {
		n += 1 + sovOpen(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovOpen(uint64(m.Ps))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOpen(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOpen(x uint64) (n int) {
	return sovOpen(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateProjectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProjectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProjectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateProjectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateProjectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateProjectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjectInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjectInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjectInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjectInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjectInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjectInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProjectInfo == nil {
				m.ProjectInfo = &ProjectInfo{}
			}
			if err := m.ProjectInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applicant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applicant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjectInfoListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjectInfoListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjectInfoListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjectInfoListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjectInfoListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjectInfoListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageInfo == nil {
				m.PageInfo = &PageInfo{}
			}
			if err := m.PageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectInfo = append(m.ProjectInfo, &ProjectInfo{})
			if err := m.ProjectInfo[len(m.ProjectInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOpenApiListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOpenApiListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOpenApiListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOpenApiListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOpenApiListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOpenApiListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = append(m.Router, &Router{})
			if err := m.Router[len(m.Router)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterAccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterAccess = append(m.RouterAccess, &RouterAccess{})
			if err := m.RouterAccess[len(m.RouterAccess)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterAccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterAccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterAccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = append(m.AppKey, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPathReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPathReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPathReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterAccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterAccess = append(m.RouterAccess, &RouterAccess{})
			if err := m.RouterAccess[len(m.RouterAccess)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePathReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePathReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePathReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathUpdate = append(m.PathUpdate, &PathUpdate{})
			if err := m.PathUpdate[len(m.PathUpdate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathId", wireType)
			}
			m.PathId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = append(m.AppKey, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterAccessUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterAccessUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterAccessUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathAccessId", wireType)
			}
			m.PathAccessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathAccessId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpen
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpen
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = append(m.AppKey, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePathReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePathReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePathReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PathId = append(m.PathId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpen
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOpen
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PathId) == 0 {
					m.PathId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PathId = append(m.PathId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PathId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePathResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePathResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePathResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedCount", wireType)
			}
			m.DeletedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletedCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveProjectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveProjectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveProjectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOpen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpen(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpen
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOpen
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOpen
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOpen
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOpen        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpen          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOpen = fmt.Errorf("proto: unexpected end of group")
)
