// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-gateway/app/app-svr/playurl/service/api/api.proto

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NetworkType int32

const (
	NetworkType_NT_UNKNOWN NetworkType = 0
	NetworkType_WIFI       NetworkType = 1
	NetworkType_CELLULAR   NetworkType = 2
	NetworkType_OFFLINE    NetworkType = 3
	NetworkType_OTHERNET   NetworkType = 4
	NetworkType_ETHERNET   NetworkType = 5
)

var NetworkType_name = map[int32]string{
	0: "NT_UNKNOWN",
	1: "WIFI",
	2: "CELLULAR",
	3: "OFFLINE",
	4: "OTHERNET",
	5: "ETHERNET",
}

var NetworkType_value = map[string]int32{
	"NT_UNKNOWN": 0,
	"WIFI":       1,
	"CELLULAR":   2,
	"OFFLINE":    3,
	"OTHERNET":   4,
	"ETHERNET":   5,
}

func (x NetworkType) String() string {
	return proto.EnumName(NetworkType_name, int32(x))
}

func (NetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{0}
}

type TFType int32

const (
	TFType_TF_UNKNOWN TFType = 0
	TFType_U_CARD     TFType = 1
	TFType_U_PKG      TFType = 2
	TFType_C_CARD     TFType = 3
	TFType_C_PKG      TFType = 4
	TFType_T_CARD     TFType = 5
	TFType_T_PKG      TFType = 6
)

var TFType_name = map[int32]string{
	0: "TF_UNKNOWN",
	1: "U_CARD",
	2: "U_PKG",
	3: "C_CARD",
	4: "C_PKG",
	5: "T_CARD",
	6: "T_PKG",
}

var TFType_value = map[string]int32{
	"TF_UNKNOWN": 0,
	"U_CARD":     1,
	"U_PKG":      2,
	"C_CARD":     3,
	"C_PKG":      4,
	"T_CARD":     5,
	"T_PKG":      6,
}

func (x TFType) String() string {
	return proto.EnumName(TFType_name, int32(x))
}

func (TFType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{1}
}

type PlayURLReq struct {
	//稿件aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty" validate:"gt=0,required"`
	//稿件cid
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty" validate:"gt=0,required"`
	//清晰度
	Qn int64 `protobuf:"varint,3,opt,name=qn,proto3" json:"qn,omitempty"`
	//是否是flv离线下载请求, npcybs=1有效,其他均无效
	Npcybs int32 `protobuf:"varint,4,opt,name=npcybs,proto3" json:"npcybs,omitempty"`
	//平台
	Platform string `protobuf:"bytes,5,opt,name=platform,proto3" json:"platform,omitempty"`
	//默认0 播放器请求端使用的, 功能版本号
	Fnver int32 `protobuf:"varint,6,opt,name=fnver,proto3" json:"fnver,omitempty"`
	//默认0 播放器请求端使用的, 功能标识
	Fnval int32 `protobuf:"varint,7,opt,name=fnval,proto3" json:"fnval,omitempty"`
	//session未找到使用点
	Session string `protobuf:"bytes,8,opt,name=session,proto3" json:"session,omitempty"`
	//build版本号
	Build int32 `protobuf:"varint,9,opt,name=build,proto3" json:"build,omitempty"`
	//返回url是否强制使用域名(非ip地址), force_host=1使用http域名，force_host=2使用https域名, 0为使用ip地址
	ForceHost int32 `protobuf:"varint,10,opt,name=force_host,json=forceHost,proto3" json:"force_host,omitempty"`
	//客户端设备唯一标识
	Buvid string `protobuf:"bytes,11,opt,name=buvid,proto3" json:"buvid,omitempty"`
	//登录mid
	Mid int64 `protobuf:"varint,12,opt,name=mid,proto3" json:"mid,omitempty"`
	//resolution未找到使用点
	Resolution string `protobuf:"bytes,13,opt,name=resolution,proto3" json:"resolution,omitempty"`
	//低版本引导升级aid
	UpgradeAid int64 `protobuf:"varint,14,opt,name=upgrade_aid,json=upgradeAid,proto3" json:"upgrade_aid,omitempty"`
	//低版本引导升级cid
	UpgradeCid int64 `protobuf:"varint,15,opt,name=upgrade_cid,json=upgradeCid,proto3" json:"upgrade_cid,omitempty"`
	// type
	Type string `protobuf:"bytes,16,opt,name=type,proto3" json:"type,omitempty"`
	//是否需要4K视频, fourk=true表示需要4K视频, 其他都是不需要
	Fourk int32 `protobuf:"varint,17,opt,name=fourk,proto3" json:"fourk,omitempty"`
	//设备：phone、ipad
	Device string `protobuf:"bytes,18,opt,name=device,proto3" json:"device,omitempty"`
	//平台：iphone、white、ipad、android、android_i、android_G、iphone_i、ipad_i、android_tv（后面带 I 是表示海外版、android_G 安卓谷歌版）
	MobiApp string `protobuf:"bytes,19,opt,name=mobi_app,json=mobiApp,proto3" json:"mobi_app,omitempty"`
	//下载那参数
	Dl int32 `protobuf:"varint,20,opt,name=dl,proto3" json:"dl,omitempty"`
	//低版本需要（是否校验支持互动视频否 1:是）
	VerifySteins         int32    `protobuf:"varint,21,opt,name=verify_steins,json=verifySteins,proto3" json:"verify_steins,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayURLReq) Reset()         { *m = PlayURLReq{} }
func (m *PlayURLReq) String() string { return proto.CompactTextString(m) }
func (*PlayURLReq) ProtoMessage()    {}
func (*PlayURLReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{0}
}
func (m *PlayURLReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayURLReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayURLReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayURLReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayURLReq.Merge(m, src)
}
func (m *PlayURLReq) XXX_Size() int {
	return m.Size()
}
func (m *PlayURLReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayURLReq.DiscardUnknown(m)
}

var xxx_messageInfo_PlayURLReq proto.InternalMessageInfo

func (m *PlayURLReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *PlayURLReq) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *PlayURLReq) GetQn() int64 {
	if m != nil {
		return m.Qn
	}
	return 0
}

func (m *PlayURLReq) GetNpcybs() int32 {
	if m != nil {
		return m.Npcybs
	}
	return 0
}

func (m *PlayURLReq) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *PlayURLReq) GetFnver() int32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *PlayURLReq) GetFnval() int32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *PlayURLReq) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *PlayURLReq) GetBuild() int32 {
	if m != nil {
		return m.Build
	}
	return 0
}

func (m *PlayURLReq) GetForceHost() int32 {
	if m != nil {
		return m.ForceHost
	}
	return 0
}

func (m *PlayURLReq) GetBuvid() string {
	if m != nil {
		return m.Buvid
	}
	return ""
}

func (m *PlayURLReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *PlayURLReq) GetResolution() string {
	if m != nil {
		return m.Resolution
	}
	return ""
}

func (m *PlayURLReq) GetUpgradeAid() int64 {
	if m != nil {
		return m.UpgradeAid
	}
	return 0
}

func (m *PlayURLReq) GetUpgradeCid() int64 {
	if m != nil {
		return m.UpgradeCid
	}
	return 0
}

func (m *PlayURLReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PlayURLReq) GetFourk() int32 {
	if m != nil {
		return m.Fourk
	}
	return 0
}

func (m *PlayURLReq) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *PlayURLReq) GetMobiApp() string {
	if m != nil {
		return m.MobiApp
	}
	return ""
}

func (m *PlayURLReq) GetDl() int32 {
	if m != nil {
		return m.Dl
	}
	return 0
}

func (m *PlayURLReq) GetVerifySteins() int32 {
	if m != nil {
		return m.VerifySteins
	}
	return 0
}

type PlayURLReply struct {
	// 表示是否是B站只有视频, 目前固定为"local"
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from"`
	// 返回结果, 正确为"suee", 错误为"error"
	Result string `protobuf:"bytes,2,opt,name=result,proto3" json:"result"`
	//返回视频的清晰度
	Quality uint32 `protobuf:"varint,3,opt,name=quality,proto3" json:"quality"`
	//返回视频的格式
	Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format"`
	//返回视频的总时长, 单位为ms
	Timelength uint64 `protobuf:"varint,5,opt,name=timelength,proto3" json:"timelength"`
	//返回视频的拥有的清晰度格式的列表
	AcceptFormat string `protobuf:"bytes,6,opt,name=accept_format,json=acceptFormat,proto3" json:"accept_format"`
	//返回视频的拥有的清晰度描述的列表
	AcceptDescription []string `protobuf:"bytes,7,rep,name=accept_description,json=acceptDescription,proto3" json:"accept_description,omitempty"`
	//返回视频的拥有的清晰度列表
	AcceptQuality []uint32 `protobuf:"varint,8,rep,packed,name=accept_quality,json=acceptQuality,proto3" json:"accept_quality"`
	//返回视频的编码号
	VideoCodecid uint32 `protobuf:"varint,9,opt,name=video_codecid,json=videoCodecid,proto3" json:"video_codecid"`
	//透传返回请求的fnver
	Fnver uint32 `protobuf:"varint,10,opt,name=fnver,proto3" json:"fnver"`
	//透传返回请求的fnval
	Fnval uint32 `protobuf:"varint,11,opt,name=fnval,proto3" json:"fnval"`
	//返回视频的是否支持投影
	VideoProject bool `protobuf:"varint,12,opt,name=video_project,json=videoProject,proto3" json:"video_project"`
	//返回视频的seek参数, 目前固定为"start"
	SeekParam string `protobuf:"bytes,13,opt,name=seek_param,json=seekParam,proto3" json:"seek_param"`
	//返回视频的seek类型, mp4视频为"second", flv视频为"offset"
	SeekType string `protobuf:"bytes,14,opt,name=seek_type,json=seekType,proto3" json:"seek_type"`
	//进行ab test时候命中测试范围返回的测试ID号, 不返回该字段如果不进行ab test
	Abtid int32 `protobuf:"varint,15,opt,name=abtid,proto3" json:"abtid,omitempty"`
	//返回视频播放url的列表，有durl则没dash字段
	Durl []*Durl `protobuf:"bytes,16,rep,name=durl,proto3" json:"durl,omitempty"`
	//返回DASH视频的MPD格式文件,有dash则没durl字段
	Dash *Dash `protobuf:"bytes,17,opt,name=dash,proto3" json:"dash,omitempty"`
	//表示cid是否非全二压，1表示非全二压
	NoRexcode            int32    `protobuf:"varint,18,opt,name=no_rexcode,json=noRexcode,proto3" json:"no_rexcode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayURLReply) Reset()         { *m = PlayURLReply{} }
func (m *PlayURLReply) String() string { return proto.CompactTextString(m) }
func (*PlayURLReply) ProtoMessage()    {}
func (*PlayURLReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{1}
}
func (m *PlayURLReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayURLReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayURLReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayURLReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayURLReply.Merge(m, src)
}
func (m *PlayURLReply) XXX_Size() int {
	return m.Size()
}
func (m *PlayURLReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayURLReply.DiscardUnknown(m)
}

var xxx_messageInfo_PlayURLReply proto.InternalMessageInfo

func (m *PlayURLReply) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *PlayURLReply) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *PlayURLReply) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *PlayURLReply) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *PlayURLReply) GetTimelength() uint64 {
	if m != nil {
		return m.Timelength
	}
	return 0
}

func (m *PlayURLReply) GetAcceptFormat() string {
	if m != nil {
		return m.AcceptFormat
	}
	return ""
}

func (m *PlayURLReply) GetAcceptDescription() []string {
	if m != nil {
		return m.AcceptDescription
	}
	return nil
}

func (m *PlayURLReply) GetAcceptQuality() []uint32 {
	if m != nil {
		return m.AcceptQuality
	}
	return nil
}

func (m *PlayURLReply) GetVideoCodecid() uint32 {
	if m != nil {
		return m.VideoCodecid
	}
	return 0
}

func (m *PlayURLReply) GetFnver() uint32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *PlayURLReply) GetFnval() uint32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *PlayURLReply) GetVideoProject() bool {
	if m != nil {
		return m.VideoProject
	}
	return false
}

func (m *PlayURLReply) GetSeekParam() string {
	if m != nil {
		return m.SeekParam
	}
	return ""
}

func (m *PlayURLReply) GetSeekType() string {
	if m != nil {
		return m.SeekType
	}
	return ""
}

func (m *PlayURLReply) GetAbtid() int32 {
	if m != nil {
		return m.Abtid
	}
	return 0
}

func (m *PlayURLReply) GetDurl() []*Durl {
	if m != nil {
		return m.Durl
	}
	return nil
}

func (m *PlayURLReply) GetDash() *Dash {
	if m != nil {
		return m.Dash
	}
	return nil
}

func (m *PlayURLReply) GetNoRexcode() int32 {
	if m != nil {
		return m.NoRexcode
	}
	return 0
}

type Dash struct {
	//dash的信息
	Duration uint32 `protobuf:"varint,1,opt,name=duration,proto3" json:"duration,omitempty"`
	//dash的信息
	MinBufferTime float32 `protobuf:"fixed32,2,opt,name=minBufferTime,proto3" json:"minBufferTime,omitempty"`
	//dash视频信息
	Video []*DashItem `protobuf:"bytes,3,rep,name=video,proto3" json:"video"`
	//dash视频信息
	Audio                []*DashItem `protobuf:"bytes,4,rep,name=audio,proto3" json:"audio"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Dash) Reset()         { *m = Dash{} }
func (m *Dash) String() string { return proto.CompactTextString(m) }
func (*Dash) ProtoMessage()    {}
func (*Dash) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{2}
}
func (m *Dash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dash.Merge(m, src)
}
func (m *Dash) XXX_Size() int {
	return m.Size()
}
func (m *Dash) XXX_DiscardUnknown() {
	xxx_messageInfo_Dash.DiscardUnknown(m)
}

var xxx_messageInfo_Dash proto.InternalMessageInfo

func (m *Dash) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Dash) GetMinBufferTime() float32 {
	if m != nil {
		return m.MinBufferTime
	}
	return 0
}

func (m *Dash) GetVideo() []*DashItem {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *Dash) GetAudio() []*DashItem {
	if m != nil {
		return m.Audio
	}
	return nil
}

type DashSegmentBase struct {
	//dash的信息
	Initialization string `protobuf:"bytes,1,opt,name=Initialization,proto3" json:"Initialization,omitempty"`
	//dash的信息
	IndexRange           string   `protobuf:"bytes,2,opt,name=indexRange,proto3" json:"indexRange,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DashSegmentBase) Reset()         { *m = DashSegmentBase{} }
func (m *DashSegmentBase) String() string { return proto.CompactTextString(m) }
func (*DashSegmentBase) ProtoMessage()    {}
func (*DashSegmentBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{3}
}
func (m *DashSegmentBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DashSegmentBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DashSegmentBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DashSegmentBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DashSegmentBase.Merge(m, src)
}
func (m *DashSegmentBase) XXX_Size() int {
	return m.Size()
}
func (m *DashSegmentBase) XXX_DiscardUnknown() {
	xxx_messageInfo_DashSegmentBase.DiscardUnknown(m)
}

var xxx_messageInfo_DashSegmentBase proto.InternalMessageInfo

func (m *DashSegmentBase) GetInitialization() string {
	if m != nil {
		return m.Initialization
	}
	return ""
}

func (m *DashSegmentBase) GetIndexRange() string {
	if m != nil {
		return m.IndexRange
	}
	return ""
}

type DashItem struct {
	//dash的清晰度
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	//dash的url地址
	BaseUrl string `protobuf:"bytes,2,opt,name=base_url,json=baseUrl,proto3" json:"base_url"`
	//dash的backup url地址
	BackupUrl []string `protobuf:"bytes,3,rep,name=backup_url,json=backupUrl,proto3" json:"backup_url,omitempty"`
	//dash的信息
	Bandwidth uint32 `protobuf:"varint,4,opt,name=bandwidth,proto3" json:"bandwidth"`
	//dash的信息
	MimeType string `protobuf:"bytes,5,opt,name=mimeType,proto3" json:"mimeType,omitempty"`
	//dash的信息
	Codecs string `protobuf:"bytes,6,opt,name=codecs,proto3" json:"codecs,omitempty"`
	//dash的信息
	Width uint32 `protobuf:"varint,7,opt,name=width,proto3" json:"width,omitempty"`
	//dash的信息
	Height uint32 `protobuf:"varint,8,opt,name=height,proto3" json:"height,omitempty"`
	//dash的信息
	FrameRate string `protobuf:"bytes,9,opt,name=frameRate,proto3" json:"frameRate,omitempty"`
	//dash的信息
	Sar string `protobuf:"bytes,10,opt,name=sar,proto3" json:"sar,omitempty"`
	//dash的信息
	StartWithSAP uint32 `protobuf:"varint,11,opt,name=startWithSAP,proto3" json:"startWithSAP,omitempty"`
	//dash的信息
	SegmentBase *DashSegmentBase `protobuf:"bytes,12,opt,name=SegmentBase,proto3" json:"SegmentBase,omitempty"`
	Codecid     uint32           `protobuf:"varint,13,opt,name=codecid,proto3" json:"codecid"`
	//视频分片的md5,只有dash离线下载才有值
	Md5 string `protobuf:"bytes,14,opt,name=md5,proto3" json:"md5,omitempty"`
	//视频分片的大小, 单位Byte,只有dash离线下载才有值
	Size_                uint64   `protobuf:"varint,15,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DashItem) Reset()         { *m = DashItem{} }
func (m *DashItem) String() string { return proto.CompactTextString(m) }
func (*DashItem) ProtoMessage()    {}
func (*DashItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{4}
}
func (m *DashItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DashItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DashItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DashItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DashItem.Merge(m, src)
}
func (m *DashItem) XXX_Size() int {
	return m.Size()
}
func (m *DashItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DashItem.DiscardUnknown(m)
}

var xxx_messageInfo_DashItem proto.InternalMessageInfo

func (m *DashItem) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DashItem) GetBaseUrl() string {
	if m != nil {
		return m.BaseUrl
	}
	return ""
}

func (m *DashItem) GetBackupUrl() []string {
	if m != nil {
		return m.BackupUrl
	}
	return nil
}

func (m *DashItem) GetBandwidth() uint32 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *DashItem) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *DashItem) GetCodecs() string {
	if m != nil {
		return m.Codecs
	}
	return ""
}

func (m *DashItem) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *DashItem) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *DashItem) GetFrameRate() string {
	if m != nil {
		return m.FrameRate
	}
	return ""
}

func (m *DashItem) GetSar() string {
	if m != nil {
		return m.Sar
	}
	return ""
}

func (m *DashItem) GetStartWithSAP() uint32 {
	if m != nil {
		return m.StartWithSAP
	}
	return 0
}

func (m *DashItem) GetSegmentBase() *DashSegmentBase {
	if m != nil {
		return m.SegmentBase
	}
	return nil
}

func (m *DashItem) GetCodecid() uint32 {
	if m != nil {
		return m.Codecid
	}
	return 0
}

func (m *DashItem) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *DashItem) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type Durl struct {
	//视频的分片序列号
	Order uint32 `protobuf:"varint,1,opt,name=order,proto3" json:"order"`
	//视频分片的时长, 单位ms
	Length uint64 `protobuf:"varint,2,opt,name=length,proto3" json:"length"`
	//视频分片的大小, 单位Byte
	Size_ uint64 `protobuf:"varint,3,opt,name=size,proto3" json:"size"`
	//视频分片的音频头信息
	Ahead string `protobuf:"bytes,4,opt,name=ahead,proto3" json:"ahead,omitempty"`
	//视频分片的视频头信息
	Vhead string `protobuf:"bytes,5,opt,name=vhead,proto3" json:"vhead,omitempty"`
	//视频分片的url地址
	Url string `protobuf:"bytes,6,opt,name=url,proto3" json:"url"`
	//视频分片的备用url地址列表
	BackupUrl []string `protobuf:"bytes,7,rep,name=backup_url,json=backupUrl,proto3" json:"backup_url,omitempty"`
	//视频分片的md5,只有离线下载才有值
	Md5                  string   `protobuf:"bytes,8,opt,name=md5,proto3" json:"md5,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Durl) Reset()         { *m = Durl{} }
func (m *Durl) String() string { return proto.CompactTextString(m) }
func (*Durl) ProtoMessage()    {}
func (*Durl) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{5}
}
func (m *Durl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Durl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Durl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Durl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Durl.Merge(m, src)
}
func (m *Durl) XXX_Size() int {
	return m.Size()
}
func (m *Durl) XXX_DiscardUnknown() {
	xxx_messageInfo_Durl.DiscardUnknown(m)
}

var xxx_messageInfo_Durl proto.InternalMessageInfo

func (m *Durl) GetOrder() uint32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *Durl) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Durl) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Durl) GetAhead() string {
	if m != nil {
		return m.Ahead
	}
	return ""
}

func (m *Durl) GetVhead() string {
	if m != nil {
		return m.Vhead
	}
	return ""
}

func (m *Durl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Durl) GetBackupUrl() []string {
	if m != nil {
		return m.BackupUrl
	}
	return nil
}

func (m *Durl) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

type SteinsPreviewReq struct {
	//稿件aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty" validate:"gt=0,required"`
	//稿件cid
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty" validate:"gt=0,required"`
	//清晰度
	Qn int64 `protobuf:"varint,3,opt,name=qn,proto3" json:"qn,omitempty"`
	//平台
	Platform string `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
	//默认0 播放器请求端使用的, 功能版本号
	Fnver int32 `protobuf:"varint,5,opt,name=fnver,proto3" json:"fnver,omitempty"`
	//默认0 播放器请求端使用的, 功能版本号
	Fnval int32 `protobuf:"varint,6,opt,name=fnval,proto3" json:"fnval,omitempty"`
	//设备号
	Buvid string `protobuf:"bytes,7,opt,name=buvid,proto3" json:"buvid,omitempty"`
	//登录mid
	Mid int64 `protobuf:"varint,8,opt,name=mid,proto3" json:"mid,omitempty" validate:"gt=0,required"`
	//返回url是否强制使用域名(非ip地址), force_host=1使用http域名，force_host=2使用https域名, 0为使用ip地址
	ForceHost int32 `protobuf:"varint,9,opt,name=force_host,json=forceHost,proto3" json:"force_host,omitempty"`
	// 网络类型
	NetType NetworkType `protobuf:"varint,10,opt,name=net_type,json=netType,proto3,enum=playurl.service.NetworkType" json:"net_type,omitempty"`
	// 免流类型
	TfType               TFType   `protobuf:"varint,11,opt,name=tf_type,json=tfType,proto3,enum=playurl.service.TFType" json:"tf_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SteinsPreviewReq) Reset()         { *m = SteinsPreviewReq{} }
func (m *SteinsPreviewReq) String() string { return proto.CompactTextString(m) }
func (*SteinsPreviewReq) ProtoMessage()    {}
func (*SteinsPreviewReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{6}
}
func (m *SteinsPreviewReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SteinsPreviewReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SteinsPreviewReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SteinsPreviewReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SteinsPreviewReq.Merge(m, src)
}
func (m *SteinsPreviewReq) XXX_Size() int {
	return m.Size()
}
func (m *SteinsPreviewReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SteinsPreviewReq.DiscardUnknown(m)
}

var xxx_messageInfo_SteinsPreviewReq proto.InternalMessageInfo

func (m *SteinsPreviewReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *SteinsPreviewReq) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *SteinsPreviewReq) GetQn() int64 {
	if m != nil {
		return m.Qn
	}
	return 0
}

func (m *SteinsPreviewReq) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *SteinsPreviewReq) GetFnver() int32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *SteinsPreviewReq) GetFnval() int32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *SteinsPreviewReq) GetBuvid() string {
	if m != nil {
		return m.Buvid
	}
	return ""
}

func (m *SteinsPreviewReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *SteinsPreviewReq) GetForceHost() int32 {
	if m != nil {
		return m.ForceHost
	}
	return 0
}

func (m *SteinsPreviewReq) GetNetType() NetworkType {
	if m != nil {
		return m.NetType
	}
	return NetworkType_NT_UNKNOWN
}

func (m *SteinsPreviewReq) GetTfType() TFType {
	if m != nil {
		return m.TfType
	}
	return TFType_TF_UNKNOWN
}

type SteinsPreviewReply struct {
	//播放地址
	Playurl              *PlayURLInfo `protobuf:"bytes,1,opt,name=playurl,proto3" json:"playurl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SteinsPreviewReply) Reset()         { *m = SteinsPreviewReply{} }
func (m *SteinsPreviewReply) String() string { return proto.CompactTextString(m) }
func (*SteinsPreviewReply) ProtoMessage()    {}
func (*SteinsPreviewReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{7}
}
func (m *SteinsPreviewReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SteinsPreviewReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SteinsPreviewReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SteinsPreviewReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SteinsPreviewReply.Merge(m, src)
}
func (m *SteinsPreviewReply) XXX_Size() int {
	return m.Size()
}
func (m *SteinsPreviewReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SteinsPreviewReply.DiscardUnknown(m)
}

var xxx_messageInfo_SteinsPreviewReply proto.InternalMessageInfo

func (m *SteinsPreviewReply) GetPlayurl() *PlayURLInfo {
	if m != nil {
		return m.Playurl
	}
	return nil
}

type PlayURLInfo struct {
	//表示是否是B站只有视频, 目前固定为"local"
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from"`
	//返回结果, 正确为"suee", 错误为"error"
	Result string `protobuf:"bytes,2,opt,name=result,proto3" json:"result"`
	//返回视频的清晰度
	Quality uint32 `protobuf:"varint,3,opt,name=quality,proto3" json:"quality"`
	//返回视频的格式
	Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format"`
	//返回视频的总时长, 单位为ms
	Timelength uint64 `protobuf:"varint,5,opt,name=timelength,proto3" json:"timelength"`
	//返回视频的拥有的清晰度格式的列表
	AcceptFormat string `protobuf:"bytes,6,opt,name=accept_format,json=acceptFormat,proto3" json:"accept_format"`
	//返回视频的拥有的清晰度描述的列表
	AcceptDescription []string `protobuf:"bytes,7,rep,name=accept_description,json=acceptDescription,proto3" json:"accept_description,omitempty"`
	//返回视频的拥有的清晰度列表
	AcceptQuality []uint32 `protobuf:"varint,8,rep,packed,name=accept_quality,json=acceptQuality,proto3" json:"accept_quality"`
	//返回视频的编码号
	VideoCodecid uint32 `protobuf:"varint,9,opt,name=video_codecid,json=videoCodecid,proto3" json:"video_codecid"`
	//透传返回请求的fnver
	Fnver uint32 `protobuf:"varint,10,opt,name=fnver,proto3" json:"fnver"`
	//透传返回请求的fnval
	Fnval uint32 `protobuf:"varint,11,opt,name=fnval,proto3" json:"fnval"`
	//返回视频的是否支持投影
	VideoProject bool `protobuf:"varint,12,opt,name=video_project,json=videoProject,proto3" json:"video_project"`
	//返回视频的seek参数, 目前固定为"start"
	SeekParam string `protobuf:"bytes,13,opt,name=seek_param,json=seekParam,proto3" json:"seek_param"`
	//返回视频的seek类型, mp4视频为"second", flv视频为"offset"
	SeekType string `protobuf:"bytes,14,opt,name=seek_type,json=seekType,proto3" json:"seek_type"`
	//进行ab test时候命中测试范围返回的测试ID号, 不返回该字段如果不进行ab test
	Abtid int32 `protobuf:"varint,15,opt,name=abtid,proto3" json:"abtid,omitempty"`
	//返回视频播放url的列表，有durl则没dash字段
	Durl []*Durl `protobuf:"bytes,16,rep,name=durl,proto3" json:"durl,omitempty"`
	//返回DASH视频的MPD格式文件,有dash则没durl字段
	Dash *Dash `protobuf:"bytes,17,opt,name=dash,proto3" json:"dash,omitempty"`
	//is_sp=1且有大会员清晰度且不是全二压，no_rexocde值为1，其他情况为0
	NoRexcode            int32    `protobuf:"varint,18,opt,name=no_rexcode,json=noRexcode,proto3" json:"no_rexcode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayURLInfo) Reset()         { *m = PlayURLInfo{} }
func (m *PlayURLInfo) String() string { return proto.CompactTextString(m) }
func (*PlayURLInfo) ProtoMessage()    {}
func (*PlayURLInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_480d8ecba8d9e654, []int{8}
}
func (m *PlayURLInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayURLInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayURLInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayURLInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayURLInfo.Merge(m, src)
}
func (m *PlayURLInfo) XXX_Size() int {
	return m.Size()
}
func (m *PlayURLInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayURLInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PlayURLInfo proto.InternalMessageInfo

func (m *PlayURLInfo) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *PlayURLInfo) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *PlayURLInfo) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *PlayURLInfo) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *PlayURLInfo) GetTimelength() uint64 {
	if m != nil {
		return m.Timelength
	}
	return 0
}

func (m *PlayURLInfo) GetAcceptFormat() string {
	if m != nil {
		return m.AcceptFormat
	}
	return ""
}

func (m *PlayURLInfo) GetAcceptDescription() []string {
	if m != nil {
		return m.AcceptDescription
	}
	return nil
}

func (m *PlayURLInfo) GetAcceptQuality() []uint32 {
	if m != nil {
		return m.AcceptQuality
	}
	return nil
}

func (m *PlayURLInfo) GetVideoCodecid() uint32 {
	if m != nil {
		return m.VideoCodecid
	}
	return 0
}

func (m *PlayURLInfo) GetFnver() uint32 {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *PlayURLInfo) GetFnval() uint32 {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *PlayURLInfo) GetVideoProject() bool {
	if m != nil {
		return m.VideoProject
	}
	return false
}

func (m *PlayURLInfo) GetSeekParam() string {
	if m != nil {
		return m.SeekParam
	}
	return ""
}

func (m *PlayURLInfo) GetSeekType() string {
	if m != nil {
		return m.SeekType
	}
	return ""
}

func (m *PlayURLInfo) GetAbtid() int32 {
	if m != nil {
		return m.Abtid
	}
	return 0
}

func (m *PlayURLInfo) GetDurl() []*Durl {
	if m != nil {
		return m.Durl
	}
	return nil
}

func (m *PlayURLInfo) GetDash() *Dash {
	if m != nil {
		return m.Dash
	}
	return nil
}

func (m *PlayURLInfo) GetNoRexcode() int32 {
	if m != nil {
		return m.NoRexcode
	}
	return 0
}

func init() {
	proto.RegisterEnum("playurl.service.NetworkType", NetworkType_name, NetworkType_value)
	proto.RegisterEnum("playurl.service.TFType", TFType_name, TFType_value)
	proto.RegisterType((*PlayURLReq)(nil), "playurl.service.PlayURLReq")
	proto.RegisterType((*PlayURLReply)(nil), "playurl.service.PlayURLReply")
	proto.RegisterType((*Dash)(nil), "playurl.service.Dash")
	proto.RegisterType((*DashSegmentBase)(nil), "playurl.service.DashSegmentBase")
	proto.RegisterType((*DashItem)(nil), "playurl.service.DashItem")
	proto.RegisterType((*Durl)(nil), "playurl.service.Durl")
	proto.RegisterType((*SteinsPreviewReq)(nil), "playurl.service.SteinsPreviewReq")
	proto.RegisterType((*SteinsPreviewReply)(nil), "playurl.service.SteinsPreviewReply")
	proto.RegisterType((*PlayURLInfo)(nil), "playurl.service.PlayURLInfo")
}

func init() {
	proto.RegisterFile("go-gateway/app/app-svr/playurl/service/api/api.proto", fileDescriptor_480d8ecba8d9e654)
}

var fileDescriptor_480d8ecba8d9e654 = []byte{
	// 1555 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xdd, 0x72, 0x1b, 0x49,
	0x15, 0x5e, 0x69, 0xf4, 0x37, 0x47, 0x96, 0xa3, 0x34, 0x9b, 0x65, 0x12, 0xb2, 0x1e, 0xa3, 0xe5,
	0xc7, 0x04, 0x2c, 0x6f, 0x05, 0x08, 0xc5, 0x56, 0x71, 0x61, 0x39, 0x36, 0xeb, 0x5a, 0x97, 0x63,
	0x3a, 0x72, 0xa5, 0xa0, 0x0a, 0x54, 0x2d, 0x4d, 0x4b, 0x6a, 0x32, 0x9a, 0x19, 0xcf, 0xf4, 0x28,
	0xab, 0xbd, 0x86, 0x77, 0xa0, 0x78, 0x03, 0xde, 0x82, 0x3b, 0xb8, 0xe4, 0x09, 0x54, 0x10, 0xee,
	0x74, 0xc9, 0x13, 0x50, 0xe7, 0xf4, 0x8c, 0xfe, 0xe2, 0x14, 0xb9, 0xe3, 0x62, 0x73, 0x11, 0xcf,
	0xf9, 0xbe, 0xf3, 0x75, 0xb7, 0xba, 0xfb, 0x9c, 0xd3, 0x27, 0xf0, 0x93, 0x51, 0x78, 0x38, 0x12,
	0x5a, 0xbe, 0x12, 0xb3, 0x23, 0x11, 0x45, 0xf8, 0xef, 0x30, 0x99, 0xc6, 0x47, 0x91, 0x2f, 0x66,
	0x69, 0xec, 0x1f, 0x25, 0x32, 0x9e, 0xaa, 0x81, 0x3c, 0x12, 0x91, 0xc2, 0x7f, 0xed, 0x28, 0x0e,
	0x75, 0xc8, 0xee, 0x64, 0xee, 0x76, 0xe6, 0x7e, 0x70, 0x38, 0x52, 0x7a, 0x9c, 0xf6, 0xdb, 0x83,
	0x70, 0x72, 0x34, 0x0a, 0x47, 0xe1, 0x11, 0xe9, 0xfa, 0xe9, 0x90, 0x10, 0x01, 0xb2, 0xcc, 0xf8,
	0xd6, 0xdf, 0x4a, 0x00, 0x57, 0xbe, 0x98, 0x5d, 0xf3, 0x0b, 0x2e, 0x6f, 0x58, 0x1b, 0x2c, 0xa1,
	0x3c, 0xa7, 0xb0, 0x5f, 0x38, 0xb0, 0x3a, 0x0f, 0xff, 0x33, 0x77, 0x9d, 0xa9, 0xf0, 0x95, 0x27,
	0xb4, 0xfc, 0xac, 0x35, 0xd2, 0xbf, 0xf8, 0xf4, 0x47, 0xb1, 0xbc, 0x49, 0x55, 0x2c, 0xbd, 0x16,
	0x47, 0x21, 0xea, 0x07, 0xca, 0x73, 0x8a, 0xef, 0xa2, 0x1f, 0x28, 0x8f, 0xed, 0x42, 0xf1, 0x26,
	0x70, 0x2c, 0x94, 0xf3, 0xe2, 0x4d, 0xc0, 0x3e, 0x82, 0x4a, 0x10, 0x0d, 0x66, 0xfd, 0xc4, 0x29,
	0xed, 0x17, 0x0e, 0xca, 0x3c, 0x43, 0xec, 0x01, 0xd4, 0x22, 0x5f, 0xe8, 0x61, 0x18, 0x4f, 0x9c,
	0xf2, 0x7e, 0xe1, 0xc0, 0xe6, 0x4b, 0xcc, 0x3e, 0x84, 0xf2, 0x30, 0x98, 0xca, 0xd8, 0xa9, 0xd0,
	0x10, 0x03, 0x32, 0x56, 0xf8, 0x4e, 0x75, 0xc9, 0x0a, 0x9f, 0x39, 0x50, 0x4d, 0x64, 0x92, 0xa8,
	0x30, 0x70, 0x6a, 0x34, 0x4d, 0x0e, 0x51, 0xdf, 0x4f, 0x95, 0xef, 0x39, 0xb6, 0xd1, 0x13, 0x60,
	0x1f, 0x03, 0x0c, 0xc3, 0x78, 0x20, 0x7b, 0xe3, 0x30, 0xd1, 0x0e, 0x90, 0xcb, 0x26, 0xe6, 0xf3,
	0x30, 0xd1, 0x66, 0xd0, 0x54, 0x79, 0x4e, 0x9d, 0x26, 0x33, 0x80, 0x35, 0xc1, 0x9a, 0x28, 0xcf,
	0xd9, 0xa1, 0x5d, 0xa1, 0xc9, 0xf6, 0x00, 0x62, 0x99, 0x84, 0x7e, 0xaa, 0x71, 0xe5, 0x06, 0x89,
	0xd7, 0x18, 0xe6, 0x42, 0x3d, 0x8d, 0x46, 0xb1, 0xf0, 0x64, 0x0f, 0x8f, 0x7b, 0x97, 0x46, 0x42,
	0x46, 0x1d, 0x2b, 0x6f, 0x5d, 0x80, 0xe7, 0x7b, 0x67, 0x43, 0x70, 0xa2, 0x3c, 0xc6, 0xa0, 0xa4,
	0x67, 0x91, 0x74, 0x9a, 0x34, 0x37, 0xd9, 0x74, 0x04, 0x61, 0x1a, 0xbf, 0x74, 0xee, 0x66, 0x47,
	0x80, 0x00, 0x8f, 0xd8, 0x93, 0x18, 0x1a, 0x0e, 0x23, 0x6d, 0x86, 0xd8, 0x7d, 0xa8, 0x4d, 0xc2,
	0xbe, 0xea, 0x89, 0x28, 0x72, 0xbe, 0x61, 0xce, 0x06, 0xf1, 0x71, 0x14, 0xe1, 0x2d, 0x79, 0xbe,
	0xf3, 0x21, 0xcd, 0x52, 0xf4, 0x7c, 0xf6, 0x09, 0x34, 0xa6, 0x32, 0x56, 0xc3, 0x59, 0x2f, 0xd1,
	0x52, 0x05, 0x89, 0x73, 0x8f, 0x5c, 0x3b, 0x86, 0x7c, 0x4e, 0x5c, 0xeb, 0x8f, 0x15, 0xd8, 0x59,
	0x46, 0x52, 0xe4, 0xcf, 0xd8, 0x43, 0x28, 0x0d, 0xe3, 0x70, 0x42, 0xc1, 0x64, 0x77, 0x6a, 0x8b,
	0xb9, 0x4b, 0x98, 0xd3, 0x5f, 0xd6, 0x82, 0x4a, 0x2c, 0x93, 0xd4, 0xd7, 0x14, 0x3c, 0x76, 0x07,
	0x16, 0x73, 0x37, 0x63, 0x78, 0xf6, 0x65, 0xdf, 0x85, 0xea, 0x4d, 0x2a, 0x7c, 0xa5, 0x67, 0x14,
	0x32, 0x8d, 0x4e, 0x7d, 0x31, 0x77, 0x73, 0x8a, 0xe7, 0x06, 0x4e, 0x85, 0x81, 0x21, 0x34, 0x05,
	0x51, 0x36, 0x95, 0x61, 0x78, 0xf6, 0x65, 0x6d, 0x00, 0xad, 0x26, 0xd2, 0x97, 0xc1, 0x48, 0x8f,
	0x29, 0xa4, 0x4a, 0x9d, 0xdd, 0xc5, 0xdc, 0x5d, 0x63, 0xf9, 0x9a, 0xcd, 0x9e, 0x40, 0x43, 0x0c,
	0x06, 0x32, 0xd2, 0xbd, 0x6c, 0xea, 0x0a, 0x4d, 0x7d, 0x77, 0x31, 0x77, 0x37, 0x1d, 0x7c, 0xc7,
	0xc0, 0x33, 0xb3, 0xce, 0x21, 0xb0, 0xcc, 0xed, 0xc9, 0x64, 0x10, 0xab, 0x88, 0x22, 0xa0, 0xba,
	0x6f, 0x1d, 0xd8, 0xfc, 0xae, 0xf1, 0x3c, 0x5d, 0x39, 0xd8, 0xcf, 0x61, 0x37, 0x93, 0xe7, 0x1b,
	0xad, 0xed, 0x5b, 0x07, 0x8d, 0x0e, 0x5b, 0xcc, 0xdd, 0x2d, 0x0f, 0xcf, 0xd6, 0xfd, 0x55, 0xb6,
	0xeb, 0x27, 0xd0, 0x98, 0x2a, 0x4f, 0x86, 0xbd, 0x41, 0xe8, 0x49, 0x0c, 0x12, 0x9b, 0x8e, 0x88,
	0x7e, 0xe1, 0x86, 0x83, 0xef, 0x10, 0x3c, 0x31, 0x88, 0xb9, 0x79, 0xfa, 0x00, 0xe9, 0xed, 0xc5,
	0xdc, 0x35, 0x44, 0x9e, 0x49, 0x6e, 0x9e, 0x49, 0xf5, 0x0d, 0x81, 0xf0, 0xf3, 0xa4, 0x5a, 0xae,
	0x1c, 0xc5, 0xe1, 0xef, 0xe5, 0x40, 0x53, 0xe4, 0xd7, 0xd6, 0x57, 0xce, 0x1c, 0xd9, 0xca, 0x57,
	0x06, 0xb1, 0x43, 0x80, 0x44, 0xca, 0x97, 0xbd, 0x48, 0xc4, 0x62, 0x62, 0xb2, 0xc2, 0xdc, 0xc1,
	0x8a, 0xe5, 0x36, 0xda, 0x57, 0x68, 0xb2, 0x47, 0x40, 0xa0, 0x47, 0x71, 0xbe, 0x4b, 0xea, 0xc6,
	0x62, 0xee, 0xae, 0x48, 0x5e, 0x43, 0xb3, 0x9b, 0x85, 0xbe, 0xe8, 0xeb, 0x2c, 0x53, 0xca, 0xdc,
	0x00, 0xf6, 0x03, 0x28, 0x79, 0x69, 0xec, 0x3b, 0xcd, 0x7d, 0xeb, 0xa0, 0xfe, 0xf8, 0x5e, 0x7b,
	0xab, 0x56, 0xb6, 0x9f, 0xa6, 0xb1, 0xcf, 0x49, 0x42, 0x52, 0x91, 0x8c, 0x29, 0x75, 0x6e, 0x95,
	0x8a, 0x64, 0xcc, 0x49, 0x82, 0x35, 0x22, 0x08, 0x7b, 0xb1, 0xfc, 0x12, 0xcf, 0x97, 0x92, 0xaa,
	0xcc, 0xed, 0x20, 0xe4, 0x86, 0x68, 0xfd, 0xb5, 0x00, 0x25, 0x54, 0x63, 0x0d, 0xf3, 0xd2, 0x58,
	0x50, 0x00, 0x60, 0x0e, 0x34, 0xf8, 0x12, 0xb3, 0xef, 0x40, 0x63, 0xa2, 0x82, 0x4e, 0x3a, 0x1c,
	0xca, 0xb8, 0xab, 0x26, 0x92, 0x92, 0xa0, 0xc8, 0x37, 0x49, 0xf6, 0x19, 0x94, 0xe9, 0x00, 0x1d,
	0x8b, 0x36, 0x70, 0xff, 0xd6, 0x5f, 0x75, 0xae, 0xe5, 0xc4, 0x5c, 0x12, 0x69, 0xb9, 0xf9, 0xe0,
	0x58, 0x91, 0x7a, 0x2a, 0x74, 0x4a, 0xef, 0x34, 0x96, 0xb4, 0xdc, 0x7c, 0x5a, 0xbf, 0x86, 0x3b,
	0xe8, 0x7d, 0x2e, 0x47, 0x13, 0x19, 0xe8, 0x8e, 0x48, 0x24, 0xfb, 0x1e, 0xec, 0x9e, 0x07, 0x4a,
	0x2b, 0xe1, 0xab, 0xaf, 0x56, 0x5b, 0xb2, 0xf9, 0x16, 0x8b, 0x95, 0x4f, 0x05, 0x9e, 0xfc, 0x92,
	0x8b, 0x60, 0x64, 0x76, 0x65, 0xf3, 0x35, 0xa6, 0x35, 0xb7, 0xa0, 0x96, 0xaf, 0xcc, 0x3e, 0x82,
	0x62, 0xf6, 0xd8, 0x34, 0x3a, 0x95, 0xc5, 0xdc, 0x2d, 0x2a, 0x8f, 0x17, 0x95, 0xc7, 0xbe, 0x0f,
	0xb5, 0xbe, 0x48, 0x64, 0x0f, 0xef, 0xce, 0x54, 0x87, 0x9d, 0xc5, 0xdc, 0x5d, 0x72, 0xbc, 0x8a,
	0xd6, 0x75, 0xec, 0xe3, 0x55, 0xf4, 0xc5, 0xe0, 0x65, 0x1a, 0x91, 0xd4, 0xa2, 0x2c, 0xb3, 0x0d,
	0x83, 0xee, 0x1f, 0x82, 0xdd, 0x17, 0x81, 0xf7, 0x4a, 0x79, 0x7a, 0x4c, 0xb5, 0xa1, 0x61, 0x22,
	0x68, 0x49, 0xf2, 0x95, 0x89, 0xd7, 0x35, 0x51, 0x13, 0x89, 0xe1, 0x94, 0x3f, 0x39, 0x39, 0xc6,
	0x1a, 0x4a, 0xc9, 0x94, 0x98, 0x32, 0xc0, 0x33, 0x84, 0x61, 0x67, 0x26, 0xaf, 0xd2, 0xfd, 0x1a,
	0x80, 0xea, 0xb1, 0x54, 0xa3, 0xb1, 0xa6, 0x37, 0xa7, 0xc1, 0x33, 0xc4, 0x1e, 0x82, 0x3d, 0x8c,
	0xc5, 0x44, 0x72, 0xa1, 0x25, 0x65, 0xab, 0xcd, 0x57, 0x04, 0xbe, 0x22, 0x89, 0x30, 0x59, 0x69,
	0x73, 0x34, 0x59, 0x0b, 0x76, 0x12, 0x2d, 0x62, 0xfd, 0x42, 0xe9, 0xf1, 0xf3, 0xe3, 0x2b, 0x93,
	0x8f, 0x7c, 0x83, 0x63, 0x1d, 0xa8, 0xaf, 0x5d, 0x13, 0x65, 0x62, 0xfd, 0xf1, 0xfe, 0xad, 0x97,
	0xbd, 0xa6, 0xe3, 0xeb, 0x83, 0xb0, 0xcc, 0xe6, 0x35, 0xa4, 0xb1, 0x2a, 0xb3, 0x79, 0xf5, 0xc8,
	0x0d, 0x7a, 0xe6, 0xbc, 0x9f, 0x9a, 0x4c, 0xe4, 0x68, 0xe2, 0x23, 0x94, 0xa8, 0xaf, 0x24, 0x25,
	0x5d, 0x89, 0x93, 0xdd, 0xfa, 0x17, 0x86, 0x3f, 0x66, 0x94, 0x0b, 0xe5, 0x30, 0xf6, 0x64, 0x9c,
	0xdd, 0x2f, 0x45, 0x19, 0x11, 0xdc, 0x7c, 0xb0, 0x6c, 0x67, 0xe5, 0xb8, 0x48, 0xe5, 0x98, 0xca,
	0x76, 0x56, 0x8a, 0xb3, 0x2f, 0xbe, 0x21, 0xb4, 0x82, 0x45, 0x0a, 0x7a, 0x43, 0x10, 0x9b, 0xb5,
	0x28, 0xeb, 0xc7, 0x52, 0x78, 0xa6, 0xee, 0x73, 0x03, 0x90, 0x9d, 0x12, 0x6b, 0x6e, 0xd1, 0x00,
	0x76, 0x1f, 0x2c, 0x8c, 0x11, 0x53, 0xc6, 0xab, 0x8b, 0xb9, 0x8b, 0x90, 0xe3, 0x9f, 0xad, 0x28,
	0xaa, 0x6e, 0x47, 0x51, 0xb6, 0xef, 0xda, 0x72, 0xdf, 0xad, 0x3f, 0x5b, 0xd0, 0x34, 0xaf, 0xde,
	0x55, 0x2c, 0xa7, 0x4a, 0xbe, 0xfa, 0x7f, 0xb4, 0x4e, 0xeb, 0x2d, 0x52, 0xe9, 0x6d, 0x2d, 0x52,
	0xf9, 0xd6, 0x16, 0xa9, 0xb2, 0xde, 0x22, 0x2d, 0x7b, 0x9a, 0xea, 0x7a, 0x4f, 0xd3, 0x36, 0x3d,
	0x4d, 0xed, 0x5d, 0x7e, 0x1d, 0x76, 0x3c, 0x9b, 0x8d, 0x93, 0xbd, 0xdd, 0x38, 0xfd, 0x0c, 0x6a,
	0x81, 0xd4, 0xa6, 0x94, 0x63, 0x84, 0xef, 0x3e, 0x7e, 0xf8, 0x46, 0x8c, 0x5e, 0x4a, 0xfd, 0x2a,
	0x8c, 0xa9, 0x9e, 0xf3, 0x6a, 0x20, 0x35, 0x65, 0xde, 0xa7, 0x50, 0xd5, 0x43, 0x33, 0xae, 0x4e,
	0xe3, 0xbe, 0xf9, 0xc6, 0xb8, 0xee, 0x19, 0x0d, 0xa9, 0xe8, 0x21, 0x7e, 0x5b, 0x17, 0xc0, 0xb6,
	0xee, 0x06, 0x9b, 0x91, 0x27, 0x50, 0xcd, 0xc6, 0xd1, 0x0d, 0xd5, 0x6f, 0x59, 0x3f, 0x6b, 0x5e,
	0xce, 0x83, 0x61, 0xc8, 0x73, 0x71, 0xeb, 0x0f, 0x15, 0xa8, 0xaf, 0x39, 0xde, 0x37, 0x35, 0xef,
	0x9b, 0x9a, 0xaf, 0x61, 0x53, 0xf3, 0xe8, 0x77, 0x50, 0x5f, 0x4b, 0x4f, 0xb6, 0x0b, 0x70, 0xd9,
	0xed, 0x5d, 0x5f, 0x7e, 0x71, 0xf9, 0xec, 0xc5, 0x65, 0xf3, 0x03, 0x56, 0x83, 0xd2, 0x8b, 0xf3,
	0xb3, 0xf3, 0x66, 0x81, 0xed, 0x40, 0xed, 0xe4, 0xf4, 0xe2, 0xe2, 0xfa, 0xe2, 0x98, 0x37, 0x8b,
	0xac, 0x0e, 0xd5, 0x67, 0x67, 0x67, 0x17, 0xe7, 0x97, 0xa7, 0x4d, 0x0b, 0x5d, 0xcf, 0xba, 0x9f,
	0x9f, 0xf2, 0xcb, 0xd3, 0x6e, 0xb3, 0x84, 0xe8, 0x34, 0x47, 0xe5, 0x47, 0xbf, 0x85, 0x8a, 0x49,
	0x63, 0x9c, 0xba, 0x7b, 0xb6, 0x36, 0x35, 0x40, 0xe5, 0xba, 0x77, 0x72, 0xcc, 0x9f, 0x36, 0x0b,
	0xcc, 0x86, 0xf2, 0x75, 0xef, 0xea, 0x8b, 0x5f, 0x36, 0x8b, 0x48, 0x9f, 0x18, 0xda, 0x42, 0xfa,
	0x84, 0xe8, 0x12, 0xd2, 0x5d, 0x43, 0x97, 0x91, 0xee, 0x12, 0x5d, 0x79, 0xfc, 0x97, 0x02, 0x54,
	0xb3, 0x2c, 0x66, 0xa7, 0x2b, 0xf3, 0x5b, 0x6f, 0xab, 0x01, 0x5c, 0xde, 0x3c, 0xf8, 0xf8, 0xed,
	0x4e, 0x2c, 0x28, 0x2f, 0xa0, 0xb1, 0x51, 0x66, 0xd8, 0xb7, 0xdf, 0xd0, 0x6f, 0x3f, 0x11, 0x0f,
	0x3e, 0xf9, 0x5f, 0x92, 0xc8, 0x9f, 0x75, 0xee, 0xfd, 0xfd, 0xf5, 0x5e, 0xe1, 0x1f, 0xaf, 0xf7,
	0x0a, 0xff, 0x7c, 0xbd, 0x57, 0xf8, 0xd3, 0xbf, 0xf7, 0x3e, 0xf8, 0x8d, 0x25, 0x22, 0xd5, 0xaf,
	0xd0, 0xff, 0xd7, 0x7f, 0xfc, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x17, 0x62, 0x9f, 0xff, 0x27,
	0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PlayURLClient is the client API for PlayURL service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PlayURLClient interface {
	// 获取播放地址
	PlayURL(ctx context.Context, in *PlayURLReq, opts ...grpc.CallOption) (*PlayURLReply, error)
	// SteinsPreview is interactive archive preview for up
	SteinsPreview(ctx context.Context, in *SteinsPreviewReq, opts ...grpc.CallOption) (*SteinsPreviewReply, error)
}

type playURLClient struct {
	cc *grpc.ClientConn
}

func NewPlayURLClient(cc *grpc.ClientConn) PlayURLClient {
	return &playURLClient{cc}
}

func (c *playURLClient) PlayURL(ctx context.Context, in *PlayURLReq, opts ...grpc.CallOption) (*PlayURLReply, error) {
	out := new(PlayURLReply)
	err := c.cc.Invoke(ctx, "/playurl.service.PlayURL/PlayURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playURLClient) SteinsPreview(ctx context.Context, in *SteinsPreviewReq, opts ...grpc.CallOption) (*SteinsPreviewReply, error) {
	out := new(SteinsPreviewReply)
	err := c.cc.Invoke(ctx, "/playurl.service.PlayURL/SteinsPreview", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlayURLServer is the server API for PlayURL service.
type PlayURLServer interface {
	// 获取播放地址
	PlayURL(context.Context, *PlayURLReq) (*PlayURLReply, error)
	// SteinsPreview is interactive archive preview for up
	SteinsPreview(context.Context, *SteinsPreviewReq) (*SteinsPreviewReply, error)
}

// UnimplementedPlayURLServer can be embedded to have forward compatible implementations.
type UnimplementedPlayURLServer struct {
}

func (*UnimplementedPlayURLServer) PlayURL(ctx context.Context, req *PlayURLReq) (*PlayURLReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayURL not implemented")
}
func (*UnimplementedPlayURLServer) SteinsPreview(ctx context.Context, req *SteinsPreviewReq) (*SteinsPreviewReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SteinsPreview not implemented")
}

func RegisterPlayURLServer(s *grpc.Server, srv PlayURLServer) {
	s.RegisterService(&_PlayURL_serviceDesc, srv)
}

func _PlayURL_PlayURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayURLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayURLServer).PlayURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/playurl.service.PlayURL/PlayURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayURLServer).PlayURL(ctx, req.(*PlayURLReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlayURL_SteinsPreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SteinsPreviewReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayURLServer).SteinsPreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/playurl.service.PlayURL/SteinsPreview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayURLServer).SteinsPreview(ctx, req.(*SteinsPreviewReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _PlayURL_serviceDesc = grpc.ServiceDesc{
	ServiceName: "playurl.service.PlayURL",
	HandlerType: (*PlayURLServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PlayURL",
			Handler:    _PlayURL_PlayURL_Handler,
		},
		{
			MethodName: "SteinsPreview",
			Handler:    _PlayURL_SteinsPreview_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go-gateway/app/app-svr/playurl/service/api/api.proto",
}

func (m *PlayURLReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayURLReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayURLReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VerifySteins != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.VerifySteins))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Dl != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Dl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.MobiApp) > 0 {
		i -= len(m.MobiApp)
		copy(dAtA[i:], m.MobiApp)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MobiApp)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Fourk != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fourk))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.UpgradeCid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UpgradeCid))
		i--
		dAtA[i] = 0x78
	}
	if m.UpgradeAid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UpgradeAid))
		i--
		dAtA[i] = 0x70
	}
	if len(m.Resolution) > 0 {
		i -= len(m.Resolution)
		copy(dAtA[i:], m.Resolution)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Resolution)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Buvid) > 0 {
		i -= len(m.Buvid)
		copy(dAtA[i:], m.Buvid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Buvid)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ForceHost != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ForceHost))
		i--
		dAtA[i] = 0x50
	}
	if m.Build != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Session) > 0 {
		i -= len(m.Session)
		copy(dAtA[i:], m.Session)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Session)))
		i--
		dAtA[i] = 0x42
	}
	if m.Fnval != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x38
	}
	if m.Fnver != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Npcybs != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Npcybs))
		i--
		dAtA[i] = 0x20
	}
	if m.Qn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Qn))
		i--
		dAtA[i] = 0x18
	}
	if m.Cid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayURLReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayURLReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayURLReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NoRexcode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoRexcode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Dash != nil {
		{
			size, err := m.Dash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Durl) > 0 {
		for iNdEx := len(m.Durl) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Durl[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Abtid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Abtid))
		i--
		dAtA[i] = 0x78
	}
	if len(m.SeekType) > 0 {
		i -= len(m.SeekType)
		copy(dAtA[i:], m.SeekType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SeekType)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SeekParam) > 0 {
		i -= len(m.SeekParam)
		copy(dAtA[i:], m.SeekParam)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SeekParam)))
		i--
		dAtA[i] = 0x6a
	}
	if m.VideoProject {
		i--
		if m.VideoProject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Fnval != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x58
	}
	if m.Fnver != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x50
	}
	if m.VideoCodecid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.VideoCodecid))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AcceptQuality) > 0 {
		dAtA3 := make([]byte, len(m.AcceptQuality)*10)
		var j2 int
		for _, num := range m.AcceptQuality {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintApi(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AcceptDescription) > 0 {
		for iNdEx := len(m.AcceptDescription) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AcceptDescription[iNdEx])
			copy(dAtA[i:], m.AcceptDescription[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.AcceptDescription[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AcceptFormat) > 0 {
		i -= len(m.AcceptFormat)
		copy(dAtA[i:], m.AcceptFormat)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AcceptFormat)))
		i--
		dAtA[i] = 0x32
	}
	if m.Timelength != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Timelength))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if m.Quality != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintApi(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Dash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Audio) > 0 {
		for iNdEx := len(m.Audio) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Audio[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Video) > 0 {
		for iNdEx := len(m.Video) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Video[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MinBufferTime != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MinBufferTime))))
		i--
		dAtA[i] = 0x15
	}
	if m.Duration != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DashSegmentBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DashSegmentBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DashSegmentBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexRange) > 0 {
		i -= len(m.IndexRange)
		copy(dAtA[i:], m.IndexRange)
		i = encodeVarintApi(dAtA, i, uint64(len(m.IndexRange)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Initialization) > 0 {
		i -= len(m.Initialization)
		copy(dAtA[i:], m.Initialization)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Initialization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DashItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DashItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DashItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size_ != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x72
	}
	if m.Codecid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Codecid))
		i--
		dAtA[i] = 0x68
	}
	if m.SegmentBase != nil {
		{
			size, err := m.SegmentBase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.StartWithSAP != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StartWithSAP))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Sar) > 0 {
		i -= len(m.Sar)
		copy(dAtA[i:], m.Sar)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sar)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FrameRate) > 0 {
		i -= len(m.FrameRate)
		copy(dAtA[i:], m.FrameRate)
		i = encodeVarintApi(dAtA, i, uint64(len(m.FrameRate)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Height != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x40
	}
	if m.Width != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Codecs) > 0 {
		i -= len(m.Codecs)
		copy(dAtA[i:], m.Codecs)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Codecs)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Bandwidth != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Bandwidth))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BackupUrl) > 0 {
		for iNdEx := len(m.BackupUrl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BackupUrl[iNdEx])
			copy(dAtA[i:], m.BackupUrl[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.BackupUrl[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BaseUrl) > 0 {
		i -= len(m.BaseUrl)
		copy(dAtA[i:], m.BaseUrl)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BaseUrl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Durl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Durl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Durl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.BackupUrl) > 0 {
		for iNdEx := len(m.BackupUrl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BackupUrl[iNdEx])
			copy(dAtA[i:], m.BackupUrl[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.BackupUrl[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Vhead) > 0 {
		i -= len(m.Vhead)
		copy(dAtA[i:], m.Vhead)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Vhead)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ahead) > 0 {
		i -= len(m.Ahead)
		copy(dAtA[i:], m.Ahead)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ahead)))
		i--
		dAtA[i] = 0x22
	}
	if m.Size_ != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if m.Length != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SteinsPreviewReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SteinsPreviewReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SteinsPreviewReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TfType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TfType))
		i--
		dAtA[i] = 0x58
	}
	if m.NetType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NetType))
		i--
		dAtA[i] = 0x50
	}
	if m.ForceHost != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ForceHost))
		i--
		dAtA[i] = 0x48
	}
	if m.Mid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Buvid) > 0 {
		i -= len(m.Buvid)
		copy(dAtA[i:], m.Buvid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Buvid)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Fnval != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x30
	}
	if m.Fnver != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x22
	}
	if m.Qn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Qn))
		i--
		dAtA[i] = 0x18
	}
	if m.Cid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SteinsPreviewReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SteinsPreviewReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SteinsPreviewReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Playurl != nil {
		{
			size, err := m.Playurl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayURLInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayURLInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayURLInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NoRexcode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NoRexcode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Dash != nil {
		{
			size, err := m.Dash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Durl) > 0 {
		for iNdEx := len(m.Durl) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Durl[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Abtid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Abtid))
		i--
		dAtA[i] = 0x78
	}
	if len(m.SeekType) > 0 {
		i -= len(m.SeekType)
		copy(dAtA[i:], m.SeekType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SeekType)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SeekParam) > 0 {
		i -= len(m.SeekParam)
		copy(dAtA[i:], m.SeekParam)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SeekParam)))
		i--
		dAtA[i] = 0x6a
	}
	if m.VideoProject {
		i--
		if m.VideoProject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Fnval != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnval))
		i--
		dAtA[i] = 0x58
	}
	if m.Fnver != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fnver))
		i--
		dAtA[i] = 0x50
	}
	if m.VideoCodecid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.VideoCodecid))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AcceptQuality) > 0 {
		dAtA8 := make([]byte, len(m.AcceptQuality)*10)
		var j7 int
		for _, num := range m.AcceptQuality {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintApi(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AcceptDescription) > 0 {
		for iNdEx := len(m.AcceptDescription) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AcceptDescription[iNdEx])
			copy(dAtA[i:], m.AcceptDescription[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.AcceptDescription[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AcceptFormat) > 0 {
		i -= len(m.AcceptFormat)
		copy(dAtA[i:], m.AcceptFormat)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AcceptFormat)))
		i--
		dAtA[i] = 0x32
	}
	if m.Timelength != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Timelength))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if m.Quality != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintApi(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PlayURLReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	if m.Qn != 0 {
		n += 1 + sovApi(uint64(m.Qn))
	}
	if m.Npcybs != 0 {
		n += 1 + sovApi(uint64(m.Npcybs))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Fnver != 0 {
		n += 1 + sovApi(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovApi(uint64(m.Fnval))
	}
	l = len(m.Session)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if m.ForceHost != 0 {
		n += 1 + sovApi(uint64(m.ForceHost))
	}
	l = len(m.Buvid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Resolution)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpgradeAid != 0 {
		n += 1 + sovApi(uint64(m.UpgradeAid))
	}
	if m.UpgradeCid != 0 {
		n += 1 + sovApi(uint64(m.UpgradeCid))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Fourk != 0 {
		n += 2 + sovApi(uint64(m.Fourk))
	}
	l = len(m.Device)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.MobiApp)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Dl != 0 {
		n += 2 + sovApi(uint64(m.Dl))
	}
	if m.VerifySteins != 0 {
		n += 2 + sovApi(uint64(m.VerifySteins))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayURLReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovApi(uint64(m.Quality))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Timelength != 0 {
		n += 1 + sovApi(uint64(m.Timelength))
	}
	l = len(m.AcceptFormat)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.AcceptDescription) > 0 {
		for _, s := range m.AcceptDescription {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.AcceptQuality) > 0 {
		l = 0
		for _, e := range m.AcceptQuality {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.VideoCodecid != 0 {
		n += 1 + sovApi(uint64(m.VideoCodecid))
	}
	if m.Fnver != 0 {
		n += 1 + sovApi(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovApi(uint64(m.Fnval))
	}
	if m.VideoProject {
		n += 2
	}
	l = len(m.SeekParam)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SeekType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Abtid != 0 {
		n += 1 + sovApi(uint64(m.Abtid))
	}
	if len(m.Durl) > 0 {
		for _, e := range m.Durl {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.Dash != nil {
		l = m.Dash.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.NoRexcode != 0 {
		n += 2 + sovApi(uint64(m.NoRexcode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != 0 {
		n += 1 + sovApi(uint64(m.Duration))
	}
	if m.MinBufferTime != 0 {
		n += 5
	}
	if len(m.Video) > 0 {
		for _, e := range m.Video {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Audio) > 0 {
		for _, e := range m.Audio {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DashSegmentBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Initialization)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IndexRange)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DashItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.BaseUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.BackupUrl) > 0 {
		for _, s := range m.BackupUrl {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Bandwidth != 0 {
		n += 1 + sovApi(uint64(m.Bandwidth))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Codecs)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovApi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovApi(uint64(m.Height))
	}
	l = len(m.FrameRate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sar)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.StartWithSAP != 0 {
		n += 1 + sovApi(uint64(m.StartWithSAP))
	}
	if m.SegmentBase != nil {
		l = m.SegmentBase.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Codecid != 0 {
		n += 1 + sovApi(uint64(m.Codecid))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Durl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	if m.Length != 0 {
		n += 1 + sovApi(uint64(m.Length))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	l = len(m.Ahead)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Vhead)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.BackupUrl) > 0 {
		for _, s := range m.BackupUrl {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SteinsPreviewReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	if m.Qn != 0 {
		n += 1 + sovApi(uint64(m.Qn))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Fnver != 0 {
		n += 1 + sovApi(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovApi(uint64(m.Fnval))
	}
	l = len(m.Buvid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.ForceHost != 0 {
		n += 1 + sovApi(uint64(m.ForceHost))
	}
	if m.NetType != 0 {
		n += 1 + sovApi(uint64(m.NetType))
	}
	if m.TfType != 0 {
		n += 1 + sovApi(uint64(m.TfType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SteinsPreviewReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Playurl != nil {
		l = m.Playurl.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayURLInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovApi(uint64(m.Quality))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Timelength != 0 {
		n += 1 + sovApi(uint64(m.Timelength))
	}
	l = len(m.AcceptFormat)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.AcceptDescription) > 0 {
		for _, s := range m.AcceptDescription {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.AcceptQuality) > 0 {
		l = 0
		for _, e := range m.AcceptQuality {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.VideoCodecid != 0 {
		n += 1 + sovApi(uint64(m.VideoCodecid))
	}
	if m.Fnver != 0 {
		n += 1 + sovApi(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovApi(uint64(m.Fnval))
	}
	if m.VideoProject {
		n += 2
	}
	l = len(m.SeekParam)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SeekType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Abtid != 0 {
		n += 1 + sovApi(uint64(m.Abtid))
	}
	if len(m.Durl) > 0 {
		for _, e := range m.Durl {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.Dash != nil {
		l = m.Dash.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.NoRexcode != 0 {
		n += 2 + sovApi(uint64(m.NoRexcode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlayURLReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayURLReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayURLReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qn", wireType)
			}
			m.Qn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Npcybs", wireType)
			}
			m.Npcybs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Npcybs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Session = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceHost", wireType)
			}
			m.ForceHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceHost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buvid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buvid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeAid", wireType)
			}
			m.UpgradeAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeCid", wireType)
			}
			m.UpgradeCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fourk", wireType)
			}
			m.Fourk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fourk |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobiApp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MobiApp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dl", wireType)
			}
			m.Dl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySteins", wireType)
			}
			m.VerifySteins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifySteins |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayURLReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayURLReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayURLReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timelength", wireType)
			}
			m.Timelength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timelength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptDescription = append(m.AcceptDescription, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptQuality = append(m.AcceptQuality, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AcceptQuality) == 0 {
					m.AcceptQuality = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptQuality = append(m.AcceptQuality, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptQuality", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoCodecid", wireType)
			}
			m.VideoCodecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoCodecid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoProject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VideoProject = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeekParam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeekType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abtid", wireType)
			}
			m.Abtid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Abtid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Durl = append(m.Durl, &Durl{})
			if err := m.Durl[len(m.Durl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dash == nil {
				m.Dash = &Dash{}
			}
			if err := m.Dash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRexcode", wireType)
			}
			m.NoRexcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoRexcode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBufferTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MinBufferTime = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Video = append(m.Video, &DashItem{})
			if err := m.Video[len(m.Video)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audio = append(m.Audio, &DashItem{})
			if err := m.Audio[len(m.Audio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DashSegmentBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DashSegmentBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DashSegmentBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initialization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Initialization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexRange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexRange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DashItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DashItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DashItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupUrl = append(m.BackupUrl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codecs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codecs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartWithSAP", wireType)
			}
			m.StartWithSAP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartWithSAP |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentBase == nil {
				m.SegmentBase = &DashSegmentBase{}
			}
			if err := m.SegmentBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codecid", wireType)
			}
			m.Codecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codecid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Durl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Durl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Durl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ahead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ahead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vhead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vhead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupUrl = append(m.BackupUrl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SteinsPreviewReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SteinsPreviewReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SteinsPreviewReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qn", wireType)
			}
			m.Qn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buvid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buvid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceHost", wireType)
			}
			m.ForceHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceHost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			m.NetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetType |= NetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TfType", wireType)
			}
			m.TfType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TfType |= TFType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SteinsPreviewReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SteinsPreviewReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SteinsPreviewReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playurl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Playurl == nil {
				m.Playurl = &PlayURLInfo{}
			}
			if err := m.Playurl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayURLInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayURLInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayURLInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timelength", wireType)
			}
			m.Timelength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timelength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptDescription = append(m.AcceptDescription, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptQuality = append(m.AcceptQuality, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AcceptQuality) == 0 {
					m.AcceptQuality = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptQuality = append(m.AcceptQuality, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptQuality", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoCodecid", wireType)
			}
			m.VideoCodecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoCodecid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoProject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VideoProject = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeekParam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeekType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abtid", wireType)
			}
			m.Abtid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Abtid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Durl = append(m.Durl, &Durl{})
			if err := m.Durl[len(m.Durl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dash == nil {
				m.Dash = &Dash{}
			}
			if err := m.Dash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRexcode", wireType)
			}
			m.NoRexcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoRexcode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
