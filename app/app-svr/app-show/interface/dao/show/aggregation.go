// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package aggregation is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// bts: -sync=true -nullcache=&agg.Aggregation{ID:-1} -check_null_code=$.ID==-1
		Aggregation(c context.Context, key int64) (*agg.Aggregation, error)
		// bts: -sync=true -nullcache=&agg.Aggregation{ID:-1} -check_null_code=$.ID==-1
		Aggregations(c context.Context, keys []int64) (map[int64]*agg.Aggregation, error)
	}
*/

package show

import (
	"context"

	"go-common/library/stat/prom"
	agg "go-gateway/app/app-svr/app-show/interface/model/aggregation"
)

// Aggregation get data from cache if miss will call source method, then add to cache.
func (d *Dao) Aggregation(c context.Context, key int64) (res *agg.Aggregation, err error) {
	addCache := true
	res, err = d.CacheAggregation(c, key)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		prom.CacheHit.Incr("Aggregation")
		return
	}
	prom.CacheMiss.Incr("Aggregation")
	res, err = d.RawAggregation(c, key)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &agg.Aggregation{ID: -1}
	}
	if !addCache {
		return
	}
	d.AddCacheAggregation(c, key, miss)
	return
}

// Aggregations get data from cache if miss will call source method, then add to cache.
func (d *Dao) Aggregations(c context.Context, keys []int64) (res map[int64]*agg.Aggregation, err error) {
	if len(keys) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheAggregations(c, keys); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range keys {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	prom.CacheHit.Add("Aggregations", int64(len(keys)-len(miss)))
	for k, v := range res {
		if v.ID == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*agg.Aggregation
	prom.CacheMiss.Add("Aggregations", int64(len(miss)))
	missData, err = d.RawAggregations(c, miss)
	if res == nil {
		res = make(map[int64]*agg.Aggregation, len(keys))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == nil {
			missData[key] = &agg.Aggregation{ID: -1}
		}
	}
	if !addCache {
		return
	}
	d.AddCacheAggregations(c, missData)
	return
}
