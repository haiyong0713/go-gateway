// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package bws is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// bts: -sync=true -struct_name=Dao
		UsersMid(c context.Context, bid int64, key int64) (*bwsmdl.Users, error)
		// bts: -sync=true -struct_name=Dao
		UsersKey(c context.Context, bid int64, ukey string) (*bwsmdl.Users, error)
		// bts: -sync=true -struct_name=Dao
		Points(c context.Context, bid int64) ([]int64, error)
		// bts: -sync=true -struct_name=Dao
		BwsPoints(c context.Context, ids []int64) (map[int64]*bwsmdl.Point, error)
		// bts: -sync=true -struct_name=Dao
		BwsSign(c context.Context, ids []int64) (map[int64]*bwsmdl.PointSign, error)
		// bts: -sync=true -struct_name=Dao
		Signs(c context.Context, pid int64) ([]int64, error)
		// bts: -sync=true -struct_name=Dao
		Achievements(c context.Context, bid int64) (*bwsmdl.Achievements, error)
		// bts: -sync=true -struct_name=Dao
		UserAchieves(c context.Context, bid int64, key string) ([]*bwsmdl.UserAchieve, error)
		// bts: -sync=true -struct_name=Dao
		UserPoints(c context.Context, bid int64, key string) ([]*bwsmdl.UserPoint, error)
		// bts: -sync=true -struct_name=Dao
		UserLockPoints(c context.Context, bid int64, lockType int64, ukey string) ([]*bwsmdl.UserPoint, error)
		// bts: -sync=true -struct_name=Dao
		UserLockPointsDay(c context.Context, bid int64, lockType int64, ukey string, day string) ([]*bwsmdl.UserPoint, error)
		// bts: -sync=true -struct_name=Dao
		AchieveCounts(c context.Context, bid int64, day string) ([]*bwsmdl.CountAchieves, error)
		// bts: -sync=true -struct_name=Dao
		RechargeLevels(c context.Context, ids []int64) (map[int64]*bwsmdl.PointsLevel, error)
		// bts: -sync=true -struct_name=Dao
		RechargeAwards(c context.Context, ids []int64) (map[int64]*bwsmdl.PointsAward, error)
		// bts: -sync=true -struct_name=Dao
		PointLevels(c context.Context, bid int64) ([]int64, error)
		// bts: -sync=true -struct_name=Dao
		PointsAward(c context.Context, plID int64) ([]int64, error)
		// bts: -sync=true -struct_name=Dao
		CompositeAchievesPoint(c context.Context, mids []int64) (map[int64]int64, error)
		// bts: -sync=true -struct_name=Dao
		ActFields(c context.Context, bid int64) (*bwsmdl.ActFields, error)
		// bts: -struct_name=Dao -nullcache=[]*bwsmdl.UserTask{{TaskID:-1}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].TaskID==-1
		UserTasks(c context.Context, userToken string, day int64) ([]*bwsmdl.UserTask, error)
		// bts: -struct_name=Dao -nullcache=[]*bwsmdl.UserAward{{ID:-1}} -check_null_code=len($)==1&&$[0]!=nil&&$[0].ID==-1
		UserAward(c context.Context, userToken string) ([]*bwsmdl.UserAward, error)
		// bts: -struct_name=Dao -nullcache=-1 -check_null_code=$==-1
		UserUnFinishVoteID(c context.Context, userToken string, pid int64) (int64, error)
		// bts: -struct_name=Dao -nullcache=-1 -check_null_code=$==-1
		UserLotteryTimes(c context.Context, userToken string) (int64, error)
		// bts: -sync=true -struct_name=Dao
		UserDetail(c context.Context, bid int64, mid int64, date string) (*bwsmdl.UserDetail, error)
		// bts: -sync=true -struct_name=Dao
		UserDetails(c context.Context, mids []int64, bid int64, date string) (map[int64]*bwsmdl.UserDetail, error)
		// bts: -sync=true -struct_name=Dao
		UsersVipKey(c context.Context, bid int64, ukey string) (*bwsmdl.VipUsersToken, error)
		// bts: -sync=true -struct_name=Dao
		UsersVipMidDate(c context.Context, bid int64, mid int64, date string) (*bwsmdl.VipUsersToken, error)
	}
*/

package bws

import (
	"context"

	"go-common/library/cache"
	bwsmdl "go-gateway/app/web-svr/activity/interface/model/bws"
)

var _ _bts

// UsersMid get data from cache if miss will call source method, then add to cache.
func (d *Dao) UsersMid(c context.Context, bid int64, key int64) (res *bwsmdl.Users, err error) {
	addCache := true
	res, err = d.CacheUsersMid(c, bid, key)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:UsersMid")
		return
	}
	cache.MetricMisses.Inc("bts:UsersMid")
	res, err = d.RawUsersMid(c, bid, key)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUsersMid(c, bid, miss, key)
	return
}

// UsersKey get data from cache if miss will call source method, then add to cache.
func (d *Dao) UsersKey(c context.Context, bid int64, ukey string) (res *bwsmdl.Users, err error) {
	addCache := true
	res, err = d.CacheUsersKey(c, bid, ukey)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:UsersKey")
		return
	}
	cache.MetricMisses.Inc("bts:UsersKey")
	res, err = d.RawUsersKey(c, bid, ukey)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUsersKey(c, bid, miss, ukey)
	return
}

// Points get data from cache if miss will call source method, then add to cache.
func (d *Dao) Points(c context.Context, bid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CachePoints(c, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:Points")
		return
	}
	cache.MetricMisses.Inc("bts:Points")
	res, err = d.RawPoints(c, bid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCachePoints(c, bid, miss)
	return
}

// BwsPoints get data from cache if miss will call source method, then add to cache.
func (d *Dao) BwsPoints(c context.Context, ids []int64) (res map[int64]*bwsmdl.Point, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheBwsPoints(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:BwsPoints")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsmdl.Point
	cache.MetricMisses.Add(float64(len(miss)), "bts:BwsPoints")
	missData, err = d.RawBwsPoints(c, miss)
	if res == nil {
		res = make(map[int64]*bwsmdl.Point, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheBwsPoints(c, missData)
	return
}

// BwsSign get data from cache if miss will call source method, then add to cache.
func (d *Dao) BwsSign(c context.Context, ids []int64) (res map[int64]*bwsmdl.PointSign, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheBwsSign(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:BwsSign")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsmdl.PointSign
	cache.MetricMisses.Add(float64(len(miss)), "bts:BwsSign")
	missData, err = d.RawBwsSign(c, miss)
	if res == nil {
		res = make(map[int64]*bwsmdl.PointSign, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheBwsSign(c, missData)
	return
}

// Signs get data from cache if miss will call source method, then add to cache.
func (d *Dao) Signs(c context.Context, pid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CacheSigns(c, pid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:Signs")
		return
	}
	cache.MetricMisses.Inc("bts:Signs")
	res, err = d.RawSigns(c, pid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheSigns(c, pid, miss)
	return
}

// Achievements get data from cache if miss will call source method, then add to cache.
func (d *Dao) Achievements(c context.Context, bid int64) (res *bwsmdl.Achievements, err error) {
	addCache := true
	res, err = d.CacheAchievements(c, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:Achievements")
		return
	}
	cache.MetricMisses.Inc("bts:Achievements")
	res, err = d.RawAchievements(c, bid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheAchievements(c, bid, miss)
	return
}

// UserAchieves get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserAchieves(c context.Context, bid int64, key string) (res []*bwsmdl.UserAchieve, err error) {
	addCache := true
	res, err = d.CacheUserAchieves(c, bid, key)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserAchieves")
		return
	}
	cache.MetricMisses.Inc("bts:UserAchieves")
	res, err = d.RawUserAchieves(c, bid, key)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUserAchieves(c, bid, miss, key)
	return
}

// UserPoints get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserPoints(c context.Context, bid int64, key string) (res []*bwsmdl.UserPoint, err error) {
	addCache := true
	res, err = d.CacheUserPoints(c, bid, key)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserPoints")
		return
	}
	cache.MetricMisses.Inc("bts:UserPoints")
	res, err = d.RawUserPoints(c, bid, key)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUserPoints(c, bid, miss, key)
	return
}

// UserLockPoints get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserLockPoints(c context.Context, bid int64, lockType int64, ukey string) (res []*bwsmdl.UserPoint, err error) {
	addCache := true
	res, err = d.CacheUserLockPoints(c, bid, lockType, ukey)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserLockPoints")
		return
	}
	cache.MetricMisses.Inc("bts:UserLockPoints")
	res, err = d.RawUserLockPoints(c, bid, lockType, ukey)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUserLockPoints(c, bid, miss, lockType, ukey)
	return
}

// UserLockPointsDay get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserLockPointsDay(c context.Context, bid int64, lockType int64, ukey string, day string) (res []*bwsmdl.UserPoint, err error) {
	addCache := true
	res, err = d.CacheUserLockPointsDay(c, bid, lockType, ukey, day)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserLockPointsDay")
		return
	}
	cache.MetricMisses.Inc("bts:UserLockPointsDay")
	res, err = d.RawUserLockPointsDay(c, bid, lockType, ukey, day)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUserLockPointsDay(c, bid, miss, lockType, ukey, day)
	return
}

// AchieveCounts get data from cache if miss will call source method, then add to cache.
func (d *Dao) AchieveCounts(c context.Context, bid int64, day string) (res []*bwsmdl.CountAchieves, err error) {
	addCache := true
	res, err = d.CacheAchieveCounts(c, bid, day)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:AchieveCounts")
		return
	}
	cache.MetricMisses.Inc("bts:AchieveCounts")
	res, err = d.RawAchieveCounts(c, bid, day)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheAchieveCounts(c, bid, miss, day)
	return
}

// RechargeLevels get data from cache if miss will call source method, then add to cache.
func (d *Dao) RechargeLevels(c context.Context, ids []int64) (res map[int64]*bwsmdl.PointsLevel, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheRechargeLevels(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:RechargeLevels")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsmdl.PointsLevel
	cache.MetricMisses.Add(float64(len(miss)), "bts:RechargeLevels")
	missData, err = d.RawRechargeLevels(c, miss)
	if res == nil {
		res = make(map[int64]*bwsmdl.PointsLevel, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheRechargeLevels(c, missData)
	return
}

// RechargeAwards get data from cache if miss will call source method, then add to cache.
func (d *Dao) RechargeAwards(c context.Context, ids []int64) (res map[int64]*bwsmdl.PointsAward, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheRechargeAwards(c, ids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:RechargeAwards")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsmdl.PointsAward
	cache.MetricMisses.Add(float64(len(miss)), "bts:RechargeAwards")
	missData, err = d.RawRechargeAwards(c, miss)
	if res == nil {
		res = make(map[int64]*bwsmdl.PointsAward, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheRechargeAwards(c, missData)
	return
}

// PointLevels get data from cache if miss will call source method, then add to cache.
func (d *Dao) PointLevels(c context.Context, bid int64) (res []int64, err error) {
	addCache := true
	res, err = d.CachePointLevels(c, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:PointLevels")
		return
	}
	cache.MetricMisses.Inc("bts:PointLevels")
	res, err = d.RawPointLevels(c, bid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCachePointLevels(c, bid, miss)
	return
}

// PointsAward get data from cache if miss will call source method, then add to cache.
func (d *Dao) PointsAward(c context.Context, plID int64) (res []int64, err error) {
	addCache := true
	res, err = d.CachePointsAward(c, plID)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:PointsAward")
		return
	}
	cache.MetricMisses.Inc("bts:PointsAward")
	res, err = d.RawPointsAward(c, plID)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCachePointsAward(c, plID, miss)
	return
}

// CompositeAchievesPoint get data from cache if miss will call source method, then add to cache.
func (d *Dao) CompositeAchievesPoint(c context.Context, mids []int64) (res map[int64]int64, err error) {
	if len(mids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheCompositeAchievesPoint(c, mids); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range mids {
		if _, ok := res[key]; !ok {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(mids)-len(miss)), "bts:CompositeAchievesPoint")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]int64
	cache.MetricMisses.Add(float64(len(miss)), "bts:CompositeAchievesPoint")
	missData, err = d.RawCompositeAchievesPoint(c, miss)
	if res == nil {
		res = make(map[int64]int64, len(mids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheCompositeAchievesPoint(c, missData)
	return
}

// ActFields get data from cache if miss will call source method, then add to cache.
func (d *Dao) ActFields(c context.Context, bid int64) (res *bwsmdl.ActFields, err error) {
	addCache := true
	res, err = d.CacheActFields(c, bid)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:ActFields")
		return
	}
	cache.MetricMisses.Inc("bts:ActFields")
	res, err = d.RawActFields(c, bid)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheActFields(c, bid, miss)
	return
}

// UserTasks get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserTasks(c context.Context, userToken string, day int64) (res []*bwsmdl.UserTask, err error) {
	addCache := true
	res, err = d.CacheUserTasks(c, userToken, day)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] != nil && res[0].TaskID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserTasks")
		return
	}
	cache.MetricMisses.Inc("bts:UserTasks")
	res, err = d.RawUserTasks(c, userToken, day)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*bwsmdl.UserTask{{TaskID: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserTasks(c, userToken, miss, day)
	})
	return
}

// UserAward get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserAward(c context.Context, userToken string) (res []*bwsmdl.UserAward, err error) {
	addCache := true
	res, err = d.CacheUserAward(c, userToken)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if len(res) == 1 && res[0] != nil && res[0].ID == -1 {
			res = nil
		}
	}()
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserAward")
		return
	}
	cache.MetricMisses.Inc("bts:UserAward")
	res, err = d.RawUserAward(c, userToken)
	if err != nil {
		return
	}
	miss := res
	if len(miss) == 0 {
		miss = []*bwsmdl.UserAward{{ID: -1}}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserAward(c, userToken, miss)
	})
	return
}

// UserUnFinishVoteID get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserUnFinishVoteID(c context.Context, userToken string, pid int64) (res int64, err error) {
	addCache := true
	res, err = d.CacheUserUnFinishVoteID(c, userToken, pid)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:UserUnFinishVoteID")
		return
	}
	cache.MetricMisses.Inc("bts:UserUnFinishVoteID")
	res, err = d.RawUserUnFinishVoteID(c, userToken, pid)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserUnFinishVoteID(c, userToken, miss, pid)
	})
	return
}

// UserLotteryTimes get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserLotteryTimes(c context.Context, userToken string) (res int64, err error) {
	addCache := true
	res, err = d.CacheUserLotteryTimes(c, userToken)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res == -1 {
			res = 0
		}
	}()
	if res != 0 {
		cache.MetricHits.Inc("bts:UserLotteryTimes")
		return
	}
	cache.MetricMisses.Inc("bts:UserLotteryTimes")
	res, err = d.RawUserLotteryTimes(c, userToken)
	if err != nil {
		return
	}
	miss := res
	if miss == 0 {
		miss = -1
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserLotteryTimes(c, userToken, miss)
	})
	return
}

// UserDetail get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserDetail(c context.Context, bid int64, mid int64, date string) (res *bwsmdl.UserDetail, err error) {
	addCache := true
	res, err = d.CacheUserDetail(c, bid, mid, date)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:UserDetail")
		return
	}
	cache.MetricMisses.Inc("bts:UserDetail")
	res, err = d.RawUserDetail(c, bid, mid, date)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUserDetail(c, bid, miss, mid, date)
	return
}

// UserDetails get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserDetails(c context.Context, mids []int64, bid int64, date string) (res map[int64]*bwsmdl.UserDetail, err error) {
	if len(mids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheUserDetails(c, mids, bid, date); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range mids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(mids)-len(miss)), "bts:UserDetails")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*bwsmdl.UserDetail
	cache.MetricMisses.Add(float64(len(miss)), "bts:UserDetails")
	missData, err = d.RawUserDetails(c, miss, bid, date)
	if res == nil {
		res = make(map[int64]*bwsmdl.UserDetail, len(mids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.AddCacheUserDetails(c, missData, bid, date)
	return
}

// UsersVipKey get data from cache if miss will call source method, then add to cache.
func (d *Dao) UsersVipKey(c context.Context, bid int64, ukey string) (res *bwsmdl.VipUsersToken, err error) {
	addCache := true
	res, err = d.CacheUsersVipKey(c, bid, ukey)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:UsersVipKey")
		return
	}
	cache.MetricMisses.Inc("bts:UsersVipKey")
	res, err = d.RawUsersVipKey(c, bid, ukey)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUsersVipKey(c, bid, miss, ukey)
	return
}

// UsersVipMidDate get data from cache if miss will call source method, then add to cache.
func (d *Dao) UsersVipMidDate(c context.Context, bid int64, mid int64, date string) (res *bwsmdl.VipUsersToken, err error) {
	addCache := true
	res, err = d.CacheUsersVipMidDate(c, bid, mid, date)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:UsersVipMidDate")
		return
	}
	cache.MetricMisses.Inc("bts:UsersVipMidDate")
	res, err = d.RawUsersVipMidDate(c, bid, mid, date)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.AddCacheUsersVipMidDate(c, bid, miss, mid, date)
	return
}
