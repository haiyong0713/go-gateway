// Code generated by kratos tool btsgen. DO NOT EDIT.

/*
  Package guess is a generated cache proxy package.
  It is generated from:
  type _bts interface {
		// cache
		UserStat(c context.Context, mid int64, stakeType int64, business int64) (*api.UserGuessDataReply, error)
		// cache
		GuessMain(c context.Context, mainID int64) (*guess.MainGuess, error)
		// cache
		UserGuessList(c context.Context, mid int64, business int64) ([]*guess.UserGuessLog, error)
		// cache
		MDResult(c context.Context, id int64, business int64) (*guess.MainRes, error)
		// cache
		MDsResult(c context.Context, ids []int64, business int64) (map[int64]*guess.MainRes, error)
		// cache
		OidMIDs(c context.Context, oid int64, business int64) ([]*guess.MainID, error)
		// cache
		OidsMIDs(c context.Context, oids []int64, business int64) (map[int64][]*guess.MainID, error)
		// cache
		UserGuess(c context.Context, mainIDs []int64, mid int64) (map[int64]*guess.UserGuessLog, error)
	}
*/

package guess

import (
	"context"

	"go-common/library/cache"
	"go-gateway/app/web-svr/activity/interface/api"
	"go-gateway/app/web-svr/activity/interface/model/guess"
)

var _ _bts

// UserStat get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserStat(c context.Context, mid int64, stakeType int64, business int64) (res *api.UserGuessDataReply, err error) {
	addCache := true
	res, err = d.CacheUserStat(c, mid, stakeType, business)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:UserStat")
		return
	}
	cache.MetricMisses.Inc("bts:UserStat")
	res, err = d.RawUserStat(c, mid, stakeType, business)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserStat(c, mid, miss, stakeType, business)
	})
	return
}

// GuessMain get data from cache if miss will call source method, then add to cache.
func (d *Dao) GuessMain(c context.Context, mainID int64) (res *guess.MainGuess, err error) {
	addCache := true
	res, err = d.CacheGuessMain(c, mainID)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:GuessMain")
		return
	}
	cache.MetricMisses.Inc("bts:GuessMain")
	res, err = d.RawGuessMain(c, mainID)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheGuessMain(c, mainID, miss)
	})
	return
}

// UserGuessList get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserGuessList(c context.Context, mid int64, business int64) (res []*guess.UserGuessLog, err error) {
	addCache := true
	res, err = d.CacheUserGuessList(c, mid, business)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:UserGuessList")
		return
	}
	cache.MetricMisses.Inc("bts:UserGuessList")
	res, err = d.RawUserGuessList(c, mid, business)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserGuessList(c, mid, miss, business)
	})
	return
}

// MDResult get data from cache if miss will call source method, then add to cache.
func (d *Dao) MDResult(c context.Context, id int64, business int64) (res *guess.MainRes, err error) {
	addCache := true
	res, err = d.CacheMDResult(c, id, business)
	if err != nil {
		addCache = false
		err = nil
	}
	if res != nil {
		cache.MetricHits.Inc("bts:MDResult")
		return
	}
	cache.MetricMisses.Inc("bts:MDResult")
	res, err = d.RawMDResult(c, id, business)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheMDResult(c, id, miss, business)
	})
	return
}

// MDsResult get data from cache if miss will call source method, then add to cache.
func (d *Dao) MDsResult(c context.Context, ids []int64, business int64) (res map[int64]*guess.MainRes, err error) {
	if len(ids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheMDsResult(c, ids, business); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range ids {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(ids)-len(miss)), "bts:MDsResult")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*guess.MainRes
	cache.MetricMisses.Add(float64(len(miss)), "bts:MDsResult")
	missData, err = d.RawMDsResult(c, miss, business)
	if res == nil {
		res = make(map[int64]*guess.MainRes, len(ids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheMDsResult(c, missData, business)
	})
	return
}

// OidMIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) OidMIDs(c context.Context, oid int64, business int64) (res []*guess.MainID, err error) {
	addCache := true
	res, err = d.CacheOidMIDs(c, oid, business)
	if err != nil {
		addCache = false
		err = nil
	}
	if len(res) != 0 {
		cache.MetricHits.Inc("bts:OidMIDs")
		return
	}
	cache.MetricMisses.Inc("bts:OidMIDs")
	res, err = d.RawOidMIDs(c, oid, business)
	if err != nil {
		return
	}
	miss := res
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheOidMIDs(c, oid, miss, business)
	})
	return
}

// OidsMIDs get data from cache if miss will call source method, then add to cache.
func (d *Dao) OidsMIDs(c context.Context, oids []int64, business int64) (res map[int64][]*guess.MainID, err error) {
	if len(oids) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheOidsMIDs(c, oids, business); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range oids {
		if (res == nil) || (len(res[key]) == 0) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(oids)-len(miss)), "bts:OidsMIDs")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64][]*guess.MainID
	cache.MetricMisses.Add(float64(len(miss)), "bts:OidsMIDs")
	missData, err = d.RawOidsMIDs(c, miss, business)
	if res == nil {
		res = make(map[int64][]*guess.MainID, len(oids))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheOidsMIDs(c, missData, business)
	})
	return
}

// UserGuess get data from cache if miss will call source method, then add to cache.
func (d *Dao) UserGuess(c context.Context, mainIDs []int64, mid int64) (res map[int64]*guess.UserGuessLog, err error) {
	if len(mainIDs) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheUserGuess(c, mainIDs, mid); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range mainIDs {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	cache.MetricHits.Add(float64(len(mainIDs)-len(miss)), "bts:UserGuess")
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	var missData map[int64]*guess.UserGuessLog
	cache.MetricMisses.Add(float64(len(miss)), "bts:UserGuess")
	missData, err = d.RawUserGuess(c, miss, mid)
	if res == nil {
		res = make(map[int64]*guess.UserGuessLog, len(mainIDs))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUserGuess(c, missData, mid)
	})
	return
}
