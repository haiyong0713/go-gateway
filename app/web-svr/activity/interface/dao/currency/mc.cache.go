// Code generated by kratos tool mcgen. DO NOT EDIT.

/*
  Package currency is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=currencyKey
		CacheCurrency(c context.Context, id int64) (*currency.Currency, error)
		// mc: -key=currencyKey -expire=d.currencyExpire -encode=pb
		AddCacheCurrency(c context.Context, id int64, data *currency.Currency) error
		// mc: -key=relationKey
		CacheRelation(c context.Context, businessID int64, foreignID int64) (*currency.CurrencyRelation, error)
		// mc: -key=relationKey -expire=d.currencyExpire -encode=pb
		AddCacheRelation(c context.Context, businessID int64, data *currency.CurrencyRelation, foreignID int64) error
		// mc: -key=userCurrKey
		CacheCurrencyUser(c context.Context, mid int64, currID int64) (*currency.CurrencyUser, error)
		// mc: -key=userCurrKey -expire=d.currencyExpire -encode=pb
		AddCacheCurrencyUser(c context.Context, mid int64, data *currency.CurrencyUser, currID int64) error
		// mc: -key=userCurrKey
		DelCacheCurrencyUser(c context.Context, mid int64, currID int64) error
	}
*/

package currency

import (
	"context"
	"fmt"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-gateway/app/web-svr/activity/interface/model/currency"
)

var _ _mc

// CacheCurrency get data from mc
func (d *Dao) CacheCurrency(c context.Context, id int64) (res *currency.Currency, err error) {
	key := currencyKey(id)
	res = &currency.Currency{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheCurrency", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheCurrency Set data to mc
func (d *Dao) AddCacheCurrency(c context.Context, id int64, val *currency.Currency) (err error) {
	if val == nil {
		return
	}
	key := currencyKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.currencyExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheCurrency", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheRelation get data from mc
func (d *Dao) CacheRelation(c context.Context, id int64, foreignID int64) (res *currency.CurrencyRelation, err error) {
	key := relationKey(id, foreignID)
	res = &currency.CurrencyRelation{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheRelation", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheRelation Set data to mc
func (d *Dao) AddCacheRelation(c context.Context, id int64, val *currency.CurrencyRelation, foreignID int64) (err error) {
	if val == nil {
		return
	}
	key := relationKey(id, foreignID)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.currencyExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheRelation", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheCurrencyUser get data from mc
func (d *Dao) CacheCurrencyUser(c context.Context, id int64, currID int64) (res *currency.CurrencyUser, err error) {
	key := userCurrKey(id, currID)
	res = &currency.CurrencyUser{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheCurrencyUser", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheCurrencyUser Set data to mc
func (d *Dao) AddCacheCurrencyUser(c context.Context, id int64, val *currency.CurrencyUser, currID int64) (err error) {
	if val == nil {
		return
	}
	key := userCurrKey(id, currID)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.currencyExpire, Flags: memcache.FlagProtobuf}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheCurrencyUser", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheCurrencyUser delete data from mc
func (d *Dao) DelCacheCurrencyUser(c context.Context, id int64, currID int64) (err error) {
	key := userCurrKey(id, currID)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheCurrencyUser", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
