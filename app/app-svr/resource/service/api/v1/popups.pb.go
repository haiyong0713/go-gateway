// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: popups.proto

package v1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PopUpsReq struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid"`
	// buvid
	Buvid string `protobuf:"bytes,2,opt,name=buvid,proto3" json:"buvid"`
	// 平台 1-iOS，2-Android
	Plat int32 `protobuf:"varint,3,opt,name=plat,proto3" json:"plat"`
	// 版本
	Build                int32    `protobuf:"varint,4,opt,name=build,proto3" json:"build"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PopUpsReq) Reset()         { *m = PopUpsReq{} }
func (m *PopUpsReq) String() string { return proto.CompactTextString(m) }
func (*PopUpsReq) ProtoMessage()    {}
func (*PopUpsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eb62809e617a7c3, []int{0}
}
func (m *PopUpsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PopUpsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PopUpsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PopUpsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PopUpsReq.Merge(m, src)
}
func (m *PopUpsReq) XXX_Size() int {
	return m.Size()
}
func (m *PopUpsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PopUpsReq.DiscardUnknown(m)
}

var xxx_messageInfo_PopUpsReq proto.InternalMessageInfo

func (m *PopUpsReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *PopUpsReq) GetBuvid() string {
	if m != nil {
		return m.Buvid
	}
	return ""
}

func (m *PopUpsReq) GetPlat() int32 {
	if m != nil {
		return m.Plat
	}
	return 0
}

func (m *PopUpsReq) GetBuild() int32 {
	if m != nil {
		return m.Build
	}
	return 0
}

type PopUpsReply struct {
	// 弹窗id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 弹窗图片
	Pic string `protobuf:"bytes,2,opt,name=pic,proto3" json:"pic"`
	// ipad弹窗图片
	PicIpad string `protobuf:"bytes,3,opt,name=pic_ipad,proto3" json:"pic_ipad"`
	// 弹窗描述
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description"`
	// 跳转类型,-1为不跳转，1为URL，2为游戏小卡，3为稿件，4为PGC，5为直播，6为专栏，7为每日精选，8为歌单，9为歌曲，10为相簿，11为小视频
	LinkType int32 `protobuf:"varint,5,opt,name=link_type,proto3" json:"link_type"`
	// 跳转链接,如果为空，则不存在跳转链接
	Link string `protobuf:"bytes,6,opt,name=link,proto3" json:"link"`
	// 自动隐藏类别,1为隐藏，2为不隐藏。暂时都是1
	AutoHideStatus int32 `protobuf:"varint,7,opt,name=auto_hide_status,proto3" json:"auto_hide_status"`
	// 关闭时间
	CloseTime int64 `protobuf:"varint,8,opt,name=close_time,proto3" json:"close_time"`
	// 是否弹过,true为已弹出过，false为未弹出过，下发一次后置为true
	IsPoped bool `protobuf:"varint,9,opt,name=is_poped,json=is_pop,proto3" json:"is_pop"`
	// 青少年模式是否弹出,预留字段，-1为不弹出，1为弹出
	TeenagePush          int32    `protobuf:"varint,10,opt,name=teenage_push,proto3" json:"teenage_push"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PopUpsReply) Reset()         { *m = PopUpsReply{} }
func (m *PopUpsReply) String() string { return proto.CompactTextString(m) }
func (*PopUpsReply) ProtoMessage()    {}
func (*PopUpsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eb62809e617a7c3, []int{1}
}
func (m *PopUpsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PopUpsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PopUpsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PopUpsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PopUpsReply.Merge(m, src)
}
func (m *PopUpsReply) XXX_Size() int {
	return m.Size()
}
func (m *PopUpsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PopUpsReply.DiscardUnknown(m)
}

var xxx_messageInfo_PopUpsReply proto.InternalMessageInfo

func (m *PopUpsReply) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PopUpsReply) GetPic() string {
	if m != nil {
		return m.Pic
	}
	return ""
}

func (m *PopUpsReply) GetPicIpad() string {
	if m != nil {
		return m.PicIpad
	}
	return ""
}

func (m *PopUpsReply) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PopUpsReply) GetLinkType() int32 {
	if m != nil {
		return m.LinkType
	}
	return 0
}

func (m *PopUpsReply) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *PopUpsReply) GetAutoHideStatus() int32 {
	if m != nil {
		return m.AutoHideStatus
	}
	return 0
}

func (m *PopUpsReply) GetCloseTime() int64 {
	if m != nil {
		return m.CloseTime
	}
	return 0
}

func (m *PopUpsReply) GetIsPoped() bool {
	if m != nil {
		return m.IsPoped
	}
	return false
}

func (m *PopUpsReply) GetTeenagePush() int32 {
	if m != nil {
		return m.TeenagePush
	}
	return 0
}

func init() {
	proto.RegisterType((*PopUpsReq)(nil), "resource.service.v1.PopUpsReq")
	proto.RegisterType((*PopUpsReply)(nil), "resource.service.v1.PopUpsReply")
}

func init() { proto.RegisterFile("popups.proto", fileDescriptor_4eb62809e617a7c3) }

var fileDescriptor_4eb62809e617a7c3 = []byte{
	// 429 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0x41, 0x8e, 0xd3, 0x30,
	0x14, 0x86, 0x95, 0x74, 0xda, 0x49, 0x3c, 0x05, 0x2a, 0x83, 0x90, 0x41, 0xa8, 0xae, 0x46, 0x2c,
	0x22, 0x21, 0x32, 0xaa, 0xe0, 0x00, 0x28, 0x27, 0x40, 0x96, 0xd8, 0xb0, 0x89, 0xd2, 0xd8, 0xb4,
	0x4f, 0xa4, 0xb5, 0x89, 0x9d, 0x4a, 0x73, 0x01, 0x8e, 0xc4, 0x19, 0x58, 0x72, 0x02, 0x0b, 0x75,
	0xe9, 0x53, 0xa0, 0xbc, 0x94, 0x4e, 0x47, 0xdd, 0x3c, 0xff, 0xff, 0xef, 0xbc, 0xa7, 0x2f, 0x4f,
	0x26, 0x53, 0xa3, 0x4d, 0x67, 0x6c, 0x6e, 0x5a, 0xed, 0x34, 0x7d, 0xde, 0x2a, 0xab, 0xbb, 0xb6,
	0x56, 0xb9, 0x55, 0xed, 0x1e, 0x6a, 0x95, 0xef, 0x97, 0xaf, 0xdf, 0xaf, 0xc1, 0x6d, 0xba, 0x55,
	0x5e, 0xeb, 0xed, 0xdd, 0x5a, 0xaf, 0xf5, 0x1d, 0x7e, 0xbb, 0xea, 0xbe, 0xa1, 0x43, 0x83, 0x6a,
	0x98, 0x71, 0xfb, 0x33, 0x22, 0xe9, 0x67, 0x6d, 0xbe, 0x18, 0x2b, 0xd4, 0x0f, 0xfa, 0x8a, 0x8c,
	0xb6, 0x20, 0x59, 0xb4, 0x88, 0xb2, 0x51, 0x71, 0x1d, 0x3c, 0xef, 0xad, 0xe8, 0x0b, 0xe5, 0x64,
	0xbc, 0xea, 0xf6, 0x20, 0x59, 0xbc, 0x88, 0xb2, 0xb4, 0x48, 0x83, 0xe7, 0x43, 0x20, 0x86, 0x83,
	0xbe, 0x21, 0x57, 0xa6, 0xa9, 0x1c, 0x1b, 0x2d, 0xa2, 0x6c, 0x5c, 0x24, 0xc1, 0x73, 0xf4, 0x02,
	0xeb, 0xd0, 0x0e, 0x8d, 0x64, 0x57, 0x78, 0x7d, 0x6c, 0x87, 0x06, 0xdb, 0xa1, 0x91, 0xb7, 0xbf,
	0x46, 0xe4, 0xe6, 0x3f, 0x88, 0x69, 0xee, 0xe9, 0x4b, 0x12, 0x9f, 0x48, 0x26, 0xc1, 0xf3, 0x18,
	0xa4, 0x88, 0x41, 0xf6, 0x88, 0x06, 0xea, 0x23, 0x05, 0x22, 0x1a, 0xa8, 0x45, 0x5f, 0x68, 0x46,
	0x12, 0x03, 0x75, 0x09, 0xa6, 0x92, 0x48, 0x91, 0x16, 0xd3, 0xe0, 0xf9, 0x29, 0x13, 0x27, 0x45,
	0x97, 0xe4, 0x46, 0x2a, 0x5b, 0xb7, 0x60, 0x1c, 0xe8, 0x1d, 0x32, 0xa5, 0xc5, 0xb3, 0xe0, 0xf9,
	0x79, 0x2c, 0xce, 0x0d, 0x7d, 0x47, 0xd2, 0x06, 0x76, 0xdf, 0x4b, 0x77, 0x6f, 0x14, 0x1b, 0xe3,
	0x4f, 0x3c, 0x09, 0x9e, 0x3f, 0x84, 0xe2, 0x41, 0xf6, 0xbb, 0xe8, 0x0d, 0x9b, 0xe0, 0x60, 0xdc,
	0x45, 0xef, 0x05, 0x56, 0xfa, 0x89, 0xcc, 0xaa, 0xce, 0xe9, 0x72, 0x03, 0x52, 0x95, 0xd6, 0x55,
	0xae, 0xb3, 0xec, 0x1a, 0x27, 0xbe, 0x08, 0x9e, 0x5f, 0xdc, 0x89, 0x8b, 0x84, 0xe6, 0x84, 0xd4,
	0x8d, 0xb6, 0xaa, 0x74, 0xb0, 0x55, 0x2c, 0xc1, 0x25, 0x3d, 0x0d, 0x9e, 0x9f, 0xa5, 0xe2, 0x4c,
	0xd3, 0xb7, 0x24, 0x01, 0x5b, 0x1a, 0x6d, 0x94, 0x64, 0xe9, 0x22, 0xca, 0x92, 0x82, 0x04, 0xcf,
	0x27, 0x43, 0x26, 0x8e, 0x27, 0xfd, 0x48, 0xa6, 0x4e, 0xa9, 0x5d, 0xb5, 0x56, 0xa5, 0xe9, 0xec,
	0x86, 0x11, 0x64, 0x9a, 0x05, 0xcf, 0x1f, 0xe5, 0xe2, 0x91, 0x2b, 0x66, 0xbf, 0x0f, 0xf3, 0xe8,
	0xcf, 0x61, 0x1e, 0xfd, 0x3d, 0xcc, 0xa3, 0xaf, 0xf1, 0x7e, 0xb9, 0x9a, 0xe0, 0xd3, 0xfa, 0xf0,
	0x2f, 0x00, 0x00, 0xff, 0xff, 0x6a, 0xca, 0x22, 0xda, 0xae, 0x02, 0x00, 0x00,
}

func (m *PopUpsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PopUpsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PopUpsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Build != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.Build))
		i--
		dAtA[i] = 0x20
	}
	if m.Plat != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.Plat))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Buvid) > 0 {
		i -= len(m.Buvid)
		copy(dAtA[i:], m.Buvid)
		i = encodeVarintPopups(dAtA, i, uint64(len(m.Buvid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PopUpsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PopUpsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PopUpsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TeenagePush != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.TeenagePush))
		i--
		dAtA[i] = 0x50
	}
	if m.IsPoped {
		i--
		if m.IsPoped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.CloseTime != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.CloseTime))
		i--
		dAtA[i] = 0x40
	}
	if m.AutoHideStatus != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.AutoHideStatus))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintPopups(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x32
	}
	if m.LinkType != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.LinkType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPopups(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PicIpad) > 0 {
		i -= len(m.PicIpad)
		copy(dAtA[i:], m.PicIpad)
		i = encodeVarintPopups(dAtA, i, uint64(len(m.PicIpad)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pic) > 0 {
		i -= len(m.Pic)
		copy(dAtA[i:], m.Pic)
		i = encodeVarintPopups(dAtA, i, uint64(len(m.Pic)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPopups(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPopups(dAtA []byte, offset int, v uint64) int {
	offset -= sovPopups(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PopUpsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovPopups(uint64(m.Mid))
	}
	l = len(m.Buvid)
	if l > 0 {
		n += 1 + l + sovPopups(uint64(l))
	}
	if m.Plat != 0 {
		n += 1 + sovPopups(uint64(m.Plat))
	}
	if m.Build != 0 {
		n += 1 + sovPopups(uint64(m.Build))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PopUpsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPopups(uint64(m.Id))
	}
	l = len(m.Pic)
	if l > 0 {
		n += 1 + l + sovPopups(uint64(l))
	}
	l = len(m.PicIpad)
	if l > 0 {
		n += 1 + l + sovPopups(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPopups(uint64(l))
	}
	if m.LinkType != 0 {
		n += 1 + sovPopups(uint64(m.LinkType))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovPopups(uint64(l))
	}
	if m.AutoHideStatus != 0 {
		n += 1 + sovPopups(uint64(m.AutoHideStatus))
	}
	if m.CloseTime != 0 {
		n += 1 + sovPopups(uint64(m.CloseTime))
	}
	if m.IsPoped {
		n += 2
	}
	if m.TeenagePush != 0 {
		n += 1 + sovPopups(uint64(m.TeenagePush))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPopups(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPopups(x uint64) (n int) {
	return sovPopups(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PopUpsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPopups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PopUpsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PopUpsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buvid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPopups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPopups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buvid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPopups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPopups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPopups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PopUpsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPopups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PopUpsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PopUpsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPopups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPopups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicIpad", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPopups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPopups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PicIpad = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPopups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPopups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkType", wireType)
			}
			m.LinkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPopups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPopups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHideStatus", wireType)
			}
			m.AutoHideStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoHideStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTime", wireType)
			}
			m.CloseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPoped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPoped = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeenagePush", wireType)
			}
			m.TeenagePush = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeenagePush |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPopups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPopups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPopups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPopups(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPopups
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPopups
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPopups
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPopups
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPopups
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPopups        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPopups          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPopups = fmt.Errorf("proto: unexpected end of group")
)
